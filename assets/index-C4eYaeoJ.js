var $R = (n) => {
  throw TypeError(n);
};
var Uw = (n, e, t) => e.has(n) || $R("Cannot " + t);
var ve = (n, e, t) => (
    Uw(n, e, "read from private field"), t ? t.call(n) : e.get(n)
  ),
  Qt = (n, e, t) =>
    e.has(n)
      ? $R("Cannot add the same private member more than once")
      : e instanceof WeakSet
      ? e.add(n)
      : e.set(n, t),
  It = (n, e, t, r) => (
    Uw(n, e, "write to private field"), r ? r.call(n, t) : e.set(n, t), t
  ),
  Tr = (n, e, t) => (Uw(n, e, "access private method"), t);
var Pg = (n, e, t, r) => ({
  set _(i) {
    It(n, e, i, t);
  },
  get _() {
    return ve(n, e, r);
  },
});
function jO(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s &&
            Object.defineProperty(
              n,
              i,
              s.get ? s : { enumerable: !0, get: () => r[i] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
function cT(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function HO(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            }
      );
    }),
    t
  );
}
var WO = { exports: {} },
  dx = {},
  GO = { exports: {} },
  jt = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cm = Symbol.for("react.element"),
  tH = Symbol.for("react.portal"),
  nH = Symbol.for("react.fragment"),
  rH = Symbol.for("react.strict_mode"),
  iH = Symbol.for("react.profiler"),
  sH = Symbol.for("react.provider"),
  oH = Symbol.for("react.context"),
  aH = Symbol.for("react.forward_ref"),
  lH = Symbol.for("react.suspense"),
  cH = Symbol.for("react.memo"),
  uH = Symbol.for("react.lazy"),
  XR = Symbol.iterator;
function dH(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (XR && n[XR]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var $O = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  XO = Object.assign,
  qO = {};
function mh(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = qO),
    (this.updater = t || $O);
}
mh.prototype.isReactComponent = {};
mh.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
mh.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function KO() {}
KO.prototype = mh.prototype;
function uT(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = qO),
    (this.updater = t || $O);
}
var dT = (uT.prototype = new KO());
dT.constructor = uT;
XO(dT, mh.prototype);
dT.isPureReactComponent = !0;
var qR = Array.isArray,
  YO = Object.prototype.hasOwnProperty,
  hT = { current: null },
  JO = { key: !0, ref: !0, __self: !0, __source: !0 };
function ZO(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  if (e != null)
    for (r in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      YO.call(e, r) && !JO.hasOwnProperty(r) && (i[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = t;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    i.children = l;
  }
  if (n && n.defaultProps)
    for (r in ((a = n.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: cm,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: hT.current,
  };
}
function hH(n, e) {
  return {
    $$typeof: cm,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function fT(n) {
  return typeof n == "object" && n !== null && n.$$typeof === cm;
}
function fH(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var KR = /\/+/g;
function Fw(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? fH("" + n.key)
    : e.toString(36);
}
function ly(n, e, t, r, i) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case cm:
          case tH:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (i = i(o)),
      (n = r === "" ? "." + Fw(o, 0) : r),
      qR(i)
        ? ((t = ""),
          n != null && (t = n.replace(KR, "$&/") + "/"),
          ly(i, e, t, "", function (c) {
            return c;
          }))
        : i != null &&
          (fT(i) &&
            (i = hH(
              i,
              t +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(KR, "$&/") + "/") +
                n
            )),
          e.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), qR(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = r + Fw(s, a);
      o += ly(s, e, t, l, i);
    }
  else if (((l = dH(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = r + Fw(s, a++)), (o += ly(s, e, t, l, i));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Ig(n, e, t) {
  if (n == null) return n;
  var r = [],
    i = 0;
  return (
    ly(n, r, "", "", function (s) {
      return e.call(t, s, i++);
    }),
    r
  );
}
function pH(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var Zr = { current: null },
  cy = { transition: null },
  mH = {
    ReactCurrentDispatcher: Zr,
    ReactCurrentBatchConfig: cy,
    ReactCurrentOwner: hT,
  };
function QO() {
  throw Error("act(...) is not supported in production builds of React.");
}
jt.Children = {
  map: Ig,
  forEach: function (n, e, t) {
    Ig(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Ig(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Ig(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!fT(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
jt.Component = mh;
jt.Fragment = nH;
jt.Profiler = iH;
jt.PureComponent = uT;
jt.StrictMode = rH;
jt.Suspense = lH;
jt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = mH;
jt.act = QO;
jt.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var r = XO({}, n.props),
    i = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = hT.current)),
      e.key !== void 0 && (i = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      YO.call(e, l) &&
        !JO.hasOwnProperty(l) &&
        (r[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) r.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    r.children = a;
  }
  return { $$typeof: cm, type: n.type, key: i, ref: s, props: r, _owner: o };
};
jt.createContext = function (n) {
  return (
    (n = {
      $$typeof: oH,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: sH, _context: n }),
    (n.Consumer = n)
  );
};
jt.createElement = ZO;
jt.createFactory = function (n) {
  var e = ZO.bind(null, n);
  return (e.type = n), e;
};
jt.createRef = function () {
  return { current: null };
};
jt.forwardRef = function (n) {
  return { $$typeof: aH, render: n };
};
jt.isValidElement = fT;
jt.lazy = function (n) {
  return { $$typeof: uH, _payload: { _status: -1, _result: n }, _init: pH };
};
jt.memo = function (n, e) {
  return { $$typeof: cH, type: n, compare: e === void 0 ? null : e };
};
jt.startTransition = function (n) {
  var e = cy.transition;
  cy.transition = {};
  try {
    n();
  } finally {
    cy.transition = e;
  }
};
jt.unstable_act = QO;
jt.useCallback = function (n, e) {
  return Zr.current.useCallback(n, e);
};
jt.useContext = function (n) {
  return Zr.current.useContext(n);
};
jt.useDebugValue = function () {};
jt.useDeferredValue = function (n) {
  return Zr.current.useDeferredValue(n);
};
jt.useEffect = function (n, e) {
  return Zr.current.useEffect(n, e);
};
jt.useId = function () {
  return Zr.current.useId();
};
jt.useImperativeHandle = function (n, e, t) {
  return Zr.current.useImperativeHandle(n, e, t);
};
jt.useInsertionEffect = function (n, e) {
  return Zr.current.useInsertionEffect(n, e);
};
jt.useLayoutEffect = function (n, e) {
  return Zr.current.useLayoutEffect(n, e);
};
jt.useMemo = function (n, e) {
  return Zr.current.useMemo(n, e);
};
jt.useReducer = function (n, e, t) {
  return Zr.current.useReducer(n, e, t);
};
jt.useRef = function (n) {
  return Zr.current.useRef(n);
};
jt.useState = function (n) {
  return Zr.current.useState(n);
};
jt.useSyncExternalStore = function (n, e, t) {
  return Zr.current.useSyncExternalStore(n, e, t);
};
jt.useTransition = function () {
  return Zr.current.useTransition();
};
jt.version = "18.3.1";
GO.exports = jt;
var P = GO.exports;
const Le = cT(P),
  pT = jO({ __proto__: null, default: Le }, [P]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var gH = P,
  vH = Symbol.for("react.element"),
  yH = Symbol.for("react.fragment"),
  xH = Object.prototype.hasOwnProperty,
  _H = gH.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  wH = { key: !0, ref: !0, __self: !0, __source: !0 };
function eD(n, e, t) {
  var r,
    i = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (r in e) xH.call(e, r) && !wH.hasOwnProperty(r) && (i[r] = e[r]);
  if (n && n.defaultProps)
    for (r in ((e = n.defaultProps), e)) i[r] === void 0 && (i[r] = e[r]);
  return {
    $$typeof: vH,
    type: n,
    key: s,
    ref: o,
    props: i,
    _owner: _H.current,
  };
}
dx.Fragment = yH;
dx.jsx = eD;
dx.jsxs = eD;
WO.exports = dx;
var T = WO.exports,
  tD = { exports: {} },
  ki = {},
  nD = { exports: {} },
  rD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(U, H) {
    var X = U.length;
    U.push(H);
    e: for (; 0 < X; ) {
      var ie = (X - 1) >>> 1,
        de = U[ie];
      if (0 < i(de, H)) (U[ie] = H), (U[X] = de), (X = ie);
      else break e;
    }
  }
  function t(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var H = U[0],
      X = U.pop();
    if (X !== H) {
      U[0] = X;
      e: for (var ie = 0, de = U.length, Ee = de >>> 1; ie < Ee; ) {
        var Ie = 2 * (ie + 1) - 1,
          se = U[Ie],
          _e = Ie + 1,
          re = U[_e];
        if (0 > i(se, X))
          _e < de && 0 > i(re, se)
            ? ((U[ie] = re), (U[_e] = X), (ie = _e))
            : ((U[ie] = se), (U[Ie] = X), (ie = Ie));
        else if (_e < de && 0 > i(re, X)) (U[ie] = re), (U[_e] = X), (ie = _e);
        else break e;
      }
    }
    return H;
  }
  function i(U, H) {
    var X = U.sortIndex - H.sortIndex;
    return X !== 0 ? X : U.id - H.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    p = 3,
    m = !1,
    v = !1,
    y = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var H = t(c); H !== null; ) {
      if (H.callback === null) r(c);
      else if (H.startTime <= U)
        r(c), (H.sortIndex = H.expirationTime), e(l, H);
      else break;
      H = t(c);
    }
  }
  function b(U) {
    if (((y = !1), S(U), !v))
      if (t(l) !== null) (v = !0), q(C);
      else {
        var H = t(c);
        H !== null && Y(b, H.startTime - U);
      }
  }
  function C(U, H) {
    (v = !1), y && ((y = !1), g(O), (O = -1)), (m = !0);
    var X = p;
    try {
      for (
        S(H), f = t(l);
        f !== null && (!(f.expirationTime > H) || (U && !D()));

      ) {
        var ie = f.callback;
        if (typeof ie == "function") {
          (f.callback = null), (p = f.priorityLevel);
          var de = ie(f.expirationTime <= H);
          (H = n.unstable_now()),
            typeof de == "function" ? (f.callback = de) : f === t(l) && r(l),
            S(H);
        } else r(l);
        f = t(l);
      }
      if (f !== null) var Ee = !0;
      else {
        var Ie = t(c);
        Ie !== null && Y(b, Ie.startTime - H), (Ee = !1);
      }
      return Ee;
    } finally {
      (f = null), (p = X), (m = !1);
    }
  }
  var A = !1,
    R = null,
    O = -1,
    I = 5,
    N = -1;
  function D() {
    return !(n.unstable_now() - N < I);
  }
  function j() {
    if (R !== null) {
      var U = n.unstable_now();
      N = U;
      var H = !0;
      try {
        H = R(!0, U);
      } finally {
        H ? $() : ((A = !1), (R = null));
      }
    } else A = !1;
  }
  var $;
  if (typeof _ == "function")
    $ = function () {
      _(j);
    };
  else if (typeof MessageChannel < "u") {
    var G = new MessageChannel(),
      Z = G.port2;
    (G.port1.onmessage = j),
      ($ = function () {
        Z.postMessage(null);
      });
  } else
    $ = function () {
      x(j, 0);
    };
  function q(U) {
    (R = U), A || ((A = !0), $());
  }
  function Y(U, H) {
    O = x(function () {
      U(n.unstable_now());
    }, H);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), q(C));
    }),
    (n.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (I = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (U) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = p;
      }
      var X = p;
      p = H;
      try {
        return U();
      } finally {
        p = X;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (U, H) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var X = p;
      p = U;
      try {
        return H();
      } finally {
        p = X;
      }
    }),
    (n.unstable_scheduleCallback = function (U, H, X) {
      var ie = n.unstable_now();
      switch (
        (typeof X == "object" && X !== null
          ? ((X = X.delay), (X = typeof X == "number" && 0 < X ? ie + X : ie))
          : (X = ie),
        U)
      ) {
        case 1:
          var de = -1;
          break;
        case 2:
          de = 250;
          break;
        case 5:
          de = 1073741823;
          break;
        case 4:
          de = 1e4;
          break;
        default:
          de = 5e3;
      }
      return (
        (de = X + de),
        (U = {
          id: u++,
          callback: H,
          priorityLevel: U,
          startTime: X,
          expirationTime: de,
          sortIndex: -1,
        }),
        X > ie
          ? ((U.sortIndex = X),
            e(c, U),
            t(l) === null &&
              U === t(c) &&
              (y ? (g(O), (O = -1)) : (y = !0), Y(b, X - ie)))
          : ((U.sortIndex = de), e(l, U), v || m || ((v = !0), q(C))),
        U
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (U) {
      var H = p;
      return function () {
        var X = p;
        p = H;
        try {
          return U.apply(this, arguments);
        } finally {
          p = X;
        }
      };
    });
})(rD);
nD.exports = rD;
var SH = nD.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var bH = P,
  Oi = SH;
function Pe(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var iD = new Set(),
  hp = {};
function $c(n, e) {
  Gd(n, e), Gd(n + "Capture", e);
}
function Gd(n, e) {
  for (hp[n] = e, n = 0; n < e.length; n++) iD.add(e[n]);
}
var Ko = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  q1 = Object.prototype.hasOwnProperty,
  EH =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  YR = {},
  JR = {};
function TH(n) {
  return q1.call(JR, n)
    ? !0
    : q1.call(YR, n)
    ? !1
    : EH.test(n)
    ? (JR[n] = !0)
    : ((YR[n] = !0), !1);
}
function MH(n, e, t, r) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function CH(n, e, t, r) {
  if (e === null || typeof e > "u" || MH(n, e, t, r)) return !0;
  if (r) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function Qr(n, e, t, r, i, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var vr = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    vr[n] = new Qr(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  vr[e] = new Qr(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  vr[n] = new Qr(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  vr[n] = new Qr(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    vr[n] = new Qr(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  vr[n] = new Qr(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  vr[n] = new Qr(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  vr[n] = new Qr(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  vr[n] = new Qr(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var mT = /[\-:]([a-z])/g;
function gT(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(mT, gT);
    vr[e] = new Qr(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace(mT, gT);
    vr[e] = new Qr(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace(mT, gT);
  vr[e] = new Qr(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  vr[n] = new Qr(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
vr.xlinkHref = new Qr(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  vr[n] = new Qr(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function vT(n, e, t, r) {
  var i = vr.hasOwnProperty(e) ? vr[e] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (CH(e, t, i, r) && (t = null),
    r || i === null
      ? TH(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : i.mustUseProperty
      ? (n[i.propertyName] = t === null ? (i.type === 3 ? !1 : "") : t)
      : ((e = i.attributeName),
        (r = i.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((i = i.type),
            (t = i === 3 || (i === 4 && t === !0) ? "" : "" + t),
            r ? n.setAttributeNS(r, e, t) : n.setAttribute(e, t))));
}
var aa = bH.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Ng = Symbol.for("react.element"),
  td = Symbol.for("react.portal"),
  nd = Symbol.for("react.fragment"),
  yT = Symbol.for("react.strict_mode"),
  K1 = Symbol.for("react.profiler"),
  sD = Symbol.for("react.provider"),
  oD = Symbol.for("react.context"),
  xT = Symbol.for("react.forward_ref"),
  Y1 = Symbol.for("react.suspense"),
  J1 = Symbol.for("react.suspense_list"),
  _T = Symbol.for("react.memo"),
  Na = Symbol.for("react.lazy"),
  aD = Symbol.for("react.offscreen"),
  ZR = Symbol.iterator;
function nf(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (ZR && n[ZR]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Mn = Object.assign,
  Bw;
function Af(n) {
  if (Bw === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      Bw = (e && e[1]) || "";
    }
  return (
    `
` +
    Bw +
    n
  );
}
var zw = !1;
function Vw(n, e) {
  if (!n || zw) return "";
  zw = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var r = c;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          r = c;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        r = c;
      }
      n();
    }
  } catch (c) {
    if (c && r && typeof c.stack == "string") {
      for (
        var i = c.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var l =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (zw = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? Af(n) : "";
}
function AH(n) {
  switch (n.tag) {
    case 5:
      return Af(n.type);
    case 16:
      return Af("Lazy");
    case 13:
      return Af("Suspense");
    case 19:
      return Af("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = Vw(n.type, !1)), n;
    case 11:
      return (n = Vw(n.type.render, !1)), n;
    case 1:
      return (n = Vw(n.type, !0)), n;
    default:
      return "";
  }
}
function Z1(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case nd:
      return "Fragment";
    case td:
      return "Portal";
    case K1:
      return "Profiler";
    case yT:
      return "StrictMode";
    case Y1:
      return "Suspense";
    case J1:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case oD:
        return (n.displayName || "Context") + ".Consumer";
      case sD:
        return (n._context.displayName || "Context") + ".Provider";
      case xT:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case _T:
        return (
          (e = n.displayName || null), e !== null ? e : Z1(n.type) || "Memo"
        );
      case Na:
        (e = n._payload), (n = n._init);
        try {
          return Z1(n(e));
        } catch {}
    }
  return null;
}
function RH(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Z1(e);
    case 8:
      return e === yT ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function al(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function lD(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function PH(n) {
  var e = lD(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    r = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var i = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Lg(n) {
  n._valueTracker || (n._valueTracker = PH(n));
}
function cD(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    r = "";
  return (
    n && (r = lD(n) ? (n.checked ? "true" : "false") : n.value),
    (n = r),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function Oy(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function Q1(n, e) {
  var t = e.checked;
  return Mn({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function QR(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  (t = al(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: r,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function uD(n, e) {
  (e = e.checked), e != null && vT(n, "checked", e, !1);
}
function eb(n, e) {
  uD(n, e);
  var t = al(e.value),
    r = e.type;
  if (t != null)
    r === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (r === "submit" || r === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? tb(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && tb(n, e.type, al(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function eP(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function tb(n, e, t) {
  (e !== "number" || Oy(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var Rf = Array.isArray;
function bd(n, e, t, r) {
  if (((n = n.options), e)) {
    e = {};
    for (var i = 0; i < t.length; i++) e["$" + t[i]] = !0;
    for (t = 0; t < n.length; t++)
      (i = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== i && (n[t].selected = i),
        i && r && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + al(t), e = null, i = 0; i < n.length; i++) {
      if (n[i].value === t) {
        (n[i].selected = !0), r && (n[i].defaultSelected = !0);
        return;
      }
      e !== null || n[i].disabled || (e = n[i]);
    }
    e !== null && (e.selected = !0);
  }
}
function nb(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Pe(91));
  return Mn({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function tP(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(Pe(92));
      if (Rf(t)) {
        if (1 < t.length) throw Error(Pe(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: al(t) };
}
function dD(n, e) {
  var t = al(e.value),
    r = al(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    r != null && (n.defaultValue = "" + r);
}
function nP(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function hD(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function rb(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? hD(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Og,
  fD = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, r, i);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Og = Og || document.createElement("div"),
          Og.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Og.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function fp(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var Ff = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  IH = ["Webkit", "ms", "Moz", "O"];
Object.keys(Ff).forEach(function (n) {
  IH.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (Ff[e] = Ff[n]);
  });
});
function pD(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (Ff.hasOwnProperty(n) && Ff[n])
    ? ("" + e).trim()
    : e + "px";
}
function mD(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var r = t.indexOf("--") === 0,
        i = pD(t, e[t], r);
      t === "float" && (t = "cssFloat"), r ? n.setProperty(t, i) : (n[t] = i);
    }
}
var NH = Mn(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function ib(n, e) {
  if (e) {
    if (NH[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(Pe(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Pe(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(Pe(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Pe(62));
  }
}
function sb(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var ob = null;
function wT(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var ab = null,
  Ed = null,
  Td = null;
function rP(n) {
  if ((n = hm(n))) {
    if (typeof ab != "function") throw Error(Pe(280));
    var e = n.stateNode;
    e && ((e = gx(e)), ab(n.stateNode, n.type, e));
  }
}
function gD(n) {
  Ed ? (Td ? Td.push(n) : (Td = [n])) : (Ed = n);
}
function vD() {
  if (Ed) {
    var n = Ed,
      e = Td;
    if (((Td = Ed = null), rP(n), e)) for (n = 0; n < e.length; n++) rP(e[n]);
  }
}
function yD(n, e) {
  return n(e);
}
function xD() {}
var jw = !1;
function _D(n, e, t) {
  if (jw) return n(e, t);
  jw = !0;
  try {
    return yD(n, e, t);
  } finally {
    (jw = !1), (Ed !== null || Td !== null) && (xD(), vD());
  }
}
function pp(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var r = gx(t);
  if (r === null) return null;
  t = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((n = n.type),
        (r = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !r);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(Pe(231, e, typeof t));
  return t;
}
var lb = !1;
if (Ko)
  try {
    var rf = {};
    Object.defineProperty(rf, "passive", {
      get: function () {
        lb = !0;
      },
    }),
      window.addEventListener("test", rf, rf),
      window.removeEventListener("test", rf, rf);
  } catch {
    lb = !1;
  }
function LH(n, e, t, r, i, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, c);
  } catch (u) {
    this.onError(u);
  }
}
var Bf = !1,
  Dy = null,
  ky = !1,
  cb = null,
  OH = {
    onError: function (n) {
      (Bf = !0), (Dy = n);
    },
  };
function DH(n, e, t, r, i, s, o, a, l) {
  (Bf = !1), (Dy = null), LH.apply(OH, arguments);
}
function kH(n, e, t, r, i, s, o, a, l) {
  if ((DH.apply(this, arguments), Bf)) {
    if (Bf) {
      var c = Dy;
      (Bf = !1), (Dy = null);
    } else throw Error(Pe(198));
    ky || ((ky = !0), (cb = c));
  }
}
function Xc(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function wD(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function iP(n) {
  if (Xc(n) !== n) throw Error(Pe(188));
}
function UH(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = Xc(n)), e === null)) throw Error(Pe(188));
    return e !== n ? null : n;
  }
  for (var t = n, r = e; ; ) {
    var i = t.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        t = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === t) return iP(i), n;
        if (s === r) return iP(i), e;
        s = s.sibling;
      }
      throw Error(Pe(188));
    }
    if (t.return !== r.return) (t = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === t) {
          (o = !0), (t = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (t = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Pe(189));
      }
    }
    if (t.alternate !== r) throw Error(Pe(190));
  }
  if (t.tag !== 3) throw Error(Pe(188));
  return t.stateNode.current === t ? n : e;
}
function SD(n) {
  return (n = UH(n)), n !== null ? bD(n) : null;
}
function bD(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = bD(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var ED = Oi.unstable_scheduleCallback,
  sP = Oi.unstable_cancelCallback,
  FH = Oi.unstable_shouldYield,
  BH = Oi.unstable_requestPaint,
  Bn = Oi.unstable_now,
  zH = Oi.unstable_getCurrentPriorityLevel,
  ST = Oi.unstable_ImmediatePriority,
  TD = Oi.unstable_UserBlockingPriority,
  Uy = Oi.unstable_NormalPriority,
  VH = Oi.unstable_LowPriority,
  MD = Oi.unstable_IdlePriority,
  hx = null,
  lo = null;
function jH(n) {
  if (lo && typeof lo.onCommitFiberRoot == "function")
    try {
      lo.onCommitFiberRoot(hx, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var Ls = Math.clz32 ? Math.clz32 : GH,
  HH = Math.log,
  WH = Math.LN2;
function GH(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((HH(n) / WH) | 0)) | 0;
}
var Dg = 64,
  kg = 4194304;
function Pf(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function Fy(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var r = 0,
    i = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = Pf(a)) : ((s &= o), s !== 0 && (r = Pf(s)));
  } else (o = t & ~i), o !== 0 ? (r = Pf(o)) : s !== 0 && (r = Pf(s));
  if (r === 0) return 0;
  if (
    e !== 0 &&
    e !== r &&
    !(e & i) &&
    ((i = r & -r), (s = e & -e), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((r & 4 && (r |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= r; 0 < e; )
      (t = 31 - Ls(e)), (i = 1 << t), (r |= n[t]), (e &= ~i);
  return r;
}
function $H(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function XH(n, e) {
  for (
    var t = n.suspendedLanes,
      r = n.pingedLanes,
      i = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - Ls(s),
      a = 1 << o,
      l = i[o];
    l === -1
      ? (!(a & t) || a & r) && (i[o] = $H(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function ub(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function CD() {
  var n = Dg;
  return (Dg <<= 1), !(Dg & 4194240) && (Dg = 64), n;
}
function Hw(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function um(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - Ls(e)),
    (n[e] = t);
}
function qH(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var r = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var i = 31 - Ls(t),
      s = 1 << i;
    (e[i] = 0), (r[i] = -1), (n[i] = -1), (t &= ~s);
  }
}
function bT(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var r = 31 - Ls(t),
      i = 1 << r;
    (i & e) | (n[r] & e) && (n[r] |= e), (t &= ~i);
  }
}
var rn = 0;
function AD(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var RD,
  ET,
  PD,
  ID,
  ND,
  db = !1,
  Ug = [],
  Ja = null,
  Za = null,
  Qa = null,
  mp = new Map(),
  gp = new Map(),
  Fa = [],
  KH =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function oP(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Ja = null;
      break;
    case "dragenter":
    case "dragleave":
      Za = null;
      break;
    case "mouseover":
    case "mouseout":
      Qa = null;
      break;
    case "pointerover":
    case "pointerout":
      mp.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      gp.delete(e.pointerId);
  }
}
function sf(n, e, t, r, i, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      e !== null && ((e = hm(e)), e !== null && ET(e)),
      n)
    : ((n.eventSystemFlags |= r),
      (e = n.targetContainers),
      i !== null && e.indexOf(i) === -1 && e.push(i),
      n);
}
function YH(n, e, t, r, i) {
  switch (e) {
    case "focusin":
      return (Ja = sf(Ja, n, e, t, r, i)), !0;
    case "dragenter":
      return (Za = sf(Za, n, e, t, r, i)), !0;
    case "mouseover":
      return (Qa = sf(Qa, n, e, t, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return mp.set(s, sf(mp.get(s) || null, n, e, t, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), gp.set(s, sf(gp.get(s) || null, n, e, t, r, i)), !0
      );
  }
  return !1;
}
function LD(n) {
  var e = uc(n.target);
  if (e !== null) {
    var t = Xc(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = wD(t)), e !== null)) {
          (n.blockedOn = e),
            ND(n.priority, function () {
              PD(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function uy(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = hb(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var r = new t.constructor(t.type, t);
      (ob = r), t.target.dispatchEvent(r), (ob = null);
    } else return (e = hm(t)), e !== null && ET(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function aP(n, e, t) {
  uy(n) && t.delete(e);
}
function JH() {
  (db = !1),
    Ja !== null && uy(Ja) && (Ja = null),
    Za !== null && uy(Za) && (Za = null),
    Qa !== null && uy(Qa) && (Qa = null),
    mp.forEach(aP),
    gp.forEach(aP);
}
function of(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    db ||
      ((db = !0),
      Oi.unstable_scheduleCallback(Oi.unstable_NormalPriority, JH)));
}
function vp(n) {
  function e(i) {
    return of(i, n);
  }
  if (0 < Ug.length) {
    of(Ug[0], n);
    for (var t = 1; t < Ug.length; t++) {
      var r = Ug[t];
      r.blockedOn === n && (r.blockedOn = null);
    }
  }
  for (
    Ja !== null && of(Ja, n),
      Za !== null && of(Za, n),
      Qa !== null && of(Qa, n),
      mp.forEach(e),
      gp.forEach(e),
      t = 0;
    t < Fa.length;
    t++
  )
    (r = Fa[t]), r.blockedOn === n && (r.blockedOn = null);
  for (; 0 < Fa.length && ((t = Fa[0]), t.blockedOn === null); )
    LD(t), t.blockedOn === null && Fa.shift();
}
var Md = aa.ReactCurrentBatchConfig,
  By = !0;
function ZH(n, e, t, r) {
  var i = rn,
    s = Md.transition;
  Md.transition = null;
  try {
    (rn = 1), TT(n, e, t, r);
  } finally {
    (rn = i), (Md.transition = s);
  }
}
function QH(n, e, t, r) {
  var i = rn,
    s = Md.transition;
  Md.transition = null;
  try {
    (rn = 4), TT(n, e, t, r);
  } finally {
    (rn = i), (Md.transition = s);
  }
}
function TT(n, e, t, r) {
  if (By) {
    var i = hb(n, e, t, r);
    if (i === null) Qw(n, e, r, zy, t), oP(n, r);
    else if (YH(i, n, e, t, r)) r.stopPropagation();
    else if ((oP(n, r), e & 4 && -1 < KH.indexOf(n))) {
      for (; i !== null; ) {
        var s = hm(i);
        if (
          (s !== null && RD(s),
          (s = hb(n, e, t, r)),
          s === null && Qw(n, e, r, zy, t),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else Qw(n, e, r, null, t);
  }
}
var zy = null;
function hb(n, e, t, r) {
  if (((zy = null), (n = wT(r)), (n = uc(n)), n !== null))
    if (((e = Xc(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = wD(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (zy = n), null;
}
function OD(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (zH()) {
        case ST:
          return 1;
        case TD:
          return 4;
        case Uy:
        case VH:
          return 16;
        case MD:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Xa = null,
  MT = null,
  dy = null;
function DD() {
  if (dy) return dy;
  var n,
    e = MT,
    t = e.length,
    r,
    i = "value" in Xa ? Xa.value : Xa.textContent,
    s = i.length;
  for (n = 0; n < t && e[n] === i[n]; n++);
  var o = t - n;
  for (r = 1; r <= o && e[t - r] === i[s - r]; r++);
  return (dy = i.slice(n, 1 < r ? 1 - r : void 0));
}
function hy(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Fg() {
  return !0;
}
function lP() {
  return !1;
}
function Ui(n) {
  function e(t, r, i, s, o) {
    (this._reactName = t),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Fg
        : lP),
      (this.isPropagationStopped = lP),
      this
    );
  }
  return (
    Mn(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Fg));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Fg));
      },
      persist: function () {},
      isPersistent: Fg,
    }),
    e
  );
}
var gh = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  CT = Ui(gh),
  dm = Mn({}, gh, { view: 0, detail: 0 }),
  eW = Ui(dm),
  Ww,
  Gw,
  af,
  fx = Mn({}, dm, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: AT,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== af &&
            (af && n.type === "mousemove"
              ? ((Ww = n.screenX - af.screenX), (Gw = n.screenY - af.screenY))
              : (Gw = Ww = 0),
            (af = n)),
          Ww);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : Gw;
    },
  }),
  cP = Ui(fx),
  tW = Mn({}, fx, { dataTransfer: 0 }),
  nW = Ui(tW),
  rW = Mn({}, dm, { relatedTarget: 0 }),
  $w = Ui(rW),
  iW = Mn({}, gh, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  sW = Ui(iW),
  oW = Mn({}, gh, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  aW = Ui(oW),
  lW = Mn({}, gh, { data: 0 }),
  uP = Ui(lW),
  cW = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  uW = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  dW = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function hW(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = dW[n]) ? !!e[n] : !1;
}
function AT() {
  return hW;
}
var fW = Mn({}, dm, {
    key: function (n) {
      if (n.key) {
        var e = cW[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = hy(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? uW[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: AT,
    charCode: function (n) {
      return n.type === "keypress" ? hy(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? hy(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  pW = Ui(fW),
  mW = Mn({}, fx, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  dP = Ui(mW),
  gW = Mn({}, dm, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: AT,
  }),
  vW = Ui(gW),
  yW = Mn({}, gh, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  xW = Ui(yW),
  _W = Mn({}, fx, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  wW = Ui(_W),
  SW = [9, 13, 27, 32],
  RT = Ko && "CompositionEvent" in window,
  zf = null;
Ko && "documentMode" in document && (zf = document.documentMode);
var bW = Ko && "TextEvent" in window && !zf,
  kD = Ko && (!RT || (zf && 8 < zf && 11 >= zf)),
  hP = " ",
  fP = !1;
function UD(n, e) {
  switch (n) {
    case "keyup":
      return SW.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function FD(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var rd = !1;
function EW(n, e) {
  switch (n) {
    case "compositionend":
      return FD(e);
    case "keypress":
      return e.which !== 32 ? null : ((fP = !0), hP);
    case "textInput":
      return (n = e.data), n === hP && fP ? null : n;
    default:
      return null;
  }
}
function TW(n, e) {
  if (rd)
    return n === "compositionend" || (!RT && UD(n, e))
      ? ((n = DD()), (dy = MT = Xa = null), (rd = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return kD && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var MW = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function pP(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!MW[n.type] : e === "textarea";
}
function BD(n, e, t, r) {
  gD(r),
    (e = Vy(e, "onChange")),
    0 < e.length &&
      ((t = new CT("onChange", "change", null, t, r)),
      n.push({ event: t, listeners: e }));
}
var Vf = null,
  yp = null;
function CW(n) {
  YD(n, 0);
}
function px(n) {
  var e = od(n);
  if (cD(e)) return n;
}
function AW(n, e) {
  if (n === "change") return e;
}
var zD = !1;
if (Ko) {
  var Xw;
  if (Ko) {
    var qw = "oninput" in document;
    if (!qw) {
      var mP = document.createElement("div");
      mP.setAttribute("oninput", "return;"),
        (qw = typeof mP.oninput == "function");
    }
    Xw = qw;
  } else Xw = !1;
  zD = Xw && (!document.documentMode || 9 < document.documentMode);
}
function gP() {
  Vf && (Vf.detachEvent("onpropertychange", VD), (yp = Vf = null));
}
function VD(n) {
  if (n.propertyName === "value" && px(yp)) {
    var e = [];
    BD(e, yp, n, wT(n)), _D(CW, e);
  }
}
function RW(n, e, t) {
  n === "focusin"
    ? (gP(), (Vf = e), (yp = t), Vf.attachEvent("onpropertychange", VD))
    : n === "focusout" && gP();
}
function PW(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return px(yp);
}
function IW(n, e) {
  if (n === "click") return px(e);
}
function NW(n, e) {
  if (n === "input" || n === "change") return px(e);
}
function LW(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var Ds = typeof Object.is == "function" ? Object.is : LW;
function xp(n, e) {
  if (Ds(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    r = Object.keys(e);
  if (t.length !== r.length) return !1;
  for (r = 0; r < t.length; r++) {
    var i = t[r];
    if (!q1.call(e, i) || !Ds(n[i], e[i])) return !1;
  }
  return !0;
}
function vP(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function yP(n, e) {
  var t = vP(n);
  n = 0;
  for (var r; t; ) {
    if (t.nodeType === 3) {
      if (((r = n + t.textContent.length), n <= e && r >= e))
        return { node: t, offset: e - n };
      n = r;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = vP(t);
  }
}
function jD(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? jD(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function HD() {
  for (var n = window, e = Oy(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = Oy(n.document);
  }
  return e;
}
function PT(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function OW(n) {
  var e = HD(),
    t = n.focusedElem,
    r = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    jD(t.ownerDocument.documentElement, t)
  ) {
    if (r !== null && PT(t)) {
      if (
        ((e = r.start),
        (n = r.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var i = t.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !n.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = yP(t, s));
        var o = yP(t, r);
        i &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== i.node ||
            n.anchorOffset !== i.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(i.node, i.offset),
          n.removeAllRanges(),
          s > r
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var DW = Ko && "documentMode" in document && 11 >= document.documentMode,
  id = null,
  fb = null,
  jf = null,
  pb = !1;
function xP(n, e, t) {
  var r = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  pb ||
    id == null ||
    id !== Oy(r) ||
    ((r = id),
    "selectionStart" in r && PT(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (jf && xp(jf, r)) ||
      ((jf = r),
      (r = Vy(fb, "onSelect")),
      0 < r.length &&
        ((e = new CT("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: r }),
        (e.target = id))));
}
function Bg(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var sd = {
    animationend: Bg("Animation", "AnimationEnd"),
    animationiteration: Bg("Animation", "AnimationIteration"),
    animationstart: Bg("Animation", "AnimationStart"),
    transitionend: Bg("Transition", "TransitionEnd"),
  },
  Kw = {},
  WD = {};
Ko &&
  ((WD = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete sd.animationend.animation,
    delete sd.animationiteration.animation,
    delete sd.animationstart.animation),
  "TransitionEvent" in window || delete sd.transitionend.transition);
function mx(n) {
  if (Kw[n]) return Kw[n];
  if (!sd[n]) return n;
  var e = sd[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in WD) return (Kw[n] = e[t]);
  return n;
}
var GD = mx("animationend"),
  $D = mx("animationiteration"),
  XD = mx("animationstart"),
  qD = mx("transitionend"),
  KD = new Map(),
  _P =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ml(n, e) {
  KD.set(n, e), $c(e, [n]);
}
for (var Yw = 0; Yw < _P.length; Yw++) {
  var Jw = _P[Yw],
    kW = Jw.toLowerCase(),
    UW = Jw[0].toUpperCase() + Jw.slice(1);
  ml(kW, "on" + UW);
}
ml(GD, "onAnimationEnd");
ml($D, "onAnimationIteration");
ml(XD, "onAnimationStart");
ml("dblclick", "onDoubleClick");
ml("focusin", "onFocus");
ml("focusout", "onBlur");
ml(qD, "onTransitionEnd");
Gd("onMouseEnter", ["mouseout", "mouseover"]);
Gd("onMouseLeave", ["mouseout", "mouseover"]);
Gd("onPointerEnter", ["pointerout", "pointerover"]);
Gd("onPointerLeave", ["pointerout", "pointerover"]);
$c(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
$c(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
$c("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
$c(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
$c(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
$c(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var If =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  FW = new Set("cancel close invalid load scroll toggle".split(" ").concat(If));
function wP(n, e, t) {
  var r = n.type || "unknown-event";
  (n.currentTarget = t), kH(r, e, void 0, n), (n.currentTarget = null);
}
function YD(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var r = n[t],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && i.isPropagationStopped())) break e;
          wP(i, a, c), (s = l);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && i.isPropagationStopped())
          )
            break e;
          wP(i, a, c), (s = l);
        }
    }
  }
  if (ky) throw ((n = cb), (ky = !1), (cb = null), n);
}
function dn(n, e) {
  var t = e[xb];
  t === void 0 && (t = e[xb] = new Set());
  var r = n + "__bubble";
  t.has(r) || (JD(e, n, 2, !1), t.add(r));
}
function Zw(n, e, t) {
  var r = 0;
  e && (r |= 4), JD(t, n, r, e);
}
var zg = "_reactListening" + Math.random().toString(36).slice(2);
function _p(n) {
  if (!n[zg]) {
    (n[zg] = !0),
      iD.forEach(function (t) {
        t !== "selectionchange" && (FW.has(t) || Zw(t, !1, n), Zw(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[zg] || ((e[zg] = !0), Zw("selectionchange", !1, e));
  }
}
function JD(n, e, t, r) {
  switch (OD(e)) {
    case 1:
      var i = ZH;
      break;
    case 4:
      i = QH;
      break;
    default:
      i = TT;
  }
  (t = i.bind(null, e, t, n)),
    (i = void 0),
    !lb ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: i })
        : n.addEventListener(e, t, !0)
      : i !== void 0
      ? n.addEventListener(e, t, { passive: i })
      : n.addEventListener(e, t, !1);
}
function Qw(n, e, t, r, i) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === i || (l.nodeType === 8 && l.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = uc(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  _D(function () {
    var c = s,
      u = wT(t),
      f = [];
    e: {
      var p = KD.get(n);
      if (p !== void 0) {
        var m = CT,
          v = n;
        switch (n) {
          case "keypress":
            if (hy(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = pW;
            break;
          case "focusin":
            (v = "focus"), (m = $w);
            break;
          case "focusout":
            (v = "blur"), (m = $w);
            break;
          case "beforeblur":
          case "afterblur":
            m = $w;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = cP;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = nW;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = vW;
            break;
          case GD:
          case $D:
          case XD:
            m = sW;
            break;
          case qD:
            m = xW;
            break;
          case "scroll":
            m = eW;
            break;
          case "wheel":
            m = wW;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = aW;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = dP;
        }
        var y = (e & 4) !== 0,
          x = !y && n === "scroll",
          g = y ? (p !== null ? p + "Capture" : null) : p;
        y = [];
        for (var _ = c, S; _ !== null; ) {
          S = _;
          var b = S.stateNode;
          if (
            (S.tag === 5 &&
              b !== null &&
              ((S = b),
              g !== null && ((b = pp(_, g)), b != null && y.push(wp(_, b, S)))),
            x)
          )
            break;
          _ = _.return;
        }
        0 < y.length &&
          ((p = new m(p, v, null, t, u)), f.push({ event: p, listeners: y }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== ob &&
            (v = t.relatedTarget || t.fromElement) &&
            (uc(v) || v[Yo]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            u.window === u
              ? u
              : (p = u.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((v = t.relatedTarget || t.toElement),
              (m = c),
              (v = v ? uc(v) : null),
              v !== null &&
                ((x = Xc(v)), v !== x || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((m = null), (v = c)),
          m !== v)
        ) {
          if (
            ((y = cP),
            (b = "onMouseLeave"),
            (g = "onMouseEnter"),
            (_ = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((y = dP),
              (b = "onPointerLeave"),
              (g = "onPointerEnter"),
              (_ = "pointer")),
            (x = m == null ? p : od(m)),
            (S = v == null ? p : od(v)),
            (p = new y(b, _ + "leave", m, t, u)),
            (p.target = x),
            (p.relatedTarget = S),
            (b = null),
            uc(u) === c &&
              ((y = new y(g, _ + "enter", v, t, u)),
              (y.target = S),
              (y.relatedTarget = x),
              (b = y)),
            (x = b),
            m && v)
          )
            t: {
              for (y = m, g = v, _ = 0, S = y; S; S = vu(S)) _++;
              for (S = 0, b = g; b; b = vu(b)) S++;
              for (; 0 < _ - S; ) (y = vu(y)), _--;
              for (; 0 < S - _; ) (g = vu(g)), S--;
              for (; _--; ) {
                if (y === g || (g !== null && y === g.alternate)) break t;
                (y = vu(y)), (g = vu(g));
              }
              y = null;
            }
          else y = null;
          m !== null && SP(f, p, m, y, !1),
            v !== null && x !== null && SP(f, x, v, y, !0);
        }
      }
      e: {
        if (
          ((p = c ? od(c) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var C = AW;
        else if (pP(p))
          if (zD) C = NW;
          else {
            C = PW;
            var A = RW;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (C = IW);
        if (C && (C = C(n, c))) {
          BD(f, C, t, u);
          break e;
        }
        A && A(n, p, c),
          n === "focusout" &&
            (A = p._wrapperState) &&
            A.controlled &&
            p.type === "number" &&
            tb(p, "number", p.value);
      }
      switch (((A = c ? od(c) : window), n)) {
        case "focusin":
          (pP(A) || A.contentEditable === "true") &&
            ((id = A), (fb = c), (jf = null));
          break;
        case "focusout":
          jf = fb = id = null;
          break;
        case "mousedown":
          pb = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (pb = !1), xP(f, t, u);
          break;
        case "selectionchange":
          if (DW) break;
        case "keydown":
        case "keyup":
          xP(f, t, u);
      }
      var R;
      if (RT)
        e: {
          switch (n) {
            case "compositionstart":
              var O = "onCompositionStart";
              break e;
            case "compositionend":
              O = "onCompositionEnd";
              break e;
            case "compositionupdate":
              O = "onCompositionUpdate";
              break e;
          }
          O = void 0;
        }
      else
        rd
          ? UD(n, t) && (O = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (O = "onCompositionStart");
      O &&
        (kD &&
          t.locale !== "ko" &&
          (rd || O !== "onCompositionStart"
            ? O === "onCompositionEnd" && rd && (R = DD())
            : ((Xa = u),
              (MT = "value" in Xa ? Xa.value : Xa.textContent),
              (rd = !0))),
        (A = Vy(c, O)),
        0 < A.length &&
          ((O = new uP(O, n, null, t, u)),
          f.push({ event: O, listeners: A }),
          R ? (O.data = R) : ((R = FD(t)), R !== null && (O.data = R)))),
        (R = bW ? EW(n, t) : TW(n, t)) &&
          ((c = Vy(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new uP("onBeforeInput", "beforeinput", null, t, u)),
            f.push({ event: u, listeners: c }),
            (u.data = R)));
    }
    YD(f, e);
  });
}
function wp(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Vy(n, e) {
  for (var t = e + "Capture", r = []; n !== null; ) {
    var i = n,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = pp(n, t)),
      s != null && r.unshift(wp(n, s, i)),
      (s = pp(n, e)),
      s != null && r.push(wp(n, s, i))),
      (n = n.return);
  }
  return r;
}
function vu(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function SP(n, e, t, r, i) {
  for (var s = e._reactName, o = []; t !== null && t !== r; ) {
    var a = t,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === r) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      i
        ? ((l = pp(t, s)), l != null && o.unshift(wp(t, l, a)))
        : i || ((l = pp(t, s)), l != null && o.push(wp(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var BW = /\r\n?/g,
  zW = /\u0000|\uFFFD/g;
function bP(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      BW,
      `
`
    )
    .replace(zW, "");
}
function Vg(n, e, t) {
  if (((e = bP(e)), bP(n) !== e && t)) throw Error(Pe(425));
}
function jy() {}
var mb = null,
  gb = null;
function vb(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var yb = typeof setTimeout == "function" ? setTimeout : void 0,
  VW = typeof clearTimeout == "function" ? clearTimeout : void 0,
  EP = typeof Promise == "function" ? Promise : void 0,
  jW =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof EP < "u"
      ? function (n) {
          return EP.resolve(null).then(n).catch(HW);
        }
      : yb;
function HW(n) {
  setTimeout(function () {
    throw n;
  });
}
function eS(n, e) {
  var t = e,
    r = 0;
  do {
    var i = t.nextSibling;
    if ((n.removeChild(t), i && i.nodeType === 8))
      if (((t = i.data), t === "/$")) {
        if (r === 0) {
          n.removeChild(i), vp(e);
          return;
        }
        r--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || r++;
    t = i;
  } while (t);
  vp(e);
}
function el(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function TP(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var vh = Math.random().toString(36).slice(2),
  ro = "__reactFiber$" + vh,
  Sp = "__reactProps$" + vh,
  Yo = "__reactContainer$" + vh,
  xb = "__reactEvents$" + vh,
  WW = "__reactListeners$" + vh,
  GW = "__reactHandles$" + vh;
function uc(n) {
  var e = n[ro];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Yo] || t[ro])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = TP(n); n !== null; ) {
          if ((t = n[ro])) return t;
          n = TP(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function hm(n) {
  return (
    (n = n[ro] || n[Yo]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function od(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(Pe(33));
}
function gx(n) {
  return n[Sp] || null;
}
var _b = [],
  ad = -1;
function gl(n) {
  return { current: n };
}
function fn(n) {
  0 > ad || ((n.current = _b[ad]), (_b[ad] = null), ad--);
}
function cn(n, e) {
  ad++, (_b[ad] = n.current), (n.current = e);
}
var ll = {},
  kr = gl(ll),
  pi = gl(!1),
  Lc = ll;
function $d(n, e) {
  var t = n.type.contextTypes;
  if (!t) return ll;
  var r = n.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in t) i[s] = e[s];
  return (
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function mi(n) {
  return (n = n.childContextTypes), n != null;
}
function Hy() {
  fn(pi), fn(kr);
}
function MP(n, e, t) {
  if (kr.current !== ll) throw Error(Pe(168));
  cn(kr, e), cn(pi, t);
}
function ZD(n, e, t) {
  var r = n.stateNode;
  if (((e = e.childContextTypes), typeof r.getChildContext != "function"))
    return t;
  r = r.getChildContext();
  for (var i in r) if (!(i in e)) throw Error(Pe(108, RH(n) || "Unknown", i));
  return Mn({}, t, r);
}
function Wy(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || ll),
    (Lc = kr.current),
    cn(kr, n),
    cn(pi, pi.current),
    !0
  );
}
function CP(n, e, t) {
  var r = n.stateNode;
  if (!r) throw Error(Pe(169));
  t
    ? ((n = ZD(n, e, Lc)),
      (r.__reactInternalMemoizedMergedChildContext = n),
      fn(pi),
      fn(kr),
      cn(kr, n))
    : fn(pi),
    cn(pi, t);
}
var zo = null,
  vx = !1,
  tS = !1;
function QD(n) {
  zo === null ? (zo = [n]) : zo.push(n);
}
function $W(n) {
  (vx = !0), QD(n);
}
function vl() {
  if (!tS && zo !== null) {
    tS = !0;
    var n = 0,
      e = rn;
    try {
      var t = zo;
      for (rn = 1; n < t.length; n++) {
        var r = t[n];
        do r = r(!0);
        while (r !== null);
      }
      (zo = null), (vx = !1);
    } catch (i) {
      throw (zo !== null && (zo = zo.slice(n + 1)), ED(ST, vl), i);
    } finally {
      (rn = e), (tS = !1);
    }
  }
  return null;
}
var ld = [],
  cd = 0,
  Gy = null,
  $y = 0,
  Zi = [],
  Qi = 0,
  Oc = null,
  Wo = 1,
  Go = "";
function Ql(n, e) {
  (ld[cd++] = $y), (ld[cd++] = Gy), (Gy = n), ($y = e);
}
function ek(n, e, t) {
  (Zi[Qi++] = Wo), (Zi[Qi++] = Go), (Zi[Qi++] = Oc), (Oc = n);
  var r = Wo;
  n = Go;
  var i = 32 - Ls(r) - 1;
  (r &= ~(1 << i)), (t += 1);
  var s = 32 - Ls(e) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (Wo = (1 << (32 - Ls(e) + i)) | (t << i) | r),
      (Go = s + n);
  } else (Wo = (1 << s) | (t << i) | r), (Go = n);
}
function IT(n) {
  n.return !== null && (Ql(n, 1), ek(n, 1, 0));
}
function NT(n) {
  for (; n === Gy; )
    (Gy = ld[--cd]), (ld[cd] = null), ($y = ld[--cd]), (ld[cd] = null);
  for (; n === Oc; )
    (Oc = Zi[--Qi]),
      (Zi[Qi] = null),
      (Go = Zi[--Qi]),
      (Zi[Qi] = null),
      (Wo = Zi[--Qi]),
      (Zi[Qi] = null);
}
var Ii = null,
  Ri = null,
  yn = !1,
  Ps = null;
function tk(n, e) {
  var t = ns(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function AP(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Ii = n), (Ri = el(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Ii = n), (Ri = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = Oc !== null ? { id: Wo, overflow: Go } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = ns(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Ii = n),
            (Ri = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function wb(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function Sb(n) {
  if (yn) {
    var e = Ri;
    if (e) {
      var t = e;
      if (!AP(n, e)) {
        if (wb(n)) throw Error(Pe(418));
        e = el(t.nextSibling);
        var r = Ii;
        e && AP(n, e)
          ? tk(r, t)
          : ((n.flags = (n.flags & -4097) | 2), (yn = !1), (Ii = n));
      }
    } else {
      if (wb(n)) throw Error(Pe(418));
      (n.flags = (n.flags & -4097) | 2), (yn = !1), (Ii = n);
    }
  }
}
function RP(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Ii = n;
}
function jg(n) {
  if (n !== Ii) return !1;
  if (!yn) return RP(n), (yn = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !vb(n.type, n.memoizedProps))),
    e && (e = Ri))
  ) {
    if (wb(n)) throw (nk(), Error(Pe(418)));
    for (; e; ) tk(n, e), (e = el(e.nextSibling));
  }
  if ((RP(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(Pe(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Ri = el(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      Ri = null;
    }
  } else Ri = Ii ? el(n.stateNode.nextSibling) : null;
  return !0;
}
function nk() {
  for (var n = Ri; n; ) n = el(n.nextSibling);
}
function Xd() {
  (Ri = Ii = null), (yn = !1);
}
function LT(n) {
  Ps === null ? (Ps = [n]) : Ps.push(n);
}
var XW = aa.ReactCurrentBatchConfig;
function lf(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(Pe(309));
        var r = t.stateNode;
      }
      if (!r) throw Error(Pe(147, n));
      var i = r,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = i.refs;
            o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(Pe(284));
    if (!t._owner) throw Error(Pe(290, n));
  }
  return n;
}
function Hg(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      Pe(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function PP(n) {
  var e = n._init;
  return e(n._payload);
}
function rk(n) {
  function e(g, _) {
    if (n) {
      var S = g.deletions;
      S === null ? ((g.deletions = [_]), (g.flags |= 16)) : S.push(_);
    }
  }
  function t(g, _) {
    if (!n) return null;
    for (; _ !== null; ) e(g, _), (_ = _.sibling);
    return null;
  }
  function r(g, _) {
    for (g = new Map(); _ !== null; )
      _.key !== null ? g.set(_.key, _) : g.set(_.index, _), (_ = _.sibling);
    return g;
  }
  function i(g, _) {
    return (g = il(g, _)), (g.index = 0), (g.sibling = null), g;
  }
  function s(g, _, S) {
    return (
      (g.index = S),
      n
        ? ((S = g.alternate),
          S !== null
            ? ((S = S.index), S < _ ? ((g.flags |= 2), _) : S)
            : ((g.flags |= 2), _))
        : ((g.flags |= 1048576), _)
    );
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, _, S, b) {
    return _ === null || _.tag !== 6
      ? ((_ = lS(S, g.mode, b)), (_.return = g), _)
      : ((_ = i(_, S)), (_.return = g), _);
  }
  function l(g, _, S, b) {
    var C = S.type;
    return C === nd
      ? u(g, _, S.props.children, b, S.key)
      : _ !== null &&
        (_.elementType === C ||
          (typeof C == "object" &&
            C !== null &&
            C.$$typeof === Na &&
            PP(C) === _.type))
      ? ((b = i(_, S.props)), (b.ref = lf(g, _, S)), (b.return = g), b)
      : ((b = xy(S.type, S.key, S.props, null, g.mode, b)),
        (b.ref = lf(g, _, S)),
        (b.return = g),
        b);
  }
  function c(g, _, S, b) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== S.containerInfo ||
      _.stateNode.implementation !== S.implementation
      ? ((_ = cS(S, g.mode, b)), (_.return = g), _)
      : ((_ = i(_, S.children || [])), (_.return = g), _);
  }
  function u(g, _, S, b, C) {
    return _ === null || _.tag !== 7
      ? ((_ = Mc(S, g.mode, b, C)), (_.return = g), _)
      : ((_ = i(_, S)), (_.return = g), _);
  }
  function f(g, _, S) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = lS("" + _, g.mode, S)), (_.return = g), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Ng:
          return (
            (S = xy(_.type, _.key, _.props, null, g.mode, S)),
            (S.ref = lf(g, null, _)),
            (S.return = g),
            S
          );
        case td:
          return (_ = cS(_, g.mode, S)), (_.return = g), _;
        case Na:
          var b = _._init;
          return f(g, b(_._payload), S);
      }
      if (Rf(_) || nf(_))
        return (_ = Mc(_, g.mode, S, null)), (_.return = g), _;
      Hg(g, _);
    }
    return null;
  }
  function p(g, _, S, b) {
    var C = _ !== null ? _.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return C !== null ? null : a(g, _, "" + S, b);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case Ng:
          return S.key === C ? l(g, _, S, b) : null;
        case td:
          return S.key === C ? c(g, _, S, b) : null;
        case Na:
          return (C = S._init), p(g, _, C(S._payload), b);
      }
      if (Rf(S) || nf(S)) return C !== null ? null : u(g, _, S, b, null);
      Hg(g, S);
    }
    return null;
  }
  function m(g, _, S, b, C) {
    if ((typeof b == "string" && b !== "") || typeof b == "number")
      return (g = g.get(S) || null), a(_, g, "" + b, C);
    if (typeof b == "object" && b !== null) {
      switch (b.$$typeof) {
        case Ng:
          return (g = g.get(b.key === null ? S : b.key) || null), l(_, g, b, C);
        case td:
          return (g = g.get(b.key === null ? S : b.key) || null), c(_, g, b, C);
        case Na:
          var A = b._init;
          return m(g, _, S, A(b._payload), C);
      }
      if (Rf(b) || nf(b)) return (g = g.get(S) || null), u(_, g, b, C, null);
      Hg(_, b);
    }
    return null;
  }
  function v(g, _, S, b) {
    for (
      var C = null, A = null, R = _, O = (_ = 0), I = null;
      R !== null && O < S.length;
      O++
    ) {
      R.index > O ? ((I = R), (R = null)) : (I = R.sibling);
      var N = p(g, R, S[O], b);
      if (N === null) {
        R === null && (R = I);
        break;
      }
      n && R && N.alternate === null && e(g, R),
        (_ = s(N, _, O)),
        A === null ? (C = N) : (A.sibling = N),
        (A = N),
        (R = I);
    }
    if (O === S.length) return t(g, R), yn && Ql(g, O), C;
    if (R === null) {
      for (; O < S.length; O++)
        (R = f(g, S[O], b)),
          R !== null &&
            ((_ = s(R, _, O)), A === null ? (C = R) : (A.sibling = R), (A = R));
      return yn && Ql(g, O), C;
    }
    for (R = r(g, R); O < S.length; O++)
      (I = m(R, g, O, S[O], b)),
        I !== null &&
          (n && I.alternate !== null && R.delete(I.key === null ? O : I.key),
          (_ = s(I, _, O)),
          A === null ? (C = I) : (A.sibling = I),
          (A = I));
    return (
      n &&
        R.forEach(function (D) {
          return e(g, D);
        }),
      yn && Ql(g, O),
      C
    );
  }
  function y(g, _, S, b) {
    var C = nf(S);
    if (typeof C != "function") throw Error(Pe(150));
    if (((S = C.call(S)), S == null)) throw Error(Pe(151));
    for (
      var A = (C = null), R = _, O = (_ = 0), I = null, N = S.next();
      R !== null && !N.done;
      O++, N = S.next()
    ) {
      R.index > O ? ((I = R), (R = null)) : (I = R.sibling);
      var D = p(g, R, N.value, b);
      if (D === null) {
        R === null && (R = I);
        break;
      }
      n && R && D.alternate === null && e(g, R),
        (_ = s(D, _, O)),
        A === null ? (C = D) : (A.sibling = D),
        (A = D),
        (R = I);
    }
    if (N.done) return t(g, R), yn && Ql(g, O), C;
    if (R === null) {
      for (; !N.done; O++, N = S.next())
        (N = f(g, N.value, b)),
          N !== null &&
            ((_ = s(N, _, O)), A === null ? (C = N) : (A.sibling = N), (A = N));
      return yn && Ql(g, O), C;
    }
    for (R = r(g, R); !N.done; O++, N = S.next())
      (N = m(R, g, O, N.value, b)),
        N !== null &&
          (n && N.alternate !== null && R.delete(N.key === null ? O : N.key),
          (_ = s(N, _, O)),
          A === null ? (C = N) : (A.sibling = N),
          (A = N));
    return (
      n &&
        R.forEach(function (j) {
          return e(g, j);
        }),
      yn && Ql(g, O),
      C
    );
  }
  function x(g, _, S, b) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === nd &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case Ng:
          e: {
            for (var C = S.key, A = _; A !== null; ) {
              if (A.key === C) {
                if (((C = S.type), C === nd)) {
                  if (A.tag === 7) {
                    t(g, A.sibling),
                      (_ = i(A, S.props.children)),
                      (_.return = g),
                      (g = _);
                    break e;
                  }
                } else if (
                  A.elementType === C ||
                  (typeof C == "object" &&
                    C !== null &&
                    C.$$typeof === Na &&
                    PP(C) === A.type)
                ) {
                  t(g, A.sibling),
                    (_ = i(A, S.props)),
                    (_.ref = lf(g, A, S)),
                    (_.return = g),
                    (g = _);
                  break e;
                }
                t(g, A);
                break;
              } else e(g, A);
              A = A.sibling;
            }
            S.type === nd
              ? ((_ = Mc(S.props.children, g.mode, b, S.key)),
                (_.return = g),
                (g = _))
              : ((b = xy(S.type, S.key, S.props, null, g.mode, b)),
                (b.ref = lf(g, _, S)),
                (b.return = g),
                (g = b));
          }
          return o(g);
        case td:
          e: {
            for (A = S.key; _ !== null; ) {
              if (_.key === A)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === S.containerInfo &&
                  _.stateNode.implementation === S.implementation
                ) {
                  t(g, _.sibling),
                    (_ = i(_, S.children || [])),
                    (_.return = g),
                    (g = _);
                  break e;
                } else {
                  t(g, _);
                  break;
                }
              else e(g, _);
              _ = _.sibling;
            }
            (_ = cS(S, g.mode, b)), (_.return = g), (g = _);
          }
          return o(g);
        case Na:
          return (A = S._init), x(g, _, A(S._payload), b);
      }
      if (Rf(S)) return v(g, _, S, b);
      if (nf(S)) return y(g, _, S, b);
      Hg(g, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        _ !== null && _.tag === 6
          ? (t(g, _.sibling), (_ = i(_, S)), (_.return = g), (g = _))
          : (t(g, _), (_ = lS(S, g.mode, b)), (_.return = g), (g = _)),
        o(g))
      : t(g, _);
  }
  return x;
}
var qd = rk(!0),
  ik = rk(!1),
  Xy = gl(null),
  qy = null,
  ud = null,
  OT = null;
function DT() {
  OT = ud = qy = null;
}
function kT(n) {
  var e = Xy.current;
  fn(Xy), (n._currentValue = e);
}
function bb(n, e, t) {
  for (; n !== null; ) {
    var r = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), r !== null && (r.childLanes |= e))
        : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function Cd(n, e) {
  (qy = n),
    (OT = ud = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (di = !0), (n.firstContext = null));
}
function os(n) {
  var e = n._currentValue;
  if (OT !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), ud === null)) {
      if (qy === null) throw Error(Pe(308));
      (ud = n), (qy.dependencies = { lanes: 0, firstContext: n });
    } else ud = ud.next = n;
  return e;
}
var dc = null;
function UT(n) {
  dc === null ? (dc = [n]) : dc.push(n);
}
function sk(n, e, t, r) {
  var i = e.interleaved;
  return (
    i === null ? ((t.next = t), UT(e)) : ((t.next = i.next), (i.next = t)),
    (e.interleaved = t),
    Jo(n, r)
  );
}
function Jo(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var La = !1;
function FT(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function ok(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function $o(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function tl(n, e, t) {
  var r = n.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), $t & 2)) {
    var i = r.pending;
    return (
      i === null ? (e.next = e) : ((e.next = i.next), (i.next = e)),
      (r.pending = e),
      Jo(n, t)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((e.next = e), UT(r)) : ((e.next = i.next), (i.next = e)),
    (r.interleaved = e),
    Jo(n, t)
  );
}
function fy(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), bT(n, t);
  }
}
function IP(n, e) {
  var t = n.updateQueue,
    r = n.alternate;
  if (r !== null && ((r = r.updateQueue), t === r)) {
    var i = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (i = s = e) : (s = s.next = e);
    } else i = s = e;
    (t = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function Ky(n, e, t, r) {
  var i = n.updateQueue;
  La = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var u = n.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (a = u.lastBaseUpdate),
      a !== o &&
        (a === null ? (u.firstBaseUpdate = c) : (a.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var f = i.baseState;
    (o = 0), (u = c = l = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((r & p) === p) {
        u !== null &&
          (u = u.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = n,
            y = a;
          switch (((p = e), (m = t), y.tag)) {
            case 1:
              if (((v = y.payload), typeof v == "function")) {
                f = v.call(m, f, p);
                break e;
              }
              f = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = y.payload),
                (p = typeof v == "function" ? v.call(m, f, p) : v),
                p == null)
              )
                break e;
              f = Mn({}, f, p);
              break e;
            case 2:
              La = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = i.effects),
          p === null ? (i.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          u === null ? ((c = u = m), (l = f)) : (u = u.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (i.lastBaseUpdate = p),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = f),
      (i.baseState = l),
      (i.firstBaseUpdate = c),
      (i.lastBaseUpdate = u),
      (e = i.shared.interleaved),
      e !== null)
    ) {
      i = e;
      do (o |= i.lane), (i = i.next);
      while (i !== e);
    } else s === null && (i.shared.lanes = 0);
    (kc |= o), (n.lanes = o), (n.memoizedState = f);
  }
}
function NP(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var r = n[e],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = t), typeof i != "function"))
          throw Error(Pe(191, i));
        i.call(r);
      }
    }
}
var fm = {},
  co = gl(fm),
  bp = gl(fm),
  Ep = gl(fm);
function hc(n) {
  if (n === fm) throw Error(Pe(174));
  return n;
}
function BT(n, e) {
  switch ((cn(Ep, e), cn(bp, n), cn(co, fm), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : rb(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = rb(e, n));
  }
  fn(co), cn(co, e);
}
function Kd() {
  fn(co), fn(bp), fn(Ep);
}
function ak(n) {
  hc(Ep.current);
  var e = hc(co.current),
    t = rb(e, n.type);
  e !== t && (cn(bp, n), cn(co, t));
}
function zT(n) {
  bp.current === n && (fn(co), fn(bp));
}
var Sn = gl(0);
function Yy(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var nS = [];
function VT() {
  for (var n = 0; n < nS.length; n++)
    nS[n]._workInProgressVersionPrimary = null;
  nS.length = 0;
}
var py = aa.ReactCurrentDispatcher,
  rS = aa.ReactCurrentBatchConfig,
  Dc = 0,
  Tn = null,
  Yn = null,
  ar = null,
  Jy = !1,
  Hf = !1,
  Tp = 0,
  qW = 0;
function Mr() {
  throw Error(Pe(321));
}
function jT(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!Ds(n[t], e[t])) return !1;
  return !0;
}
function HT(n, e, t, r, i, s) {
  if (
    ((Dc = s),
    (Tn = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (py.current = n === null || n.memoizedState === null ? ZW : QW),
    (n = t(r, i)),
    Hf)
  ) {
    s = 0;
    do {
      if (((Hf = !1), (Tp = 0), 25 <= s)) throw Error(Pe(301));
      (s += 1),
        (ar = Yn = null),
        (e.updateQueue = null),
        (py.current = eG),
        (n = t(r, i));
    } while (Hf);
  }
  if (
    ((py.current = Zy),
    (e = Yn !== null && Yn.next !== null),
    (Dc = 0),
    (ar = Yn = Tn = null),
    (Jy = !1),
    e)
  )
    throw Error(Pe(300));
  return n;
}
function WT() {
  var n = Tp !== 0;
  return (Tp = 0), n;
}
function Qs() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return ar === null ? (Tn.memoizedState = ar = n) : (ar = ar.next = n), ar;
}
function as() {
  if (Yn === null) {
    var n = Tn.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Yn.next;
  var e = ar === null ? Tn.memoizedState : ar.next;
  if (e !== null) (ar = e), (Yn = n);
  else {
    if (n === null) throw Error(Pe(310));
    (Yn = n),
      (n = {
        memoizedState: Yn.memoizedState,
        baseState: Yn.baseState,
        baseQueue: Yn.baseQueue,
        queue: Yn.queue,
        next: null,
      }),
      ar === null ? (Tn.memoizedState = ar = n) : (ar = ar.next = n);
  }
  return ar;
}
function Mp(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function iS(n) {
  var e = as(),
    t = e.queue;
  if (t === null) throw Error(Pe(311));
  t.lastRenderedReducer = n;
  var r = Yn,
    i = r.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (t.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((Dc & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (r = c.hasEagerState ? c.eagerState : n(r, c.action));
      else {
        var f = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = f), (o = r)) : (l = l.next = f),
          (Tn.lanes |= u),
          (kc |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = r) : (l.next = a),
      Ds(r, e.memoizedState) || (di = !0),
      (e.memoizedState = r),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = r);
  }
  if (((n = t.interleaved), n !== null)) {
    i = n;
    do (s = i.lane), (Tn.lanes |= s), (kc |= s), (i = i.next);
    while (i !== n);
  } else i === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function sS(n) {
  var e = as(),
    t = e.queue;
  if (t === null) throw Error(Pe(311));
  t.lastRenderedReducer = n;
  var r = t.dispatch,
    i = t.pending,
    s = e.memoizedState;
  if (i !== null) {
    t.pending = null;
    var o = (i = i.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== i);
    Ds(s, e.memoizedState) || (di = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, r];
}
function lk() {}
function ck(n, e) {
  var t = Tn,
    r = as(),
    i = e(),
    s = !Ds(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (di = !0)),
    (r = r.queue),
    GT(hk.bind(null, t, r, n), [n]),
    r.getSnapshot !== e || s || (ar !== null && ar.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      Cp(9, dk.bind(null, t, r, i, e), void 0, null),
      cr === null)
    )
      throw Error(Pe(349));
    Dc & 30 || uk(t, e, i);
  }
  return i;
}
function uk(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = Tn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Tn.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function dk(n, e, t, r) {
  (e.value = t), (e.getSnapshot = r), fk(e) && pk(n);
}
function hk(n, e, t) {
  return t(function () {
    fk(e) && pk(n);
  });
}
function fk(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !Ds(n, t);
  } catch {
    return !0;
  }
}
function pk(n) {
  var e = Jo(n, 1);
  e !== null && Os(e, n, 1, -1);
}
function LP(n) {
  var e = Qs();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Mp,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = JW.bind(null, Tn, n)),
    [e.memoizedState, n]
  );
}
function Cp(n, e, t, r) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: r, next: null }),
    (e = Tn.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (Tn.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((r = t.next), (t.next = n), (n.next = r), (e.lastEffect = n))),
    n
  );
}
function mk() {
  return as().memoizedState;
}
function my(n, e, t, r) {
  var i = Qs();
  (Tn.flags |= n),
    (i.memoizedState = Cp(1 | e, t, void 0, r === void 0 ? null : r));
}
function yx(n, e, t, r) {
  var i = as();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (Yn !== null) {
    var o = Yn.memoizedState;
    if (((s = o.destroy), r !== null && jT(r, o.deps))) {
      i.memoizedState = Cp(e, t, s, r);
      return;
    }
  }
  (Tn.flags |= n), (i.memoizedState = Cp(1 | e, t, s, r));
}
function OP(n, e) {
  return my(8390656, 8, n, e);
}
function GT(n, e) {
  return yx(2048, 8, n, e);
}
function gk(n, e) {
  return yx(4, 2, n, e);
}
function vk(n, e) {
  return yx(4, 4, n, e);
}
function yk(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function xk(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), yx(4, 4, yk.bind(null, e, n), t)
  );
}
function $T() {}
function _k(n, e) {
  var t = as();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && jT(e, r[1])
    ? r[0]
    : ((t.memoizedState = [n, e]), n);
}
function wk(n, e) {
  var t = as();
  e = e === void 0 ? null : e;
  var r = t.memoizedState;
  return r !== null && e !== null && jT(e, r[1])
    ? r[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function Sk(n, e, t) {
  return Dc & 21
    ? (Ds(t, e) || ((t = CD()), (Tn.lanes |= t), (kc |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (di = !0)), (n.memoizedState = t));
}
function KW(n, e) {
  var t = rn;
  (rn = t !== 0 && 4 > t ? t : 4), n(!0);
  var r = rS.transition;
  rS.transition = {};
  try {
    n(!1), e();
  } finally {
    (rn = t), (rS.transition = r);
  }
}
function bk() {
  return as().memoizedState;
}
function YW(n, e, t) {
  var r = rl(n);
  if (
    ((t = {
      lane: r,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Ek(n))
  )
    Tk(e, t);
  else if (((t = sk(n, e, t, r)), t !== null)) {
    var i = Yr();
    Os(t, n, r, i), Mk(t, e, r);
  }
}
function JW(n, e, t) {
  var r = rl(n),
    i = { lane: r, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (Ek(n)) Tk(e, i);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((i.hasEagerState = !0), (i.eagerState = a), Ds(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((i.next = i), UT(e))
            : ((i.next = l.next), (l.next = i)),
            (e.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (t = sk(n, e, i, r)),
      t !== null && ((i = Yr()), Os(t, n, r, i), Mk(t, e, r));
  }
}
function Ek(n) {
  var e = n.alternate;
  return n === Tn || (e !== null && e === Tn);
}
function Tk(n, e) {
  Hf = Jy = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function Mk(n, e, t) {
  if (t & 4194240) {
    var r = e.lanes;
    (r &= n.pendingLanes), (t |= r), (e.lanes = t), bT(n, t);
  }
}
var Zy = {
    readContext: os,
    useCallback: Mr,
    useContext: Mr,
    useEffect: Mr,
    useImperativeHandle: Mr,
    useInsertionEffect: Mr,
    useLayoutEffect: Mr,
    useMemo: Mr,
    useReducer: Mr,
    useRef: Mr,
    useState: Mr,
    useDebugValue: Mr,
    useDeferredValue: Mr,
    useTransition: Mr,
    useMutableSource: Mr,
    useSyncExternalStore: Mr,
    useId: Mr,
    unstable_isNewReconciler: !1,
  },
  ZW = {
    readContext: os,
    useCallback: function (n, e) {
      return (Qs().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: os,
    useEffect: OP,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        my(4194308, 4, yk.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return my(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return my(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = Qs();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var r = Qs();
      return (
        (e = t !== void 0 ? t(e) : e),
        (r.memoizedState = r.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (r.queue = n),
        (n = n.dispatch = YW.bind(null, Tn, n)),
        [r.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = Qs();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: LP,
    useDebugValue: $T,
    useDeferredValue: function (n) {
      return (Qs().memoizedState = n);
    },
    useTransition: function () {
      var n = LP(!1),
        e = n[0];
      return (n = KW.bind(null, n[1])), (Qs().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var r = Tn,
        i = Qs();
      if (yn) {
        if (t === void 0) throw Error(Pe(407));
        t = t();
      } else {
        if (((t = e()), cr === null)) throw Error(Pe(349));
        Dc & 30 || uk(r, e, t);
      }
      i.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (i.queue = s),
        OP(hk.bind(null, r, s, n), [n]),
        (r.flags |= 2048),
        Cp(9, dk.bind(null, r, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = Qs(),
        e = cr.identifierPrefix;
      if (yn) {
        var t = Go,
          r = Wo;
        (t = (r & ~(1 << (32 - Ls(r) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Tp++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = qW++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  QW = {
    readContext: os,
    useCallback: _k,
    useContext: os,
    useEffect: GT,
    useImperativeHandle: xk,
    useInsertionEffect: gk,
    useLayoutEffect: vk,
    useMemo: wk,
    useReducer: iS,
    useRef: mk,
    useState: function () {
      return iS(Mp);
    },
    useDebugValue: $T,
    useDeferredValue: function (n) {
      var e = as();
      return Sk(e, Yn.memoizedState, n);
    },
    useTransition: function () {
      var n = iS(Mp)[0],
        e = as().memoizedState;
      return [n, e];
    },
    useMutableSource: lk,
    useSyncExternalStore: ck,
    useId: bk,
    unstable_isNewReconciler: !1,
  },
  eG = {
    readContext: os,
    useCallback: _k,
    useContext: os,
    useEffect: GT,
    useImperativeHandle: xk,
    useInsertionEffect: gk,
    useLayoutEffect: vk,
    useMemo: wk,
    useReducer: sS,
    useRef: mk,
    useState: function () {
      return sS(Mp);
    },
    useDebugValue: $T,
    useDeferredValue: function (n) {
      var e = as();
      return Yn === null ? (e.memoizedState = n) : Sk(e, Yn.memoizedState, n);
    },
    useTransition: function () {
      var n = sS(Mp)[0],
        e = as().memoizedState;
      return [n, e];
    },
    useMutableSource: lk,
    useSyncExternalStore: ck,
    useId: bk,
    unstable_isNewReconciler: !1,
  };
function Ss(n, e) {
  if (n && n.defaultProps) {
    (e = Mn({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
function Eb(n, e, t, r) {
  (e = n.memoizedState),
    (t = t(r, e)),
    (t = t == null ? e : Mn({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var xx = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? Xc(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var r = Yr(),
      i = rl(n),
      s = $o(r, i);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = tl(n, s, i)),
      e !== null && (Os(e, n, i, r), fy(e, n, i));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var r = Yr(),
      i = rl(n),
      s = $o(r, i);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = tl(n, s, i)),
      e !== null && (Os(e, n, i, r), fy(e, n, i));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = Yr(),
      r = rl(n),
      i = $o(t, r);
    (i.tag = 2),
      e != null && (i.callback = e),
      (e = tl(n, i, r)),
      e !== null && (Os(e, n, r, t), fy(e, n, r));
  },
};
function DP(n, e, t, r, i, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(r, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !xp(t, r) || !xp(i, s)
      : !0
  );
}
function Ck(n, e, t) {
  var r = !1,
    i = ll,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = os(s))
      : ((i = mi(e) ? Lc : kr.current),
        (r = e.contextTypes),
        (s = (r = r != null) ? $d(n, i) : ll)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = xx),
    (n.stateNode = e),
    (e._reactInternals = n),
    r &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = i),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function kP(n, e, t, r) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, r),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, r),
    e.state !== n && xx.enqueueReplaceState(e, e.state, null);
}
function Tb(n, e, t, r) {
  var i = n.stateNode;
  (i.props = t), (i.state = n.memoizedState), (i.refs = {}), FT(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (i.context = os(s))
    : ((s = mi(e) ? Lc : kr.current), (i.context = $d(n, s))),
    (i.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (Eb(n, e, s, t), (i.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((e = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      e !== i.state && xx.enqueueReplaceState(i, i.state, null),
      Ky(n, t, i, r),
      (i.state = n.memoizedState)),
    typeof i.componentDidMount == "function" && (n.flags |= 4194308);
}
function Yd(n, e) {
  try {
    var t = "",
      r = e;
    do (t += AH(r)), (r = r.return);
    while (r);
    var i = t;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: i, digest: null };
}
function oS(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Mb(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var tG = typeof WeakMap == "function" ? WeakMap : Map;
function Ak(n, e, t) {
  (t = $o(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var r = e.value;
  return (
    (t.callback = function () {
      e0 || ((e0 = !0), (kb = r)), Mb(n, e);
    }),
    t
  );
}
function Rk(n, e, t) {
  (t = $o(-1, t)), (t.tag = 3);
  var r = n.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = e.value;
    (t.payload = function () {
      return r(i);
    }),
      (t.callback = function () {
        Mb(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Mb(n, e),
          typeof r != "function" &&
            (nl === null ? (nl = new Set([this])) : nl.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function UP(n, e, t) {
  var r = n.pingCache;
  if (r === null) {
    r = n.pingCache = new tG();
    var i = new Set();
    r.set(e, i);
  } else (i = r.get(e)), i === void 0 && ((i = new Set()), r.set(e, i));
  i.has(t) || (i.add(t), (n = mG.bind(null, n, e, t)), e.then(n, n));
}
function FP(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function BP(n, e, t, r, i) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = i), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = $o(-1, 1)), (e.tag = 2), tl(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var nG = aa.ReactCurrentOwner,
  di = !1;
function Gr(n, e, t, r) {
  e.child = n === null ? ik(e, null, t, r) : qd(e, n.child, t, r);
}
function zP(n, e, t, r, i) {
  t = t.render;
  var s = e.ref;
  return (
    Cd(e, i),
    (r = HT(n, e, t, r, s, i)),
    (t = WT()),
    n !== null && !di
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        Zo(n, e, i))
      : (yn && t && IT(e), (e.flags |= 1), Gr(n, e, r, i), e.child)
  );
}
function VP(n, e, t, r, i) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !eM(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), Pk(n, e, s, r, i))
      : ((n = xy(t.type, null, r, e, e.mode, i)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : xp), t(o, r) && n.ref === e.ref)
    )
      return Zo(n, e, i);
  }
  return (
    (e.flags |= 1),
    (n = il(s, r)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function Pk(n, e, t, r, i) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (xp(s, r) && n.ref === e.ref)
      if (((di = !1), (e.pendingProps = r = s), (n.lanes & i) !== 0))
        n.flags & 131072 && (di = !0);
      else return (e.lanes = n.lanes), Zo(n, e, i);
  }
  return Cb(n, e, t, r, i);
}
function Ik(n, e, t) {
  var r = e.pendingProps,
    i = r.children,
    s = n !== null ? n.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        cn(hd, Ti),
        (Ti |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          cn(hd, Ti),
          (Ti |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : t),
        cn(hd, Ti),
        (Ti |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | t), (e.memoizedState = null)) : (r = t),
      cn(hd, Ti),
      (Ti |= r);
  return Gr(n, e, i, t), e.child;
}
function Nk(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Cb(n, e, t, r, i) {
  var s = mi(t) ? Lc : kr.current;
  return (
    (s = $d(e, s)),
    Cd(e, i),
    (t = HT(n, e, t, r, s, i)),
    (r = WT()),
    n !== null && !di
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~i),
        Zo(n, e, i))
      : (yn && r && IT(e), (e.flags |= 1), Gr(n, e, t, i), e.child)
  );
}
function jP(n, e, t, r, i) {
  if (mi(t)) {
    var s = !0;
    Wy(e);
  } else s = !1;
  if ((Cd(e, i), e.stateNode === null))
    gy(n, e), Ck(e, t, r), Tb(e, t, r, i), (r = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      c = t.contextType;
    typeof c == "object" && c !== null
      ? (c = os(c))
      : ((c = mi(t) ? Lc : kr.current), (c = $d(e, c)));
    var u = t.getDerivedStateFromProps,
      f =
        typeof u == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    f ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || l !== c) && kP(e, o, r, c)),
      (La = !1);
    var p = e.memoizedState;
    (o.state = p),
      Ky(e, r, o, i),
      (l = e.memoizedState),
      a !== r || p !== l || pi.current || La
        ? (typeof u == "function" && (Eb(e, t, u, r), (l = e.memoizedState)),
          (a = La || DP(e, t, a, r, p, l, c))
            ? (f ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = r),
              (e.memoizedState = l)),
          (o.props = r),
          (o.state = l),
          (o.context = c),
          (r = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (r = !1));
  } else {
    (o = e.stateNode),
      ok(n, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : Ss(e.type, a)),
      (o.props = c),
      (f = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = os(l))
        : ((l = mi(t) ? Lc : kr.current), (l = $d(e, l)));
    var m = t.getDerivedStateFromProps;
    (u =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== f || p !== l) && kP(e, o, r, l)),
      (La = !1),
      (p = e.memoizedState),
      (o.state = p),
      Ky(e, r, o, i);
    var v = e.memoizedState;
    a !== f || p !== v || pi.current || La
      ? (typeof m == "function" && (Eb(e, t, m, r), (v = e.memoizedState)),
        (c = La || DP(e, t, c, r, p, v, l) || !1)
          ? (u ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, v, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, v, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = r),
            (e.memoizedState = v)),
        (o.props = r),
        (o.state = v),
        (o.context = l),
        (r = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (r = !1));
  }
  return Ab(n, e, t, r, s, i);
}
function Ab(n, e, t, r, i, s) {
  Nk(n, e);
  var o = (e.flags & 128) !== 0;
  if (!r && !o) return i && CP(e, t, !1), Zo(n, e, s);
  (r = e.stateNode), (nG.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = qd(e, n.child, null, s)), (e.child = qd(e, null, a, s)))
      : Gr(n, e, a, s),
    (e.memoizedState = r.state),
    i && CP(e, t, !0),
    e.child
  );
}
function Lk(n) {
  var e = n.stateNode;
  e.pendingContext
    ? MP(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && MP(n, e.context, !1),
    BT(n, e.containerInfo);
}
function HP(n, e, t, r, i) {
  return Xd(), LT(i), (e.flags |= 256), Gr(n, e, t, r), e.child;
}
var Rb = { dehydrated: null, treeContext: null, retryLane: 0 };
function Pb(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function Ok(n, e, t) {
  var r = e.pendingProps,
    i = Sn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (i |= 1),
    cn(Sn, i & 1),
    n === null)
  )
    return (
      Sb(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = r.children),
          (n = r.fallback),
          s
            ? ((r = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = Sx(o, r, 0, null)),
              (n = Mc(n, r, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Pb(t)),
              (e.memoizedState = Rb),
              n)
            : XT(e, o))
    );
  if (((i = n.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return rG(n, e, o, r, a, i, t);
  if (s) {
    (s = r.fallback), (o = e.mode), (i = n.child), (a = i.sibling);
    var l = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && e.child !== i
        ? ((r = e.child),
          (r.childLanes = 0),
          (r.pendingProps = l),
          (e.deletions = null))
        : ((r = il(i, l)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = il(a, s)) : ((s = Mc(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (r.return = e),
      (r.sibling = s),
      (e.child = r),
      (r = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Pb(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = Rb),
      r
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (r = il(s, { mode: "visible", children: r.children })),
    !(e.mode & 1) && (r.lanes = t),
    (r.return = e),
    (r.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = r),
    (e.memoizedState = null),
    r
  );
}
function XT(n, e) {
  return (
    (e = Sx({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function Wg(n, e, t, r) {
  return (
    r !== null && LT(r),
    qd(e, n.child, null, t),
    (n = XT(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function rG(n, e, t, r, i, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (r = oS(Error(Pe(422)))), Wg(n, e, o, r))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = r.fallback),
        (i = e.mode),
        (r = Sx({ mode: "visible", children: r.children }, i, 0, null)),
        (s = Mc(s, i, o, null)),
        (s.flags |= 2),
        (r.return = e),
        (s.return = e),
        (r.sibling = s),
        (e.child = r),
        e.mode & 1 && qd(e, n.child, null, o),
        (e.child.memoizedState = Pb(o)),
        (e.memoizedState = Rb),
        s);
  if (!(e.mode & 1)) return Wg(n, e, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (
      (r = a), (s = Error(Pe(419))), (r = oS(s, r, void 0)), Wg(n, e, o, r)
    );
  }
  if (((a = (o & n.childLanes) !== 0), di || a)) {
    if (((r = cr), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), Jo(n, i), Os(r, n, i, -1));
    }
    return QT(), (r = oS(Error(Pe(421)))), Wg(n, e, o, r);
  }
  return i.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = gG.bind(null, n)),
      (i._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (Ri = el(i.nextSibling)),
      (Ii = e),
      (yn = !0),
      (Ps = null),
      n !== null &&
        ((Zi[Qi++] = Wo),
        (Zi[Qi++] = Go),
        (Zi[Qi++] = Oc),
        (Wo = n.id),
        (Go = n.overflow),
        (Oc = e)),
      (e = XT(e, r.children)),
      (e.flags |= 4096),
      e);
}
function WP(n, e, t) {
  n.lanes |= e;
  var r = n.alternate;
  r !== null && (r.lanes |= e), bb(n.return, e, t);
}
function aS(n, e, t, r, i) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: t,
        tailMode: i,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = t),
      (s.tailMode = i));
}
function Dk(n, e, t) {
  var r = e.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((Gr(n, e, r.children, t), (r = Sn.current), r & 2))
    (r = (r & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && WP(n, t, e);
        else if (n.tag === 19) WP(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    r &= 1;
  }
  if ((cn(Sn, r), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (t = e.child, i = null; t !== null; )
          (n = t.alternate),
            n !== null && Yy(n) === null && (i = t),
            (t = t.sibling);
        (t = i),
          t === null
            ? ((i = e.child), (e.child = null))
            : ((i = t.sibling), (t.sibling = null)),
          aS(e, !1, i, t, s);
        break;
      case "backwards":
        for (t = null, i = e.child, e.child = null; i !== null; ) {
          if (((n = i.alternate), n !== null && Yy(n) === null)) {
            e.child = i;
            break;
          }
          (n = i.sibling), (i.sibling = t), (t = i), (i = n);
        }
        aS(e, !0, t, null, s);
        break;
      case "together":
        aS(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function gy(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function Zo(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (kc |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(Pe(153));
  if (e.child !== null) {
    for (
      n = e.child, t = il(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = il(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function iG(n, e, t) {
  switch (e.tag) {
    case 3:
      Lk(e), Xd();
      break;
    case 5:
      ak(e);
      break;
    case 1:
      mi(e.type) && Wy(e);
      break;
    case 4:
      BT(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        i = e.memoizedProps.value;
      cn(Xy, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = e.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (cn(Sn, Sn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? Ok(n, e, t)
          : (cn(Sn, Sn.current & 1),
            (n = Zo(n, e, t)),
            n !== null ? n.sibling : null);
      cn(Sn, Sn.current & 1);
      break;
    case 19:
      if (((r = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (r) return Dk(n, e, t);
        e.flags |= 128;
      }
      if (
        ((i = e.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        cn(Sn, Sn.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), Ik(n, e, t);
  }
  return Zo(n, e, t);
}
var kk, Ib, Uk, Fk;
kk = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Ib = function () {};
Uk = function (n, e, t, r) {
  var i = n.memoizedProps;
  if (i !== r) {
    (n = e.stateNode), hc(co.current);
    var s = null;
    switch (t) {
      case "input":
        (i = Q1(n, i)), (r = Q1(n, r)), (s = []);
        break;
      case "select":
        (i = Mn({}, i, { value: void 0 })),
          (r = Mn({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = nb(n, i)), (r = nb(n, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (n.onclick = jy);
    }
    ib(t, r);
    var o;
    t = null;
    for (c in i)
      if (!r.hasOwnProperty(c) && i.hasOwnProperty(c) && i[c] != null)
        if (c === "style") {
          var a = i[c];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (hp.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in r) {
      var l = r[c];
      if (
        ((a = i != null ? i[c] : void 0),
        r.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(c, t)), (t = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (hp.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && dn("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    t && (s = s || []).push("style", t);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
Fk = function (n, e, t, r) {
  t !== r && (e.flags |= 4);
};
function cf(n, e) {
  if (!yn)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var r = null; t !== null; )
          t.alternate !== null && (r = t), (t = t.sibling);
        r === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (r.sibling = null);
    }
}
function Cr(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    r = 0;
  if (e)
    for (var i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = n),
        (i = i.sibling);
  else
    for (i = n.child; i !== null; )
      (t |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = n),
        (i = i.sibling);
  return (n.subtreeFlags |= r), (n.childLanes = t), e;
}
function sG(n, e, t) {
  var r = e.pendingProps;
  switch ((NT(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Cr(e), null;
    case 1:
      return mi(e.type) && Hy(), Cr(e), null;
    case 3:
      return (
        (r = e.stateNode),
        Kd(),
        fn(pi),
        fn(kr),
        VT(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (n === null || n.child === null) &&
          (jg(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Ps !== null && (Bb(Ps), (Ps = null)))),
        Ib(n, e),
        Cr(e),
        null
      );
    case 5:
      zT(e);
      var i = hc(Ep.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        Uk(n, e, t, r, i),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(Pe(166));
          return Cr(e), null;
        }
        if (((n = hc(co.current)), jg(e))) {
          (r = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((r[ro] = e), (r[Sp] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              dn("cancel", r), dn("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              dn("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < If.length; i++) dn(If[i], r);
              break;
            case "source":
              dn("error", r);
              break;
            case "img":
            case "image":
            case "link":
              dn("error", r), dn("load", r);
              break;
            case "details":
              dn("toggle", r);
              break;
            case "input":
              QR(r, s), dn("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                dn("invalid", r);
              break;
            case "textarea":
              tP(r, s), dn("invalid", r);
          }
          ib(t, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Vg(r.textContent, a, n),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Vg(r.textContent, a, n),
                    (i = ["children", "" + a]))
                : hp.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  dn("scroll", r);
            }
          switch (t) {
            case "input":
              Lg(r), eP(r, s, !0);
              break;
            case "textarea":
              Lg(r), nP(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = jy);
          }
          (r = i), (e.updateQueue = r), r !== null && (e.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = hD(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof r.is == "string"
                ? (n = o.createElement(t, { is: r.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (n = o.createElementNS(n, t)),
            (n[ro] = e),
            (n[Sp] = r),
            kk(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = sb(t, r)), t)) {
              case "dialog":
                dn("cancel", n), dn("close", n), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                dn("load", n), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < If.length; i++) dn(If[i], n);
                i = r;
                break;
              case "source":
                dn("error", n), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                dn("error", n), dn("load", n), (i = r);
                break;
              case "details":
                dn("toggle", n), (i = r);
                break;
              case "input":
                QR(n, r), (i = Q1(n, r)), dn("invalid", n);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = Mn({}, r, { value: void 0 })),
                  dn("invalid", n);
                break;
              case "textarea":
                tP(n, r), (i = nb(n, r)), dn("invalid", n);
                break;
              default:
                i = r;
            }
            ib(t, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? mD(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && fD(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && fp(n, l)
                    : typeof l == "number" && fp(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (hp.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && dn("scroll", n)
                      : l != null && vT(n, s, l, o));
              }
            switch (t) {
              case "input":
                Lg(n), eP(n, r, !1);
                break;
              case "textarea":
                Lg(n), nP(n);
                break;
              case "option":
                r.value != null && n.setAttribute("value", "" + al(r.value));
                break;
              case "select":
                (n.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? bd(n, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      bd(n, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (n.onclick = jy);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return Cr(e), null;
    case 6:
      if (n && e.stateNode != null) Fk(n, e, n.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(Pe(166));
        if (((t = hc(Ep.current)), hc(co.current), jg(e))) {
          if (
            ((r = e.stateNode),
            (t = e.memoizedProps),
            (r[ro] = e),
            (s = r.nodeValue !== t) && ((n = Ii), n !== null))
          )
            switch (n.tag) {
              case 3:
                Vg(r.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  Vg(r.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (r = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(r)),
            (r[ro] = e),
            (e.stateNode = r);
      }
      return Cr(e), null;
    case 13:
      if (
        (fn(Sn),
        (r = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if (yn && Ri !== null && e.mode & 1 && !(e.flags & 128))
          nk(), Xd(), (e.flags |= 98560), (s = !1);
        else if (((s = jg(e)), r !== null && r.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(Pe(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(Pe(317));
            s[ro] = e;
          } else
            Xd(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          Cr(e), (s = !1);
        } else Ps !== null && (Bb(Ps), (Ps = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((r = r !== null),
          r !== (n !== null && n.memoizedState !== null) &&
            r &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || Sn.current & 1 ? Jn === 0 && (Jn = 3) : QT())),
          e.updateQueue !== null && (e.flags |= 4),
          Cr(e),
          null);
    case 4:
      return (
        Kd(), Ib(n, e), n === null && _p(e.stateNode.containerInfo), Cr(e), null
      );
    case 10:
      return kT(e.type._context), Cr(e), null;
    case 17:
      return mi(e.type) && Hy(), Cr(e), null;
    case 19:
      if ((fn(Sn), (s = e.memoizedState), s === null)) return Cr(e), null;
      if (((r = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) cf(s, !1);
        else {
          if (Jn !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = Yy(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    cf(s, !1),
                    r = o.updateQueue,
                    r !== null && ((e.updateQueue = r), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    r = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return cn(Sn, (Sn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            Bn() > Jd &&
            ((e.flags |= 128), (r = !0), cf(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!r)
          if (((n = Yy(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (r = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              cf(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !yn)
            )
              return Cr(e), null;
          } else
            2 * Bn() - s.renderingStartTime > Jd &&
              t !== 1073741824 &&
              ((e.flags |= 128), (r = !0), cf(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Bn()),
          (e.sibling = null),
          (t = Sn.current),
          cn(Sn, r ? (t & 1) | 2 : t & 1),
          e)
        : (Cr(e), null);
    case 22:
    case 23:
      return (
        ZT(),
        (r = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== r && (e.flags |= 8192),
        r && e.mode & 1
          ? Ti & 1073741824 && (Cr(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : Cr(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Pe(156, e.tag));
}
function oG(n, e) {
  switch ((NT(e), e.tag)) {
    case 1:
      return (
        mi(e.type) && Hy(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Kd(),
        fn(pi),
        fn(kr),
        VT(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return zT(e), null;
    case 13:
      if (
        (fn(Sn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(Pe(340));
        Xd();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return fn(Sn), null;
    case 4:
      return Kd(), null;
    case 10:
      return kT(e.type._context), null;
    case 22:
    case 23:
      return ZT(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Gg = !1,
  Nr = !1,
  aG = typeof WeakSet == "function" ? WeakSet : Set,
  et = null;
function dd(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (r) {
        In(n, e, r);
      }
    else t.current = null;
}
function Nb(n, e, t) {
  try {
    t();
  } catch (r) {
    In(n, e, r);
  }
}
var GP = !1;
function lG(n, e) {
  if (((mb = By), (n = HD()), PT(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var r = t.getSelection && t.getSelection();
        if (r && r.rangeCount !== 0) {
          t = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            u = 0,
            f = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              f !== t || (i !== 0 && f.nodeType !== 3) || (a = o + i),
                f !== s || (r !== 0 && f.nodeType !== 3) || (l = o + r),
                f.nodeType === 3 && (o += f.nodeValue.length),
                (m = f.firstChild) !== null;

            )
              (p = f), (f = m);
            for (;;) {
              if (f === n) break t;
              if (
                (p === t && ++c === i && (a = o),
                p === s && ++u === r && (l = o),
                (m = f.nextSibling) !== null)
              )
                break;
              (f = p), (p = f.parentNode);
            }
            f = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    gb = { focusedElem: n, selectionRange: t }, By = !1, et = e;
    et !== null;

  )
    if (((e = et), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (et = n);
    else
      for (; et !== null; ) {
        e = et;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var y = v.memoizedProps,
                    x = v.memoizedState,
                    g = e.stateNode,
                    _ = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? y : Ss(e.type, y),
                      x
                    );
                  g.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(Pe(163));
            }
        } catch (b) {
          In(e, e.return, b);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (et = n);
          break;
        }
        et = e.return;
      }
  return (v = GP), (GP = !1), v;
}
function Wf(n, e, t) {
  var r = e.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & n) === n) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && Nb(e, t, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function _x(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var r = t.create;
        t.destroy = r();
      }
      t = t.next;
    } while (t !== e);
  }
}
function Lb(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function Bk(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), Bk(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[ro], delete e[Sp], delete e[xb], delete e[WW], delete e[GW])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function zk(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function $P(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || zk(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Ob(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = jy));
  else if (r !== 4 && ((n = n.child), n !== null))
    for (Ob(n, e, t), n = n.sibling; n !== null; ) Ob(n, e, t), (n = n.sibling);
}
function Db(n, e, t) {
  var r = n.tag;
  if (r === 5 || r === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (r !== 4 && ((n = n.child), n !== null))
    for (Db(n, e, t), n = n.sibling; n !== null; ) Db(n, e, t), (n = n.sibling);
}
var hr = null,
  As = !1;
function ya(n, e, t) {
  for (t = t.child; t !== null; ) Vk(n, e, t), (t = t.sibling);
}
function Vk(n, e, t) {
  if (lo && typeof lo.onCommitFiberUnmount == "function")
    try {
      lo.onCommitFiberUnmount(hx, t);
    } catch {}
  switch (t.tag) {
    case 5:
      Nr || dd(t, e);
    case 6:
      var r = hr,
        i = As;
      (hr = null),
        ya(n, e, t),
        (hr = r),
        (As = i),
        hr !== null &&
          (As
            ? ((n = hr),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : hr.removeChild(t.stateNode));
      break;
    case 18:
      hr !== null &&
        (As
          ? ((n = hr),
            (t = t.stateNode),
            n.nodeType === 8
              ? eS(n.parentNode, t)
              : n.nodeType === 1 && eS(n, t),
            vp(n))
          : eS(hr, t.stateNode));
      break;
    case 4:
      (r = hr),
        (i = As),
        (hr = t.stateNode.containerInfo),
        (As = !0),
        ya(n, e, t),
        (hr = r),
        (As = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Nr &&
        ((r = t.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Nb(t, e, o),
            (i = i.next);
        } while (i !== r);
      }
      ya(n, e, t);
      break;
    case 1:
      if (
        !Nr &&
        (dd(t, e),
        (r = t.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = t.memoizedProps),
            (r.state = t.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          In(t, e, a);
        }
      ya(n, e, t);
      break;
    case 21:
      ya(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((Nr = (r = Nr) || t.memoizedState !== null), ya(n, e, t), (Nr = r))
        : ya(n, e, t);
      break;
    default:
      ya(n, e, t);
  }
}
function XP(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new aG()),
      e.forEach(function (r) {
        var i = vG.bind(null, n, r);
        t.has(r) || (t.add(r), r.then(i, i));
      });
  }
}
function fs(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (hr = a.stateNode), (As = !1);
              break e;
            case 3:
              (hr = a.stateNode.containerInfo), (As = !0);
              break e;
            case 4:
              (hr = a.stateNode.containerInfo), (As = !0);
              break e;
          }
          a = a.return;
        }
        if (hr === null) throw Error(Pe(160));
        Vk(s, o, i), (hr = null), (As = !1);
        var l = i.alternate;
        l !== null && (l.return = null), (i.return = null);
      } catch (c) {
        In(i, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) jk(e, n), (e = e.sibling);
}
function jk(n, e) {
  var t = n.alternate,
    r = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((fs(e, n), Ys(n), r & 4)) {
        try {
          Wf(3, n, n.return), _x(3, n);
        } catch (y) {
          In(n, n.return, y);
        }
        try {
          Wf(5, n, n.return);
        } catch (y) {
          In(n, n.return, y);
        }
      }
      break;
    case 1:
      fs(e, n), Ys(n), r & 512 && t !== null && dd(t, t.return);
      break;
    case 5:
      if (
        (fs(e, n),
        Ys(n),
        r & 512 && t !== null && dd(t, t.return),
        n.flags & 32)
      ) {
        var i = n.stateNode;
        try {
          fp(i, "");
        } catch (y) {
          In(n, n.return, y);
        }
      }
      if (r & 4 && ((i = n.stateNode), i != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && uD(i, s),
              sb(a, o);
            var c = sb(a, s);
            for (o = 0; o < l.length; o += 2) {
              var u = l[o],
                f = l[o + 1];
              u === "style"
                ? mD(i, f)
                : u === "dangerouslySetInnerHTML"
                ? fD(i, f)
                : u === "children"
                ? fp(i, f)
                : vT(i, u, f, c);
            }
            switch (a) {
              case "input":
                eb(i, s);
                break;
              case "textarea":
                dD(i, s);
                break;
              case "select":
                var p = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? bd(i, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? bd(i, !!s.multiple, s.defaultValue, !0)
                      : bd(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[Sp] = s;
          } catch (y) {
            In(n, n.return, y);
          }
      }
      break;
    case 6:
      if ((fs(e, n), Ys(n), r & 4)) {
        if (n.stateNode === null) throw Error(Pe(162));
        (i = n.stateNode), (s = n.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (y) {
          In(n, n.return, y);
        }
      }
      break;
    case 3:
      if (
        (fs(e, n), Ys(n), r & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          vp(e.containerInfo);
        } catch (y) {
          In(n, n.return, y);
        }
      break;
    case 4:
      fs(e, n), Ys(n);
      break;
    case 13:
      fs(e, n),
        Ys(n),
        (i = n.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (YT = Bn())),
        r & 4 && XP(n);
      break;
    case 22:
      if (
        ((u = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((Nr = (c = Nr) || u), fs(e, n), (Nr = c)) : fs(e, n),
        Ys(n),
        r & 8192)
      ) {
        if (
          ((c = n.memoizedState !== null),
          (n.stateNode.isHidden = c) && !u && n.mode & 1)
        )
          for (et = n, u = n.child; u !== null; ) {
            for (f = et = u; et !== null; ) {
              switch (((p = et), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Wf(4, p, p.return);
                  break;
                case 1:
                  dd(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (r = p), (t = p.return);
                    try {
                      (e = r),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (y) {
                      In(r, t, y);
                    }
                  }
                  break;
                case 5:
                  dd(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    KP(f);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (et = m)) : KP(f);
            }
            u = u.sibling;
          }
        e: for (u = null, f = n; ; ) {
          if (f.tag === 5) {
            if (u === null) {
              u = f;
              try {
                (i = f.stateNode),
                  c
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = f.stateNode),
                      (l = f.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = pD("display", o)));
              } catch (y) {
                In(n, n.return, y);
              }
            }
          } else if (f.tag === 6) {
            if (u === null)
              try {
                f.stateNode.nodeValue = c ? "" : f.memoizedProps;
              } catch (y) {
                In(n, n.return, y);
              }
          } else if (
            ((f.tag !== 22 && f.tag !== 23) ||
              f.memoizedState === null ||
              f === n) &&
            f.child !== null
          ) {
            (f.child.return = f), (f = f.child);
            continue;
          }
          if (f === n) break e;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === n) break e;
            u === f && (u = null), (f = f.return);
          }
          u === f && (u = null), (f.sibling.return = f.return), (f = f.sibling);
        }
      }
      break;
    case 19:
      fs(e, n), Ys(n), r & 4 && XP(n);
      break;
    case 21:
      break;
    default:
      fs(e, n), Ys(n);
  }
}
function Ys(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (zk(t)) {
            var r = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Pe(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (fp(i, ""), (r.flags &= -33));
          var s = $P(n);
          Db(n, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = $P(n);
          Ob(n, a, o);
          break;
        default:
          throw Error(Pe(161));
      }
    } catch (l) {
      In(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function cG(n, e, t) {
  (et = n), Hk(n);
}
function Hk(n, e, t) {
  for (var r = (n.mode & 1) !== 0; et !== null; ) {
    var i = et,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || Gg;
      if (!o) {
        var a = i.alternate,
          l = (a !== null && a.memoizedState !== null) || Nr;
        a = Gg;
        var c = Nr;
        if (((Gg = o), (Nr = l) && !c))
          for (et = i; et !== null; )
            (o = et),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? YP(i)
                : l !== null
                ? ((l.return = o), (et = l))
                : YP(i);
        for (; s !== null; ) (et = s), Hk(s), (s = s.sibling);
        (et = i), (Gg = a), (Nr = c);
      }
      qP(n);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (et = s)) : qP(n);
  }
}
function qP(n) {
  for (; et !== null; ) {
    var e = et;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              Nr || _x(5, e);
              break;
            case 1:
              var r = e.stateNode;
              if (e.flags & 4 && !Nr)
                if (t === null) r.componentDidMount();
                else {
                  var i =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Ss(e.type, t.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    t.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && NP(e, s, r);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                NP(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var f = u.dehydrated;
                    f !== null && vp(f);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(Pe(163));
          }
        Nr || (e.flags & 512 && Lb(e));
      } catch (p) {
        In(e, e.return, p);
      }
    }
    if (e === n) {
      et = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (et = t);
      break;
    }
    et = e.return;
  }
}
function KP(n) {
  for (; et !== null; ) {
    var e = et;
    if (e === n) {
      et = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (et = t);
      break;
    }
    et = e.return;
  }
}
function YP(n) {
  for (; et !== null; ) {
    var e = et;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            _x(4, e);
          } catch (l) {
            In(e, t, l);
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = e.return;
            try {
              r.componentDidMount();
            } catch (l) {
              In(e, i, l);
            }
          }
          var s = e.return;
          try {
            Lb(e);
          } catch (l) {
            In(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            Lb(e);
          } catch (l) {
            In(e, o, l);
          }
      }
    } catch (l) {
      In(e, e.return, l);
    }
    if (e === n) {
      et = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (et = a);
      break;
    }
    et = e.return;
  }
}
var uG = Math.ceil,
  Qy = aa.ReactCurrentDispatcher,
  qT = aa.ReactCurrentOwner,
  is = aa.ReactCurrentBatchConfig,
  $t = 0,
  cr = null,
  Gn = null,
  pr = 0,
  Ti = 0,
  hd = gl(0),
  Jn = 0,
  Ap = null,
  kc = 0,
  wx = 0,
  KT = 0,
  Gf = null,
  ci = null,
  YT = 0,
  Jd = 1 / 0,
  Fo = null,
  e0 = !1,
  kb = null,
  nl = null,
  $g = !1,
  qa = null,
  t0 = 0,
  $f = 0,
  Ub = null,
  vy = -1,
  yy = 0;
function Yr() {
  return $t & 6 ? Bn() : vy !== -1 ? vy : (vy = Bn());
}
function rl(n) {
  return n.mode & 1
    ? $t & 2 && pr !== 0
      ? pr & -pr
      : XW.transition !== null
      ? (yy === 0 && (yy = CD()), yy)
      : ((n = rn),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : OD(n.type))),
        n)
    : 1;
}
function Os(n, e, t, r) {
  if (50 < $f) throw (($f = 0), (Ub = null), Error(Pe(185)));
  um(n, t, r),
    (!($t & 2) || n !== cr) &&
      (n === cr && (!($t & 2) && (wx |= t), Jn === 4 && Ba(n, pr)),
      gi(n, r),
      t === 1 && $t === 0 && !(e.mode & 1) && ((Jd = Bn() + 500), vx && vl()));
}
function gi(n, e) {
  var t = n.callbackNode;
  XH(n, e);
  var r = Fy(n, n === cr ? pr : 0);
  if (r === 0)
    t !== null && sP(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = r & -r), n.callbackPriority !== e)) {
    if ((t != null && sP(t), e === 1))
      n.tag === 0 ? $W(JP.bind(null, n)) : QD(JP.bind(null, n)),
        jW(function () {
          !($t & 6) && vl();
        }),
        (t = null);
    else {
      switch (AD(r)) {
        case 1:
          t = ST;
          break;
        case 4:
          t = TD;
          break;
        case 16:
          t = Uy;
          break;
        case 536870912:
          t = MD;
          break;
        default:
          t = Uy;
      }
      t = Jk(t, Wk.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function Wk(n, e) {
  if (((vy = -1), (yy = 0), $t & 6)) throw Error(Pe(327));
  var t = n.callbackNode;
  if (Ad() && n.callbackNode !== t) return null;
  var r = Fy(n, n === cr ? pr : 0);
  if (r === 0) return null;
  if (r & 30 || r & n.expiredLanes || e) e = n0(n, r);
  else {
    e = r;
    var i = $t;
    $t |= 2;
    var s = $k();
    (cr !== n || pr !== e) && ((Fo = null), (Jd = Bn() + 500), Tc(n, e));
    do
      try {
        fG();
        break;
      } catch (a) {
        Gk(n, a);
      }
    while (!0);
    DT(),
      (Qy.current = s),
      ($t = i),
      Gn !== null ? (e = 0) : ((cr = null), (pr = 0), (e = Jn));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((i = ub(n)), i !== 0 && ((r = i), (e = Fb(n, i)))), e === 1)
    )
      throw ((t = Ap), Tc(n, 0), Ba(n, r), gi(n, Bn()), t);
    if (e === 6) Ba(n, r);
    else {
      if (
        ((i = n.current.alternate),
        !(r & 30) &&
          !dG(i) &&
          ((e = n0(n, r)),
          e === 2 && ((s = ub(n)), s !== 0 && ((r = s), (e = Fb(n, s)))),
          e === 1))
      )
        throw ((t = Ap), Tc(n, 0), Ba(n, r), gi(n, Bn()), t);
      switch (((n.finishedWork = i), (n.finishedLanes = r), e)) {
        case 0:
        case 1:
          throw Error(Pe(345));
        case 2:
          ec(n, ci, Fo);
          break;
        case 3:
          if (
            (Ba(n, r), (r & 130023424) === r && ((e = YT + 500 - Bn()), 10 < e))
          ) {
            if (Fy(n, 0) !== 0) break;
            if (((i = n.suspendedLanes), (i & r) !== r)) {
              Yr(), (n.pingedLanes |= n.suspendedLanes & i);
              break;
            }
            n.timeoutHandle = yb(ec.bind(null, n, ci, Fo), e);
            break;
          }
          ec(n, ci, Fo);
          break;
        case 4:
          if ((Ba(n, r), (r & 4194240) === r)) break;
          for (e = n.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - Ls(r);
            (s = 1 << o), (o = e[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = Bn() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * uG(r / 1960)) - r),
            10 < r)
          ) {
            n.timeoutHandle = yb(ec.bind(null, n, ci, Fo), r);
            break;
          }
          ec(n, ci, Fo);
          break;
        case 5:
          ec(n, ci, Fo);
          break;
        default:
          throw Error(Pe(329));
      }
    }
  }
  return gi(n, Bn()), n.callbackNode === t ? Wk.bind(null, n) : null;
}
function Fb(n, e) {
  var t = Gf;
  return (
    n.current.memoizedState.isDehydrated && (Tc(n, e).flags |= 256),
    (n = n0(n, e)),
    n !== 2 && ((e = ci), (ci = t), e !== null && Bb(e)),
    n
  );
}
function Bb(n) {
  ci === null ? (ci = n) : ci.push.apply(ci, n);
}
function dG(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var r = 0; r < t.length; r++) {
          var i = t[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!Ds(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Ba(n, e) {
  for (
    e &= ~KT,
      e &= ~wx,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - Ls(e),
      r = 1 << t;
    (n[t] = -1), (e &= ~r);
  }
}
function JP(n) {
  if ($t & 6) throw Error(Pe(327));
  Ad();
  var e = Fy(n, 0);
  if (!(e & 1)) return gi(n, Bn()), null;
  var t = n0(n, e);
  if (n.tag !== 0 && t === 2) {
    var r = ub(n);
    r !== 0 && ((e = r), (t = Fb(n, r)));
  }
  if (t === 1) throw ((t = Ap), Tc(n, 0), Ba(n, e), gi(n, Bn()), t);
  if (t === 6) throw Error(Pe(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    ec(n, ci, Fo),
    gi(n, Bn()),
    null
  );
}
function JT(n, e) {
  var t = $t;
  $t |= 1;
  try {
    return n(e);
  } finally {
    ($t = t), $t === 0 && ((Jd = Bn() + 500), vx && vl());
  }
}
function Uc(n) {
  qa !== null && qa.tag === 0 && !($t & 6) && Ad();
  var e = $t;
  $t |= 1;
  var t = is.transition,
    r = rn;
  try {
    if (((is.transition = null), (rn = 1), n)) return n();
  } finally {
    (rn = r), (is.transition = t), ($t = e), !($t & 6) && vl();
  }
}
function ZT() {
  (Ti = hd.current), fn(hd);
}
function Tc(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), VW(t)), Gn !== null))
    for (t = Gn.return; t !== null; ) {
      var r = t;
      switch ((NT(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && Hy();
          break;
        case 3:
          Kd(), fn(pi), fn(kr), VT();
          break;
        case 5:
          zT(r);
          break;
        case 4:
          Kd();
          break;
        case 13:
          fn(Sn);
          break;
        case 19:
          fn(Sn);
          break;
        case 10:
          kT(r.type._context);
          break;
        case 22:
        case 23:
          ZT();
      }
      t = t.return;
    }
  if (
    ((cr = n),
    (Gn = n = il(n.current, null)),
    (pr = Ti = e),
    (Jn = 0),
    (Ap = null),
    (KT = wx = kc = 0),
    (ci = Gf = null),
    dc !== null)
  ) {
    for (e = 0; e < dc.length; e++)
      if (((t = dc[e]), (r = t.interleaved), r !== null)) {
        t.interleaved = null;
        var i = r.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        t.pending = r;
      }
    dc = null;
  }
  return n;
}
function Gk(n, e) {
  do {
    var t = Gn;
    try {
      if ((DT(), (py.current = Zy), Jy)) {
        for (var r = Tn.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        Jy = !1;
      }
      if (
        ((Dc = 0),
        (ar = Yn = Tn = null),
        (Hf = !1),
        (Tp = 0),
        (qT.current = null),
        t === null || t.return === null)
      ) {
        (Jn = 1), (Ap = e), (Gn = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = pr),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = a,
            f = u.tag;
          if (!(u.mode & 1) && (f === 0 || f === 11 || f === 15)) {
            var p = u.alternate;
            p
              ? ((u.updateQueue = p.updateQueue),
                (u.memoizedState = p.memoizedState),
                (u.lanes = p.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var m = FP(o);
          if (m !== null) {
            (m.flags &= -257),
              BP(m, o, a, s, e),
              m.mode & 1 && UP(s, c, e),
              (e = m),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var y = new Set();
              y.add(l), (e.updateQueue = y);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              UP(s, c, e), QT();
              break e;
            }
            l = Error(Pe(426));
          }
        } else if (yn && a.mode & 1) {
          var x = FP(o);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              BP(x, o, a, s, e),
              LT(Yd(l, a));
            break e;
          }
        }
        (s = l = Yd(l, a)),
          Jn !== 4 && (Jn = 2),
          Gf === null ? (Gf = [s]) : Gf.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var g = Ak(s, l, e);
              IP(s, g);
              break e;
            case 1:
              a = l;
              var _ = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (nl === null || !nl.has(S))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var b = Rk(s, a, e);
                IP(s, b);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      qk(t);
    } catch (C) {
      (e = C), Gn === t && t !== null && (Gn = t = t.return);
      continue;
    }
    break;
  } while (!0);
}
function $k() {
  var n = Qy.current;
  return (Qy.current = Zy), n === null ? Zy : n;
}
function QT() {
  (Jn === 0 || Jn === 3 || Jn === 2) && (Jn = 4),
    cr === null || (!(kc & 268435455) && !(wx & 268435455)) || Ba(cr, pr);
}
function n0(n, e) {
  var t = $t;
  $t |= 2;
  var r = $k();
  (cr !== n || pr !== e) && ((Fo = null), Tc(n, e));
  do
    try {
      hG();
      break;
    } catch (i) {
      Gk(n, i);
    }
  while (!0);
  if ((DT(), ($t = t), (Qy.current = r), Gn !== null)) throw Error(Pe(261));
  return (cr = null), (pr = 0), Jn;
}
function hG() {
  for (; Gn !== null; ) Xk(Gn);
}
function fG() {
  for (; Gn !== null && !FH(); ) Xk(Gn);
}
function Xk(n) {
  var e = Yk(n.alternate, n, Ti);
  (n.memoizedProps = n.pendingProps),
    e === null ? qk(n) : (Gn = e),
    (qT.current = null);
}
function qk(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = oG(t, e)), t !== null)) {
        (t.flags &= 32767), (Gn = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (Jn = 6), (Gn = null);
        return;
      }
    } else if (((t = sG(t, e, Ti)), t !== null)) {
      Gn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Gn = e;
      return;
    }
    Gn = e = n;
  } while (e !== null);
  Jn === 0 && (Jn = 5);
}
function ec(n, e, t) {
  var r = rn,
    i = is.transition;
  try {
    (is.transition = null), (rn = 1), pG(n, e, t, r);
  } finally {
    (is.transition = i), (rn = r);
  }
  return null;
}
function pG(n, e, t, r) {
  do Ad();
  while (qa !== null);
  if ($t & 6) throw Error(Pe(327));
  t = n.finishedWork;
  var i = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(Pe(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (qH(n, s),
    n === cr && ((Gn = cr = null), (pr = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      $g ||
      (($g = !0),
      Jk(Uy, function () {
        return Ad(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = is.transition), (is.transition = null);
    var o = rn;
    rn = 1;
    var a = $t;
    ($t |= 4),
      (qT.current = null),
      lG(n, t),
      jk(t, n),
      OW(gb),
      (By = !!mb),
      (gb = mb = null),
      (n.current = t),
      cG(t),
      BH(),
      ($t = a),
      (rn = o),
      (is.transition = s);
  } else n.current = t;
  if (
    ($g && (($g = !1), (qa = n), (t0 = i)),
    (s = n.pendingLanes),
    s === 0 && (nl = null),
    jH(t.stateNode),
    gi(n, Bn()),
    e !== null)
  )
    for (r = n.onRecoverableError, t = 0; t < e.length; t++)
      (i = e[t]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (e0) throw ((e0 = !1), (n = kb), (kb = null), n);
  return (
    t0 & 1 && n.tag !== 0 && Ad(),
    (s = n.pendingLanes),
    s & 1 ? (n === Ub ? $f++ : (($f = 0), (Ub = n))) : ($f = 0),
    vl(),
    null
  );
}
function Ad() {
  if (qa !== null) {
    var n = AD(t0),
      e = is.transition,
      t = rn;
    try {
      if (((is.transition = null), (rn = 16 > n ? 16 : n), qa === null))
        var r = !1;
      else {
        if (((n = qa), (qa = null), (t0 = 0), $t & 6)) throw Error(Pe(331));
        var i = $t;
        for ($t |= 4, et = n.current; et !== null; ) {
          var s = et,
            o = s.child;
          if (et.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (et = c; et !== null; ) {
                  var u = et;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Wf(8, u, s);
                  }
                  var f = u.child;
                  if (f !== null) (f.return = u), (et = f);
                  else
                    for (; et !== null; ) {
                      u = et;
                      var p = u.sibling,
                        m = u.return;
                      if ((Bk(u), u === c)) {
                        et = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (et = p);
                        break;
                      }
                      et = m;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var y = v.child;
                if (y !== null) {
                  v.child = null;
                  do {
                    var x = y.sibling;
                    (y.sibling = null), (y = x);
                  } while (y !== null);
                }
              }
              et = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (et = o);
          else
            e: for (; et !== null; ) {
              if (((s = et), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Wf(9, s, s.return);
                }
              var g = s.sibling;
              if (g !== null) {
                (g.return = s.return), (et = g);
                break e;
              }
              et = s.return;
            }
        }
        var _ = n.current;
        for (et = _; et !== null; ) {
          o = et;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (et = S);
          else
            e: for (o = _; et !== null; ) {
              if (((a = et), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      _x(9, a);
                  }
                } catch (C) {
                  In(a, a.return, C);
                }
              if (a === o) {
                et = null;
                break e;
              }
              var b = a.sibling;
              if (b !== null) {
                (b.return = a.return), (et = b);
                break e;
              }
              et = a.return;
            }
        }
        if (
          (($t = i), vl(), lo && typeof lo.onPostCommitFiberRoot == "function")
        )
          try {
            lo.onPostCommitFiberRoot(hx, n);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (rn = t), (is.transition = e);
    }
  }
  return !1;
}
function ZP(n, e, t) {
  (e = Yd(t, e)),
    (e = Ak(n, e, 1)),
    (n = tl(n, e, 1)),
    (e = Yr()),
    n !== null && (um(n, 1, e), gi(n, e));
}
function In(n, e, t) {
  if (n.tag === 3) ZP(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        ZP(e, n, t);
        break;
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (nl === null || !nl.has(r)))
        ) {
          (n = Yd(t, n)),
            (n = Rk(e, n, 1)),
            (e = tl(e, n, 1)),
            (n = Yr()),
            e !== null && (um(e, 1, n), gi(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function mG(n, e, t) {
  var r = n.pingCache;
  r !== null && r.delete(e),
    (e = Yr()),
    (n.pingedLanes |= n.suspendedLanes & t),
    cr === n &&
      (pr & t) === t &&
      (Jn === 4 || (Jn === 3 && (pr & 130023424) === pr && 500 > Bn() - YT)
        ? Tc(n, 0)
        : (KT |= t)),
    gi(n, e);
}
function Kk(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = kg), (kg <<= 1), !(kg & 130023424) && (kg = 4194304))
      : (e = 1));
  var t = Yr();
  (n = Jo(n, e)), n !== null && (um(n, e, t), gi(n, t));
}
function gG(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), Kk(n, t);
}
function vG(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var r = n.stateNode,
        i = n.memoizedState;
      i !== null && (t = i.retryLane);
      break;
    case 19:
      r = n.stateNode;
      break;
    default:
      throw Error(Pe(314));
  }
  r !== null && r.delete(e), Kk(n, t);
}
var Yk;
Yk = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || pi.current) di = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (di = !1), iG(n, e, t);
      di = !!(n.flags & 131072);
    }
  else (di = !1), yn && e.flags & 1048576 && ek(e, $y, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var r = e.type;
      gy(n, e), (n = e.pendingProps);
      var i = $d(e, kr.current);
      Cd(e, t), (i = HT(null, e, r, n, i, t));
      var s = WT();
      return (
        (e.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            mi(r) ? ((s = !0), Wy(e)) : (s = !1),
            (e.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            FT(e),
            (i.updater = xx),
            (e.stateNode = i),
            (i._reactInternals = e),
            Tb(e, r, n, t),
            (e = Ab(null, e, r, !0, s, t)))
          : ((e.tag = 0), yn && s && IT(e), Gr(null, e, i, t), (e = e.child)),
        e
      );
    case 16:
      r = e.elementType;
      e: {
        switch (
          (gy(n, e),
          (n = e.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (e.type = r),
          (i = e.tag = xG(r)),
          (n = Ss(r, n)),
          i)
        ) {
          case 0:
            e = Cb(null, e, r, n, t);
            break e;
          case 1:
            e = jP(null, e, r, n, t);
            break e;
          case 11:
            e = zP(null, e, r, n, t);
            break e;
          case 14:
            e = VP(null, e, r, Ss(r.type, n), t);
            break e;
        }
        throw Error(Pe(306, r, ""));
      }
      return e;
    case 0:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Ss(r, i)),
        Cb(n, e, r, i, t)
      );
    case 1:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Ss(r, i)),
        jP(n, e, r, i, t)
      );
    case 3:
      e: {
        if ((Lk(e), n === null)) throw Error(Pe(387));
        (r = e.pendingProps),
          (s = e.memoizedState),
          (i = s.element),
          ok(n, e),
          Ky(e, r, null, t);
        var o = e.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (i = Yd(Error(Pe(423)), e)), (e = HP(n, e, r, t, i));
            break e;
          } else if (r !== i) {
            (i = Yd(Error(Pe(424)), e)), (e = HP(n, e, r, t, i));
            break e;
          } else
            for (
              Ri = el(e.stateNode.containerInfo.firstChild),
                Ii = e,
                yn = !0,
                Ps = null,
                t = ik(e, null, r, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Xd(), r === i)) {
            e = Zo(n, e, t);
            break e;
          }
          Gr(n, e, r, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        ak(e),
        n === null && Sb(e),
        (r = e.type),
        (i = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = i.children),
        vb(r, i) ? (o = null) : s !== null && vb(r, s) && (e.flags |= 32),
        Nk(n, e),
        Gr(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && Sb(e), null;
    case 13:
      return Ok(n, e, t);
    case 4:
      return (
        BT(e, e.stateNode.containerInfo),
        (r = e.pendingProps),
        n === null ? (e.child = qd(e, null, r, t)) : Gr(n, e, r, t),
        e.child
      );
    case 11:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Ss(r, i)),
        zP(n, e, r, i, t)
      );
    case 7:
      return Gr(n, e, e.pendingProps, t), e.child;
    case 8:
      return Gr(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return Gr(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((r = e.type._context),
          (i = e.pendingProps),
          (s = e.memoizedProps),
          (o = i.value),
          cn(Xy, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (Ds(s.value, o)) {
            if (s.children === i.children && !pi.current) {
              e = Zo(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === r) {
                    if (s.tag === 1) {
                      (l = $o(-1, t & -t)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      bb(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(Pe(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  bb(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        Gr(n, e, i.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (i = e.type),
        (r = e.pendingProps.children),
        Cd(e, t),
        (i = os(i)),
        (r = r(i)),
        (e.flags |= 1),
        Gr(n, e, r, t),
        e.child
      );
    case 14:
      return (
        (r = e.type),
        (i = Ss(r, e.pendingProps)),
        (i = Ss(r.type, i)),
        VP(n, e, r, i, t)
      );
    case 15:
      return Pk(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (r = e.type),
        (i = e.pendingProps),
        (i = e.elementType === r ? i : Ss(r, i)),
        gy(n, e),
        (e.tag = 1),
        mi(r) ? ((n = !0), Wy(e)) : (n = !1),
        Cd(e, t),
        Ck(e, r, i),
        Tb(e, r, i, t),
        Ab(null, e, r, !0, n, t)
      );
    case 19:
      return Dk(n, e, t);
    case 22:
      return Ik(n, e, t);
  }
  throw Error(Pe(156, e.tag));
};
function Jk(n, e) {
  return ED(n, e);
}
function yG(n, e, t, r) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function ns(n, e, t, r) {
  return new yG(n, e, t, r);
}
function eM(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function xG(n) {
  if (typeof n == "function") return eM(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === xT)) return 11;
    if (n === _T) return 14;
  }
  return 2;
}
function il(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = ns(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function xy(n, e, t, r, i, s) {
  var o = 2;
  if (((r = n), typeof n == "function")) eM(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case nd:
        return Mc(t.children, i, s, e);
      case yT:
        (o = 8), (i |= 8);
        break;
      case K1:
        return (
          (n = ns(12, t, e, i | 2)), (n.elementType = K1), (n.lanes = s), n
        );
      case Y1:
        return (n = ns(13, t, e, i)), (n.elementType = Y1), (n.lanes = s), n;
      case J1:
        return (n = ns(19, t, e, i)), (n.elementType = J1), (n.lanes = s), n;
      case aD:
        return Sx(t, i, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case sD:
              o = 10;
              break e;
            case oD:
              o = 9;
              break e;
            case xT:
              o = 11;
              break e;
            case _T:
              o = 14;
              break e;
            case Na:
              (o = 16), (r = null);
              break e;
          }
        throw Error(Pe(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = ns(o, t, e, i)), (e.elementType = n), (e.type = r), (e.lanes = s), e
  );
}
function Mc(n, e, t, r) {
  return (n = ns(7, n, r, e)), (n.lanes = t), n;
}
function Sx(n, e, t, r) {
  return (
    (n = ns(22, n, r, e)),
    (n.elementType = aD),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function lS(n, e, t) {
  return (n = ns(6, n, null, e)), (n.lanes = t), n;
}
function cS(n, e, t) {
  return (
    (e = ns(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function _G(n, e, t, r, i) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Hw(0)),
    (this.expirationTimes = Hw(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Hw(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function tM(n, e, t, r, i, s, o, a, l) {
  return (
    (n = new _G(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = ns(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: r,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    FT(s),
    n
  );
}
function wG(n, e, t) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: td,
    key: r == null ? null : "" + r,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function Zk(n) {
  if (!n) return ll;
  n = n._reactInternals;
  e: {
    if (Xc(n) !== n || n.tag !== 1) throw Error(Pe(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (mi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Pe(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (mi(t)) return ZD(n, t, e);
  }
  return e;
}
function Qk(n, e, t, r, i, s, o, a, l) {
  return (
    (n = tM(t, r, !0, n, i, s, o, a, l)),
    (n.context = Zk(null)),
    (t = n.current),
    (r = Yr()),
    (i = rl(t)),
    (s = $o(r, i)),
    (s.callback = e ?? null),
    tl(t, s, i),
    (n.current.lanes = i),
    um(n, i, r),
    gi(n, r),
    n
  );
}
function bx(n, e, t, r) {
  var i = e.current,
    s = Yr(),
    o = rl(i);
  return (
    (t = Zk(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = $o(s, o)),
    (e.payload = { element: n }),
    (r = r === void 0 ? null : r),
    r !== null && (e.callback = r),
    (n = tl(i, e, o)),
    n !== null && (Os(n, i, o, s), fy(n, i, o)),
    o
  );
}
function r0(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function QP(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function nM(n, e) {
  QP(n, e), (n = n.alternate) && QP(n, e);
}
function SG() {
  return null;
}
var e3 =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function rM(n) {
  this._internalRoot = n;
}
Ex.prototype.render = rM.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(Pe(409));
  bx(n, e, null, null);
};
Ex.prototype.unmount = rM.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    Uc(function () {
      bx(null, n, null, null);
    }),
      (e[Yo] = null);
  }
};
function Ex(n) {
  this._internalRoot = n;
}
Ex.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = ID();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < Fa.length && e !== 0 && e < Fa[t].priority; t++);
    Fa.splice(t, 0, n), t === 0 && LD(n);
  }
};
function iM(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function Tx(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function eI() {}
function bG(n, e, t, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var c = r0(o);
        s.call(c);
      };
    }
    var o = Qk(e, r, n, 0, null, !1, !1, "", eI);
    return (
      (n._reactRootContainer = o),
      (n[Yo] = o.current),
      _p(n.nodeType === 8 ? n.parentNode : n),
      Uc(),
      o
    );
  }
  for (; (i = n.lastChild); ) n.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var c = r0(l);
      a.call(c);
    };
  }
  var l = tM(n, 0, !1, null, null, !1, !1, "", eI);
  return (
    (n._reactRootContainer = l),
    (n[Yo] = l.current),
    _p(n.nodeType === 8 ? n.parentNode : n),
    Uc(function () {
      bx(e, l, t, r);
    }),
    l
  );
}
function Mx(n, e, t, r, i) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var l = r0(o);
        a.call(l);
      };
    }
    bx(e, o, n, i);
  } else o = bG(t, e, n, i, r);
  return r0(o);
}
RD = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = Pf(e.pendingLanes);
        t !== 0 &&
          (bT(e, t | 1), gi(e, Bn()), !($t & 6) && ((Jd = Bn() + 500), vl()));
      }
      break;
    case 13:
      Uc(function () {
        var r = Jo(n, 1);
        if (r !== null) {
          var i = Yr();
          Os(r, n, 1, i);
        }
      }),
        nM(n, 1);
  }
};
ET = function (n) {
  if (n.tag === 13) {
    var e = Jo(n, 134217728);
    if (e !== null) {
      var t = Yr();
      Os(e, n, 134217728, t);
    }
    nM(n, 134217728);
  }
};
PD = function (n) {
  if (n.tag === 13) {
    var e = rl(n),
      t = Jo(n, e);
    if (t !== null) {
      var r = Yr();
      Os(t, n, e, r);
    }
    nM(n, e);
  }
};
ID = function () {
  return rn;
};
ND = function (n, e) {
  var t = rn;
  try {
    return (rn = n), e();
  } finally {
    rn = t;
  }
};
ab = function (n, e, t) {
  switch (e) {
    case "input":
      if ((eb(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var r = t[e];
          if (r !== n && r.form === n.form) {
            var i = gx(r);
            if (!i) throw Error(Pe(90));
            cD(r), eb(r, i);
          }
        }
      }
      break;
    case "textarea":
      dD(n, t);
      break;
    case "select":
      (e = t.value), e != null && bd(n, !!t.multiple, e, !1);
  }
};
yD = JT;
xD = Uc;
var EG = { usingClientEntryPoint: !1, Events: [hm, od, gx, gD, vD, JT] },
  uf = {
    findFiberByHostInstance: uc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  TG = {
    bundleType: uf.bundleType,
    version: uf.version,
    rendererPackageName: uf.rendererPackageName,
    rendererConfig: uf.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: aa.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = SD(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: uf.findFiberByHostInstance || SG,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Xg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Xg.isDisabled && Xg.supportsFiber)
    try {
      (hx = Xg.inject(TG)), (lo = Xg);
    } catch {}
}
ki.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = EG;
ki.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!iM(e)) throw Error(Pe(200));
  return wG(n, e, null, t);
};
ki.createRoot = function (n, e) {
  if (!iM(n)) throw Error(Pe(299));
  var t = !1,
    r = "",
    i = e3;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (r = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (i = e.onRecoverableError)),
    (e = tM(n, 1, !1, null, null, t, !1, r, i)),
    (n[Yo] = e.current),
    _p(n.nodeType === 8 ? n.parentNode : n),
    new rM(e)
  );
};
ki.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(Pe(188))
      : ((n = Object.keys(n).join(",")), Error(Pe(268, n)));
  return (n = SD(e)), (n = n === null ? null : n.stateNode), n;
};
ki.flushSync = function (n) {
  return Uc(n);
};
ki.hydrate = function (n, e, t) {
  if (!Tx(e)) throw Error(Pe(200));
  return Mx(null, n, e, !0, t);
};
ki.hydrateRoot = function (n, e, t) {
  if (!iM(n)) throw Error(Pe(405));
  var r = (t != null && t.hydratedSources) || null,
    i = !1,
    s = "",
    o = e3;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (i = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = Qk(e, null, n, 1, t ?? null, i, !1, s, o)),
    (n[Yo] = e.current),
    _p(n),
    r)
  )
    for (n = 0; n < r.length; n++)
      (t = r[n]),
        (i = t._getVersion),
        (i = i(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, i])
          : e.mutableSourceEagerHydrationData.push(t, i);
  return new Ex(e);
};
ki.render = function (n, e, t) {
  if (!Tx(e)) throw Error(Pe(200));
  return Mx(null, n, e, !1, t);
};
ki.unmountComponentAtNode = function (n) {
  if (!Tx(n)) throw Error(Pe(40));
  return n._reactRootContainer
    ? (Uc(function () {
        Mx(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Yo] = null);
        });
      }),
      !0)
    : !1;
};
ki.unstable_batchedUpdates = JT;
ki.unstable_renderSubtreeIntoContainer = function (n, e, t, r) {
  if (!Tx(t)) throw Error(Pe(200));
  if (n == null || n._reactInternals === void 0) throw Error(Pe(38));
  return Mx(n, e, t, !1, r);
};
ki.version = "18.3.1-next-f1338f8080-20240426";
function t3() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t3);
    } catch (n) {
      console.error(n);
    }
}
t3(), (tD.exports = ki);
var qc = tD.exports;
const n3 = cT(qc);
var r3,
  tI = qc;
(r3 = tI.createRoot), tI.hydrateRoot;
const MG = 5,
  CG = 5e3;
let uS = 0;
function AG() {
  return (uS = (uS + 1) % Number.MAX_SAFE_INTEGER), uS.toString();
}
const dS = new Map(),
  nI = (n) => {
    if (dS.has(n)) return;
    const e = setTimeout(() => {
      dS.delete(n), Xf({ type: "REMOVE_TOAST", toastId: n });
    }, CG);
    dS.set(n, e);
  },
  RG = (n, e) => {
    switch (e.type) {
      case "ADD_TOAST":
        return { ...n, toasts: [e.toast, ...n.toasts].slice(0, MG) };
      case "UPDATE_TOAST":
        return {
          ...n,
          toasts: n.toasts.map((t) =>
            t.id === e.toast.id ? { ...t, ...e.toast } : t
          ),
        };
      case "DISMISS_TOAST": {
        const { toastId: t } = e;
        return (
          t
            ? nI(t)
            : n.toasts.forEach((r) => {
                nI(r.id);
              }),
          {
            ...n,
            toasts: n.toasts.map((r) =>
              r.id === t || t === void 0 ? { ...r, open: !1 } : r
            ),
          }
        );
      }
      case "REMOVE_TOAST":
        return e.toastId === void 0
          ? { ...n, toasts: [] }
          : { ...n, toasts: n.toasts.filter((t) => t.id !== e.toastId) };
    }
  },
  _y = [];
let wy = { toasts: [] };
function Xf(n) {
  (wy = RG(wy, n)),
    _y.forEach((e) => {
      e(wy);
    });
}
function PG({ ...n }) {
  const e = AG(),
    t = (i) => Xf({ type: "UPDATE_TOAST", toast: { ...i, id: e } }),
    r = () => Xf({ type: "DISMISS_TOAST", toastId: e });
  return (
    Xf({
      type: "ADD_TOAST",
      toast: {
        ...n,
        id: e,
        open: !0,
        onOpenChange: (i) => {
          i || r();
        },
      },
    }),
    { id: e, dismiss: r, update: t }
  );
}
function IG() {
  const [n, e] = P.useState(wy);
  return (
    P.useEffect(
      () => (
        _y.push(e),
        () => {
          const t = _y.indexOf(e);
          t > -1 && _y.splice(t, 1);
        }
      ),
      [n]
    ),
    {
      ...n,
      toast: PG,
      dismiss: (t) => Xf({ type: "DISMISS_TOAST", toastId: t }),
    }
  );
}
function Bt(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function (i) {
    if ((n == null || n(i), t === !1 || !i.defaultPrevented))
      return e == null ? void 0 : e(i);
  };
}
function rI(n, e) {
  if (typeof n == "function") return n(e);
  n != null && (n.current = e);
}
function i3(...n) {
  return (e) => {
    let t = !1;
    const r = n.map((i) => {
      const s = rI(i, e);
      return !t && typeof s == "function" && (t = !0), s;
    });
    if (t)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : rI(n[i], null);
        }
      };
  };
}
function pn(...n) {
  return P.useCallback(i3(...n), n);
}
function NG(n, e) {
  const t = P.createContext(e),
    r = (s) => {
      const { children: o, ...a } = s,
        l = P.useMemo(() => a, Object.values(a));
      return T.jsx(t.Provider, { value: l, children: o });
    };
  r.displayName = n + "Provider";
  function i(s) {
    const o = P.useContext(t);
    if (o) return o;
    if (e !== void 0) return e;
    throw new Error(`\`${s}\` must be used within \`${n}\``);
  }
  return [r, i];
}
function yh(n, e = []) {
  let t = [];
  function r(s, o) {
    const a = P.createContext(o),
      l = t.length;
    t = [...t, o];
    const c = (f) => {
      var g;
      const { scope: p, children: m, ...v } = f,
        y = ((g = p == null ? void 0 : p[n]) == null ? void 0 : g[l]) || a,
        x = P.useMemo(() => v, Object.values(v));
      return T.jsx(y.Provider, { value: x, children: m });
    };
    c.displayName = s + "Provider";
    function u(f, p) {
      var y;
      const m = ((y = p == null ? void 0 : p[n]) == null ? void 0 : y[l]) || a,
        v = P.useContext(m);
      if (v) return v;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${s}\``);
    }
    return [c, u];
  }
  const i = () => {
    const s = t.map((o) => P.createContext(o));
    return function (a) {
      const l = (a == null ? void 0 : a[n]) || s;
      return P.useMemo(() => ({ [`__scope${n}`]: { ...a, [n]: l } }), [a, l]);
    };
  };
  return (i.scopeName = n), [r, LG(i, ...e)];
}
function LG(...n) {
  const e = n[0];
  if (n.length === 1) return e;
  const t = () => {
    const r = n.map((i) => ({ useScope: i(), scopeName: i.scopeName }));
    return function (s) {
      const o = r.reduce((a, { useScope: l, scopeName: c }) => {
        const f = l(s)[`__scope${c}`];
        return { ...a, ...f };
      }, {});
      return P.useMemo(() => ({ [`__scope${e.scopeName}`]: o }), [o]);
    };
  };
  return (t.scopeName = e.scopeName), t;
}
function Zd(n) {
  const e = DG(n),
    t = P.forwardRef((r, i) => {
      const { children: s, ...o } = r,
        a = P.Children.toArray(s),
        l = a.find(UG);
      if (l) {
        const c = l.props.children,
          u = a.map((f) =>
            f === l
              ? P.Children.count(c) > 1
                ? P.Children.only(null)
                : P.isValidElement(c)
                ? c.props.children
                : null
              : f
          );
        return T.jsx(e, {
          ...o,
          ref: i,
          children: P.isValidElement(c) ? P.cloneElement(c, void 0, u) : null,
        });
      }
      return T.jsx(e, { ...o, ref: i, children: s });
    });
  return (t.displayName = `${n}.Slot`), t;
}
var OG = Zd("Slot");
function DG(n) {
  const e = P.forwardRef((t, r) => {
    const { children: i, ...s } = t;
    if (P.isValidElement(i)) {
      const o = BG(i),
        a = FG(s, i.props);
      return (
        i.type !== P.Fragment && (a.ref = r ? i3(r, o) : o),
        P.cloneElement(i, a)
      );
    }
    return P.Children.count(i) > 1 ? P.Children.only(null) : null;
  });
  return (e.displayName = `${n}.SlotClone`), e;
}
var s3 = Symbol("radix.slottable");
function kG(n) {
  const e = ({ children: t }) => T.jsx(T.Fragment, { children: t });
  return (e.displayName = `${n}.Slottable`), (e.__radixId = s3), e;
}
function UG(n) {
  return (
    P.isValidElement(n) &&
    typeof n.type == "function" &&
    "__radixId" in n.type &&
    n.type.__radixId === s3
  );
}
function FG(n, e) {
  const t = { ...e };
  for (const r in e) {
    const i = n[r],
      s = e[r];
    /^on[A-Z]/.test(r)
      ? i && s
        ? (t[r] = (...a) => {
            const l = s(...a);
            return i(...a), l;
          })
        : i && (t[r] = i)
      : r === "style"
      ? (t[r] = { ...i, ...s })
      : r === "className" && (t[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...n, ...t };
}
function BG(n) {
  var r, i;
  let e =
      (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null
        ? void 0
        : r.get,
    t = e && "isReactWarning" in e && e.isReactWarning;
  return t
    ? n.ref
    : ((e =
        (i = Object.getOwnPropertyDescriptor(n, "ref")) == null
          ? void 0
          : i.get),
      (t = e && "isReactWarning" in e && e.isReactWarning),
      t ? n.props.ref : n.props.ref || n.ref);
}
function o3(n) {
  const e = n + "CollectionProvider",
    [t, r] = yh(e),
    [i, s] = t(e, { collectionRef: { current: null }, itemMap: new Map() }),
    o = (y) => {
      const { scope: x, children: g } = y,
        _ = Le.useRef(null),
        S = Le.useRef(new Map()).current;
      return T.jsx(i, { scope: x, itemMap: S, collectionRef: _, children: g });
    };
  o.displayName = e;
  const a = n + "CollectionSlot",
    l = Zd(a),
    c = Le.forwardRef((y, x) => {
      const { scope: g, children: _ } = y,
        S = s(a, g),
        b = pn(x, S.collectionRef);
      return T.jsx(l, { ref: b, children: _ });
    });
  c.displayName = a;
  const u = n + "CollectionItemSlot",
    f = "data-radix-collection-item",
    p = Zd(u),
    m = Le.forwardRef((y, x) => {
      const { scope: g, children: _, ...S } = y,
        b = Le.useRef(null),
        C = pn(x, b),
        A = s(u, g);
      return (
        Le.useEffect(
          () => (
            A.itemMap.set(b, { ref: b, ...S }), () => void A.itemMap.delete(b)
          )
        ),
        T.jsx(p, { [f]: "", ref: C, children: _ })
      );
    });
  m.displayName = u;
  function v(y) {
    const x = s(n + "CollectionConsumer", y);
    return Le.useCallback(() => {
      const _ = x.collectionRef.current;
      if (!_) return [];
      const S = Array.from(_.querySelectorAll(`[${f}]`));
      return Array.from(x.itemMap.values()).sort(
        (A, R) => S.indexOf(A.ref.current) - S.indexOf(R.ref.current)
      );
    }, [x.collectionRef, x.itemMap]);
  }
  return [{ Provider: o, Slot: c, ItemSlot: m }, v, r];
}
var zG = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul",
  ],
  Kt = zG.reduce((n, e) => {
    const t = Zd(`Primitive.${e}`),
      r = P.forwardRef((i, s) => {
        const { asChild: o, ...a } = i,
          l = o ? t : e;
        return (
          typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
          T.jsx(l, { ...a, ref: s })
        );
      });
    return (r.displayName = `Primitive.${e}`), { ...n, [e]: r };
  }, {});
function a3(n, e) {
  n && qc.flushSync(() => n.dispatchEvent(e));
}
function ks(n) {
  const e = P.useRef(n);
  return (
    P.useEffect(() => {
      e.current = n;
    }),
    P.useMemo(
      () =>
        (...t) => {
          var r;
          return (r = e.current) == null ? void 0 : r.call(e, ...t);
        },
      []
    )
  );
}
function VG(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ks(n);
  P.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && t(i);
    };
    return (
      e.addEventListener("keydown", r, { capture: !0 }),
      () => e.removeEventListener("keydown", r, { capture: !0 })
    );
  }, [t, e]);
}
var jG = "DismissableLayer",
  zb = "dismissableLayer.update",
  HG = "dismissableLayer.pointerDownOutside",
  WG = "dismissableLayer.focusOutside",
  iI,
  l3 = P.createContext({
    layers: new Set(),
    layersWithOutsidePointerEventsDisabled: new Set(),
    branches: new Set(),
  }),
  pm = P.forwardRef((n, e) => {
    const {
        disableOutsidePointerEvents: t = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: i,
        onFocusOutside: s,
        onInteractOutside: o,
        onDismiss: a,
        ...l
      } = n,
      c = P.useContext(l3),
      [u, f] = P.useState(null),
      p =
        (u == null ? void 0 : u.ownerDocument) ??
        (globalThis == null ? void 0 : globalThis.document),
      [, m] = P.useState({}),
      v = pn(e, (R) => f(R)),
      y = Array.from(c.layers),
      [x] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1),
      g = y.indexOf(x),
      _ = u ? y.indexOf(u) : -1,
      S = c.layersWithOutsidePointerEventsDisabled.size > 0,
      b = _ >= g,
      C = $G((R) => {
        const O = R.target,
          I = [...c.branches].some((N) => N.contains(O));
        !b ||
          I ||
          (i == null || i(R),
          o == null || o(R),
          R.defaultPrevented || a == null || a());
      }, p),
      A = XG((R) => {
        const O = R.target;
        [...c.branches].some((N) => N.contains(O)) ||
          (s == null || s(R),
          o == null || o(R),
          R.defaultPrevented || a == null || a());
      }, p);
    return (
      VG((R) => {
        _ === c.layers.size - 1 &&
          (r == null || r(R),
          !R.defaultPrevented && a && (R.preventDefault(), a()));
      }, p),
      P.useEffect(() => {
        if (u)
          return (
            t &&
              (c.layersWithOutsidePointerEventsDisabled.size === 0 &&
                ((iI = p.body.style.pointerEvents),
                (p.body.style.pointerEvents = "none")),
              c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            sI(),
            () => {
              t &&
                c.layersWithOutsidePointerEventsDisabled.size === 1 &&
                (p.body.style.pointerEvents = iI);
            }
          );
      }, [u, p, t, c]),
      P.useEffect(
        () => () => {
          u &&
            (c.layers.delete(u),
            c.layersWithOutsidePointerEventsDisabled.delete(u),
            sI());
        },
        [u, c]
      ),
      P.useEffect(() => {
        const R = () => m({});
        return (
          document.addEventListener(zb, R),
          () => document.removeEventListener(zb, R)
        );
      }, []),
      T.jsx(Kt.div, {
        ...l,
        ref: v,
        style: {
          pointerEvents: S ? (b ? "auto" : "none") : void 0,
          ...n.style,
        },
        onFocusCapture: Bt(n.onFocusCapture, A.onFocusCapture),
        onBlurCapture: Bt(n.onBlurCapture, A.onBlurCapture),
        onPointerDownCapture: Bt(
          n.onPointerDownCapture,
          C.onPointerDownCapture
        ),
      })
    );
  });
pm.displayName = jG;
var GG = "DismissableLayerBranch",
  c3 = P.forwardRef((n, e) => {
    const t = P.useContext(l3),
      r = P.useRef(null),
      i = pn(e, r);
    return (
      P.useEffect(() => {
        const s = r.current;
        if (s)
          return (
            t.branches.add(s),
            () => {
              t.branches.delete(s);
            }
          );
      }, [t.branches]),
      T.jsx(Kt.div, { ...n, ref: i })
    );
  });
c3.displayName = GG;
function $G(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ks(n),
    r = P.useRef(!1),
    i = P.useRef(() => {});
  return (
    P.useEffect(() => {
      const s = (a) => {
          if (a.target && !r.current) {
            let l = function () {
              u3(HG, t, c, { discrete: !0 });
            };
            const c = { originalEvent: a };
            a.pointerType === "touch"
              ? (e.removeEventListener("click", i.current),
                (i.current = l),
                e.addEventListener("click", i.current, { once: !0 }))
              : l();
          } else e.removeEventListener("click", i.current);
          r.current = !1;
        },
        o = window.setTimeout(() => {
          e.addEventListener("pointerdown", s);
        }, 0);
      return () => {
        window.clearTimeout(o),
          e.removeEventListener("pointerdown", s),
          e.removeEventListener("click", i.current);
      };
    }, [e, t]),
    { onPointerDownCapture: () => (r.current = !0) }
  );
}
function XG(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = ks(n),
    r = P.useRef(!1);
  return (
    P.useEffect(() => {
      const i = (s) => {
        s.target &&
          !r.current &&
          u3(WG, t, { originalEvent: s }, { discrete: !1 });
      };
      return (
        e.addEventListener("focusin", i),
        () => e.removeEventListener("focusin", i)
      );
    }, [e, t]),
    {
      onFocusCapture: () => (r.current = !0),
      onBlurCapture: () => (r.current = !1),
    }
  );
}
function sI() {
  const n = new CustomEvent(zb);
  document.dispatchEvent(n);
}
function u3(n, e, t, { discrete: r }) {
  const i = t.originalEvent.target,
    s = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t });
  e && i.addEventListener(n, e, { once: !0 }),
    r ? a3(i, s) : i.dispatchEvent(s);
}
var qG = pm,
  KG = c3,
  yr = globalThis != null && globalThis.document ? P.useLayoutEffect : () => {},
  YG = "Portal",
  Cx = P.forwardRef((n, e) => {
    var a;
    const { container: t, ...r } = n,
      [i, s] = P.useState(!1);
    yr(() => s(!0), []);
    const o =
      t ||
      (i &&
        ((a = globalThis == null ? void 0 : globalThis.document) == null
          ? void 0
          : a.body));
    return o ? n3.createPortal(T.jsx(Kt.div, { ...r, ref: e }), o) : null;
  });
Cx.displayName = YG;
function JG(n, e) {
  return P.useReducer((t, r) => e[t][r] ?? t, n);
}
var xh = (n) => {
  const { present: e, children: t } = n,
    r = ZG(e),
    i =
      typeof t == "function" ? t({ present: r.isPresent }) : P.Children.only(t),
    s = pn(r.ref, QG(i));
  return typeof t == "function" || r.isPresent
    ? P.cloneElement(i, { ref: s })
    : null;
};
xh.displayName = "Presence";
function ZG(n) {
  const [e, t] = P.useState(),
    r = P.useRef(null),
    i = P.useRef(n),
    s = P.useRef("none"),
    o = n ? "mounted" : "unmounted",
    [a, l] = JG(o, {
      mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" },
      unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" },
      unmounted: { MOUNT: "mounted" },
    });
  return (
    P.useEffect(() => {
      const c = qg(r.current);
      s.current = a === "mounted" ? c : "none";
    }, [a]),
    yr(() => {
      const c = r.current,
        u = i.current;
      if (u !== n) {
        const p = s.current,
          m = qg(c);
        n
          ? l("MOUNT")
          : m === "none" || (c == null ? void 0 : c.display) === "none"
          ? l("UNMOUNT")
          : l(u && p !== m ? "ANIMATION_OUT" : "UNMOUNT"),
          (i.current = n);
      }
    }, [n, l]),
    yr(() => {
      if (e) {
        let c;
        const u = e.ownerDocument.defaultView ?? window,
          f = (m) => {
            const y = qg(r.current).includes(m.animationName);
            if (m.target === e && y && (l("ANIMATION_END"), !i.current)) {
              const x = e.style.animationFillMode;
              (e.style.animationFillMode = "forwards"),
                (c = u.setTimeout(() => {
                  e.style.animationFillMode === "forwards" &&
                    (e.style.animationFillMode = x);
                }));
            }
          },
          p = (m) => {
            m.target === e && (s.current = qg(r.current));
          };
        return (
          e.addEventListener("animationstart", p),
          e.addEventListener("animationcancel", f),
          e.addEventListener("animationend", f),
          () => {
            u.clearTimeout(c),
              e.removeEventListener("animationstart", p),
              e.removeEventListener("animationcancel", f),
              e.removeEventListener("animationend", f);
          }
        );
      } else l("ANIMATION_END");
    }, [e, l]),
    {
      isPresent: ["mounted", "unmountSuspended"].includes(a),
      ref: P.useCallback((c) => {
        (r.current = c ? getComputedStyle(c) : null), t(c);
      }, []),
    }
  );
}
function qg(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function QG(n) {
  var r, i;
  let e =
      (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null
        ? void 0
        : r.get,
    t = e && "isReactWarning" in e && e.isReactWarning;
  return t
    ? n.ref
    : ((e =
        (i = Object.getOwnPropertyDescriptor(n, "ref")) == null
          ? void 0
          : i.get),
      (t = e && "isReactWarning" in e && e.isReactWarning),
      t ? n.props.ref : n.props.ref || n.ref);
}
var e8 = pT[" useInsertionEffect ".trim().toString()] || yr;
function i0({ prop: n, defaultProp: e, onChange: t = () => {}, caller: r }) {
  const [i, s, o] = t8({ defaultProp: e, onChange: t }),
    a = n !== void 0,
    l = a ? n : i;
  {
    const u = P.useRef(n !== void 0);
    P.useEffect(() => {
      const f = u.current;
      f !== a &&
        console.warn(
          `${r} is changing from ${f ? "controlled" : "uncontrolled"} to ${
            a ? "controlled" : "uncontrolled"
          }. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ),
        (u.current = a);
    }, [a, r]);
  }
  const c = P.useCallback(
    (u) => {
      var f;
      if (a) {
        const p = n8(u) ? u(n) : u;
        p !== n && ((f = o.current) == null || f.call(o, p));
      } else s(u);
    },
    [a, n, s, o]
  );
  return [l, c];
}
function t8({ defaultProp: n, onChange: e }) {
  const [t, r] = P.useState(n),
    i = P.useRef(t),
    s = P.useRef(e);
  return (
    e8(() => {
      s.current = e;
    }, [e]),
    P.useEffect(() => {
      var o;
      i.current !== t &&
        ((o = s.current) == null || o.call(s, t), (i.current = t));
    }, [t, i]),
    [t, r, s]
  );
}
function n8(n) {
  return typeof n == "function";
}
var d3 = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal",
  }),
  r8 = "VisuallyHidden",
  Ax = P.forwardRef((n, e) =>
    T.jsx(Kt.span, { ...n, ref: e, style: { ...d3, ...n.style } })
  );
Ax.displayName = r8;
var i8 = Ax,
  sM = "ToastProvider",
  [oM, s8, o8] = o3("Toast"),
  [h3, Yde] = yh("Toast", [o8]),
  [a8, Rx] = h3(sM),
  f3 = (n) => {
    const {
        __scopeToast: e,
        label: t = "Notification",
        duration: r = 5e3,
        swipeDirection: i = "right",
        swipeThreshold: s = 50,
        children: o,
      } = n,
      [a, l] = P.useState(null),
      [c, u] = P.useState(0),
      f = P.useRef(!1),
      p = P.useRef(!1);
    return (
      t.trim() ||
        console.error(
          `Invalid prop \`label\` supplied to \`${sM}\`. Expected non-empty \`string\`.`
        ),
      T.jsx(oM.Provider, {
        scope: e,
        children: T.jsx(a8, {
          scope: e,
          label: t,
          duration: r,
          swipeDirection: i,
          swipeThreshold: s,
          toastCount: c,
          viewport: a,
          onViewportChange: l,
          onToastAdd: P.useCallback(() => u((m) => m + 1), []),
          onToastRemove: P.useCallback(() => u((m) => m - 1), []),
          isFocusedToastEscapeKeyDownRef: f,
          isClosePausedRef: p,
          children: o,
        }),
      })
    );
  };
f3.displayName = sM;
var p3 = "ToastViewport",
  l8 = ["F8"],
  Vb = "toast.viewportPause",
  jb = "toast.viewportResume",
  m3 = P.forwardRef((n, e) => {
    const {
        __scopeToast: t,
        hotkey: r = l8,
        label: i = "Notifications ({hotkey})",
        ...s
      } = n,
      o = Rx(p3, t),
      a = s8(t),
      l = P.useRef(null),
      c = P.useRef(null),
      u = P.useRef(null),
      f = P.useRef(null),
      p = pn(e, f, o.onViewportChange),
      m = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""),
      v = o.toastCount > 0;
    P.useEffect(() => {
      const x = (g) => {
        var S;
        r.length !== 0 &&
          r.every((b) => g[b] || g.code === b) &&
          ((S = f.current) == null || S.focus());
      };
      return (
        document.addEventListener("keydown", x),
        () => document.removeEventListener("keydown", x)
      );
    }, [r]),
      P.useEffect(() => {
        const x = l.current,
          g = f.current;
        if (v && x && g) {
          const _ = () => {
              if (!o.isClosePausedRef.current) {
                const A = new CustomEvent(Vb);
                g.dispatchEvent(A), (o.isClosePausedRef.current = !0);
              }
            },
            S = () => {
              if (o.isClosePausedRef.current) {
                const A = new CustomEvent(jb);
                g.dispatchEvent(A), (o.isClosePausedRef.current = !1);
              }
            },
            b = (A) => {
              !x.contains(A.relatedTarget) && S();
            },
            C = () => {
              x.contains(document.activeElement) || S();
            };
          return (
            x.addEventListener("focusin", _),
            x.addEventListener("focusout", b),
            x.addEventListener("pointermove", _),
            x.addEventListener("pointerleave", C),
            window.addEventListener("blur", _),
            window.addEventListener("focus", S),
            () => {
              x.removeEventListener("focusin", _),
                x.removeEventListener("focusout", b),
                x.removeEventListener("pointermove", _),
                x.removeEventListener("pointerleave", C),
                window.removeEventListener("blur", _),
                window.removeEventListener("focus", S);
            }
          );
        }
      }, [v, o.isClosePausedRef]);
    const y = P.useCallback(
      ({ tabbingDirection: x }) => {
        const _ = a().map((S) => {
          const b = S.ref.current,
            C = [b, ...w8(b)];
          return x === "forwards" ? C : C.reverse();
        });
        return (x === "forwards" ? _.reverse() : _).flat();
      },
      [a]
    );
    return (
      P.useEffect(() => {
        const x = f.current;
        if (x) {
          const g = (_) => {
            var C, A, R;
            const S = _.altKey || _.ctrlKey || _.metaKey;
            if (_.key === "Tab" && !S) {
              const O = document.activeElement,
                I = _.shiftKey;
              if (_.target === x && I) {
                (C = c.current) == null || C.focus();
                return;
              }
              const j = y({ tabbingDirection: I ? "backwards" : "forwards" }),
                $ = j.findIndex((G) => G === O);
              hS(j.slice($ + 1))
                ? _.preventDefault()
                : I
                ? (A = c.current) == null || A.focus()
                : (R = u.current) == null || R.focus();
            }
          };
          return (
            x.addEventListener("keydown", g),
            () => x.removeEventListener("keydown", g)
          );
        }
      }, [a, y]),
      T.jsxs(KG, {
        ref: l,
        role: "region",
        "aria-label": i.replace("{hotkey}", m),
        tabIndex: -1,
        style: { pointerEvents: v ? void 0 : "none" },
        children: [
          v &&
            T.jsx(Hb, {
              ref: c,
              onFocusFromOutsideViewport: () => {
                const x = y({ tabbingDirection: "forwards" });
                hS(x);
              },
            }),
          T.jsx(oM.Slot, {
            scope: t,
            children: T.jsx(Kt.ol, { tabIndex: -1, ...s, ref: p }),
          }),
          v &&
            T.jsx(Hb, {
              ref: u,
              onFocusFromOutsideViewport: () => {
                const x = y({ tabbingDirection: "backwards" });
                hS(x);
              },
            }),
        ],
      })
    );
  });
m3.displayName = p3;
var g3 = "ToastFocusProxy",
  Hb = P.forwardRef((n, e) => {
    const { __scopeToast: t, onFocusFromOutsideViewport: r, ...i } = n,
      s = Rx(g3, t);
    return T.jsx(Ax, {
      "aria-hidden": !0,
      tabIndex: 0,
      ...i,
      ref: e,
      style: { position: "fixed" },
      onFocus: (o) => {
        var c;
        const a = o.relatedTarget;
        !((c = s.viewport) != null && c.contains(a)) && r();
      },
    });
  });
Hb.displayName = g3;
var mm = "Toast",
  c8 = "toast.swipeStart",
  u8 = "toast.swipeMove",
  d8 = "toast.swipeCancel",
  h8 = "toast.swipeEnd",
  v3 = P.forwardRef((n, e) => {
    const { forceMount: t, open: r, defaultOpen: i, onOpenChange: s, ...o } = n,
      [a, l] = i0({ prop: r, defaultProp: i ?? !0, onChange: s, caller: mm });
    return T.jsx(xh, {
      present: t || a,
      children: T.jsx(m8, {
        open: a,
        ...o,
        ref: e,
        onClose: () => l(!1),
        onPause: ks(n.onPause),
        onResume: ks(n.onResume),
        onSwipeStart: Bt(n.onSwipeStart, (c) => {
          c.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: Bt(n.onSwipeMove, (c) => {
          const { x: u, y: f } = c.detail.delta;
          c.currentTarget.setAttribute("data-swipe", "move"),
            c.currentTarget.style.setProperty(
              "--radix-toast-swipe-move-x",
              `${u}px`
            ),
            c.currentTarget.style.setProperty(
              "--radix-toast-swipe-move-y",
              `${f}px`
            );
        }),
        onSwipeCancel: Bt(n.onSwipeCancel, (c) => {
          c.currentTarget.setAttribute("data-swipe", "cancel"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: Bt(n.onSwipeEnd, (c) => {
          const { x: u, y: f } = c.detail.delta;
          c.currentTarget.setAttribute("data-swipe", "end"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
            c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
            c.currentTarget.style.setProperty(
              "--radix-toast-swipe-end-x",
              `${u}px`
            ),
            c.currentTarget.style.setProperty(
              "--radix-toast-swipe-end-y",
              `${f}px`
            ),
            l(!1);
        }),
      }),
    });
  });
v3.displayName = mm;
var [f8, p8] = h3(mm, { onClose() {} }),
  m8 = P.forwardRef((n, e) => {
    const {
        __scopeToast: t,
        type: r = "foreground",
        duration: i,
        open: s,
        onClose: o,
        onEscapeKeyDown: a,
        onPause: l,
        onResume: c,
        onSwipeStart: u,
        onSwipeMove: f,
        onSwipeCancel: p,
        onSwipeEnd: m,
        ...v
      } = n,
      y = Rx(mm, t),
      [x, g] = P.useState(null),
      _ = pn(e, (G) => g(G)),
      S = P.useRef(null),
      b = P.useRef(null),
      C = i || y.duration,
      A = P.useRef(0),
      R = P.useRef(C),
      O = P.useRef(0),
      { onToastAdd: I, onToastRemove: N } = y,
      D = ks(() => {
        var Z;
        (x == null ? void 0 : x.contains(document.activeElement)) &&
          ((Z = y.viewport) == null || Z.focus()),
          o();
      }),
      j = P.useCallback(
        (G) => {
          !G ||
            G === 1 / 0 ||
            (window.clearTimeout(O.current),
            (A.current = new Date().getTime()),
            (O.current = window.setTimeout(D, G)));
        },
        [D]
      );
    P.useEffect(() => {
      const G = y.viewport;
      if (G) {
        const Z = () => {
            j(R.current), c == null || c();
          },
          q = () => {
            const Y = new Date().getTime() - A.current;
            (R.current = R.current - Y),
              window.clearTimeout(O.current),
              l == null || l();
          };
        return (
          G.addEventListener(Vb, q),
          G.addEventListener(jb, Z),
          () => {
            G.removeEventListener(Vb, q), G.removeEventListener(jb, Z);
          }
        );
      }
    }, [y.viewport, C, l, c, j]),
      P.useEffect(() => {
        s && !y.isClosePausedRef.current && j(C);
      }, [s, C, y.isClosePausedRef, j]),
      P.useEffect(() => (I(), () => N()), [I, N]);
    const $ = P.useMemo(() => (x ? E3(x) : null), [x]);
    return y.viewport
      ? T.jsxs(T.Fragment, {
          children: [
            $ &&
              T.jsx(g8, {
                __scopeToast: t,
                role: "status",
                "aria-live": r === "foreground" ? "assertive" : "polite",
                "aria-atomic": !0,
                children: $,
              }),
            T.jsx(f8, {
              scope: t,
              onClose: D,
              children: qc.createPortal(
                T.jsx(oM.ItemSlot, {
                  scope: t,
                  children: T.jsx(qG, {
                    asChild: !0,
                    onEscapeKeyDown: Bt(a, () => {
                      y.isFocusedToastEscapeKeyDownRef.current || D(),
                        (y.isFocusedToastEscapeKeyDownRef.current = !1);
                    }),
                    children: T.jsx(Kt.li, {
                      role: "status",
                      "aria-live": "off",
                      "aria-atomic": !0,
                      tabIndex: 0,
                      "data-state": s ? "open" : "closed",
                      "data-swipe-direction": y.swipeDirection,
                      ...v,
                      ref: _,
                      style: {
                        userSelect: "none",
                        touchAction: "none",
                        ...n.style,
                      },
                      onKeyDown: Bt(n.onKeyDown, (G) => {
                        G.key === "Escape" &&
                          (a == null || a(G.nativeEvent),
                          G.nativeEvent.defaultPrevented ||
                            ((y.isFocusedToastEscapeKeyDownRef.current = !0),
                            D()));
                      }),
                      onPointerDown: Bt(n.onPointerDown, (G) => {
                        G.button === 0 &&
                          (S.current = { x: G.clientX, y: G.clientY });
                      }),
                      onPointerMove: Bt(n.onPointerMove, (G) => {
                        if (!S.current) return;
                        const Z = G.clientX - S.current.x,
                          q = G.clientY - S.current.y,
                          Y = !!b.current,
                          U = ["left", "right"].includes(y.swipeDirection),
                          H = ["left", "up"].includes(y.swipeDirection)
                            ? Math.min
                            : Math.max,
                          X = U ? H(0, Z) : 0,
                          ie = U ? 0 : H(0, q),
                          de = G.pointerType === "touch" ? 10 : 2,
                          Ee = { x: X, y: ie },
                          Ie = { originalEvent: G, delta: Ee };
                        Y
                          ? ((b.current = Ee), Kg(u8, f, Ie, { discrete: !1 }))
                          : oI(Ee, y.swipeDirection, de)
                          ? ((b.current = Ee),
                            Kg(c8, u, Ie, { discrete: !1 }),
                            G.target.setPointerCapture(G.pointerId))
                          : (Math.abs(Z) > de || Math.abs(q) > de) &&
                            (S.current = null);
                      }),
                      onPointerUp: Bt(n.onPointerUp, (G) => {
                        const Z = b.current,
                          q = G.target;
                        if (
                          (q.hasPointerCapture(G.pointerId) &&
                            q.releasePointerCapture(G.pointerId),
                          (b.current = null),
                          (S.current = null),
                          Z)
                        ) {
                          const Y = G.currentTarget,
                            U = { originalEvent: G, delta: Z };
                          oI(Z, y.swipeDirection, y.swipeThreshold)
                            ? Kg(h8, m, U, { discrete: !0 })
                            : Kg(d8, p, U, { discrete: !0 }),
                            Y.addEventListener(
                              "click",
                              (H) => H.preventDefault(),
                              { once: !0 }
                            );
                        }
                      }),
                    }),
                  }),
                }),
                y.viewport
              ),
            }),
          ],
        })
      : null;
  }),
  g8 = (n) => {
    const { __scopeToast: e, children: t, ...r } = n,
      i = Rx(mm, e),
      [s, o] = P.useState(!1),
      [a, l] = P.useState(!1);
    return (
      x8(() => o(!0)),
      P.useEffect(() => {
        const c = window.setTimeout(() => l(!0), 1e3);
        return () => window.clearTimeout(c);
      }, []),
      a
        ? null
        : T.jsx(Cx, {
            asChild: !0,
            children: T.jsx(Ax, {
              ...r,
              children:
                s && T.jsxs(T.Fragment, { children: [i.label, " ", t] }),
            }),
          })
    );
  },
  v8 = "ToastTitle",
  y3 = P.forwardRef((n, e) => {
    const { __scopeToast: t, ...r } = n;
    return T.jsx(Kt.div, { ...r, ref: e });
  });
y3.displayName = v8;
var y8 = "ToastDescription",
  x3 = P.forwardRef((n, e) => {
    const { __scopeToast: t, ...r } = n;
    return T.jsx(Kt.div, { ...r, ref: e });
  });
x3.displayName = y8;
var _3 = "ToastAction",
  w3 = P.forwardRef((n, e) => {
    const { altText: t, ...r } = n;
    return t.trim()
      ? T.jsx(b3, {
          altText: t,
          asChild: !0,
          children: T.jsx(aM, { ...r, ref: e }),
        })
      : (console.error(
          `Invalid prop \`altText\` supplied to \`${_3}\`. Expected non-empty \`string\`.`
        ),
        null);
  });
w3.displayName = _3;
var S3 = "ToastClose",
  aM = P.forwardRef((n, e) => {
    const { __scopeToast: t, ...r } = n,
      i = p8(S3, t);
    return T.jsx(b3, {
      asChild: !0,
      children: T.jsx(Kt.button, {
        type: "button",
        ...r,
        ref: e,
        onClick: Bt(n.onClick, i.onClose),
      }),
    });
  });
aM.displayName = S3;
var b3 = P.forwardRef((n, e) => {
  const { __scopeToast: t, altText: r, ...i } = n;
  return T.jsx(Kt.div, {
    "data-radix-toast-announce-exclude": "",
    "data-radix-toast-announce-alt": r || void 0,
    ...i,
    ref: e,
  });
});
function E3(n) {
  const e = [];
  return (
    Array.from(n.childNodes).forEach((r) => {
      if (
        (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent),
        _8(r))
      ) {
        const i = r.ariaHidden || r.hidden || r.style.display === "none",
          s = r.dataset.radixToastAnnounceExclude === "";
        if (!i)
          if (s) {
            const o = r.dataset.radixToastAnnounceAlt;
            o && e.push(o);
          } else e.push(...E3(r));
      }
    }),
    e
  );
}
function Kg(n, e, t, { discrete: r }) {
  const i = t.originalEvent.currentTarget,
    s = new CustomEvent(n, { bubbles: !0, cancelable: !0, detail: t });
  e && i.addEventListener(n, e, { once: !0 }),
    r ? a3(i, s) : i.dispatchEvent(s);
}
var oI = (n, e, t = 0) => {
  const r = Math.abs(n.x),
    i = Math.abs(n.y),
    s = r > i;
  return e === "left" || e === "right" ? s && r > t : !s && i > t;
};
function x8(n = () => {}) {
  const e = ks(n);
  yr(() => {
    let t = 0,
      r = 0;
    return (
      (t = window.requestAnimationFrame(
        () => (r = window.requestAnimationFrame(e))
      )),
      () => {
        window.cancelAnimationFrame(t), window.cancelAnimationFrame(r);
      }
    );
  }, [e]);
}
function _8(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function w8(n) {
  const e = [],
    t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function hS(n) {
  const e = document.activeElement;
  return n.some((t) =>
    t === e ? !0 : (t.focus(), document.activeElement !== e)
  );
}
var S8 = f3,
  T3 = m3,
  M3 = v3,
  C3 = y3,
  A3 = x3,
  R3 = w3,
  P3 = aM;
function I3(n) {
  var e,
    t,
    r = "";
  if (typeof n == "string" || typeof n == "number") r += n;
  else if (typeof n == "object")
    if (Array.isArray(n)) {
      var i = n.length;
      for (e = 0; e < i; e++)
        n[e] && (t = I3(n[e])) && (r && (r += " "), (r += t));
    } else for (t in n) n[t] && (r && (r += " "), (r += t));
  return r;
}
function N3() {
  for (var n, e, t = 0, r = "", i = arguments.length; t < i; t++)
    (n = arguments[t]) && (e = I3(n)) && (r && (r += " "), (r += e));
  return r;
}
const aI = (n) => (typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n),
  lI = N3,
  lM = (n, e) => (t) => {
    var r;
    if ((e == null ? void 0 : e.variants) == null)
      return lI(
        n,
        t == null ? void 0 : t.class,
        t == null ? void 0 : t.className
      );
    const { variants: i, defaultVariants: s } = e,
      o = Object.keys(i).map((c) => {
        const u = t == null ? void 0 : t[c],
          f = s == null ? void 0 : s[c];
        if (u === null) return null;
        const p = aI(u) || aI(f);
        return i[c][p];
      }),
      a =
        t &&
        Object.entries(t).reduce((c, u) => {
          let [f, p] = u;
          return p === void 0 || (c[f] = p), c;
        }, {}),
      l =
        e == null || (r = e.compoundVariants) === null || r === void 0
          ? void 0
          : r.reduce((c, u) => {
              let { class: f, className: p, ...m } = u;
              return Object.entries(m).every((v) => {
                let [y, x] = v;
                return Array.isArray(x)
                  ? x.includes({ ...s, ...a }[y])
                  : { ...s, ...a }[y] === x;
              })
                ? [...c, f, p]
                : c;
            }, []);
    return lI(
      n,
      o,
      l,
      t == null ? void 0 : t.class,
      t == null ? void 0 : t.className
    );
  };
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const b8 = (n) => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
  L3 = (...n) =>
    n
      .filter((e, t, r) => !!e && e.trim() !== "" && r.indexOf(e) === t)
      .join(" ")
      .trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ var E8 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const T8 = P.forwardRef(
  (
    {
      color: n = "currentColor",
      size: e = 24,
      strokeWidth: t = 2,
      absoluteStrokeWidth: r,
      className: i = "",
      children: s,
      iconNode: o,
      ...a
    },
    l
  ) =>
    P.createElement(
      "svg",
      {
        ref: l,
        ...E8,
        width: e,
        height: e,
        stroke: n,
        strokeWidth: r ? (Number(t) * 24) / Number(e) : t,
        className: L3("lucide", i),
        ...a,
      },
      [
        ...o.map(([c, u]) => P.createElement(c, u)),
        ...(Array.isArray(s) ? s : [s]),
      ]
    )
);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Ln = (n, e) => {
  const t = P.forwardRef(({ className: r, ...i }, s) =>
    P.createElement(T8, {
      ref: s,
      iconNode: e,
      className: L3(`lucide-${b8(n)}`, r),
      ...i,
    })
  );
  return (t.displayName = `${n}`), t;
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const M8 = Ln("Activity", [
  [
    "path",
    {
      d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
      key: "169zse",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const C8 = Ln("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  [
    "rect",
    { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" },
  ],
  ["path", { d: "M3 10h18", key: "8toen8" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const A8 = Ln("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const O3 = Ln("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const R8 = Ln("ChevronUp", [
  ["path", { d: "m18 15-6-6-6 6", key: "153udz" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const D3 = Ln("Clock", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["polyline", { points: "12 6 12 12 16 14", key: "68esgv" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const P8 = Ln("Code", [
  ["polyline", { points: "16 18 22 12 16 6", key: "z7tu5w" }],
  ["polyline", { points: "8 6 2 12 8 18", key: "1eg1df" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const I8 = Ln("Database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const N8 = Ln("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const k3 = Ln("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  [
    "path",
    {
      d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
      key: "a6xqqp",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const L8 = Ln("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0",
    },
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const O8 = Ln("Globe", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  [
    "path",
    { d: "M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20", key: "13o1zl" },
  ],
  ["path", { d: "M2 12h20", key: "9i4pu4" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const cM = Ln("Grid3x3", [
  [
    "rect",
    { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" },
  ],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }],
  ["path", { d: "M9 3v18", key: "fh3hqa" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const D8 = Ln("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0",
      key: "1r0f0z",
    },
  ],
  ["circle", { cx: "12", cy: "10", r: "3", key: "ilqhr7" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const uM = Ln("MessageCircle", [
  ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const Sy = Ln("MessageSquare", [
  [
    "path",
    {
      d: "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z",
      key: "1lielz",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const U3 = Ln("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const k8 = Ln("Send", [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3",
    },
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const U8 = Ln("Shield", [
  [
    "path",
    {
      d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
      key: "oel41y",
    },
  ],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const F3 = Ln("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const B3 = Ln("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */ const F8 = Ln("Zap", [
    [
      "path",
      {
        d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
        key: "1xq2db",
      },
    ],
  ]),
  dM = "-",
  B8 = (n) => {
    const e = V8(n),
      { conflictingClassGroups: t, conflictingClassGroupModifiers: r } = n;
    return {
      getClassGroupId: (o) => {
        const a = o.split(dM);
        return a[0] === "" && a.length !== 1 && a.shift(), z3(a, e) || z8(o);
      },
      getConflictingClassGroupIds: (o, a) => {
        const l = t[o] || [];
        return a && r[o] ? [...l, ...r[o]] : l;
      },
    };
  },
  z3 = (n, e) => {
    var o;
    if (n.length === 0) return e.classGroupId;
    const t = n[0],
      r = e.nextPart.get(t),
      i = r ? z3(n.slice(1), r) : void 0;
    if (i) return i;
    if (e.validators.length === 0) return;
    const s = n.join(dM);
    return (o = e.validators.find(({ validator: a }) => a(s))) == null
      ? void 0
      : o.classGroupId;
  },
  cI = /^\[(.+)\]$/,
  z8 = (n) => {
    if (cI.test(n)) {
      const e = cI.exec(n)[1],
        t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
      if (t) return "arbitrary.." + t;
    }
  },
  V8 = (n) => {
    const { theme: e, prefix: t } = n,
      r = { nextPart: new Map(), validators: [] };
    return (
      H8(Object.entries(n.classGroups), t).forEach(([s, o]) => {
        Wb(o, r, s, e);
      }),
      r
    );
  },
  Wb = (n, e, t, r) => {
    n.forEach((i) => {
      if (typeof i == "string") {
        const s = i === "" ? e : uI(e, i);
        s.classGroupId = t;
        return;
      }
      if (typeof i == "function") {
        if (j8(i)) {
          Wb(i(r), e, t, r);
          return;
        }
        e.validators.push({ validator: i, classGroupId: t });
        return;
      }
      Object.entries(i).forEach(([s, o]) => {
        Wb(o, uI(e, s), t, r);
      });
    });
  },
  uI = (n, e) => {
    let t = n;
    return (
      e.split(dM).forEach((r) => {
        t.nextPart.has(r) ||
          t.nextPart.set(r, { nextPart: new Map(), validators: [] }),
          (t = t.nextPart.get(r));
      }),
      t
    );
  },
  j8 = (n) => n.isThemeGetter,
  H8 = (n, e) =>
    e
      ? n.map(([t, r]) => {
          const i = r.map((s) =>
            typeof s == "string"
              ? e + s
              : typeof s == "object"
              ? Object.fromEntries(
                  Object.entries(s).map(([o, a]) => [e + o, a])
                )
              : s
          );
          return [t, i];
        })
      : n,
  W8 = (n) => {
    if (n < 1) return { get: () => {}, set: () => {} };
    let e = 0,
      t = new Map(),
      r = new Map();
    const i = (s, o) => {
      t.set(s, o), e++, e > n && ((e = 0), (r = t), (t = new Map()));
    };
    return {
      get(s) {
        let o = t.get(s);
        if (o !== void 0) return o;
        if ((o = r.get(s)) !== void 0) return i(s, o), o;
      },
      set(s, o) {
        t.has(s) ? t.set(s, o) : i(s, o);
      },
    };
  },
  V3 = "!",
  G8 = (n) => {
    const { separator: e, experimentalParseClassName: t } = n,
      r = e.length === 1,
      i = e[0],
      s = e.length,
      o = (a) => {
        const l = [];
        let c = 0,
          u = 0,
          f;
        for (let x = 0; x < a.length; x++) {
          let g = a[x];
          if (c === 0) {
            if (g === i && (r || a.slice(x, x + s) === e)) {
              l.push(a.slice(u, x)), (u = x + s);
              continue;
            }
            if (g === "/") {
              f = x;
              continue;
            }
          }
          g === "[" ? c++ : g === "]" && c--;
        }
        const p = l.length === 0 ? a : a.substring(u),
          m = p.startsWith(V3),
          v = m ? p.substring(1) : p,
          y = f && f > u ? f - u : void 0;
        return {
          modifiers: l,
          hasImportantModifier: m,
          baseClassName: v,
          maybePostfixModifierPosition: y,
        };
      };
    return t ? (a) => t({ className: a, parseClassName: o }) : o;
  },
  $8 = (n) => {
    if (n.length <= 1) return n;
    const e = [];
    let t = [];
    return (
      n.forEach((r) => {
        r[0] === "[" ? (e.push(...t.sort(), r), (t = [])) : t.push(r);
      }),
      e.push(...t.sort()),
      e
    );
  },
  X8 = (n) => ({ cache: W8(n.cacheSize), parseClassName: G8(n), ...B8(n) }),
  q8 = /\s+/,
  K8 = (n, e) => {
    const {
        parseClassName: t,
        getClassGroupId: r,
        getConflictingClassGroupIds: i,
      } = e,
      s = [],
      o = n.trim().split(q8);
    let a = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l],
        {
          modifiers: u,
          hasImportantModifier: f,
          baseClassName: p,
          maybePostfixModifierPosition: m,
        } = t(c);
      let v = !!m,
        y = r(v ? p.substring(0, m) : p);
      if (!y) {
        if (!v) {
          a = c + (a.length > 0 ? " " + a : a);
          continue;
        }
        if (((y = r(p)), !y)) {
          a = c + (a.length > 0 ? " " + a : a);
          continue;
        }
        v = !1;
      }
      const x = $8(u).join(":"),
        g = f ? x + V3 : x,
        _ = g + y;
      if (s.includes(_)) continue;
      s.push(_);
      const S = i(y, v);
      for (let b = 0; b < S.length; ++b) {
        const C = S[b];
        s.push(g + C);
      }
      a = c + (a.length > 0 ? " " + a : a);
    }
    return a;
  };
function Y8() {
  let n = 0,
    e,
    t,
    r = "";
  for (; n < arguments.length; )
    (e = arguments[n++]) && (t = j3(e)) && (r && (r += " "), (r += t));
  return r;
}
const j3 = (n) => {
  if (typeof n == "string") return n;
  let e,
    t = "";
  for (let r = 0; r < n.length; r++)
    n[r] && (e = j3(n[r])) && (t && (t += " "), (t += e));
  return t;
};
function J8(n, ...e) {
  let t,
    r,
    i,
    s = o;
  function o(l) {
    const c = e.reduce((u, f) => f(u), n());
    return (t = X8(c)), (r = t.cache.get), (i = t.cache.set), (s = a), a(l);
  }
  function a(l) {
    const c = r(l);
    if (c) return c;
    const u = K8(l, t);
    return i(l, u), u;
  }
  return function () {
    return s(Y8.apply(null, arguments));
  };
}
const un = (n) => {
    const e = (t) => t[n] || [];
    return (e.isThemeGetter = !0), e;
  },
  H3 = /^\[(?:([a-z-]+):)?(.+)\]$/i,
  Z8 = /^\d+\/\d+$/,
  Q8 = new Set(["px", "full", "screen"]),
  e6 = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
  t6 =
    /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
  n6 = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
  r6 = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
  i6 =
    /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
  Po = (n) => Rd(n) || Q8.has(n) || Z8.test(n),
  xa = (n) => _h(n, "length", h6),
  Rd = (n) => !!n && !Number.isNaN(Number(n)),
  fS = (n) => _h(n, "number", Rd),
  df = (n) => !!n && Number.isInteger(Number(n)),
  s6 = (n) => n.endsWith("%") && Rd(n.slice(0, -1)),
  Ut = (n) => H3.test(n),
  _a = (n) => e6.test(n),
  o6 = new Set(["length", "size", "percentage"]),
  a6 = (n) => _h(n, o6, W3),
  l6 = (n) => _h(n, "position", W3),
  c6 = new Set(["image", "url"]),
  u6 = (n) => _h(n, c6, p6),
  d6 = (n) => _h(n, "", f6),
  hf = () => !0,
  _h = (n, e, t) => {
    const r = H3.exec(n);
    return r
      ? r[1]
        ? typeof e == "string"
          ? r[1] === e
          : e.has(r[1])
        : t(r[2])
      : !1;
  },
  h6 = (n) => t6.test(n) && !n6.test(n),
  W3 = () => !1,
  f6 = (n) => r6.test(n),
  p6 = (n) => i6.test(n),
  m6 = () => {
    const n = un("colors"),
      e = un("spacing"),
      t = un("blur"),
      r = un("brightness"),
      i = un("borderColor"),
      s = un("borderRadius"),
      o = un("borderSpacing"),
      a = un("borderWidth"),
      l = un("contrast"),
      c = un("grayscale"),
      u = un("hueRotate"),
      f = un("invert"),
      p = un("gap"),
      m = un("gradientColorStops"),
      v = un("gradientColorStopPositions"),
      y = un("inset"),
      x = un("margin"),
      g = un("opacity"),
      _ = un("padding"),
      S = un("saturate"),
      b = un("scale"),
      C = un("sepia"),
      A = un("skew"),
      R = un("space"),
      O = un("translate"),
      I = () => ["auto", "contain", "none"],
      N = () => ["auto", "hidden", "clip", "visible", "scroll"],
      D = () => ["auto", Ut, e],
      j = () => [Ut, e],
      $ = () => ["", Po, xa],
      G = () => ["auto", Rd, Ut],
      Z = () => [
        "bottom",
        "center",
        "left",
        "left-bottom",
        "left-top",
        "right",
        "right-bottom",
        "right-top",
        "top",
      ],
      q = () => ["solid", "dashed", "dotted", "double", "none"],
      Y = () => [
        "normal",
        "multiply",
        "screen",
        "overlay",
        "darken",
        "lighten",
        "color-dodge",
        "color-burn",
        "hard-light",
        "soft-light",
        "difference",
        "exclusion",
        "hue",
        "saturation",
        "color",
        "luminosity",
      ],
      U = () => [
        "start",
        "end",
        "center",
        "between",
        "around",
        "evenly",
        "stretch",
      ],
      H = () => ["", "0", Ut],
      X = () => [
        "auto",
        "avoid",
        "all",
        "avoid-page",
        "page",
        "left",
        "right",
        "column",
      ],
      ie = () => [Rd, Ut];
    return {
      cacheSize: 500,
      separator: ":",
      theme: {
        colors: [hf],
        spacing: [Po, xa],
        blur: ["none", "", _a, Ut],
        brightness: ie(),
        borderColor: [n],
        borderRadius: ["none", "", "full", _a, Ut],
        borderSpacing: j(),
        borderWidth: $(),
        contrast: ie(),
        grayscale: H(),
        hueRotate: ie(),
        invert: H(),
        gap: j(),
        gradientColorStops: [n],
        gradientColorStopPositions: [s6, xa],
        inset: D(),
        margin: D(),
        opacity: ie(),
        padding: j(),
        saturate: ie(),
        scale: ie(),
        sepia: H(),
        skew: ie(),
        space: j(),
        translate: j(),
      },
      classGroups: {
        aspect: [{ aspect: ["auto", "square", "video", Ut] }],
        container: ["container"],
        columns: [{ columns: [_a] }],
        "break-after": [{ "break-after": X() }],
        "break-before": [{ "break-before": X() }],
        "break-inside": [
          { "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] },
        ],
        "box-decoration": [{ "box-decoration": ["slice", "clone"] }],
        box: [{ box: ["border", "content"] }],
        display: [
          "block",
          "inline-block",
          "inline",
          "flex",
          "inline-flex",
          "table",
          "inline-table",
          "table-caption",
          "table-cell",
          "table-column",
          "table-column-group",
          "table-footer-group",
          "table-header-group",
          "table-row-group",
          "table-row",
          "flow-root",
          "grid",
          "inline-grid",
          "contents",
          "list-item",
          "hidden",
        ],
        float: [{ float: ["right", "left", "none", "start", "end"] }],
        clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }],
        isolation: ["isolate", "isolation-auto"],
        "object-fit": [
          { object: ["contain", "cover", "fill", "none", "scale-down"] },
        ],
        "object-position": [{ object: [...Z(), Ut] }],
        overflow: [{ overflow: N() }],
        "overflow-x": [{ "overflow-x": N() }],
        "overflow-y": [{ "overflow-y": N() }],
        overscroll: [{ overscroll: I() }],
        "overscroll-x": [{ "overscroll-x": I() }],
        "overscroll-y": [{ "overscroll-y": I() }],
        position: ["static", "fixed", "absolute", "relative", "sticky"],
        inset: [{ inset: [y] }],
        "inset-x": [{ "inset-x": [y] }],
        "inset-y": [{ "inset-y": [y] }],
        start: [{ start: [y] }],
        end: [{ end: [y] }],
        top: [{ top: [y] }],
        right: [{ right: [y] }],
        bottom: [{ bottom: [y] }],
        left: [{ left: [y] }],
        visibility: ["visible", "invisible", "collapse"],
        z: [{ z: ["auto", df, Ut] }],
        basis: [{ basis: D() }],
        "flex-direction": [
          { flex: ["row", "row-reverse", "col", "col-reverse"] },
        ],
        "flex-wrap": [{ flex: ["wrap", "wrap-reverse", "nowrap"] }],
        flex: [{ flex: ["1", "auto", "initial", "none", Ut] }],
        grow: [{ grow: H() }],
        shrink: [{ shrink: H() }],
        order: [{ order: ["first", "last", "none", df, Ut] }],
        "grid-cols": [{ "grid-cols": [hf] }],
        "col-start-end": [{ col: ["auto", { span: ["full", df, Ut] }, Ut] }],
        "col-start": [{ "col-start": G() }],
        "col-end": [{ "col-end": G() }],
        "grid-rows": [{ "grid-rows": [hf] }],
        "row-start-end": [{ row: ["auto", { span: [df, Ut] }, Ut] }],
        "row-start": [{ "row-start": G() }],
        "row-end": [{ "row-end": G() }],
        "grid-flow": [
          { "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] },
        ],
        "auto-cols": [{ "auto-cols": ["auto", "min", "max", "fr", Ut] }],
        "auto-rows": [{ "auto-rows": ["auto", "min", "max", "fr", Ut] }],
        gap: [{ gap: [p] }],
        "gap-x": [{ "gap-x": [p] }],
        "gap-y": [{ "gap-y": [p] }],
        "justify-content": [{ justify: ["normal", ...U()] }],
        "justify-items": [
          { "justify-items": ["start", "end", "center", "stretch"] },
        ],
        "justify-self": [
          { "justify-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        "align-content": [{ content: ["normal", ...U(), "baseline"] }],
        "align-items": [
          { items: ["start", "end", "center", "baseline", "stretch"] },
        ],
        "align-self": [
          { self: ["auto", "start", "end", "center", "stretch", "baseline"] },
        ],
        "place-content": [{ "place-content": [...U(), "baseline"] }],
        "place-items": [
          { "place-items": ["start", "end", "center", "baseline", "stretch"] },
        ],
        "place-self": [
          { "place-self": ["auto", "start", "end", "center", "stretch"] },
        ],
        p: [{ p: [_] }],
        px: [{ px: [_] }],
        py: [{ py: [_] }],
        ps: [{ ps: [_] }],
        pe: [{ pe: [_] }],
        pt: [{ pt: [_] }],
        pr: [{ pr: [_] }],
        pb: [{ pb: [_] }],
        pl: [{ pl: [_] }],
        m: [{ m: [x] }],
        mx: [{ mx: [x] }],
        my: [{ my: [x] }],
        ms: [{ ms: [x] }],
        me: [{ me: [x] }],
        mt: [{ mt: [x] }],
        mr: [{ mr: [x] }],
        mb: [{ mb: [x] }],
        ml: [{ ml: [x] }],
        "space-x": [{ "space-x": [R] }],
        "space-x-reverse": ["space-x-reverse"],
        "space-y": [{ "space-y": [R] }],
        "space-y-reverse": ["space-y-reverse"],
        w: [{ w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Ut, e] }],
        "min-w": [{ "min-w": [Ut, e, "min", "max", "fit"] }],
        "max-w": [
          {
            "max-w": [
              Ut,
              e,
              "none",
              "full",
              "min",
              "max",
              "fit",
              "prose",
              { screen: [_a] },
              _a,
            ],
          },
        ],
        h: [{ h: [Ut, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"] }],
        "min-h": [
          { "min-h": [Ut, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        "max-h": [
          { "max-h": [Ut, e, "min", "max", "fit", "svh", "lvh", "dvh"] },
        ],
        size: [{ size: [Ut, e, "auto", "min", "max", "fit"] }],
        "font-size": [{ text: ["base", _a, xa] }],
        "font-smoothing": ["antialiased", "subpixel-antialiased"],
        "font-style": ["italic", "not-italic"],
        "font-weight": [
          {
            font: [
              "thin",
              "extralight",
              "light",
              "normal",
              "medium",
              "semibold",
              "bold",
              "extrabold",
              "black",
              fS,
            ],
          },
        ],
        "font-family": [{ font: [hf] }],
        "fvn-normal": ["normal-nums"],
        "fvn-ordinal": ["ordinal"],
        "fvn-slashed-zero": ["slashed-zero"],
        "fvn-figure": ["lining-nums", "oldstyle-nums"],
        "fvn-spacing": ["proportional-nums", "tabular-nums"],
        "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
        tracking: [
          {
            tracking: [
              "tighter",
              "tight",
              "normal",
              "wide",
              "wider",
              "widest",
              Ut,
            ],
          },
        ],
        "line-clamp": [{ "line-clamp": ["none", Rd, fS] }],
        leading: [
          {
            leading: [
              "none",
              "tight",
              "snug",
              "normal",
              "relaxed",
              "loose",
              Po,
              Ut,
            ],
          },
        ],
        "list-image": [{ "list-image": ["none", Ut] }],
        "list-style-type": [{ list: ["none", "disc", "decimal", Ut] }],
        "list-style-position": [{ list: ["inside", "outside"] }],
        "placeholder-color": [{ placeholder: [n] }],
        "placeholder-opacity": [{ "placeholder-opacity": [g] }],
        "text-alignment": [
          { text: ["left", "center", "right", "justify", "start", "end"] },
        ],
        "text-color": [{ text: [n] }],
        "text-opacity": [{ "text-opacity": [g] }],
        "text-decoration": [
          "underline",
          "overline",
          "line-through",
          "no-underline",
        ],
        "text-decoration-style": [{ decoration: [...q(), "wavy"] }],
        "text-decoration-thickness": [
          { decoration: ["auto", "from-font", Po, xa] },
        ],
        "underline-offset": [{ "underline-offset": ["auto", Po, Ut] }],
        "text-decoration-color": [{ decoration: [n] }],
        "text-transform": [
          "uppercase",
          "lowercase",
          "capitalize",
          "normal-case",
        ],
        "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
        "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }],
        indent: [{ indent: j() }],
        "vertical-align": [
          {
            align: [
              "baseline",
              "top",
              "middle",
              "bottom",
              "text-top",
              "text-bottom",
              "sub",
              "super",
              Ut,
            ],
          },
        ],
        whitespace: [
          {
            whitespace: [
              "normal",
              "nowrap",
              "pre",
              "pre-line",
              "pre-wrap",
              "break-spaces",
            ],
          },
        ],
        break: [{ break: ["normal", "words", "all", "keep"] }],
        hyphens: [{ hyphens: ["none", "manual", "auto"] }],
        content: [{ content: ["none", Ut] }],
        "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }],
        "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }],
        "bg-opacity": [{ "bg-opacity": [g] }],
        "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }],
        "bg-position": [{ bg: [...Z(), l6] }],
        "bg-repeat": [
          { bg: ["no-repeat", { repeat: ["", "x", "y", "round", "space"] }] },
        ],
        "bg-size": [{ bg: ["auto", "cover", "contain", a6] }],
        "bg-image": [
          {
            bg: [
              "none",
              { "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"] },
              u6,
            ],
          },
        ],
        "bg-color": [{ bg: [n] }],
        "gradient-from-pos": [{ from: [v] }],
        "gradient-via-pos": [{ via: [v] }],
        "gradient-to-pos": [{ to: [v] }],
        "gradient-from": [{ from: [m] }],
        "gradient-via": [{ via: [m] }],
        "gradient-to": [{ to: [m] }],
        rounded: [{ rounded: [s] }],
        "rounded-s": [{ "rounded-s": [s] }],
        "rounded-e": [{ "rounded-e": [s] }],
        "rounded-t": [{ "rounded-t": [s] }],
        "rounded-r": [{ "rounded-r": [s] }],
        "rounded-b": [{ "rounded-b": [s] }],
        "rounded-l": [{ "rounded-l": [s] }],
        "rounded-ss": [{ "rounded-ss": [s] }],
        "rounded-se": [{ "rounded-se": [s] }],
        "rounded-ee": [{ "rounded-ee": [s] }],
        "rounded-es": [{ "rounded-es": [s] }],
        "rounded-tl": [{ "rounded-tl": [s] }],
        "rounded-tr": [{ "rounded-tr": [s] }],
        "rounded-br": [{ "rounded-br": [s] }],
        "rounded-bl": [{ "rounded-bl": [s] }],
        "border-w": [{ border: [a] }],
        "border-w-x": [{ "border-x": [a] }],
        "border-w-y": [{ "border-y": [a] }],
        "border-w-s": [{ "border-s": [a] }],
        "border-w-e": [{ "border-e": [a] }],
        "border-w-t": [{ "border-t": [a] }],
        "border-w-r": [{ "border-r": [a] }],
        "border-w-b": [{ "border-b": [a] }],
        "border-w-l": [{ "border-l": [a] }],
        "border-opacity": [{ "border-opacity": [g] }],
        "border-style": [{ border: [...q(), "hidden"] }],
        "divide-x": [{ "divide-x": [a] }],
        "divide-x-reverse": ["divide-x-reverse"],
        "divide-y": [{ "divide-y": [a] }],
        "divide-y-reverse": ["divide-y-reverse"],
        "divide-opacity": [{ "divide-opacity": [g] }],
        "divide-style": [{ divide: q() }],
        "border-color": [{ border: [i] }],
        "border-color-x": [{ "border-x": [i] }],
        "border-color-y": [{ "border-y": [i] }],
        "border-color-s": [{ "border-s": [i] }],
        "border-color-e": [{ "border-e": [i] }],
        "border-color-t": [{ "border-t": [i] }],
        "border-color-r": [{ "border-r": [i] }],
        "border-color-b": [{ "border-b": [i] }],
        "border-color-l": [{ "border-l": [i] }],
        "divide-color": [{ divide: [i] }],
        "outline-style": [{ outline: ["", ...q()] }],
        "outline-offset": [{ "outline-offset": [Po, Ut] }],
        "outline-w": [{ outline: [Po, xa] }],
        "outline-color": [{ outline: [n] }],
        "ring-w": [{ ring: $() }],
        "ring-w-inset": ["ring-inset"],
        "ring-color": [{ ring: [n] }],
        "ring-opacity": [{ "ring-opacity": [g] }],
        "ring-offset-w": [{ "ring-offset": [Po, xa] }],
        "ring-offset-color": [{ "ring-offset": [n] }],
        shadow: [{ shadow: ["", "inner", "none", _a, d6] }],
        "shadow-color": [{ shadow: [hf] }],
        opacity: [{ opacity: [g] }],
        "mix-blend": [{ "mix-blend": [...Y(), "plus-lighter", "plus-darker"] }],
        "bg-blend": [{ "bg-blend": Y() }],
        filter: [{ filter: ["", "none"] }],
        blur: [{ blur: [t] }],
        brightness: [{ brightness: [r] }],
        contrast: [{ contrast: [l] }],
        "drop-shadow": [{ "drop-shadow": ["", "none", _a, Ut] }],
        grayscale: [{ grayscale: [c] }],
        "hue-rotate": [{ "hue-rotate": [u] }],
        invert: [{ invert: [f] }],
        saturate: [{ saturate: [S] }],
        sepia: [{ sepia: [C] }],
        "backdrop-filter": [{ "backdrop-filter": ["", "none"] }],
        "backdrop-blur": [{ "backdrop-blur": [t] }],
        "backdrop-brightness": [{ "backdrop-brightness": [r] }],
        "backdrop-contrast": [{ "backdrop-contrast": [l] }],
        "backdrop-grayscale": [{ "backdrop-grayscale": [c] }],
        "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [u] }],
        "backdrop-invert": [{ "backdrop-invert": [f] }],
        "backdrop-opacity": [{ "backdrop-opacity": [g] }],
        "backdrop-saturate": [{ "backdrop-saturate": [S] }],
        "backdrop-sepia": [{ "backdrop-sepia": [C] }],
        "border-collapse": [{ border: ["collapse", "separate"] }],
        "border-spacing": [{ "border-spacing": [o] }],
        "border-spacing-x": [{ "border-spacing-x": [o] }],
        "border-spacing-y": [{ "border-spacing-y": [o] }],
        "table-layout": [{ table: ["auto", "fixed"] }],
        caption: [{ caption: ["top", "bottom"] }],
        transition: [
          {
            transition: [
              "none",
              "all",
              "",
              "colors",
              "opacity",
              "shadow",
              "transform",
              Ut,
            ],
          },
        ],
        duration: [{ duration: ie() }],
        ease: [{ ease: ["linear", "in", "out", "in-out", Ut] }],
        delay: [{ delay: ie() }],
        animate: [{ animate: ["none", "spin", "ping", "pulse", "bounce", Ut] }],
        transform: [{ transform: ["", "gpu", "none"] }],
        scale: [{ scale: [b] }],
        "scale-x": [{ "scale-x": [b] }],
        "scale-y": [{ "scale-y": [b] }],
        rotate: [{ rotate: [df, Ut] }],
        "translate-x": [{ "translate-x": [O] }],
        "translate-y": [{ "translate-y": [O] }],
        "skew-x": [{ "skew-x": [A] }],
        "skew-y": [{ "skew-y": [A] }],
        "transform-origin": [
          {
            origin: [
              "center",
              "top",
              "top-right",
              "right",
              "bottom-right",
              "bottom",
              "bottom-left",
              "left",
              "top-left",
              Ut,
            ],
          },
        ],
        accent: [{ accent: ["auto", n] }],
        appearance: [{ appearance: ["none", "auto"] }],
        cursor: [
          {
            cursor: [
              "auto",
              "default",
              "pointer",
              "wait",
              "text",
              "move",
              "help",
              "not-allowed",
              "none",
              "context-menu",
              "progress",
              "cell",
              "crosshair",
              "vertical-text",
              "alias",
              "copy",
              "no-drop",
              "grab",
              "grabbing",
              "all-scroll",
              "col-resize",
              "row-resize",
              "n-resize",
              "e-resize",
              "s-resize",
              "w-resize",
              "ne-resize",
              "nw-resize",
              "se-resize",
              "sw-resize",
              "ew-resize",
              "ns-resize",
              "nesw-resize",
              "nwse-resize",
              "zoom-in",
              "zoom-out",
              Ut,
            ],
          },
        ],
        "caret-color": [{ caret: [n] }],
        "pointer-events": [{ "pointer-events": ["none", "auto"] }],
        resize: [{ resize: ["none", "y", "x", ""] }],
        "scroll-behavior": [{ scroll: ["auto", "smooth"] }],
        "scroll-m": [{ "scroll-m": j() }],
        "scroll-mx": [{ "scroll-mx": j() }],
        "scroll-my": [{ "scroll-my": j() }],
        "scroll-ms": [{ "scroll-ms": j() }],
        "scroll-me": [{ "scroll-me": j() }],
        "scroll-mt": [{ "scroll-mt": j() }],
        "scroll-mr": [{ "scroll-mr": j() }],
        "scroll-mb": [{ "scroll-mb": j() }],
        "scroll-ml": [{ "scroll-ml": j() }],
        "scroll-p": [{ "scroll-p": j() }],
        "scroll-px": [{ "scroll-px": j() }],
        "scroll-py": [{ "scroll-py": j() }],
        "scroll-ps": [{ "scroll-ps": j() }],
        "scroll-pe": [{ "scroll-pe": j() }],
        "scroll-pt": [{ "scroll-pt": j() }],
        "scroll-pr": [{ "scroll-pr": j() }],
        "scroll-pb": [{ "scroll-pb": j() }],
        "scroll-pl": [{ "scroll-pl": j() }],
        "snap-align": [{ snap: ["start", "end", "center", "align-none"] }],
        "snap-stop": [{ snap: ["normal", "always"] }],
        "snap-type": [{ snap: ["none", "x", "y", "both"] }],
        "snap-strictness": [{ snap: ["mandatory", "proximity"] }],
        touch: [{ touch: ["auto", "none", "manipulation"] }],
        "touch-x": [{ "touch-pan": ["x", "left", "right"] }],
        "touch-y": [{ "touch-pan": ["y", "up", "down"] }],
        "touch-pz": ["touch-pinch-zoom"],
        select: [{ select: ["none", "text", "all", "auto"] }],
        "will-change": [
          { "will-change": ["auto", "scroll", "contents", "transform", Ut] },
        ],
        fill: [{ fill: [n, "none"] }],
        "stroke-w": [{ stroke: [Po, xa, fS] }],
        stroke: [{ stroke: [n, "none"] }],
        sr: ["sr-only", "not-sr-only"],
        "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }],
      },
      conflictingClassGroups: {
        overflow: ["overflow-x", "overflow-y"],
        overscroll: ["overscroll-x", "overscroll-y"],
        inset: [
          "inset-x",
          "inset-y",
          "start",
          "end",
          "top",
          "right",
          "bottom",
          "left",
        ],
        "inset-x": ["right", "left"],
        "inset-y": ["top", "bottom"],
        flex: ["basis", "grow", "shrink"],
        gap: ["gap-x", "gap-y"],
        p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
        px: ["pr", "pl"],
        py: ["pt", "pb"],
        m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
        mx: ["mr", "ml"],
        my: ["mt", "mb"],
        size: ["w", "h"],
        "font-size": ["leading"],
        "fvn-normal": [
          "fvn-ordinal",
          "fvn-slashed-zero",
          "fvn-figure",
          "fvn-spacing",
          "fvn-fraction",
        ],
        "fvn-ordinal": ["fvn-normal"],
        "fvn-slashed-zero": ["fvn-normal"],
        "fvn-figure": ["fvn-normal"],
        "fvn-spacing": ["fvn-normal"],
        "fvn-fraction": ["fvn-normal"],
        "line-clamp": ["display", "overflow"],
        rounded: [
          "rounded-s",
          "rounded-e",
          "rounded-t",
          "rounded-r",
          "rounded-b",
          "rounded-l",
          "rounded-ss",
          "rounded-se",
          "rounded-ee",
          "rounded-es",
          "rounded-tl",
          "rounded-tr",
          "rounded-br",
          "rounded-bl",
        ],
        "rounded-s": ["rounded-ss", "rounded-es"],
        "rounded-e": ["rounded-se", "rounded-ee"],
        "rounded-t": ["rounded-tl", "rounded-tr"],
        "rounded-r": ["rounded-tr", "rounded-br"],
        "rounded-b": ["rounded-br", "rounded-bl"],
        "rounded-l": ["rounded-tl", "rounded-bl"],
        "border-spacing": ["border-spacing-x", "border-spacing-y"],
        "border-w": [
          "border-w-s",
          "border-w-e",
          "border-w-t",
          "border-w-r",
          "border-w-b",
          "border-w-l",
        ],
        "border-w-x": ["border-w-r", "border-w-l"],
        "border-w-y": ["border-w-t", "border-w-b"],
        "border-color": [
          "border-color-s",
          "border-color-e",
          "border-color-t",
          "border-color-r",
          "border-color-b",
          "border-color-l",
        ],
        "border-color-x": ["border-color-r", "border-color-l"],
        "border-color-y": ["border-color-t", "border-color-b"],
        "scroll-m": [
          "scroll-mx",
          "scroll-my",
          "scroll-ms",
          "scroll-me",
          "scroll-mt",
          "scroll-mr",
          "scroll-mb",
          "scroll-ml",
        ],
        "scroll-mx": ["scroll-mr", "scroll-ml"],
        "scroll-my": ["scroll-mt", "scroll-mb"],
        "scroll-p": [
          "scroll-px",
          "scroll-py",
          "scroll-ps",
          "scroll-pe",
          "scroll-pt",
          "scroll-pr",
          "scroll-pb",
          "scroll-pl",
        ],
        "scroll-px": ["scroll-pr", "scroll-pl"],
        "scroll-py": ["scroll-pt", "scroll-pb"],
        touch: ["touch-x", "touch-y", "touch-pz"],
        "touch-x": ["touch"],
        "touch-y": ["touch"],
        "touch-pz": ["touch"],
      },
      conflictingClassGroupModifiers: { "font-size": ["leading"] },
    };
  },
  g6 = J8(m6);
function qt(...n) {
  return g6(N3(n));
}
const v6 = S8,
  G3 = P.forwardRef(({ className: n, ...e }, t) =>
    T.jsx(T3, {
      ref: t,
      className: qt(
        "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
        n
      ),
      ...e,
    })
  );
G3.displayName = T3.displayName;
const y6 = lM(
    "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
    {
      variants: {
        variant: {
          default: "border bg-background text-foreground",
          destructive:
            "destructive group border-destructive bg-destructive text-destructive-foreground",
        },
      },
      defaultVariants: { variant: "default" },
    }
  ),
  $3 = P.forwardRef(({ className: n, variant: e, ...t }, r) =>
    T.jsx(M3, { ref: r, className: qt(y6({ variant: e }), n), ...t })
  );
$3.displayName = M3.displayName;
const x6 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(R3, {
    ref: t,
    className: qt(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      n
    ),
    ...e,
  })
);
x6.displayName = R3.displayName;
const X3 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(P3, {
    ref: t,
    className: qt(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      n
    ),
    "toast-close": "",
    ...e,
    children: T.jsx(B3, { className: "h-4 w-4" }),
  })
);
X3.displayName = P3.displayName;
const q3 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(C3, { ref: t, className: qt("text-sm font-semibold", n), ...e })
);
q3.displayName = C3.displayName;
const K3 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(A3, { ref: t, className: qt("text-sm opacity-90", n), ...e })
);
K3.displayName = A3.displayName;
function _6() {
  const { toasts: n } = IG();
  return T.jsxs(v6, {
    children: [
      n.map(function ({ id: e, title: t, description: r, action: i, ...s }) {
        return T.jsxs(
          $3,
          {
            ...s,
            children: [
              T.jsxs("div", {
                className: "grid gap-1",
                children: [
                  t && T.jsx(q3, { children: t }),
                  r && T.jsx(K3, { children: r }),
                ],
              }),
              i,
              T.jsx(X3, {}),
            ],
          },
          e
        );
      }),
      T.jsx(G3, {}),
    ],
  });
}
var dI = ["light", "dark"],
  w6 = "(prefers-color-scheme: dark)",
  S6 = P.createContext(void 0),
  b6 = { setTheme: (n) => {}, themes: [] },
  E6 = () => {
    var n;
    return (n = P.useContext(S6)) != null ? n : b6;
  };
P.memo(
  ({
    forcedTheme: n,
    storageKey: e,
    attribute: t,
    enableSystem: r,
    enableColorScheme: i,
    defaultTheme: s,
    value: o,
    attrs: a,
    nonce: l,
  }) => {
    let c = s === "system",
      u =
        t === "class"
          ? `var d=document.documentElement,c=d.classList;${`c.remove(${a
              .map((v) => `'${v}'`)
              .join(",")})`};`
          : `var d=document.documentElement,n='${t}',s='setAttribute';`,
      f = i
        ? dI.includes(s) && s
          ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${s}'`
          : "if(e==='light'||e==='dark')d.style.colorScheme=e"
        : "",
      p = (v, y = !1, x = !0) => {
        let g = o ? o[v] : v,
          _ = y ? v + "|| ''" : `'${g}'`,
          S = "";
        return (
          i &&
            x &&
            !y &&
            dI.includes(v) &&
            (S += `d.style.colorScheme = '${v}';`),
          t === "class"
            ? y || g
              ? (S += `c.add(${_})`)
              : (S += "null")
            : g && (S += `d[s](n,${_})`),
          S
        );
      },
      m = n
        ? `!function(){${u}${p(n)}}()`
        : r
        ? `!function(){try{${u}var e=localStorage.getItem('${e}');if('system'===e||(!e&&${c})){var t='${w6}',m=window.matchMedia(t);if(m.media!==t||m.matches){${p(
            "dark"
          )}}else{${p("light")}}}else if(e){${
            o ? `var x=${JSON.stringify(o)};` : ""
          }${p(o ? "x[e]" : "e", !0)}}${
            c ? "" : "else{" + p(s, !1, !1) + "}"
          }${f}}catch(e){}}()`
        : `!function(){try{${u}var e=localStorage.getItem('${e}');if(e){${
            o ? `var x=${JSON.stringify(o)};` : ""
          }${p(o ? "x[e]" : "e", !0)}}else{${p(
            s,
            !1,
            !1
          )};}${f}}catch(t){}}();`;
    return P.createElement("script", {
      nonce: l,
      dangerouslySetInnerHTML: { __html: m },
    });
  }
);
var T6 = (n) => {
    switch (n) {
      case "success":
        return A6;
      case "info":
        return P6;
      case "warning":
        return R6;
      case "error":
        return I6;
      default:
        return null;
    }
  },
  M6 = Array(12).fill(0),
  C6 = ({ visible: n, className: e }) =>
    Le.createElement(
      "div",
      {
        className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "),
        "data-visible": n,
      },
      Le.createElement(
        "div",
        { className: "sonner-spinner" },
        M6.map((t, r) =>
          Le.createElement("div", {
            className: "sonner-loading-bar",
            key: `spinner-bar-${r}`,
          })
        )
      )
    ),
  A6 = Le.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    Le.createElement("path", {
      fillRule: "evenodd",
      d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
      clipRule: "evenodd",
    })
  ),
  R6 = Le.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    Le.createElement("path", {
      fillRule: "evenodd",
      d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
      clipRule: "evenodd",
    })
  ),
  P6 = Le.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    Le.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
      clipRule: "evenodd",
    })
  ),
  I6 = Le.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 20 20",
      fill: "currentColor",
      height: "20",
      width: "20",
    },
    Le.createElement("path", {
      fillRule: "evenodd",
      d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
      clipRule: "evenodd",
    })
  ),
  N6 = Le.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "12",
      height: "12",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "1.5",
      strokeLinecap: "round",
      strokeLinejoin: "round",
    },
    Le.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
    Le.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })
  ),
  L6 = () => {
    let [n, e] = Le.useState(document.hidden);
    return (
      Le.useEffect(() => {
        let t = () => {
          e(document.hidden);
        };
        return (
          document.addEventListener("visibilitychange", t),
          () => window.removeEventListener("visibilitychange", t)
        );
      }, []),
      n
    );
  },
  Gb = 1,
  O6 = class {
    constructor() {
      (this.subscribe = (n) => (
        this.subscribers.push(n),
        () => {
          let e = this.subscribers.indexOf(n);
          this.subscribers.splice(e, 1);
        }
      )),
        (this.publish = (n) => {
          this.subscribers.forEach((e) => e(n));
        }),
        (this.addToast = (n) => {
          this.publish(n), (this.toasts = [...this.toasts, n]);
        }),
        (this.create = (n) => {
          var e;
          let { message: t, ...r } = n,
            i =
              typeof (n == null ? void 0 : n.id) == "number" ||
              ((e = n.id) == null ? void 0 : e.length) > 0
                ? n.id
                : Gb++,
            s = this.toasts.find((a) => a.id === i),
            o = n.dismissible === void 0 ? !0 : n.dismissible;
          return (
            this.dismissedToasts.has(i) && this.dismissedToasts.delete(i),
            s
              ? (this.toasts = this.toasts.map((a) =>
                  a.id === i
                    ? (this.publish({ ...a, ...n, id: i, title: t }),
                      { ...a, ...n, id: i, dismissible: o, title: t })
                    : a
                ))
              : this.addToast({ title: t, ...r, dismissible: o, id: i }),
            i
          );
        }),
        (this.dismiss = (n) => (
          this.dismissedToasts.add(n),
          n ||
            this.toasts.forEach((e) => {
              this.subscribers.forEach((t) => t({ id: e.id, dismiss: !0 }));
            }),
          this.subscribers.forEach((e) => e({ id: n, dismiss: !0 })),
          n
        )),
        (this.message = (n, e) => this.create({ ...e, message: n })),
        (this.error = (n, e) =>
          this.create({ ...e, message: n, type: "error" })),
        (this.success = (n, e) =>
          this.create({ ...e, type: "success", message: n })),
        (this.info = (n, e) => this.create({ ...e, type: "info", message: n })),
        (this.warning = (n, e) =>
          this.create({ ...e, type: "warning", message: n })),
        (this.loading = (n, e) =>
          this.create({ ...e, type: "loading", message: n })),
        (this.promise = (n, e) => {
          if (!e) return;
          let t;
          e.loading !== void 0 &&
            (t = this.create({
              ...e,
              promise: n,
              type: "loading",
              message: e.loading,
              description:
                typeof e.description != "function" ? e.description : void 0,
            }));
          let r = n instanceof Promise ? n : n(),
            i = t !== void 0,
            s,
            o = r
              .then(async (l) => {
                if (((s = ["resolve", l]), Le.isValidElement(l)))
                  (i = !1), this.create({ id: t, type: "default", message: l });
                else if (k6(l) && !l.ok) {
                  i = !1;
                  let c =
                      typeof e.error == "function"
                        ? await e.error(`HTTP error! status: ${l.status}`)
                        : e.error,
                    u =
                      typeof e.description == "function"
                        ? await e.description(`HTTP error! status: ${l.status}`)
                        : e.description;
                  this.create({
                    id: t,
                    type: "error",
                    message: c,
                    description: u,
                  });
                } else if (e.success !== void 0) {
                  i = !1;
                  let c =
                      typeof e.success == "function"
                        ? await e.success(l)
                        : e.success,
                    u =
                      typeof e.description == "function"
                        ? await e.description(l)
                        : e.description;
                  this.create({
                    id: t,
                    type: "success",
                    message: c,
                    description: u,
                  });
                }
              })
              .catch(async (l) => {
                if (((s = ["reject", l]), e.error !== void 0)) {
                  i = !1;
                  let c =
                      typeof e.error == "function" ? await e.error(l) : e.error,
                    u =
                      typeof e.description == "function"
                        ? await e.description(l)
                        : e.description;
                  this.create({
                    id: t,
                    type: "error",
                    message: c,
                    description: u,
                  });
                }
              })
              .finally(() => {
                var l;
                i && (this.dismiss(t), (t = void 0)),
                  (l = e.finally) == null || l.call(e);
              }),
            a = () =>
              new Promise((l, c) =>
                o.then(() => (s[0] === "reject" ? c(s[1]) : l(s[1]))).catch(c)
              );
          return typeof t != "string" && typeof t != "number"
            ? { unwrap: a }
            : Object.assign(t, { unwrap: a });
        }),
        (this.custom = (n, e) => {
          let t = (e == null ? void 0 : e.id) || Gb++;
          return this.create({ jsx: n(t), id: t, ...e }), t;
        }),
        (this.getActiveToasts = () =>
          this.toasts.filter((n) => !this.dismissedToasts.has(n.id))),
        (this.subscribers = []),
        (this.toasts = []),
        (this.dismissedToasts = new Set());
    }
  },
  ai = new O6(),
  D6 = (n, e) => {
    let t = (e == null ? void 0 : e.id) || Gb++;
    return ai.addToast({ title: n, ...e, id: t }), t;
  },
  k6 = (n) =>
    n &&
    typeof n == "object" &&
    "ok" in n &&
    typeof n.ok == "boolean" &&
    "status" in n &&
    typeof n.status == "number",
  U6 = D6,
  F6 = () => ai.toasts,
  B6 = () => ai.getActiveToasts(),
  es = Object.assign(
    U6,
    {
      success: ai.success,
      info: ai.info,
      warning: ai.warning,
      error: ai.error,
      custom: ai.custom,
      message: ai.message,
      promise: ai.promise,
      dismiss: ai.dismiss,
      loading: ai.loading,
    },
    { getHistory: F6, getToasts: B6 }
  );
function z6(n, { insertAt: e } = {}) {
  if (typeof document > "u") return;
  let t = document.head || document.getElementsByTagName("head")[0],
    r = document.createElement("style");
  (r.type = "text/css"),
    e === "top" && t.firstChild
      ? t.insertBefore(r, t.firstChild)
      : t.appendChild(r),
    r.styleSheet
      ? (r.styleSheet.cssText = n)
      : r.appendChild(document.createTextNode(n));
}
z6(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function Yg(n) {
  return n.label !== void 0;
}
var V6 = 3,
  j6 = "32px",
  H6 = "16px",
  hI = 4e3,
  W6 = 356,
  G6 = 14,
  $6 = 20,
  X6 = 200;
function ps(...n) {
  return n.filter(Boolean).join(" ");
}
function q6(n) {
  let [e, t] = n.split("-"),
    r = [];
  return e && r.push(e), t && r.push(t), r;
}
var K6 = (n) => {
  var e, t, r, i, s, o, a, l, c, u, f;
  let {
      invert: p,
      toast: m,
      unstyled: v,
      interacting: y,
      setHeights: x,
      visibleToasts: g,
      heights: _,
      index: S,
      toasts: b,
      expanded: C,
      removeToast: A,
      defaultRichColors: R,
      closeButton: O,
      style: I,
      cancelButtonStyle: N,
      actionButtonStyle: D,
      className: j = "",
      descriptionClassName: $ = "",
      duration: G,
      position: Z,
      gap: q,
      loadingIcon: Y,
      expandByDefault: U,
      classNames: H,
      icons: X,
      closeButtonAriaLabel: ie = "Close toast",
      pauseWhenPageIsHidden: de,
    } = n,
    [Ee, Ie] = Le.useState(null),
    [se, _e] = Le.useState(null),
    [re, Be] = Le.useState(!1),
    [Ue, Fe] = Le.useState(!1),
    [Ke, Ve] = Le.useState(!1),
    [W, ge] = Le.useState(!1),
    [pe, Se] = Le.useState(!1),
    [me, Oe] = Le.useState(0),
    [Te, De] = Le.useState(0),
    _t = Le.useRef(m.duration || G || hI),
    wt = Le.useRef(null),
    B = Le.useRef(null),
    k = S === 0,
    ne = S + 1 <= g,
    ae = m.type,
    we = m.dismissible !== !1,
    he = m.className || "",
    ot = m.descriptionClassName || "",
    Ne = Le.useMemo(
      () => _.findIndex((be) => be.toastId === m.id) || 0,
      [_, m.id]
    ),
    it = Le.useMemo(() => {
      var be;
      return (be = m.closeButton) != null ? be : O;
    }, [m.closeButton, O]),
    tt = Le.useMemo(() => m.duration || G || hI, [m.duration, G]),
    Ce = Le.useRef(0),
    je = Le.useRef(0),
    vt = Le.useRef(0),
    Qe = Le.useRef(null),
    [He, Ct] = Z.split("-"),
    K = Le.useMemo(
      () => _.reduce((be, $e, mt) => (mt >= Ne ? be : be + $e.height), 0),
      [_, Ne]
    ),
    Re = L6(),
    ze = m.invert || p,
    Ye = ae === "loading";
  (je.current = Le.useMemo(() => Ne * q + K, [Ne, K])),
    Le.useEffect(() => {
      _t.current = tt;
    }, [tt]),
    Le.useEffect(() => {
      Be(!0);
    }, []),
    Le.useEffect(() => {
      let be = B.current;
      if (be) {
        let $e = be.getBoundingClientRect().height;
        return (
          De($e),
          x((mt) => [
            { toastId: m.id, height: $e, position: m.position },
            ...mt,
          ]),
          () => x((mt) => mt.filter((At) => At.toastId !== m.id))
        );
      }
    }, [x, m.id]),
    Le.useLayoutEffect(() => {
      if (!re) return;
      let be = B.current,
        $e = be.style.height;
      be.style.height = "auto";
      let mt = be.getBoundingClientRect().height;
      (be.style.height = $e),
        De(mt),
        x((At) =>
          At.find((mn) => mn.toastId === m.id)
            ? At.map((mn) => (mn.toastId === m.id ? { ...mn, height: mt } : mn))
            : [{ toastId: m.id, height: mt, position: m.position }, ...At]
        );
    }, [re, m.title, m.description, x, m.id]);
  let Me = Le.useCallback(() => {
    Fe(!0),
      Oe(je.current),
      x((be) => be.filter(($e) => $e.toastId !== m.id)),
      setTimeout(() => {
        A(m);
      }, X6);
  }, [m, A, x, je]);
  Le.useEffect(() => {
    if (
      (m.promise && ae === "loading") ||
      m.duration === 1 / 0 ||
      m.type === "loading"
    )
      return;
    let be;
    return (
      C || y || (de && Re)
        ? (() => {
            if (vt.current < Ce.current) {
              let $e = new Date().getTime() - Ce.current;
              _t.current = _t.current - $e;
            }
            vt.current = new Date().getTime();
          })()
        : _t.current !== 1 / 0 &&
          ((Ce.current = new Date().getTime()),
          (be = setTimeout(() => {
            var $e;
            ($e = m.onAutoClose) == null || $e.call(m, m), Me();
          }, _t.current))),
      () => clearTimeout(be)
    );
  }, [C, y, m, ae, de, Re, Me]),
    Le.useEffect(() => {
      m.delete && Me();
    }, [Me, m.delete]);
  function ye() {
    var be, $e, mt;
    return X != null && X.loading
      ? Le.createElement(
          "div",
          {
            className: ps(
              H == null ? void 0 : H.loader,
              (be = m == null ? void 0 : m.classNames) == null
                ? void 0
                : be.loader,
              "sonner-loader"
            ),
            "data-visible": ae === "loading",
          },
          X.loading
        )
      : Y
      ? Le.createElement(
          "div",
          {
            className: ps(
              H == null ? void 0 : H.loader,
              ($e = m == null ? void 0 : m.classNames) == null
                ? void 0
                : $e.loader,
              "sonner-loader"
            ),
            "data-visible": ae === "loading",
          },
          Y
        )
      : Le.createElement(C6, {
          className: ps(
            H == null ? void 0 : H.loader,
            (mt = m == null ? void 0 : m.classNames) == null
              ? void 0
              : mt.loader
          ),
          visible: ae === "loading",
        });
  }
  return Le.createElement(
    "li",
    {
      tabIndex: 0,
      ref: B,
      className: ps(
        j,
        he,
        H == null ? void 0 : H.toast,
        (e = m == null ? void 0 : m.classNames) == null ? void 0 : e.toast,
        H == null ? void 0 : H.default,
        H == null ? void 0 : H[ae],
        (t = m == null ? void 0 : m.classNames) == null ? void 0 : t[ae]
      ),
      "data-sonner-toast": "",
      "data-rich-colors": (r = m.richColors) != null ? r : R,
      "data-styled": !(m.jsx || m.unstyled || v),
      "data-mounted": re,
      "data-promise": !!m.promise,
      "data-swiped": pe,
      "data-removed": Ue,
      "data-visible": ne,
      "data-y-position": He,
      "data-x-position": Ct,
      "data-index": S,
      "data-front": k,
      "data-swiping": Ke,
      "data-dismissible": we,
      "data-type": ae,
      "data-invert": ze,
      "data-swipe-out": W,
      "data-swipe-direction": se,
      "data-expanded": !!(C || (U && re)),
      style: {
        "--index": S,
        "--toasts-before": S,
        "--z-index": b.length - S,
        "--offset": `${Ue ? me : je.current}px`,
        "--initial-height": U ? "auto" : `${Te}px`,
        ...I,
        ...m.style,
      },
      onDragEnd: () => {
        Ve(!1), Ie(null), (Qe.current = null);
      },
      onPointerDown: (be) => {
        Ye ||
          !we ||
          ((wt.current = new Date()),
          Oe(je.current),
          be.target.setPointerCapture(be.pointerId),
          be.target.tagName !== "BUTTON" &&
            (Ve(!0), (Qe.current = { x: be.clientX, y: be.clientY })));
      },
      onPointerUp: () => {
        var be, $e, mt, At;
        if (W || !we) return;
        Qe.current = null;
        let mn = Number(
            ((be = B.current) == null
              ? void 0
              : be.style
                  .getPropertyValue("--swipe-amount-x")
                  .replace("px", "")) || 0
          ),
          On = Number(
            (($e = B.current) == null
              ? void 0
              : $e.style
                  .getPropertyValue("--swipe-amount-y")
                  .replace("px", "")) || 0
          ),
          Fi =
            new Date().getTime() -
            ((mt = wt.current) == null ? void 0 : mt.getTime()),
          Dn = Ee === "x" ? mn : On,
          Fr = Math.abs(Dn) / Fi;
        if (Math.abs(Dn) >= $6 || Fr > 0.11) {
          Oe(je.current),
            (At = m.onDismiss) == null || At.call(m, m),
            _e(
              Ee === "x" ? (mn > 0 ? "right" : "left") : On > 0 ? "down" : "up"
            ),
            Me(),
            ge(!0),
            Se(!1);
          return;
        }
        Ve(!1), Ie(null);
      },
      onPointerMove: (be) => {
        var $e, mt, At, mn;
        if (
          !Qe.current ||
          !we ||
          (($e = window.getSelection()) == null
            ? void 0
            : $e.toString().length) > 0
        )
          return;
        let On = be.clientY - Qe.current.y,
          Fi = be.clientX - Qe.current.x,
          Dn = (mt = n.swipeDirections) != null ? mt : q6(Z);
        !Ee &&
          (Math.abs(Fi) > 1 || Math.abs(On) > 1) &&
          Ie(Math.abs(Fi) > Math.abs(On) ? "x" : "y");
        let Fr = { x: 0, y: 0 };
        Ee === "y"
          ? (Dn.includes("top") || Dn.includes("bottom")) &&
            ((Dn.includes("top") && On < 0) ||
              (Dn.includes("bottom") && On > 0)) &&
            (Fr.y = On)
          : Ee === "x" &&
            (Dn.includes("left") || Dn.includes("right")) &&
            ((Dn.includes("left") && Fi < 0) ||
              (Dn.includes("right") && Fi > 0)) &&
            (Fr.x = Fi),
          (Math.abs(Fr.x) > 0 || Math.abs(Fr.y) > 0) && Se(!0),
          (At = B.current) == null ||
            At.style.setProperty("--swipe-amount-x", `${Fr.x}px`),
          (mn = B.current) == null ||
            mn.style.setProperty("--swipe-amount-y", `${Fr.y}px`);
      },
    },
    it && !m.jsx
      ? Le.createElement(
          "button",
          {
            "aria-label": ie,
            "data-disabled": Ye,
            "data-close-button": !0,
            onClick:
              Ye || !we
                ? () => {}
                : () => {
                    var be;
                    Me(), (be = m.onDismiss) == null || be.call(m, m);
                  },
            className: ps(
              H == null ? void 0 : H.closeButton,
              (i = m == null ? void 0 : m.classNames) == null
                ? void 0
                : i.closeButton
            ),
          },
          (s = X == null ? void 0 : X.close) != null ? s : N6
        )
      : null,
    m.jsx || P.isValidElement(m.title)
      ? m.jsx
        ? m.jsx
        : typeof m.title == "function"
        ? m.title()
        : m.title
      : Le.createElement(
          Le.Fragment,
          null,
          ae || m.icon || m.promise
            ? Le.createElement(
                "div",
                {
                  "data-icon": "",
                  className: ps(
                    H == null ? void 0 : H.icon,
                    (o = m == null ? void 0 : m.classNames) == null
                      ? void 0
                      : o.icon
                  ),
                },
                m.promise || (m.type === "loading" && !m.icon)
                  ? m.icon || ye()
                  : null,
                m.type !== "loading"
                  ? m.icon || (X == null ? void 0 : X[ae]) || T6(ae)
                  : null
              )
            : null,
          Le.createElement(
            "div",
            {
              "data-content": "",
              className: ps(
                H == null ? void 0 : H.content,
                (a = m == null ? void 0 : m.classNames) == null
                  ? void 0
                  : a.content
              ),
            },
            Le.createElement(
              "div",
              {
                "data-title": "",
                className: ps(
                  H == null ? void 0 : H.title,
                  (l = m == null ? void 0 : m.classNames) == null
                    ? void 0
                    : l.title
                ),
              },
              typeof m.title == "function" ? m.title() : m.title
            ),
            m.description
              ? Le.createElement(
                  "div",
                  {
                    "data-description": "",
                    className: ps(
                      $,
                      ot,
                      H == null ? void 0 : H.description,
                      (c = m == null ? void 0 : m.classNames) == null
                        ? void 0
                        : c.description
                    ),
                  },
                  typeof m.description == "function"
                    ? m.description()
                    : m.description
                )
              : null
          ),
          P.isValidElement(m.cancel)
            ? m.cancel
            : m.cancel && Yg(m.cancel)
            ? Le.createElement(
                "button",
                {
                  "data-button": !0,
                  "data-cancel": !0,
                  style: m.cancelButtonStyle || N,
                  onClick: (be) => {
                    var $e, mt;
                    Yg(m.cancel) &&
                      we &&
                      ((mt = ($e = m.cancel).onClick) == null ||
                        mt.call($e, be),
                      Me());
                  },
                  className: ps(
                    H == null ? void 0 : H.cancelButton,
                    (u = m == null ? void 0 : m.classNames) == null
                      ? void 0
                      : u.cancelButton
                  ),
                },
                m.cancel.label
              )
            : null,
          P.isValidElement(m.action)
            ? m.action
            : m.action && Yg(m.action)
            ? Le.createElement(
                "button",
                {
                  "data-button": !0,
                  "data-action": !0,
                  style: m.actionButtonStyle || D,
                  onClick: (be) => {
                    var $e, mt;
                    Yg(m.action) &&
                      ((mt = ($e = m.action).onClick) == null ||
                        mt.call($e, be),
                      !be.defaultPrevented && Me());
                  },
                  className: ps(
                    H == null ? void 0 : H.actionButton,
                    (f = m == null ? void 0 : m.classNames) == null
                      ? void 0
                      : f.actionButton
                  ),
                },
                m.action.label
              )
            : null
        )
  );
};
function fI() {
  if (typeof window > "u" || typeof document > "u") return "ltr";
  let n = document.documentElement.getAttribute("dir");
  return n === "auto" || !n
    ? window.getComputedStyle(document.documentElement).direction
    : n;
}
function Y6(n, e) {
  let t = {};
  return (
    [n, e].forEach((r, i) => {
      let s = i === 1,
        o = s ? "--mobile-offset" : "--offset",
        a = s ? H6 : j6;
      function l(c) {
        ["top", "right", "bottom", "left"].forEach((u) => {
          t[`${o}-${u}`] = typeof c == "number" ? `${c}px` : c;
        });
      }
      typeof r == "number" || typeof r == "string"
        ? l(r)
        : typeof r == "object"
        ? ["top", "right", "bottom", "left"].forEach((c) => {
            r[c] === void 0
              ? (t[`${o}-${c}`] = a)
              : (t[`${o}-${c}`] = typeof r[c] == "number" ? `${r[c]}px` : r[c]);
          })
        : l(a);
    }),
    t
  );
}
var J6 = P.forwardRef(function (n, e) {
  let {
      invert: t,
      position: r = "bottom-right",
      hotkey: i = ["altKey", "KeyT"],
      expand: s,
      closeButton: o,
      className: a,
      offset: l,
      mobileOffset: c,
      theme: u = "light",
      richColors: f,
      duration: p,
      style: m,
      visibleToasts: v = V6,
      toastOptions: y,
      dir: x = fI(),
      gap: g = G6,
      loadingIcon: _,
      icons: S,
      containerAriaLabel: b = "Notifications",
      pauseWhenPageIsHidden: C,
    } = n,
    [A, R] = Le.useState([]),
    O = Le.useMemo(
      () =>
        Array.from(
          new Set(
            [r].concat(A.filter((de) => de.position).map((de) => de.position))
          )
        ),
      [A, r]
    ),
    [I, N] = Le.useState([]),
    [D, j] = Le.useState(!1),
    [$, G] = Le.useState(!1),
    [Z, q] = Le.useState(
      u !== "system"
        ? u
        : typeof window < "u" &&
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
        ? "dark"
        : "light"
    ),
    Y = Le.useRef(null),
    U = i.join("+").replace(/Key/g, "").replace(/Digit/g, ""),
    H = Le.useRef(null),
    X = Le.useRef(!1),
    ie = Le.useCallback((de) => {
      R((Ee) => {
        var Ie;
        return (
          ((Ie = Ee.find((se) => se.id === de.id)) != null && Ie.delete) ||
            ai.dismiss(de.id),
          Ee.filter(({ id: se }) => se !== de.id)
        );
      });
    }, []);
  return (
    Le.useEffect(
      () =>
        ai.subscribe((de) => {
          if (de.dismiss) {
            R((Ee) =>
              Ee.map((Ie) => (Ie.id === de.id ? { ...Ie, delete: !0 } : Ie))
            );
            return;
          }
          setTimeout(() => {
            n3.flushSync(() => {
              R((Ee) => {
                let Ie = Ee.findIndex((se) => se.id === de.id);
                return Ie !== -1
                  ? [
                      ...Ee.slice(0, Ie),
                      { ...Ee[Ie], ...de },
                      ...Ee.slice(Ie + 1),
                    ]
                  : [de, ...Ee];
              });
            });
          });
        }),
      []
    ),
    Le.useEffect(() => {
      if (u !== "system") {
        q(u);
        return;
      }
      if (
        (u === "system" &&
          (window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches
            ? q("dark")
            : q("light")),
        typeof window > "u")
      )
        return;
      let de = window.matchMedia("(prefers-color-scheme: dark)");
      try {
        de.addEventListener("change", ({ matches: Ee }) => {
          q(Ee ? "dark" : "light");
        });
      } catch {
        de.addListener(({ matches: Ie }) => {
          try {
            q(Ie ? "dark" : "light");
          } catch (se) {
            console.error(se);
          }
        });
      }
    }, [u]),
    Le.useEffect(() => {
      A.length <= 1 && j(!1);
    }, [A]),
    Le.useEffect(() => {
      let de = (Ee) => {
        var Ie, se;
        i.every((_e) => Ee[_e] || Ee.code === _e) &&
          (j(!0), (Ie = Y.current) == null || Ie.focus()),
          Ee.code === "Escape" &&
            (document.activeElement === Y.current ||
              ((se = Y.current) != null &&
                se.contains(document.activeElement))) &&
            j(!1);
      };
      return (
        document.addEventListener("keydown", de),
        () => document.removeEventListener("keydown", de)
      );
    }, [i]),
    Le.useEffect(() => {
      if (Y.current)
        return () => {
          H.current &&
            (H.current.focus({ preventScroll: !0 }),
            (H.current = null),
            (X.current = !1));
        };
    }, [Y.current]),
    Le.createElement(
      "section",
      {
        ref: e,
        "aria-label": `${b} ${U}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: !0,
      },
      O.map((de, Ee) => {
        var Ie;
        let [se, _e] = de.split("-");
        return A.length
          ? Le.createElement(
              "ol",
              {
                key: de,
                dir: x === "auto" ? fI() : x,
                tabIndex: -1,
                ref: Y,
                className: a,
                "data-sonner-toaster": !0,
                "data-theme": Z,
                "data-y-position": se,
                "data-lifted": D && A.length > 1 && !s,
                "data-x-position": _e,
                style: {
                  "--front-toast-height": `${
                    ((Ie = I[0]) == null ? void 0 : Ie.height) || 0
                  }px`,
                  "--width": `${W6}px`,
                  "--gap": `${g}px`,
                  ...m,
                  ...Y6(l, c),
                },
                onBlur: (re) => {
                  X.current &&
                    !re.currentTarget.contains(re.relatedTarget) &&
                    ((X.current = !1),
                    H.current &&
                      (H.current.focus({ preventScroll: !0 }),
                      (H.current = null)));
                },
                onFocus: (re) => {
                  (re.target instanceof HTMLElement &&
                    re.target.dataset.dismissible === "false") ||
                    X.current ||
                    ((X.current = !0), (H.current = re.relatedTarget));
                },
                onMouseEnter: () => j(!0),
                onMouseMove: () => j(!0),
                onMouseLeave: () => {
                  $ || j(!1);
                },
                onDragEnd: () => j(!1),
                onPointerDown: (re) => {
                  (re.target instanceof HTMLElement &&
                    re.target.dataset.dismissible === "false") ||
                    G(!0);
                },
                onPointerUp: () => G(!1),
              },
              A.filter(
                (re) => (!re.position && Ee === 0) || re.position === de
              ).map((re, Be) => {
                var Ue, Fe;
                return Le.createElement(K6, {
                  key: re.id,
                  icons: S,
                  index: Be,
                  toast: re,
                  defaultRichColors: f,
                  duration:
                    (Ue = y == null ? void 0 : y.duration) != null ? Ue : p,
                  className: y == null ? void 0 : y.className,
                  descriptionClassName:
                    y == null ? void 0 : y.descriptionClassName,
                  invert: t,
                  visibleToasts: v,
                  closeButton:
                    (Fe = y == null ? void 0 : y.closeButton) != null ? Fe : o,
                  interacting: $,
                  position: de,
                  style: y == null ? void 0 : y.style,
                  unstyled: y == null ? void 0 : y.unstyled,
                  classNames: y == null ? void 0 : y.classNames,
                  cancelButtonStyle: y == null ? void 0 : y.cancelButtonStyle,
                  actionButtonStyle: y == null ? void 0 : y.actionButtonStyle,
                  removeToast: ie,
                  toasts: A.filter((Ke) => Ke.position == re.position),
                  heights: I.filter((Ke) => Ke.position == re.position),
                  setHeights: N,
                  expandByDefault: s,
                  gap: g,
                  loadingIcon: _,
                  expanded: D,
                  pauseWhenPageIsHidden: C,
                  swipeDirections: n.swipeDirections,
                });
              })
            )
          : null;
      })
    )
  );
});
const Z6 = ({ ...n }) => {
  const { theme: e = "system" } = E6();
  return T.jsx(J6, {
    theme: e,
    className: "toaster group",
    duration: 5e3,
    closeButton: !0,
    toastOptions: {
      classNames: {
        toast:
          "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
        description: "group-[.toast]:text-muted-foreground",
        actionButton:
          "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
        cancelButton:
          "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        closeButton:
          "group-[.toast]:bg-background group-[.toast]:text-foreground group-[.toast]:border group-[.toast]:border-border",
      },
    },
    ...n,
  });
};
var Q6 = pT[" useId ".trim().toString()] || (() => {}),
  e$ = 0;
function Pd(n) {
  const [e, t] = P.useState(Q6());
  return (
    yr(() => {
      t((r) => r ?? String(e$++));
    }, [n]),
    e ? `radix-${e}` : ""
  );
}
const t$ = ["top", "right", "bottom", "left"],
  cl = Math.min,
  Mi = Math.max,
  s0 = Math.round,
  Jg = Math.floor,
  uo = (n) => ({ x: n, y: n }),
  n$ = { left: "right", right: "left", bottom: "top", top: "bottom" },
  r$ = { start: "end", end: "start" };
function $b(n, e, t) {
  return Mi(n, cl(e, t));
}
function Qo(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function ea(n) {
  return n.split("-")[0];
}
function wh(n) {
  return n.split("-")[1];
}
function hM(n) {
  return n === "x" ? "y" : "x";
}
function fM(n) {
  return n === "y" ? "height" : "width";
}
const i$ = new Set(["top", "bottom"]);
function so(n) {
  return i$.has(ea(n)) ? "y" : "x";
}
function pM(n) {
  return hM(so(n));
}
function s$(n, e, t) {
  t === void 0 && (t = !1);
  const r = wh(n),
    i = pM(n),
    s = fM(i);
  let o =
    i === "x"
      ? r === (t ? "end" : "start")
        ? "right"
        : "left"
      : r === "start"
      ? "bottom"
      : "top";
  return e.reference[s] > e.floating[s] && (o = o0(o)), [o, o0(o)];
}
function o$(n) {
  const e = o0(n);
  return [Xb(n), e, Xb(e)];
}
function Xb(n) {
  return n.replace(/start|end/g, (e) => r$[e]);
}
const pI = ["left", "right"],
  mI = ["right", "left"],
  a$ = ["top", "bottom"],
  l$ = ["bottom", "top"];
function c$(n, e, t) {
  switch (n) {
    case "top":
    case "bottom":
      return t ? (e ? mI : pI) : e ? pI : mI;
    case "left":
    case "right":
      return e ? a$ : l$;
    default:
      return [];
  }
}
function u$(n, e, t, r) {
  const i = wh(n);
  let s = c$(ea(n), t === "start", r);
  return (
    i && ((s = s.map((o) => o + "-" + i)), e && (s = s.concat(s.map(Xb)))), s
  );
}
function o0(n) {
  return n.replace(/left|right|bottom|top/g, (e) => n$[e]);
}
function d$(n) {
  return { top: 0, right: 0, bottom: 0, left: 0, ...n };
}
function Y3(n) {
  return typeof n != "number"
    ? d$(n)
    : { top: n, right: n, bottom: n, left: n };
}
function a0(n) {
  const { x: e, y: t, width: r, height: i } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t,
  };
}
function gI(n, e, t) {
  let { reference: r, floating: i } = n;
  const s = so(e),
    o = pM(e),
    a = fM(o),
    l = ea(e),
    c = s === "y",
    u = r.x + r.width / 2 - i.width / 2,
    f = r.y + r.height / 2 - i.height / 2,
    p = r[a] / 2 - i[a] / 2;
  let m;
  switch (l) {
    case "top":
      m = { x: u, y: r.y - i.height };
      break;
    case "bottom":
      m = { x: u, y: r.y + r.height };
      break;
    case "right":
      m = { x: r.x + r.width, y: f };
      break;
    case "left":
      m = { x: r.x - i.width, y: f };
      break;
    default:
      m = { x: r.x, y: r.y };
  }
  switch (wh(e)) {
    case "start":
      m[o] -= p * (t && c ? -1 : 1);
      break;
    case "end":
      m[o] += p * (t && c ? -1 : 1);
      break;
  }
  return m;
}
const h$ = async (n, e, t) => {
  const {
      placement: r = "bottom",
      strategy: i = "absolute",
      middleware: s = [],
      platform: o,
    } = t,
    a = s.filter(Boolean),
    l = await (o.isRTL == null ? void 0 : o.isRTL(e));
  let c = await o.getElementRects({ reference: n, floating: e, strategy: i }),
    { x: u, y: f } = gI(c, r, l),
    p = r,
    m = {},
    v = 0;
  for (let y = 0; y < a.length; y++) {
    const { name: x, fn: g } = a[y],
      {
        x: _,
        y: S,
        data: b,
        reset: C,
      } = await g({
        x: u,
        y: f,
        initialPlacement: r,
        placement: p,
        strategy: i,
        middlewareData: m,
        rects: c,
        platform: o,
        elements: { reference: n, floating: e },
      });
    (u = _ ?? u),
      (f = S ?? f),
      (m = { ...m, [x]: { ...m[x], ...b } }),
      C &&
        v <= 50 &&
        (v++,
        typeof C == "object" &&
          (C.placement && (p = C.placement),
          C.rects &&
            (c =
              C.rects === !0
                ? await o.getElementRects({
                    reference: n,
                    floating: e,
                    strategy: i,
                  })
                : C.rects),
          ({ x: u, y: f } = gI(c, p, l))),
        (y = -1));
  }
  return { x: u, y: f, placement: p, strategy: i, middlewareData: m };
};
async function Rp(n, e) {
  var t;
  e === void 0 && (e = {});
  const { x: r, y: i, platform: s, rects: o, elements: a, strategy: l } = n,
    {
      boundary: c = "clippingAncestors",
      rootBoundary: u = "viewport",
      elementContext: f = "floating",
      altBoundary: p = !1,
      padding: m = 0,
    } = Qo(e, n),
    v = Y3(m),
    x = a[p ? (f === "floating" ? "reference" : "floating") : f],
    g = a0(
      await s.getClippingRect({
        element:
          (t = await (s.isElement == null ? void 0 : s.isElement(x))) == null ||
          t
            ? x
            : x.contextElement ||
              (await (s.getDocumentElement == null
                ? void 0
                : s.getDocumentElement(a.floating))),
        boundary: c,
        rootBoundary: u,
        strategy: l,
      })
    ),
    _ =
      f === "floating"
        ? { x: r, y: i, width: o.floating.width, height: o.floating.height }
        : o.reference,
    S = await (s.getOffsetParent == null
      ? void 0
      : s.getOffsetParent(a.floating)),
    b = (await (s.isElement == null ? void 0 : s.isElement(S)))
      ? (await (s.getScale == null ? void 0 : s.getScale(S))) || { x: 1, y: 1 }
      : { x: 1, y: 1 },
    C = a0(
      s.convertOffsetParentRelativeRectToViewportRelativeRect
        ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
            elements: a,
            rect: _,
            offsetParent: S,
            strategy: l,
          })
        : _
    );
  return {
    top: (g.top - C.top + v.top) / b.y,
    bottom: (C.bottom - g.bottom + v.bottom) / b.y,
    left: (g.left - C.left + v.left) / b.x,
    right: (C.right - g.right + v.right) / b.x,
  };
}
const f$ = (n) => ({
    name: "arrow",
    options: n,
    async fn(e) {
      const {
          x: t,
          y: r,
          placement: i,
          rects: s,
          platform: o,
          elements: a,
          middlewareData: l,
        } = e,
        { element: c, padding: u = 0 } = Qo(n, e) || {};
      if (c == null) return {};
      const f = Y3(u),
        p = { x: t, y: r },
        m = pM(i),
        v = fM(m),
        y = await o.getDimensions(c),
        x = m === "y",
        g = x ? "top" : "left",
        _ = x ? "bottom" : "right",
        S = x ? "clientHeight" : "clientWidth",
        b = s.reference[v] + s.reference[m] - p[m] - s.floating[v],
        C = p[m] - s.reference[m],
        A = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
      let R = A ? A[S] : 0;
      (!R || !(await (o.isElement == null ? void 0 : o.isElement(A)))) &&
        (R = a.floating[S] || s.floating[v]);
      const O = b / 2 - C / 2,
        I = R / 2 - y[v] / 2 - 1,
        N = cl(f[g], I),
        D = cl(f[_], I),
        j = N,
        $ = R - y[v] - D,
        G = R / 2 - y[v] / 2 + O,
        Z = $b(j, G, $),
        q =
          !l.arrow &&
          wh(i) != null &&
          G !== Z &&
          s.reference[v] / 2 - (G < j ? N : D) - y[v] / 2 < 0,
        Y = q ? (G < j ? G - j : G - $) : 0;
      return {
        [m]: p[m] + Y,
        data: {
          [m]: Z,
          centerOffset: G - Z - Y,
          ...(q && { alignmentOffset: Y }),
        },
        reset: q,
      };
    },
  }),
  p$ = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "flip",
        options: n,
        async fn(e) {
          var t, r;
          const {
              placement: i,
              middlewareData: s,
              rects: o,
              initialPlacement: a,
              platform: l,
              elements: c,
            } = e,
            {
              mainAxis: u = !0,
              crossAxis: f = !0,
              fallbackPlacements: p,
              fallbackStrategy: m = "bestFit",
              fallbackAxisSideDirection: v = "none",
              flipAlignment: y = !0,
              ...x
            } = Qo(n, e);
          if ((t = s.arrow) != null && t.alignmentOffset) return {};
          const g = ea(i),
            _ = so(a),
            S = ea(a) === a,
            b = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)),
            C = p || (S || !y ? [o0(a)] : o$(a)),
            A = v !== "none";
          !p && A && C.push(...u$(a, y, v, b));
          const R = [a, ...C],
            O = await Rp(e, x),
            I = [];
          let N = ((r = s.flip) == null ? void 0 : r.overflows) || [];
          if ((u && I.push(O[g]), f)) {
            const G = s$(i, o, b);
            I.push(O[G[0]], O[G[1]]);
          }
          if (
            ((N = [...N, { placement: i, overflows: I }]),
            !I.every((G) => G <= 0))
          ) {
            var D, j;
            const G = (((D = s.flip) == null ? void 0 : D.index) || 0) + 1,
              Z = R[G];
            if (
              Z &&
              (!(f === "alignment" ? _ !== so(Z) : !1) ||
                N.every((U) => U.overflows[0] > 0 && so(U.placement) === _))
            )
              return {
                data: { index: G, overflows: N },
                reset: { placement: Z },
              };
            let q =
              (j = N.filter((Y) => Y.overflows[0] <= 0).sort(
                (Y, U) => Y.overflows[1] - U.overflows[1]
              )[0]) == null
                ? void 0
                : j.placement;
            if (!q)
              switch (m) {
                case "bestFit": {
                  var $;
                  const Y =
                    ($ = N.filter((U) => {
                      if (A) {
                        const H = so(U.placement);
                        return H === _ || H === "y";
                      }
                      return !0;
                    })
                      .map((U) => [
                        U.placement,
                        U.overflows
                          .filter((H) => H > 0)
                          .reduce((H, X) => H + X, 0),
                      ])
                      .sort((U, H) => U[1] - H[1])[0]) == null
                      ? void 0
                      : $[0];
                  Y && (q = Y);
                  break;
                }
                case "initialPlacement":
                  q = a;
                  break;
              }
            if (i !== q) return { reset: { placement: q } };
          }
          return {};
        },
      }
    );
  };
function vI(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width,
  };
}
function yI(n) {
  return t$.some((e) => n[e] >= 0);
}
const m$ = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "hide",
        options: n,
        async fn(e) {
          const { rects: t } = e,
            { strategy: r = "referenceHidden", ...i } = Qo(n, e);
          switch (r) {
            case "referenceHidden": {
              const s = await Rp(e, { ...i, elementContext: "reference" }),
                o = vI(s, t.reference);
              return {
                data: { referenceHiddenOffsets: o, referenceHidden: yI(o) },
              };
            }
            case "escaped": {
              const s = await Rp(e, { ...i, altBoundary: !0 }),
                o = vI(s, t.floating);
              return { data: { escapedOffsets: o, escaped: yI(o) } };
            }
            default:
              return {};
          }
        },
      }
    );
  },
  J3 = new Set(["left", "top"]);
async function g$(n, e) {
  const { placement: t, platform: r, elements: i } = n,
    s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
    o = ea(t),
    a = wh(t),
    l = so(t) === "y",
    c = J3.has(o) ? -1 : 1,
    u = s && l ? -1 : 1,
    f = Qo(e, n);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: v,
  } = typeof f == "number"
    ? { mainAxis: f, crossAxis: 0, alignmentAxis: null }
    : {
        mainAxis: f.mainAxis || 0,
        crossAxis: f.crossAxis || 0,
        alignmentAxis: f.alignmentAxis,
      };
  return (
    a && typeof v == "number" && (m = a === "end" ? v * -1 : v),
    l ? { x: m * u, y: p * c } : { x: p * c, y: m * u }
  );
}
const v$ = function (n) {
    return (
      n === void 0 && (n = 0),
      {
        name: "offset",
        options: n,
        async fn(e) {
          var t, r;
          const { x: i, y: s, placement: o, middlewareData: a } = e,
            l = await g$(e, n);
          return o === ((t = a.offset) == null ? void 0 : t.placement) &&
            (r = a.arrow) != null &&
            r.alignmentOffset
            ? {}
            : { x: i + l.x, y: s + l.y, data: { ...l, placement: o } };
        },
      }
    );
  },
  y$ = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "shift",
        options: n,
        async fn(e) {
          const { x: t, y: r, placement: i } = e,
            {
              mainAxis: s = !0,
              crossAxis: o = !1,
              limiter: a = {
                fn: (x) => {
                  let { x: g, y: _ } = x;
                  return { x: g, y: _ };
                },
              },
              ...l
            } = Qo(n, e),
            c = { x: t, y: r },
            u = await Rp(e, l),
            f = so(ea(i)),
            p = hM(f);
          let m = c[p],
            v = c[f];
          if (s) {
            const x = p === "y" ? "top" : "left",
              g = p === "y" ? "bottom" : "right",
              _ = m + u[x],
              S = m - u[g];
            m = $b(_, m, S);
          }
          if (o) {
            const x = f === "y" ? "top" : "left",
              g = f === "y" ? "bottom" : "right",
              _ = v + u[x],
              S = v - u[g];
            v = $b(_, v, S);
          }
          const y = a.fn({ ...e, [p]: m, [f]: v });
          return {
            ...y,
            data: { x: y.x - t, y: y.y - r, enabled: { [p]: s, [f]: o } },
          };
        },
      }
    );
  },
  x$ = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        options: n,
        fn(e) {
          const { x: t, y: r, placement: i, rects: s, middlewareData: o } = e,
            { offset: a = 0, mainAxis: l = !0, crossAxis: c = !0 } = Qo(n, e),
            u = { x: t, y: r },
            f = so(i),
            p = hM(f);
          let m = u[p],
            v = u[f];
          const y = Qo(a, e),
            x =
              typeof y == "number"
                ? { mainAxis: y, crossAxis: 0 }
                : { mainAxis: 0, crossAxis: 0, ...y };
          if (l) {
            const S = p === "y" ? "height" : "width",
              b = s.reference[p] - s.floating[S] + x.mainAxis,
              C = s.reference[p] + s.reference[S] - x.mainAxis;
            m < b ? (m = b) : m > C && (m = C);
          }
          if (c) {
            var g, _;
            const S = p === "y" ? "width" : "height",
              b = J3.has(ea(i)),
              C =
                s.reference[f] -
                s.floating[S] +
                ((b && ((g = o.offset) == null ? void 0 : g[f])) || 0) +
                (b ? 0 : x.crossAxis),
              A =
                s.reference[f] +
                s.reference[S] +
                (b ? 0 : ((_ = o.offset) == null ? void 0 : _[f]) || 0) -
                (b ? x.crossAxis : 0);
            v < C ? (v = C) : v > A && (v = A);
          }
          return { [p]: m, [f]: v };
        },
      }
    );
  },
  _$ = function (n) {
    return (
      n === void 0 && (n = {}),
      {
        name: "size",
        options: n,
        async fn(e) {
          var t, r;
          const { placement: i, rects: s, platform: o, elements: a } = e,
            { apply: l = () => {}, ...c } = Qo(n, e),
            u = await Rp(e, c),
            f = ea(i),
            p = wh(i),
            m = so(i) === "y",
            { width: v, height: y } = s.floating;
          let x, g;
          f === "top" || f === "bottom"
            ? ((x = f),
              (g =
                p ===
                ((await (o.isRTL == null ? void 0 : o.isRTL(a.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right"))
            : ((g = f), (x = p === "end" ? "top" : "bottom"));
          const _ = y - u.top - u.bottom,
            S = v - u.left - u.right,
            b = cl(y - u[x], _),
            C = cl(v - u[g], S),
            A = !e.middlewareData.shift;
          let R = b,
            O = C;
          if (
            ((t = e.middlewareData.shift) != null && t.enabled.x && (O = S),
            (r = e.middlewareData.shift) != null && r.enabled.y && (R = _),
            A && !p)
          ) {
            const N = Mi(u.left, 0),
              D = Mi(u.right, 0),
              j = Mi(u.top, 0),
              $ = Mi(u.bottom, 0);
            m
              ? (O = v - 2 * (N !== 0 || D !== 0 ? N + D : Mi(u.left, u.right)))
              : (R =
                  y - 2 * (j !== 0 || $ !== 0 ? j + $ : Mi(u.top, u.bottom)));
          }
          await l({ ...e, availableWidth: O, availableHeight: R });
          const I = await o.getDimensions(a.floating);
          return v !== I.width || y !== I.height
            ? { reset: { rects: !0 } }
            : {};
        },
      }
    );
  };
function Px() {
  return typeof window < "u";
}
function Sh(n) {
  return Z3(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function Ni(n) {
  var e;
  return (
    (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) ||
    window
  );
}
function _o(n) {
  var e;
  return (e = (Z3(n) ? n.ownerDocument : n.document) || window.document) == null
    ? void 0
    : e.documentElement;
}
function Z3(n) {
  return Px() ? n instanceof Node || n instanceof Ni(n).Node : !1;
}
function Us(n) {
  return Px() ? n instanceof Element || n instanceof Ni(n).Element : !1;
}
function yo(n) {
  return Px() ? n instanceof HTMLElement || n instanceof Ni(n).HTMLElement : !1;
}
function xI(n) {
  return !Px() || typeof ShadowRoot > "u"
    ? !1
    : n instanceof ShadowRoot || n instanceof Ni(n).ShadowRoot;
}
const w$ = new Set(["inline", "contents"]);
function gm(n) {
  const { overflow: e, overflowX: t, overflowY: r, display: i } = Fs(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !w$.has(i);
}
const S$ = new Set(["table", "td", "th"]);
function b$(n) {
  return S$.has(Sh(n));
}
const E$ = [":popover-open", ":modal"];
function Ix(n) {
  return E$.some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
const T$ = ["transform", "translate", "scale", "rotate", "perspective"],
  M$ = ["transform", "translate", "scale", "rotate", "perspective", "filter"],
  C$ = ["paint", "layout", "strict", "content"];
function mM(n) {
  const e = gM(),
    t = Us(n) ? Fs(n) : n;
  return (
    T$.some((r) => (t[r] ? t[r] !== "none" : !1)) ||
    (t.containerType ? t.containerType !== "normal" : !1) ||
    (!e && (t.backdropFilter ? t.backdropFilter !== "none" : !1)) ||
    (!e && (t.filter ? t.filter !== "none" : !1)) ||
    M$.some((r) => (t.willChange || "").includes(r)) ||
    C$.some((r) => (t.contain || "").includes(r))
  );
}
function A$(n) {
  let e = ul(n);
  for (; yo(e) && !Qd(e); ) {
    if (mM(e)) return e;
    if (Ix(e)) return null;
    e = ul(e);
  }
  return null;
}
function gM() {
  return typeof CSS > "u" || !CSS.supports
    ? !1
    : CSS.supports("-webkit-backdrop-filter", "none");
}
const R$ = new Set(["html", "body", "#document"]);
function Qd(n) {
  return R$.has(Sh(n));
}
function Fs(n) {
  return Ni(n).getComputedStyle(n);
}
function Nx(n) {
  return Us(n)
    ? { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop }
    : { scrollLeft: n.scrollX, scrollTop: n.scrollY };
}
function ul(n) {
  if (Sh(n) === "html") return n;
  const e = n.assignedSlot || n.parentNode || (xI(n) && n.host) || _o(n);
  return xI(e) ? e.host : e;
}
function Q3(n) {
  const e = ul(n);
  return Qd(e)
    ? n.ownerDocument
      ? n.ownerDocument.body
      : n.body
    : yo(e) && gm(e)
    ? e
    : Q3(e);
}
function Pp(n, e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const i = Q3(n),
    s = i === ((r = n.ownerDocument) == null ? void 0 : r.body),
    o = Ni(i);
  if (s) {
    const a = qb(o);
    return e.concat(
      o,
      o.visualViewport || [],
      gm(i) ? i : [],
      a && t ? Pp(a) : []
    );
  }
  return e.concat(i, Pp(i, [], t));
}
function qb(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function eU(n) {
  const e = Fs(n);
  let t = parseFloat(e.width) || 0,
    r = parseFloat(e.height) || 0;
  const i = yo(n),
    s = i ? n.offsetWidth : t,
    o = i ? n.offsetHeight : r,
    a = s0(t) !== s || s0(r) !== o;
  return a && ((t = s), (r = o)), { width: t, height: r, $: a };
}
function vM(n) {
  return Us(n) ? n : n.contextElement;
}
function Id(n) {
  const e = vM(n);
  if (!yo(e)) return uo(1);
  const t = e.getBoundingClientRect(),
    { width: r, height: i, $: s } = eU(e);
  let o = (s ? s0(t.width) : t.width) / r,
    a = (s ? s0(t.height) : t.height) / i;
  return (
    (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    { x: o, y: a }
  );
}
const P$ = uo(0);
function tU(n) {
  const e = Ni(n);
  return !gM() || !e.visualViewport
    ? P$
    : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function I$(n, e, t) {
  return e === void 0 && (e = !1), !t || (e && t !== Ni(n)) ? !1 : e;
}
function Fc(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(),
    s = vM(n);
  let o = uo(1);
  e && (r ? Us(r) && (o = Id(r)) : (o = Id(n)));
  const a = I$(s, t, r) ? tU(s) : uo(0);
  let l = (i.left + a.x) / o.x,
    c = (i.top + a.y) / o.y,
    u = i.width / o.x,
    f = i.height / o.y;
  if (s) {
    const p = Ni(s),
      m = r && Us(r) ? Ni(r) : r;
    let v = p,
      y = qb(v);
    for (; y && r && m !== v; ) {
      const x = Id(y),
        g = y.getBoundingClientRect(),
        _ = Fs(y),
        S = g.left + (y.clientLeft + parseFloat(_.paddingLeft)) * x.x,
        b = g.top + (y.clientTop + parseFloat(_.paddingTop)) * x.y;
      (l *= x.x),
        (c *= x.y),
        (u *= x.x),
        (f *= x.y),
        (l += S),
        (c += b),
        (v = Ni(y)),
        (y = qb(v));
    }
  }
  return a0({ width: u, height: f, x: l, y: c });
}
function yM(n, e) {
  const t = Nx(n).scrollLeft;
  return e ? e.left + t : Fc(_o(n)).left + t;
}
function nU(n, e, t) {
  t === void 0 && (t = !1);
  const r = n.getBoundingClientRect(),
    i = r.left + e.scrollLeft - (t ? 0 : yM(n, r)),
    s = r.top + e.scrollTop;
  return { x: i, y: s };
}
function N$(n) {
  let { elements: e, rect: t, offsetParent: r, strategy: i } = n;
  const s = i === "fixed",
    o = _o(r),
    a = e ? Ix(e.floating) : !1;
  if (r === o || (a && s)) return t;
  let l = { scrollLeft: 0, scrollTop: 0 },
    c = uo(1);
  const u = uo(0),
    f = yo(r);
  if (
    (f || (!f && !s)) &&
    ((Sh(r) !== "body" || gm(o)) && (l = Nx(r)), yo(r))
  ) {
    const m = Fc(r);
    (c = Id(r)), (u.x = m.x + r.clientLeft), (u.y = m.y + r.clientTop);
  }
  const p = o && !f && !s ? nU(o, l, !0) : uo(0);
  return {
    width: t.width * c.x,
    height: t.height * c.y,
    x: t.x * c.x - l.scrollLeft * c.x + u.x + p.x,
    y: t.y * c.y - l.scrollTop * c.y + u.y + p.y,
  };
}
function L$(n) {
  return Array.from(n.getClientRects());
}
function O$(n) {
  const e = _o(n),
    t = Nx(n),
    r = n.ownerDocument.body,
    i = Mi(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
    s = Mi(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -t.scrollLeft + yM(n);
  const a = -t.scrollTop;
  return (
    Fs(r).direction === "rtl" && (o += Mi(e.clientWidth, r.clientWidth) - i),
    { width: i, height: s, x: o, y: a }
  );
}
function D$(n, e) {
  const t = Ni(n),
    r = _o(n),
    i = t.visualViewport;
  let s = r.clientWidth,
    o = r.clientHeight,
    a = 0,
    l = 0;
  if (i) {
    (s = i.width), (o = i.height);
    const c = gM();
    (!c || (c && e === "fixed")) && ((a = i.offsetLeft), (l = i.offsetTop));
  }
  return { width: s, height: o, x: a, y: l };
}
const k$ = new Set(["absolute", "fixed"]);
function U$(n, e) {
  const t = Fc(n, !0, e === "fixed"),
    r = t.top + n.clientTop,
    i = t.left + n.clientLeft,
    s = yo(n) ? Id(n) : uo(1),
    o = n.clientWidth * s.x,
    a = n.clientHeight * s.y,
    l = i * s.x,
    c = r * s.y;
  return { width: o, height: a, x: l, y: c };
}
function _I(n, e, t) {
  let r;
  if (e === "viewport") r = D$(n, t);
  else if (e === "document") r = O$(_o(n));
  else if (Us(e)) r = U$(e, t);
  else {
    const i = tU(n);
    r = { x: e.x - i.x, y: e.y - i.y, width: e.width, height: e.height };
  }
  return a0(r);
}
function rU(n, e) {
  const t = ul(n);
  return t === e || !Us(t) || Qd(t)
    ? !1
    : Fs(t).position === "fixed" || rU(t, e);
}
function F$(n, e) {
  const t = e.get(n);
  if (t) return t;
  let r = Pp(n, [], !1).filter((a) => Us(a) && Sh(a) !== "body"),
    i = null;
  const s = Fs(n).position === "fixed";
  let o = s ? ul(n) : n;
  for (; Us(o) && !Qd(o); ) {
    const a = Fs(o),
      l = mM(o);
    !l && a.position === "fixed" && (i = null),
      (
        s
          ? !l && !i
          : (!l && a.position === "static" && !!i && k$.has(i.position)) ||
            (gm(o) && !l && rU(n, o))
      )
        ? (r = r.filter((u) => u !== o))
        : (i = a),
      (o = ul(o));
  }
  return e.set(n, r), r;
}
function B$(n) {
  let { element: e, boundary: t, rootBoundary: r, strategy: i } = n;
  const o = [
      ...(t === "clippingAncestors"
        ? Ix(e)
          ? []
          : F$(e, this._c)
        : [].concat(t)),
      r,
    ],
    a = o[0],
    l = o.reduce((c, u) => {
      const f = _I(e, u, i);
      return (
        (c.top = Mi(f.top, c.top)),
        (c.right = cl(f.right, c.right)),
        (c.bottom = cl(f.bottom, c.bottom)),
        (c.left = Mi(f.left, c.left)),
        c
      );
    }, _I(e, a, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top,
  };
}
function z$(n) {
  const { width: e, height: t } = eU(n);
  return { width: e, height: t };
}
function V$(n, e, t) {
  const r = yo(e),
    i = _o(e),
    s = t === "fixed",
    o = Fc(n, !0, s, e);
  let a = { scrollLeft: 0, scrollTop: 0 };
  const l = uo(0);
  function c() {
    l.x = yM(i);
  }
  if (r || (!r && !s))
    if (((Sh(e) !== "body" || gm(i)) && (a = Nx(e)), r)) {
      const m = Fc(e, !0, s, e);
      (l.x = m.x + e.clientLeft), (l.y = m.y + e.clientTop);
    } else i && c();
  s && !r && i && c();
  const u = i && !r && !s ? nU(i, a) : uo(0),
    f = o.left + a.scrollLeft - l.x - u.x,
    p = o.top + a.scrollTop - l.y - u.y;
  return { x: f, y: p, width: o.width, height: o.height };
}
function pS(n) {
  return Fs(n).position === "static";
}
function wI(n, e) {
  if (!yo(n) || Fs(n).position === "fixed") return null;
  if (e) return e(n);
  let t = n.offsetParent;
  return _o(n) === t && (t = t.ownerDocument.body), t;
}
function iU(n, e) {
  const t = Ni(n);
  if (Ix(n)) return t;
  if (!yo(n)) {
    let i = ul(n);
    for (; i && !Qd(i); ) {
      if (Us(i) && !pS(i)) return i;
      i = ul(i);
    }
    return t;
  }
  let r = wI(n, e);
  for (; r && b$(r) && pS(r); ) r = wI(r, e);
  return r && Qd(r) && pS(r) && !mM(r) ? t : r || A$(n) || t;
}
const j$ = async function (n) {
  const e = this.getOffsetParent || iU,
    t = this.getDimensions,
    r = await t(n.floating);
  return {
    reference: V$(n.reference, await e(n.floating), n.strategy),
    floating: { x: 0, y: 0, width: r.width, height: r.height },
  };
};
function H$(n) {
  return Fs(n).direction === "rtl";
}
const W$ = {
  convertOffsetParentRelativeRectToViewportRelativeRect: N$,
  getDocumentElement: _o,
  getClippingRect: B$,
  getOffsetParent: iU,
  getElementRects: j$,
  getClientRects: L$,
  getDimensions: z$,
  getScale: Id,
  isElement: Us,
  isRTL: H$,
};
function sU(n, e) {
  return (
    n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height
  );
}
function G$(n, e) {
  let t = null,
    r;
  const i = _o(n);
  function s() {
    var a;
    clearTimeout(r), (a = t) == null || a.disconnect(), (t = null);
  }
  function o(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), s();
    const c = n.getBoundingClientRect(),
      { left: u, top: f, width: p, height: m } = c;
    if ((a || e(), !p || !m)) return;
    const v = Jg(f),
      y = Jg(i.clientWidth - (u + p)),
      x = Jg(i.clientHeight - (f + m)),
      g = Jg(u),
      S = {
        rootMargin: -v + "px " + -y + "px " + -x + "px " + -g + "px",
        threshold: Mi(0, cl(1, l)) || 1,
      };
    let b = !0;
    function C(A) {
      const R = A[0].intersectionRatio;
      if (R !== l) {
        if (!b) return o();
        R
          ? o(!1, R)
          : (r = setTimeout(() => {
              o(!1, 1e-7);
            }, 1e3));
      }
      R === 1 && !sU(c, n.getBoundingClientRect()) && o(), (b = !1);
    }
    try {
      t = new IntersectionObserver(C, { ...S, root: i.ownerDocument });
    } catch {
      t = new IntersectionObserver(C, S);
    }
    t.observe(n);
  }
  return o(!0), s;
}
function $$(n, e, t, r) {
  r === void 0 && (r = {});
  const {
      ancestorScroll: i = !0,
      ancestorResize: s = !0,
      elementResize: o = typeof ResizeObserver == "function",
      layoutShift: a = typeof IntersectionObserver == "function",
      animationFrame: l = !1,
    } = r,
    c = vM(n),
    u = i || s ? [...(c ? Pp(c) : []), ...Pp(e)] : [];
  u.forEach((g) => {
    i && g.addEventListener("scroll", t, { passive: !0 }),
      s && g.addEventListener("resize", t);
  });
  const f = c && a ? G$(c, t) : null;
  let p = -1,
    m = null;
  o &&
    ((m = new ResizeObserver((g) => {
      let [_] = g;
      _ &&
        _.target === c &&
        m &&
        (m.unobserve(e),
        cancelAnimationFrame(p),
        (p = requestAnimationFrame(() => {
          var S;
          (S = m) == null || S.observe(e);
        }))),
        t();
    })),
    c && !l && m.observe(c),
    m.observe(e));
  let v,
    y = l ? Fc(n) : null;
  l && x();
  function x() {
    const g = Fc(n);
    y && !sU(y, g) && t(), (y = g), (v = requestAnimationFrame(x));
  }
  return (
    t(),
    () => {
      var g;
      u.forEach((_) => {
        i && _.removeEventListener("scroll", t),
          s && _.removeEventListener("resize", t);
      }),
        f == null || f(),
        (g = m) == null || g.disconnect(),
        (m = null),
        l && cancelAnimationFrame(v);
    }
  );
}
const X$ = v$,
  q$ = y$,
  K$ = p$,
  Y$ = _$,
  J$ = m$,
  SI = f$,
  Z$ = x$,
  Q$ = (n, e, t) => {
    const r = new Map(),
      i = { platform: W$, ...t },
      s = { ...i.platform, _c: r };
    return h$(n, e, { ...i, platform: s });
  };
var e9 = typeof document < "u",
  t9 = function () {},
  by = e9 ? P.useLayoutEffect : t9;
function l0(n, e) {
  if (n === e) return !0;
  if (typeof n != typeof e) return !1;
  if (typeof n == "function" && n.toString() === e.toString()) return !0;
  let t, r, i;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (((t = n.length), t !== e.length)) return !1;
      for (r = t; r-- !== 0; ) if (!l0(n[r], e[r])) return !1;
      return !0;
    }
    if (((i = Object.keys(n)), (t = i.length), t !== Object.keys(e).length))
      return !1;
    for (r = t; r-- !== 0; ) if (!{}.hasOwnProperty.call(e, i[r])) return !1;
    for (r = t; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && n.$$typeof) && !l0(n[s], e[s])) return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function oU(n) {
  return typeof window > "u"
    ? 1
    : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function bI(n, e) {
  const t = oU(n);
  return Math.round(e * t) / t;
}
function mS(n) {
  const e = P.useRef(n);
  return (
    by(() => {
      e.current = n;
    }),
    e
  );
}
function n9(n) {
  n === void 0 && (n = {});
  const {
      placement: e = "bottom",
      strategy: t = "absolute",
      middleware: r = [],
      platform: i,
      elements: { reference: s, floating: o } = {},
      transform: a = !0,
      whileElementsMounted: l,
      open: c,
    } = n,
    [u, f] = P.useState({
      x: 0,
      y: 0,
      strategy: t,
      placement: e,
      middlewareData: {},
      isPositioned: !1,
    }),
    [p, m] = P.useState(r);
  l0(p, r) || m(r);
  const [v, y] = P.useState(null),
    [x, g] = P.useState(null),
    _ = P.useCallback((U) => {
      U !== A.current && ((A.current = U), y(U));
    }, []),
    S = P.useCallback((U) => {
      U !== R.current && ((R.current = U), g(U));
    }, []),
    b = s || v,
    C = o || x,
    A = P.useRef(null),
    R = P.useRef(null),
    O = P.useRef(u),
    I = l != null,
    N = mS(l),
    D = mS(i),
    j = mS(c),
    $ = P.useCallback(() => {
      if (!A.current || !R.current) return;
      const U = { placement: e, strategy: t, middleware: p };
      D.current && (U.platform = D.current),
        Q$(A.current, R.current, U).then((H) => {
          const X = { ...H, isPositioned: j.current !== !1 };
          G.current &&
            !l0(O.current, X) &&
            ((O.current = X),
            qc.flushSync(() => {
              f(X);
            }));
        });
    }, [p, e, t, D, j]);
  by(() => {
    c === !1 &&
      O.current.isPositioned &&
      ((O.current.isPositioned = !1), f((U) => ({ ...U, isPositioned: !1 })));
  }, [c]);
  const G = P.useRef(!1);
  by(
    () => (
      (G.current = !0),
      () => {
        G.current = !1;
      }
    ),
    []
  ),
    by(() => {
      if ((b && (A.current = b), C && (R.current = C), b && C)) {
        if (N.current) return N.current(b, C, $);
        $();
      }
    }, [b, C, $, N, I]);
  const Z = P.useMemo(
      () => ({ reference: A, floating: R, setReference: _, setFloating: S }),
      [_, S]
    ),
    q = P.useMemo(() => ({ reference: b, floating: C }), [b, C]),
    Y = P.useMemo(() => {
      const U = { position: t, left: 0, top: 0 };
      if (!q.floating) return U;
      const H = bI(q.floating, u.x),
        X = bI(q.floating, u.y);
      return a
        ? {
            ...U,
            transform: "translate(" + H + "px, " + X + "px)",
            ...(oU(q.floating) >= 1.5 && { willChange: "transform" }),
          }
        : { position: t, left: H, top: X };
    }, [t, a, q.floating, u.x, u.y]);
  return P.useMemo(
    () => ({ ...u, update: $, refs: Z, elements: q, floatingStyles: Y }),
    [u, $, Z, q, Y]
  );
}
const r9 = (n) => {
    function e(t) {
      return {}.hasOwnProperty.call(t, "current");
    }
    return {
      name: "arrow",
      options: n,
      fn(t) {
        const { element: r, padding: i } = typeof n == "function" ? n(t) : n;
        return r && e(r)
          ? r.current != null
            ? SI({ element: r.current, padding: i }).fn(t)
            : {}
          : r
          ? SI({ element: r, padding: i }).fn(t)
          : {};
      },
    };
  },
  i9 = (n, e) => ({ ...X$(n), options: [n, e] }),
  s9 = (n, e) => ({ ...q$(n), options: [n, e] }),
  o9 = (n, e) => ({ ...Z$(n), options: [n, e] }),
  a9 = (n, e) => ({ ...K$(n), options: [n, e] }),
  l9 = (n, e) => ({ ...Y$(n), options: [n, e] }),
  c9 = (n, e) => ({ ...J$(n), options: [n, e] }),
  u9 = (n, e) => ({ ...r9(n), options: [n, e] });
var d9 = "Arrow",
  aU = P.forwardRef((n, e) => {
    const { children: t, width: r = 10, height: i = 5, ...s } = n;
    return T.jsx(Kt.svg, {
      ...s,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? t : T.jsx("polygon", { points: "0,0 30,0 15,10" }),
    });
  });
aU.displayName = d9;
var h9 = aU;
function f9(n) {
  const [e, t] = P.useState(void 0);
  return (
    yr(() => {
      if (n) {
        t({ width: n.offsetWidth, height: n.offsetHeight });
        const r = new ResizeObserver((i) => {
          if (!Array.isArray(i) || !i.length) return;
          const s = i[0];
          let o, a;
          if ("borderBoxSize" in s) {
            const l = s.borderBoxSize,
              c = Array.isArray(l) ? l[0] : l;
            (o = c.inlineSize), (a = c.blockSize);
          } else (o = n.offsetWidth), (a = n.offsetHeight);
          t({ width: o, height: a });
        });
        return r.observe(n, { box: "border-box" }), () => r.unobserve(n);
      } else t(void 0);
    }, [n]),
    e
  );
}
var xM = "Popper",
  [lU, Lx] = yh(xM),
  [p9, cU] = lU(xM),
  uU = (n) => {
    const { __scopePopper: e, children: t } = n,
      [r, i] = P.useState(null);
    return T.jsx(p9, { scope: e, anchor: r, onAnchorChange: i, children: t });
  };
uU.displayName = xM;
var dU = "PopperAnchor",
  hU = P.forwardRef((n, e) => {
    const { __scopePopper: t, virtualRef: r, ...i } = n,
      s = cU(dU, t),
      o = P.useRef(null),
      a = pn(e, o);
    return (
      P.useEffect(() => {
        s.onAnchorChange((r == null ? void 0 : r.current) || o.current);
      }),
      r ? null : T.jsx(Kt.div, { ...i, ref: a })
    );
  });
hU.displayName = dU;
var _M = "PopperContent",
  [m9, g9] = lU(_M),
  fU = P.forwardRef((n, e) => {
    var re, Be, Ue, Fe, Ke, Ve;
    const {
        __scopePopper: t,
        side: r = "bottom",
        sideOffset: i = 0,
        align: s = "center",
        alignOffset: o = 0,
        arrowPadding: a = 0,
        avoidCollisions: l = !0,
        collisionBoundary: c = [],
        collisionPadding: u = 0,
        sticky: f = "partial",
        hideWhenDetached: p = !1,
        updatePositionStrategy: m = "optimized",
        onPlaced: v,
        ...y
      } = n,
      x = cU(_M, t),
      [g, _] = P.useState(null),
      S = pn(e, (W) => _(W)),
      [b, C] = P.useState(null),
      A = f9(b),
      R = (A == null ? void 0 : A.width) ?? 0,
      O = (A == null ? void 0 : A.height) ?? 0,
      I = r + (s !== "center" ? "-" + s : ""),
      N =
        typeof u == "number"
          ? u
          : { top: 0, right: 0, bottom: 0, left: 0, ...u },
      D = Array.isArray(c) ? c : [c],
      j = D.length > 0,
      $ = { padding: N, boundary: D.filter(y9), altBoundary: j },
      {
        refs: G,
        floatingStyles: Z,
        placement: q,
        isPositioned: Y,
        middlewareData: U,
      } = n9({
        strategy: "fixed",
        placement: I,
        whileElementsMounted: (...W) =>
          $$(...W, { animationFrame: m === "always" }),
        elements: { reference: x.anchor },
        middleware: [
          i9({ mainAxis: i + O, alignmentAxis: o }),
          l &&
            s9({
              mainAxis: !0,
              crossAxis: !1,
              limiter: f === "partial" ? o9() : void 0,
              ...$,
            }),
          l && a9({ ...$ }),
          l9({
            ...$,
            apply: ({
              elements: W,
              rects: ge,
              availableWidth: pe,
              availableHeight: Se,
            }) => {
              const { width: me, height: Oe } = ge.reference,
                Te = W.floating.style;
              Te.setProperty("--radix-popper-available-width", `${pe}px`),
                Te.setProperty("--radix-popper-available-height", `${Se}px`),
                Te.setProperty("--radix-popper-anchor-width", `${me}px`),
                Te.setProperty("--radix-popper-anchor-height", `${Oe}px`);
            },
          }),
          b && u9({ element: b, padding: a }),
          x9({ arrowWidth: R, arrowHeight: O }),
          p && c9({ strategy: "referenceHidden", ...$ }),
        ],
      }),
      [H, X] = gU(q),
      ie = ks(v);
    yr(() => {
      Y && (ie == null || ie());
    }, [Y, ie]);
    const de = (re = U.arrow) == null ? void 0 : re.x,
      Ee = (Be = U.arrow) == null ? void 0 : Be.y,
      Ie = ((Ue = U.arrow) == null ? void 0 : Ue.centerOffset) !== 0,
      [se, _e] = P.useState();
    return (
      yr(() => {
        g && _e(window.getComputedStyle(g).zIndex);
      }, [g]),
      T.jsx("div", {
        ref: G.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...Z,
          transform: Y ? Z.transform : "translate(0, -200%)",
          minWidth: "max-content",
          zIndex: se,
          "--radix-popper-transform-origin": [
            (Fe = U.transformOrigin) == null ? void 0 : Fe.x,
            (Ke = U.transformOrigin) == null ? void 0 : Ke.y,
          ].join(" "),
          ...(((Ve = U.hide) == null ? void 0 : Ve.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none",
          }),
        },
        dir: n.dir,
        children: T.jsx(m9, {
          scope: t,
          placedSide: H,
          onArrowChange: C,
          arrowX: de,
          arrowY: Ee,
          shouldHideArrow: Ie,
          children: T.jsx(Kt.div, {
            "data-side": H,
            "data-align": X,
            ...y,
            ref: S,
            style: { ...y.style, animation: Y ? void 0 : "none" },
          }),
        }),
      })
    );
  });
fU.displayName = _M;
var pU = "PopperArrow",
  v9 = { top: "bottom", right: "left", bottom: "top", left: "right" },
  mU = P.forwardRef(function (e, t) {
    const { __scopePopper: r, ...i } = e,
      s = g9(pU, r),
      o = v9[s.placedSide];
    return T.jsx("span", {
      ref: s.onArrowChange,
      style: {
        position: "absolute",
        left: s.arrowX,
        top: s.arrowY,
        [o]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0",
        }[s.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)",
        }[s.placedSide],
        visibility: s.shouldHideArrow ? "hidden" : void 0,
      },
      children: T.jsx(h9, {
        ...i,
        ref: t,
        style: { ...i.style, display: "block" },
      }),
    });
  });
mU.displayName = pU;
function y9(n) {
  return n !== null;
}
var x9 = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var x, g, _;
    const { placement: t, rects: r, middlewareData: i } = e,
      o = ((x = i.arrow) == null ? void 0 : x.centerOffset) !== 0,
      a = o ? 0 : n.arrowWidth,
      l = o ? 0 : n.arrowHeight,
      [c, u] = gU(t),
      f = { start: "0%", center: "50%", end: "100%" }[u],
      p = (((g = i.arrow) == null ? void 0 : g.x) ?? 0) + a / 2,
      m = (((_ = i.arrow) == null ? void 0 : _.y) ?? 0) + l / 2;
    let v = "",
      y = "";
    return (
      c === "bottom"
        ? ((v = o ? f : `${p}px`), (y = `${-l}px`))
        : c === "top"
        ? ((v = o ? f : `${p}px`), (y = `${r.floating.height + l}px`))
        : c === "right"
        ? ((v = `${-l}px`), (y = o ? f : `${m}px`))
        : c === "left" &&
          ((v = `${r.floating.width + l}px`), (y = o ? f : `${m}px`)),
      { data: { x: v, y } }
    );
  },
});
function gU(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
var _9 = uU,
  vU = hU,
  yU = fU,
  xU = mU,
  [Ox, Jde] = yh("Tooltip", [Lx]),
  wM = Lx(),
  _U = "TooltipProvider",
  w9 = 700,
  EI = "tooltip.open",
  [S9, wU] = Ox(_U),
  SU = (n) => {
    const {
        __scopeTooltip: e,
        delayDuration: t = w9,
        skipDelayDuration: r = 300,
        disableHoverableContent: i = !1,
        children: s,
      } = n,
      o = P.useRef(!0),
      a = P.useRef(!1),
      l = P.useRef(0);
    return (
      P.useEffect(() => {
        const c = l.current;
        return () => window.clearTimeout(c);
      }, []),
      T.jsx(S9, {
        scope: e,
        isOpenDelayedRef: o,
        delayDuration: t,
        onOpen: P.useCallback(() => {
          window.clearTimeout(l.current), (o.current = !1);
        }, []),
        onClose: P.useCallback(() => {
          window.clearTimeout(l.current),
            (l.current = window.setTimeout(() => (o.current = !0), r));
        }, [r]),
        isPointerInTransitRef: a,
        onPointerInTransitChange: P.useCallback((c) => {
          a.current = c;
        }, []),
        disableHoverableContent: i,
        children: s,
      })
    );
  };
SU.displayName = _U;
var bU = "Tooltip",
  [Zde, Dx] = Ox(bU),
  Kb = "TooltipTrigger",
  b9 = P.forwardRef((n, e) => {
    const { __scopeTooltip: t, ...r } = n,
      i = Dx(Kb, t),
      s = wU(Kb, t),
      o = wM(t),
      a = P.useRef(null),
      l = pn(e, a, i.onTriggerChange),
      c = P.useRef(!1),
      u = P.useRef(!1),
      f = P.useCallback(() => (c.current = !1), []);
    return (
      P.useEffect(
        () => () => document.removeEventListener("pointerup", f),
        [f]
      ),
      T.jsx(vU, {
        asChild: !0,
        ...o,
        children: T.jsx(Kt.button, {
          "aria-describedby": i.open ? i.contentId : void 0,
          "data-state": i.stateAttribute,
          ...r,
          ref: l,
          onPointerMove: Bt(n.onPointerMove, (p) => {
            p.pointerType !== "touch" &&
              !u.current &&
              !s.isPointerInTransitRef.current &&
              (i.onTriggerEnter(), (u.current = !0));
          }),
          onPointerLeave: Bt(n.onPointerLeave, () => {
            i.onTriggerLeave(), (u.current = !1);
          }),
          onPointerDown: Bt(n.onPointerDown, () => {
            i.open && i.onClose(),
              (c.current = !0),
              document.addEventListener("pointerup", f, { once: !0 });
          }),
          onFocus: Bt(n.onFocus, () => {
            c.current || i.onOpen();
          }),
          onBlur: Bt(n.onBlur, i.onClose),
          onClick: Bt(n.onClick, i.onClose),
        }),
      })
    );
  });
b9.displayName = Kb;
var E9 = "TooltipPortal",
  [Qde, T9] = Ox(E9, { forceMount: void 0 }),
  eh = "TooltipContent",
  EU = P.forwardRef((n, e) => {
    const t = T9(eh, n.__scopeTooltip),
      { forceMount: r = t.forceMount, side: i = "top", ...s } = n,
      o = Dx(eh, n.__scopeTooltip);
    return T.jsx(xh, {
      present: r || o.open,
      children: o.disableHoverableContent
        ? T.jsx(TU, { side: i, ...s, ref: e })
        : T.jsx(M9, { side: i, ...s, ref: e }),
    });
  }),
  M9 = P.forwardRef((n, e) => {
    const t = Dx(eh, n.__scopeTooltip),
      r = wU(eh, n.__scopeTooltip),
      i = P.useRef(null),
      s = pn(e, i),
      [o, a] = P.useState(null),
      { trigger: l, onClose: c } = t,
      u = i.current,
      { onPointerInTransitChange: f } = r,
      p = P.useCallback(() => {
        a(null), f(!1);
      }, [f]),
      m = P.useCallback(
        (v, y) => {
          const x = v.currentTarget,
            g = { x: v.clientX, y: v.clientY },
            _ = I9(g, x.getBoundingClientRect()),
            S = N9(g, _),
            b = L9(y.getBoundingClientRect()),
            C = D9([...S, ...b]);
          a(C), f(!0);
        },
        [f]
      );
    return (
      P.useEffect(() => () => p(), [p]),
      P.useEffect(() => {
        if (l && u) {
          const v = (x) => m(x, u),
            y = (x) => m(x, l);
          return (
            l.addEventListener("pointerleave", v),
            u.addEventListener("pointerleave", y),
            () => {
              l.removeEventListener("pointerleave", v),
                u.removeEventListener("pointerleave", y);
            }
          );
        }
      }, [l, u, m, p]),
      P.useEffect(() => {
        if (o) {
          const v = (y) => {
            const x = y.target,
              g = { x: y.clientX, y: y.clientY },
              _ =
                (l == null ? void 0 : l.contains(x)) ||
                (u == null ? void 0 : u.contains(x)),
              S = !O9(g, o);
            _ ? p() : S && (p(), c());
          };
          return (
            document.addEventListener("pointermove", v),
            () => document.removeEventListener("pointermove", v)
          );
        }
      }, [l, u, o, c, p]),
      T.jsx(TU, { ...n, ref: s })
    );
  }),
  [C9, A9] = Ox(bU, { isInside: !1 }),
  R9 = kG("TooltipContent"),
  TU = P.forwardRef((n, e) => {
    const {
        __scopeTooltip: t,
        children: r,
        "aria-label": i,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        ...a
      } = n,
      l = Dx(eh, t),
      c = wM(t),
      { onClose: u } = l;
    return (
      P.useEffect(
        () => (
          document.addEventListener(EI, u),
          () => document.removeEventListener(EI, u)
        ),
        [u]
      ),
      P.useEffect(() => {
        if (l.trigger) {
          const f = (p) => {
            const m = p.target;
            m != null && m.contains(l.trigger) && u();
          };
          return (
            window.addEventListener("scroll", f, { capture: !0 }),
            () => window.removeEventListener("scroll", f, { capture: !0 })
          );
        }
      }, [l.trigger, u]),
      T.jsx(pm, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        onFocusOutside: (f) => f.preventDefault(),
        onDismiss: u,
        children: T.jsxs(yU, {
          "data-state": l.stateAttribute,
          ...c,
          ...a,
          ref: e,
          style: {
            ...a.style,
            "--radix-tooltip-content-transform-origin":
              "var(--radix-popper-transform-origin)",
            "--radix-tooltip-content-available-width":
              "var(--radix-popper-available-width)",
            "--radix-tooltip-content-available-height":
              "var(--radix-popper-available-height)",
            "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-tooltip-trigger-height":
              "var(--radix-popper-anchor-height)",
          },
          children: [
            T.jsx(R9, { children: r }),
            T.jsx(C9, {
              scope: t,
              isInside: !0,
              children: T.jsx(i8, {
                id: l.contentId,
                role: "tooltip",
                children: i || r,
              }),
            }),
          ],
        }),
      })
    );
  });
EU.displayName = eh;
var MU = "TooltipArrow",
  P9 = P.forwardRef((n, e) => {
    const { __scopeTooltip: t, ...r } = n,
      i = wM(t);
    return A9(MU, t).isInside ? null : T.jsx(xU, { ...i, ...r, ref: e });
  });
P9.displayName = MU;
function I9(n, e) {
  const t = Math.abs(e.top - n.y),
    r = Math.abs(e.bottom - n.y),
    i = Math.abs(e.right - n.x),
    s = Math.abs(e.left - n.x);
  switch (Math.min(t, r, i, s)) {
    case s:
      return "left";
    case i:
      return "right";
    case t:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function N9(n, e, t = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push({ x: n.x - t, y: n.y + t }, { x: n.x + t, y: n.y + t });
      break;
    case "bottom":
      r.push({ x: n.x - t, y: n.y - t }, { x: n.x + t, y: n.y - t });
      break;
    case "left":
      r.push({ x: n.x + t, y: n.y - t }, { x: n.x + t, y: n.y + t });
      break;
    case "right":
      r.push({ x: n.x - t, y: n.y - t }, { x: n.x - t, y: n.y + t });
      break;
  }
  return r;
}
function L9(n) {
  const { top: e, right: t, bottom: r, left: i } = n;
  return [
    { x: i, y: e },
    { x: t, y: e },
    { x: t, y: r },
    { x: i, y: r },
  ];
}
function O9(n, e) {
  const { x: t, y: r } = n;
  let i = !1;
  for (let s = 0, o = e.length - 1; s < e.length; o = s++) {
    const a = e[s],
      l = e[o],
      c = a.x,
      u = a.y,
      f = l.x,
      p = l.y;
    u > r != p > r && t < ((f - c) * (r - u)) / (p - u) + c && (i = !i);
  }
  return i;
}
function D9(n) {
  const e = n.slice();
  return (
    e.sort((t, r) =>
      t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0
    ),
    k9(e)
  );
}
function k9(n) {
  if (n.length <= 1) return n.slice();
  const e = [];
  for (let r = 0; r < n.length; r++) {
    const i = n[r];
    for (; e.length >= 2; ) {
      const s = e[e.length - 1],
        o = e[e.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) e.pop();
      else break;
    }
    e.push(i);
  }
  e.pop();
  const t = [];
  for (let r = n.length - 1; r >= 0; r--) {
    const i = n[r];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1],
        o = t[t.length - 2];
      if ((s.x - o.x) * (i.y - o.y) >= (s.y - o.y) * (i.x - o.x)) t.pop();
      else break;
    }
    t.push(i);
  }
  return (
    t.pop(),
    e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y
      ? e
      : e.concat(t)
  );
}
var U9 = SU,
  CU = EU;
const F9 = U9,
  B9 = P.forwardRef(({ className: n, sideOffset: e = 4, ...t }, r) =>
    T.jsx(CU, {
      ref: r,
      sideOffset: e,
      className: qt(
        "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        n
      ),
      ...t,
    })
  );
B9.displayName = CU.displayName;
var kx = class {
    constructor() {
      (this.listeners = new Set()),
        (this.subscribe = this.subscribe.bind(this));
    }
    subscribe(n) {
      return (
        this.listeners.add(n),
        this.onSubscribe(),
        () => {
          this.listeners.delete(n), this.onUnsubscribe();
        }
      );
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {}
    onUnsubscribe() {}
  },
  Ux = typeof window > "u" || "Deno" in globalThis;
function bs() {}
function z9(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function V9(n) {
  return typeof n == "number" && n >= 0 && n !== 1 / 0;
}
function j9(n, e) {
  return Math.max(n + (e || 0) - Date.now(), 0);
}
function Yb(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function H9(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function TI(n, e) {
  const {
    type: t = "all",
    exact: r,
    fetchStatus: i,
    predicate: s,
    queryKey: o,
    stale: a,
  } = n;
  if (o) {
    if (r) {
      if (e.queryHash !== SM(o, e.options)) return !1;
    } else if (!Np(e.queryKey, o)) return !1;
  }
  if (t !== "all") {
    const l = e.isActive();
    if ((t === "active" && !l) || (t === "inactive" && l)) return !1;
  }
  return !(
    (typeof a == "boolean" && e.isStale() !== a) ||
    (i && i !== e.state.fetchStatus) ||
    (s && !s(e))
  );
}
function MI(n, e) {
  const { exact: t, status: r, predicate: i, mutationKey: s } = n;
  if (s) {
    if (!e.options.mutationKey) return !1;
    if (t) {
      if (Ip(e.options.mutationKey) !== Ip(s)) return !1;
    } else if (!Np(e.options.mutationKey, s)) return !1;
  }
  return !((r && e.state.status !== r) || (i && !i(e)));
}
function SM(n, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || Ip)(n);
}
function Ip(n) {
  return JSON.stringify(n, (e, t) =>
    Jb(t)
      ? Object.keys(t)
          .sort()
          .reduce((r, i) => ((r[i] = t[i]), r), {})
      : t
  );
}
function Np(n, e) {
  return n === e
    ? !0
    : typeof n != typeof e
    ? !1
    : n && e && typeof n == "object" && typeof e == "object"
    ? Object.keys(e).every((t) => Np(n[t], e[t]))
    : !1;
}
function AU(n, e) {
  if (n === e) return n;
  const t = CI(n) && CI(e);
  if (t || (Jb(n) && Jb(e))) {
    const r = t ? n : Object.keys(n),
      i = r.length,
      s = t ? e : Object.keys(e),
      o = s.length,
      a = t ? [] : {},
      l = new Set(r);
    let c = 0;
    for (let u = 0; u < o; u++) {
      const f = t ? u : s[u];
      ((!t && l.has(f)) || t) && n[f] === void 0 && e[f] === void 0
        ? ((a[f] = void 0), c++)
        : ((a[f] = AU(n[f], e[f])), a[f] === n[f] && n[f] !== void 0 && c++);
    }
    return i === o && c === i ? n : a;
  }
  return e;
}
function CI(n) {
  return Array.isArray(n) && n.length === Object.keys(n).length;
}
function Jb(n) {
  if (!AI(n)) return !1;
  const e = n.constructor;
  if (e === void 0) return !0;
  const t = e.prototype;
  return !(
    !AI(t) ||
    !t.hasOwnProperty("isPrototypeOf") ||
    Object.getPrototypeOf(n) !== Object.prototype
  );
}
function AI(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
function W9(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function G9(n, e, t) {
  return typeof t.structuralSharing == "function"
    ? t.structuralSharing(n, e)
    : t.structuralSharing !== !1
    ? AU(n, e)
    : e;
}
function $9(n, e, t = 0) {
  const r = [...n, e];
  return t && r.length > t ? r.slice(1) : r;
}
function X9(n, e, t = 0) {
  const r = [e, ...n];
  return t && r.length > t ? r.slice(0, -1) : r;
}
var bM = Symbol();
function RU(n, e) {
  return !n.queryFn && e != null && e.initialPromise
    ? () => e.initialPromise
    : !n.queryFn || n.queryFn === bM
    ? () => Promise.reject(new Error(`Missing queryFn: '${n.queryHash}'`))
    : n.queryFn;
}
var xc,
  ja,
  Ud,
  OO,
  q9 =
    ((OO = class extends kx {
      constructor() {
        super();
        Qt(this, xc);
        Qt(this, ja);
        Qt(this, Ud);
        It(this, Ud, (e) => {
          if (!Ux && window.addEventListener) {
            const t = () => e();
            return (
              window.addEventListener("visibilitychange", t, !1),
              () => {
                window.removeEventListener("visibilitychange", t);
              }
            );
          }
        });
      }
      onSubscribe() {
        ve(this, ja) || this.setEventListener(ve(this, Ud));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = ve(this, ja)) == null || e.call(this), It(this, ja, void 0));
      }
      setEventListener(e) {
        var t;
        It(this, Ud, e),
          (t = ve(this, ja)) == null || t.call(this),
          It(
            this,
            ja,
            e((r) => {
              typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
            })
          );
      }
      setFocused(e) {
        ve(this, xc) !== e && (It(this, xc, e), this.onFocus());
      }
      onFocus() {
        const e = this.isFocused();
        this.listeners.forEach((t) => {
          t(e);
        });
      }
      isFocused() {
        var e;
        return typeof ve(this, xc) == "boolean"
          ? ve(this, xc)
          : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !==
              "hidden";
      }
    }),
    (xc = new WeakMap()),
    (ja = new WeakMap()),
    (Ud = new WeakMap()),
    OO),
  PU = new q9(),
  Fd,
  Ha,
  Bd,
  DO,
  K9 =
    ((DO = class extends kx {
      constructor() {
        super();
        Qt(this, Fd, !0);
        Qt(this, Ha);
        Qt(this, Bd);
        It(this, Bd, (e) => {
          if (!Ux && window.addEventListener) {
            const t = () => e(!0),
              r = () => e(!1);
            return (
              window.addEventListener("online", t, !1),
              window.addEventListener("offline", r, !1),
              () => {
                window.removeEventListener("online", t),
                  window.removeEventListener("offline", r);
              }
            );
          }
        });
      }
      onSubscribe() {
        ve(this, Ha) || this.setEventListener(ve(this, Bd));
      }
      onUnsubscribe() {
        var e;
        this.hasListeners() ||
          ((e = ve(this, Ha)) == null || e.call(this), It(this, Ha, void 0));
      }
      setEventListener(e) {
        var t;
        It(this, Bd, e),
          (t = ve(this, Ha)) == null || t.call(this),
          It(this, Ha, e(this.setOnline.bind(this)));
      }
      setOnline(e) {
        ve(this, Fd) !== e &&
          (It(this, Fd, e),
          this.listeners.forEach((r) => {
            r(e);
          }));
      }
      isOnline() {
        return ve(this, Fd);
      }
    }),
    (Fd = new WeakMap()),
    (Ha = new WeakMap()),
    (Bd = new WeakMap()),
    DO),
  c0 = new K9();
function Y9() {
  let n, e;
  const t = new Promise((i, s) => {
    (n = i), (e = s);
  });
  (t.status = "pending"), t.catch(() => {});
  function r(i) {
    Object.assign(t, i), delete t.resolve, delete t.reject;
  }
  return (
    (t.resolve = (i) => {
      r({ status: "fulfilled", value: i }), n(i);
    }),
    (t.reject = (i) => {
      r({ status: "rejected", reason: i }), e(i);
    }),
    t
  );
}
function J9(n) {
  return Math.min(1e3 * 2 ** n, 3e4);
}
function IU(n) {
  return (n ?? "online") === "online" ? c0.isOnline() : !0;
}
var NU = class extends Error {
  constructor(n) {
    super("CancelledError"),
      (this.revert = n == null ? void 0 : n.revert),
      (this.silent = n == null ? void 0 : n.silent);
  }
};
function gS(n) {
  return n instanceof NU;
}
function LU(n) {
  let e = !1,
    t = 0,
    r = !1,
    i;
  const s = Y9(),
    o = (y) => {
      var x;
      r || (p(new NU(y)), (x = n.abort) == null || x.call(n));
    },
    a = () => {
      e = !0;
    },
    l = () => {
      e = !1;
    },
    c = () =>
      PU.isFocused() &&
      (n.networkMode === "always" || c0.isOnline()) &&
      n.canRun(),
    u = () => IU(n.networkMode) && n.canRun(),
    f = (y) => {
      var x;
      r ||
        ((r = !0),
        (x = n.onSuccess) == null || x.call(n, y),
        i == null || i(),
        s.resolve(y));
    },
    p = (y) => {
      var x;
      r ||
        ((r = !0),
        (x = n.onError) == null || x.call(n, y),
        i == null || i(),
        s.reject(y));
    },
    m = () =>
      new Promise((y) => {
        var x;
        (i = (g) => {
          (r || c()) && y(g);
        }),
          (x = n.onPause) == null || x.call(n);
      }).then(() => {
        var y;
        (i = void 0), r || (y = n.onContinue) == null || y.call(n);
      }),
    v = () => {
      if (r) return;
      let y;
      const x = t === 0 ? n.initialPromise : void 0;
      try {
        y = x ?? n.fn();
      } catch (g) {
        y = Promise.reject(g);
      }
      Promise.resolve(y)
        .then(f)
        .catch((g) => {
          var A;
          if (r) return;
          const _ = n.retry ?? (Ux ? 0 : 3),
            S = n.retryDelay ?? J9,
            b = typeof S == "function" ? S(t, g) : S,
            C =
              _ === !0 ||
              (typeof _ == "number" && t < _) ||
              (typeof _ == "function" && _(t, g));
          if (e || !C) {
            p(g);
            return;
          }
          t++,
            (A = n.onFail) == null || A.call(n, t, g),
            W9(b)
              .then(() => (c() ? void 0 : m()))
              .then(() => {
                e ? p(g) : v();
              });
        });
    };
  return {
    promise: s,
    cancel: o,
    continue: () => (i == null || i(), s),
    cancelRetry: a,
    continueRetry: l,
    canStart: u,
    start: () => (u() ? v() : m().then(v), s),
  };
}
var Z9 = (n) => setTimeout(n, 0);
function Q9() {
  let n = [],
    e = 0,
    t = (a) => {
      a();
    },
    r = (a) => {
      a();
    },
    i = Z9;
  const s = (a) => {
      e
        ? n.push(a)
        : i(() => {
            t(a);
          });
    },
    o = () => {
      const a = n;
      (n = []),
        a.length &&
          i(() => {
            r(() => {
              a.forEach((l) => {
                t(l);
              });
            });
          });
    };
  return {
    batch: (a) => {
      let l;
      e++;
      try {
        l = a();
      } finally {
        e--, e || o();
      }
      return l;
    },
    batchCalls:
      (a) =>
      (...l) => {
        s(() => {
          a(...l);
        });
      },
    schedule: s,
    setNotifyFunction: (a) => {
      t = a;
    },
    setBatchNotifyFunction: (a) => {
      r = a;
    },
    setScheduler: (a) => {
      i = a;
    },
  };
}
var $r = Q9(),
  _c,
  kO,
  OU =
    ((kO = class {
      constructor() {
        Qt(this, _c);
      }
      destroy() {
        this.clearGcTimeout();
      }
      scheduleGc() {
        this.clearGcTimeout(),
          V9(this.gcTime) &&
            It(
              this,
              _c,
              setTimeout(() => {
                this.optionalRemove();
              }, this.gcTime)
            );
      }
      updateGcTime(n) {
        this.gcTime = Math.max(
          this.gcTime || 0,
          n ?? (Ux ? 1 / 0 : 5 * 60 * 1e3)
        );
      }
      clearGcTimeout() {
        ve(this, _c) && (clearTimeout(ve(this, _c)), It(this, _c, void 0));
      }
    }),
    (_c = new WeakMap()),
    kO),
  zd,
  wc,
  Ji,
  Sc,
  Ir,
  am,
  bc,
  Ms,
  Uo,
  UO,
  e7 =
    ((UO = class extends OU {
      constructor(e) {
        super();
        Qt(this, Ms);
        Qt(this, zd);
        Qt(this, wc);
        Qt(this, Ji);
        Qt(this, Sc);
        Qt(this, Ir);
        Qt(this, am);
        Qt(this, bc);
        It(this, bc, !1),
          It(this, am, e.defaultOptions),
          this.setOptions(e.options),
          (this.observers = []),
          It(this, Sc, e.client),
          It(this, Ji, ve(this, Sc).getQueryCache()),
          (this.queryKey = e.queryKey),
          (this.queryHash = e.queryHash),
          It(this, zd, n7(this.options)),
          (this.state = e.state ?? ve(this, zd)),
          this.scheduleGc();
      }
      get meta() {
        return this.options.meta;
      }
      get promise() {
        var e;
        return (e = ve(this, Ir)) == null ? void 0 : e.promise;
      }
      setOptions(e) {
        (this.options = { ...ve(this, am), ...e }),
          this.updateGcTime(this.options.gcTime);
      }
      optionalRemove() {
        !this.observers.length &&
          this.state.fetchStatus === "idle" &&
          ve(this, Ji).remove(this);
      }
      setData(e, t) {
        const r = G9(this.state.data, e, this.options);
        return (
          Tr(this, Ms, Uo).call(this, {
            data: r,
            type: "success",
            dataUpdatedAt: t == null ? void 0 : t.updatedAt,
            manual: t == null ? void 0 : t.manual,
          }),
          r
        );
      }
      setState(e, t) {
        Tr(this, Ms, Uo).call(this, {
          type: "setState",
          state: e,
          setStateOptions: t,
        });
      }
      cancel(e) {
        var r, i;
        const t = (r = ve(this, Ir)) == null ? void 0 : r.promise;
        return (
          (i = ve(this, Ir)) == null || i.cancel(e),
          t ? t.then(bs).catch(bs) : Promise.resolve()
        );
      }
      destroy() {
        super.destroy(), this.cancel({ silent: !0 });
      }
      reset() {
        this.destroy(), this.setState(ve(this, zd));
      }
      isActive() {
        return this.observers.some((e) => H9(e.options.enabled, this) !== !1);
      }
      isDisabled() {
        return this.getObserversCount() > 0
          ? !this.isActive()
          : this.options.queryFn === bM ||
              this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
      }
      isStatic() {
        return this.getObserversCount() > 0
          ? this.observers.some(
              (e) => Yb(e.options.staleTime, this) === "static"
            )
          : !1;
      }
      isStale() {
        return this.getObserversCount() > 0
          ? this.observers.some((e) => e.getCurrentResult().isStale)
          : this.state.data === void 0 || this.state.isInvalidated;
      }
      isStaleByTime(e = 0) {
        return this.state.data === void 0
          ? !0
          : e === "static"
          ? !1
          : this.state.isInvalidated
          ? !0
          : !j9(this.state.dataUpdatedAt, e);
      }
      onFocus() {
        var t;
        const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (t = ve(this, Ir)) == null || t.continue();
      }
      onOnline() {
        var t;
        const e = this.observers.find((r) => r.shouldFetchOnReconnect());
        e == null || e.refetch({ cancelRefetch: !1 }),
          (t = ve(this, Ir)) == null || t.continue();
      }
      addObserver(e) {
        this.observers.includes(e) ||
          (this.observers.push(e),
          this.clearGcTimeout(),
          ve(this, Ji).notify({
            type: "observerAdded",
            query: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        this.observers.includes(e) &&
          ((this.observers = this.observers.filter((t) => t !== e)),
          this.observers.length ||
            (ve(this, Ir) &&
              (ve(this, bc)
                ? ve(this, Ir).cancel({ revert: !0 })
                : ve(this, Ir).cancelRetry()),
            this.scheduleGc()),
          ve(this, Ji).notify({
            type: "observerRemoved",
            query: this,
            observer: e,
          }));
      }
      getObserversCount() {
        return this.observers.length;
      }
      invalidate() {
        this.state.isInvalidated ||
          Tr(this, Ms, Uo).call(this, { type: "invalidate" });
      }
      fetch(e, t) {
        var c, u, f;
        if (this.state.fetchStatus !== "idle") {
          if (this.state.data !== void 0 && t != null && t.cancelRefetch)
            this.cancel({ silent: !0 });
          else if (ve(this, Ir))
            return ve(this, Ir).continueRetry(), ve(this, Ir).promise;
        }
        if ((e && this.setOptions(e), !this.options.queryFn)) {
          const p = this.observers.find((m) => m.options.queryFn);
          p && this.setOptions(p.options);
        }
        const r = new AbortController(),
          i = (p) => {
            Object.defineProperty(p, "signal", {
              enumerable: !0,
              get: () => (It(this, bc, !0), r.signal),
            });
          },
          s = () => {
            const p = RU(this.options, t),
              v = (() => {
                const y = {
                  client: ve(this, Sc),
                  queryKey: this.queryKey,
                  meta: this.meta,
                };
                return i(y), y;
              })();
            return (
              It(this, bc, !1),
              this.options.persister ? this.options.persister(p, v, this) : p(v)
            );
          },
          a = (() => {
            const p = {
              fetchOptions: t,
              options: this.options,
              queryKey: this.queryKey,
              client: ve(this, Sc),
              state: this.state,
              fetchFn: s,
            };
            return i(p), p;
          })();
        (c = this.options.behavior) == null || c.onFetch(a, this),
          It(this, wc, this.state),
          (this.state.fetchStatus === "idle" ||
            this.state.fetchMeta !==
              ((u = a.fetchOptions) == null ? void 0 : u.meta)) &&
            Tr(this, Ms, Uo).call(this, {
              type: "fetch",
              meta: (f = a.fetchOptions) == null ? void 0 : f.meta,
            });
        const l = (p) => {
          var m, v, y, x;
          (gS(p) && p.silent) ||
            Tr(this, Ms, Uo).call(this, { type: "error", error: p }),
            gS(p) ||
              ((v = (m = ve(this, Ji).config).onError) == null ||
                v.call(m, p, this),
              (x = (y = ve(this, Ji).config).onSettled) == null ||
                x.call(y, this.state.data, p, this)),
            this.scheduleGc();
        };
        return (
          It(
            this,
            Ir,
            LU({
              initialPromise: t == null ? void 0 : t.initialPromise,
              fn: a.fetchFn,
              abort: r.abort.bind(r),
              onSuccess: (p) => {
                var m, v, y, x;
                if (p === void 0) {
                  l(new Error(`${this.queryHash} data is undefined`));
                  return;
                }
                try {
                  this.setData(p);
                } catch (g) {
                  l(g);
                  return;
                }
                (v = (m = ve(this, Ji).config).onSuccess) == null ||
                  v.call(m, p, this),
                  (x = (y = ve(this, Ji).config).onSettled) == null ||
                    x.call(y, p, this.state.error, this),
                  this.scheduleGc();
              },
              onError: l,
              onFail: (p, m) => {
                Tr(this, Ms, Uo).call(this, {
                  type: "failed",
                  failureCount: p,
                  error: m,
                });
              },
              onPause: () => {
                Tr(this, Ms, Uo).call(this, { type: "pause" });
              },
              onContinue: () => {
                Tr(this, Ms, Uo).call(this, { type: "continue" });
              },
              retry: a.options.retry,
              retryDelay: a.options.retryDelay,
              networkMode: a.options.networkMode,
              canRun: () => !0,
            })
          ),
          ve(this, Ir).start()
        );
      }
    }),
    (zd = new WeakMap()),
    (wc = new WeakMap()),
    (Ji = new WeakMap()),
    (Sc = new WeakMap()),
    (Ir = new WeakMap()),
    (am = new WeakMap()),
    (bc = new WeakMap()),
    (Ms = new WeakSet()),
    (Uo = function (e) {
      const t = (r) => {
        switch (e.type) {
          case "failed":
            return {
              ...r,
              fetchFailureCount: e.failureCount,
              fetchFailureReason: e.error,
            };
          case "pause":
            return { ...r, fetchStatus: "paused" };
          case "continue":
            return { ...r, fetchStatus: "fetching" };
          case "fetch":
            return {
              ...r,
              ...t7(r.data, this.options),
              fetchMeta: e.meta ?? null,
            };
          case "success":
            return (
              It(this, wc, void 0),
              {
                ...r,
                data: e.data,
                dataUpdateCount: r.dataUpdateCount + 1,
                dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...(!e.manual && {
                  fetchStatus: "idle",
                  fetchFailureCount: 0,
                  fetchFailureReason: null,
                }),
              }
            );
          case "error":
            const i = e.error;
            return gS(i) && i.revert && ve(this, wc)
              ? { ...ve(this, wc), fetchStatus: "idle" }
              : {
                  ...r,
                  error: i,
                  errorUpdateCount: r.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: r.fetchFailureCount + 1,
                  fetchFailureReason: i,
                  fetchStatus: "idle",
                  status: "error",
                };
          case "invalidate":
            return { ...r, isInvalidated: !0 };
          case "setState":
            return { ...r, ...e.state };
        }
      };
      (this.state = t(this.state)),
        $r.batch(() => {
          this.observers.forEach((r) => {
            r.onQueryUpdate();
          }),
            ve(this, Ji).notify({ query: this, type: "updated", action: e });
        });
    }),
    UO);
function t7(n, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: IU(e.networkMode) ? "fetching" : "paused",
    ...(n === void 0 && { error: null, status: "pending" }),
  };
}
function n7(n) {
  const e =
      typeof n.initialData == "function" ? n.initialData() : n.initialData,
    t = e !== void 0,
    r = t
      ? typeof n.initialDataUpdatedAt == "function"
        ? n.initialDataUpdatedAt()
        : n.initialDataUpdatedAt
      : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: t ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: t ? "success" : "pending",
    fetchStatus: "idle",
  };
}
var eo,
  FO,
  r7 =
    ((FO = class extends kx {
      constructor(e = {}) {
        super();
        Qt(this, eo);
        (this.config = e), It(this, eo, new Map());
      }
      build(e, t, r) {
        const i = t.queryKey,
          s = t.queryHash ?? SM(i, t);
        let o = this.get(s);
        return (
          o ||
            ((o = new e7({
              client: e,
              queryKey: i,
              queryHash: s,
              options: e.defaultQueryOptions(t),
              state: r,
              defaultOptions: e.getQueryDefaults(i),
            })),
            this.add(o)),
          o
        );
      }
      add(e) {
        ve(this, eo).has(e.queryHash) ||
          (ve(this, eo).set(e.queryHash, e),
          this.notify({ type: "added", query: e }));
      }
      remove(e) {
        const t = ve(this, eo).get(e.queryHash);
        t &&
          (e.destroy(),
          t === e && ve(this, eo).delete(e.queryHash),
          this.notify({ type: "removed", query: e }));
      }
      clear() {
        $r.batch(() => {
          this.getAll().forEach((e) => {
            this.remove(e);
          });
        });
      }
      get(e) {
        return ve(this, eo).get(e);
      }
      getAll() {
        return [...ve(this, eo).values()];
      }
      find(e) {
        const t = { exact: !0, ...e };
        return this.getAll().find((r) => TI(t, r));
      }
      findAll(e = {}) {
        const t = this.getAll();
        return Object.keys(e).length > 0 ? t.filter((r) => TI(e, r)) : t;
      }
      notify(e) {
        $r.batch(() => {
          this.listeners.forEach((t) => {
            t(e);
          });
        });
      }
      onFocus() {
        $r.batch(() => {
          this.getAll().forEach((e) => {
            e.onFocus();
          });
        });
      }
      onOnline() {
        $r.batch(() => {
          this.getAll().forEach((e) => {
            e.onOnline();
          });
        });
      }
    }),
    (eo = new WeakMap()),
    FO),
  to,
  Wr,
  Ec,
  no,
  Ra,
  BO,
  i7 =
    ((BO = class extends OU {
      constructor(e) {
        super();
        Qt(this, no);
        Qt(this, to);
        Qt(this, Wr);
        Qt(this, Ec);
        (this.mutationId = e.mutationId),
          It(this, Wr, e.mutationCache),
          It(this, to, []),
          (this.state = e.state || s7()),
          this.setOptions(e.options),
          this.scheduleGc();
      }
      setOptions(e) {
        (this.options = e), this.updateGcTime(this.options.gcTime);
      }
      get meta() {
        return this.options.meta;
      }
      addObserver(e) {
        ve(this, to).includes(e) ||
          (ve(this, to).push(e),
          this.clearGcTimeout(),
          ve(this, Wr).notify({
            type: "observerAdded",
            mutation: this,
            observer: e,
          }));
      }
      removeObserver(e) {
        It(
          this,
          to,
          ve(this, to).filter((t) => t !== e)
        ),
          this.scheduleGc(),
          ve(this, Wr).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e,
          });
      }
      optionalRemove() {
        ve(this, to).length ||
          (this.state.status === "pending"
            ? this.scheduleGc()
            : ve(this, Wr).remove(this));
      }
      continue() {
        var e;
        return (
          ((e = ve(this, Ec)) == null ? void 0 : e.continue()) ??
          this.execute(this.state.variables)
        );
      }
      async execute(e) {
        var s, o, a, l, c, u, f, p, m, v, y, x, g, _, S, b, C, A, R, O;
        const t = () => {
          Tr(this, no, Ra).call(this, { type: "continue" });
        };
        It(
          this,
          Ec,
          LU({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(e)
                : Promise.reject(new Error("No mutationFn found")),
            onFail: (I, N) => {
              Tr(this, no, Ra).call(this, {
                type: "failed",
                failureCount: I,
                error: N,
              });
            },
            onPause: () => {
              Tr(this, no, Ra).call(this, { type: "pause" });
            },
            onContinue: t,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => ve(this, Wr).canRun(this),
          })
        );
        const r = this.state.status === "pending",
          i = !ve(this, Ec).canStart();
        try {
          if (r) t();
          else {
            Tr(this, no, Ra).call(this, {
              type: "pending",
              variables: e,
              isPaused: i,
            }),
              await ((o = (s = ve(this, Wr).config).onMutate) == null
                ? void 0
                : o.call(s, e, this));
            const N = await ((l = (a = this.options).onMutate) == null
              ? void 0
              : l.call(a, e));
            N !== this.state.context &&
              Tr(this, no, Ra).call(this, {
                type: "pending",
                context: N,
                variables: e,
                isPaused: i,
              });
          }
          const I = await ve(this, Ec).start();
          return (
            await ((u = (c = ve(this, Wr).config).onSuccess) == null
              ? void 0
              : u.call(c, I, e, this.state.context, this)),
            await ((p = (f = this.options).onSuccess) == null
              ? void 0
              : p.call(f, I, e, this.state.context)),
            await ((v = (m = ve(this, Wr).config).onSettled) == null
              ? void 0
              : v.call(
                  m,
                  I,
                  null,
                  this.state.variables,
                  this.state.context,
                  this
                )),
            await ((x = (y = this.options).onSettled) == null
              ? void 0
              : x.call(y, I, null, e, this.state.context)),
            Tr(this, no, Ra).call(this, { type: "success", data: I }),
            I
          );
        } catch (I) {
          try {
            throw (
              (await ((_ = (g = ve(this, Wr).config).onError) == null
                ? void 0
                : _.call(g, I, e, this.state.context, this)),
              await ((b = (S = this.options).onError) == null
                ? void 0
                : b.call(S, I, e, this.state.context)),
              await ((A = (C = ve(this, Wr).config).onSettled) == null
                ? void 0
                : A.call(
                    C,
                    void 0,
                    I,
                    this.state.variables,
                    this.state.context,
                    this
                  )),
              await ((O = (R = this.options).onSettled) == null
                ? void 0
                : O.call(R, void 0, I, e, this.state.context)),
              I)
            );
          } finally {
            Tr(this, no, Ra).call(this, { type: "error", error: I });
          }
        } finally {
          ve(this, Wr).runNext(this);
        }
      }
    }),
    (to = new WeakMap()),
    (Wr = new WeakMap()),
    (Ec = new WeakMap()),
    (no = new WeakSet()),
    (Ra = function (e) {
      const t = (r) => {
        switch (e.type) {
          case "failed":
            return {
              ...r,
              failureCount: e.failureCount,
              failureReason: e.error,
            };
          case "pause":
            return { ...r, isPaused: !0 };
          case "continue":
            return { ...r, isPaused: !1 };
          case "pending":
            return {
              ...r,
              context: e.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: e.isPaused,
              status: "pending",
              variables: e.variables,
              submittedAt: Date.now(),
            };
          case "success":
            return {
              ...r,
              data: e.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: !1,
            };
          case "error":
            return {
              ...r,
              data: void 0,
              error: e.error,
              failureCount: r.failureCount + 1,
              failureReason: e.error,
              isPaused: !1,
              status: "error",
            };
        }
      };
      (this.state = t(this.state)),
        $r.batch(() => {
          ve(this, to).forEach((r) => {
            r.onMutationUpdate(e);
          }),
            ve(this, Wr).notify({ mutation: this, type: "updated", action: e });
        });
    }),
    BO);
function s7() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0,
  };
}
var Vo,
  Cs,
  lm,
  zO,
  o7 =
    ((zO = class extends kx {
      constructor(e = {}) {
        super();
        Qt(this, Vo);
        Qt(this, Cs);
        Qt(this, lm);
        (this.config = e),
          It(this, Vo, new Set()),
          It(this, Cs, new Map()),
          It(this, lm, 0);
      }
      build(e, t, r) {
        const i = new i7({
          mutationCache: this,
          mutationId: ++Pg(this, lm)._,
          options: e.defaultMutationOptions(t),
          state: r,
        });
        return this.add(i), i;
      }
      add(e) {
        ve(this, Vo).add(e);
        const t = Zg(e);
        if (typeof t == "string") {
          const r = ve(this, Cs).get(t);
          r ? r.push(e) : ve(this, Cs).set(t, [e]);
        }
        this.notify({ type: "added", mutation: e });
      }
      remove(e) {
        if (ve(this, Vo).delete(e)) {
          const t = Zg(e);
          if (typeof t == "string") {
            const r = ve(this, Cs).get(t);
            if (r)
              if (r.length > 1) {
                const i = r.indexOf(e);
                i !== -1 && r.splice(i, 1);
              } else r[0] === e && ve(this, Cs).delete(t);
          }
        }
        this.notify({ type: "removed", mutation: e });
      }
      canRun(e) {
        const t = Zg(e);
        if (typeof t == "string") {
          const r = ve(this, Cs).get(t),
            i =
              r == null ? void 0 : r.find((s) => s.state.status === "pending");
          return !i || i === e;
        } else return !0;
      }
      runNext(e) {
        var r;
        const t = Zg(e);
        if (typeof t == "string") {
          const i =
            (r = ve(this, Cs).get(t)) == null
              ? void 0
              : r.find((s) => s !== e && s.state.isPaused);
          return (i == null ? void 0 : i.continue()) ?? Promise.resolve();
        } else return Promise.resolve();
      }
      clear() {
        $r.batch(() => {
          ve(this, Vo).forEach((e) => {
            this.notify({ type: "removed", mutation: e });
          }),
            ve(this, Vo).clear(),
            ve(this, Cs).clear();
        });
      }
      getAll() {
        return Array.from(ve(this, Vo));
      }
      find(e) {
        const t = { exact: !0, ...e };
        return this.getAll().find((r) => MI(t, r));
      }
      findAll(e = {}) {
        return this.getAll().filter((t) => MI(e, t));
      }
      notify(e) {
        $r.batch(() => {
          this.listeners.forEach((t) => {
            t(e);
          });
        });
      }
      resumePausedMutations() {
        const e = this.getAll().filter((t) => t.state.isPaused);
        return $r.batch(() =>
          Promise.all(e.map((t) => t.continue().catch(bs)))
        );
      }
    }),
    (Vo = new WeakMap()),
    (Cs = new WeakMap()),
    (lm = new WeakMap()),
    zO);
function Zg(n) {
  var e;
  return (e = n.options.scope) == null ? void 0 : e.id;
}
function RI(n) {
  return {
    onFetch: (e, t) => {
      var u, f, p, m, v;
      const r = e.options,
        i =
          (p =
            (f = (u = e.fetchOptions) == null ? void 0 : u.meta) == null
              ? void 0
              : f.fetchMore) == null
            ? void 0
            : p.direction,
        s = ((m = e.state.data) == null ? void 0 : m.pages) || [],
        o = ((v = e.state.data) == null ? void 0 : v.pageParams) || [];
      let a = { pages: [], pageParams: [] },
        l = 0;
      const c = async () => {
        let y = !1;
        const x = (S) => {
            Object.defineProperty(S, "signal", {
              enumerable: !0,
              get: () => (
                e.signal.aborted
                  ? (y = !0)
                  : e.signal.addEventListener("abort", () => {
                      y = !0;
                    }),
                e.signal
              ),
            });
          },
          g = RU(e.options, e.fetchOptions),
          _ = async (S, b, C) => {
            if (y) return Promise.reject();
            if (b == null && S.pages.length) return Promise.resolve(S);
            const R = (() => {
                const D = {
                  client: e.client,
                  queryKey: e.queryKey,
                  pageParam: b,
                  direction: C ? "backward" : "forward",
                  meta: e.options.meta,
                };
                return x(D), D;
              })(),
              O = await g(R),
              { maxPages: I } = e.options,
              N = C ? X9 : $9;
            return {
              pages: N(S.pages, O, I),
              pageParams: N(S.pageParams, b, I),
            };
          };
        if (i && s.length) {
          const S = i === "backward",
            b = S ? a7 : PI,
            C = { pages: s, pageParams: o },
            A = b(r, C);
          a = await _(C, A, S);
        } else {
          const S = n ?? s.length;
          do {
            const b = l === 0 ? o[0] ?? r.initialPageParam : PI(r, a);
            if (l > 0 && b == null) break;
            (a = await _(a, b)), l++;
          } while (l < S);
        }
        return a;
      };
      e.options.persister
        ? (e.fetchFn = () => {
            var y, x;
            return (x = (y = e.options).persister) == null
              ? void 0
              : x.call(
                  y,
                  c,
                  {
                    client: e.client,
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal,
                  },
                  t
                );
          })
        : (e.fetchFn = c);
    },
  };
}
function PI(n, { pages: e, pageParams: t }) {
  const r = e.length - 1;
  return e.length > 0 ? n.getNextPageParam(e[r], e, t[r], t) : void 0;
}
function a7(n, { pages: e, pageParams: t }) {
  var r;
  return e.length > 0
    ? (r = n.getPreviousPageParam) == null
      ? void 0
      : r.call(n, e[0], e, t[0], t)
    : void 0;
}
var Rn,
  Wa,
  Ga,
  Vd,
  jd,
  $a,
  Hd,
  Wd,
  VO,
  l7 =
    ((VO = class {
      constructor(n = {}) {
        Qt(this, Rn);
        Qt(this, Wa);
        Qt(this, Ga);
        Qt(this, Vd);
        Qt(this, jd);
        Qt(this, $a);
        Qt(this, Hd);
        Qt(this, Wd);
        It(this, Rn, n.queryCache || new r7()),
          It(this, Wa, n.mutationCache || new o7()),
          It(this, Ga, n.defaultOptions || {}),
          It(this, Vd, new Map()),
          It(this, jd, new Map()),
          It(this, $a, 0);
      }
      mount() {
        Pg(this, $a)._++,
          ve(this, $a) === 1 &&
            (It(
              this,
              Hd,
              PU.subscribe(async (n) => {
                n &&
                  (await this.resumePausedMutations(), ve(this, Rn).onFocus());
              })
            ),
            It(
              this,
              Wd,
              c0.subscribe(async (n) => {
                n &&
                  (await this.resumePausedMutations(), ve(this, Rn).onOnline());
              })
            ));
      }
      unmount() {
        var n, e;
        Pg(this, $a)._--,
          ve(this, $a) === 0 &&
            ((n = ve(this, Hd)) == null || n.call(this),
            It(this, Hd, void 0),
            (e = ve(this, Wd)) == null || e.call(this),
            It(this, Wd, void 0));
      }
      isFetching(n) {
        return ve(this, Rn).findAll({ ...n, fetchStatus: "fetching" }).length;
      }
      isMutating(n) {
        return ve(this, Wa).findAll({ ...n, status: "pending" }).length;
      }
      getQueryData(n) {
        var t;
        const e = this.defaultQueryOptions({ queryKey: n });
        return (t = ve(this, Rn).get(e.queryHash)) == null
          ? void 0
          : t.state.data;
      }
      ensureQueryData(n) {
        const e = this.defaultQueryOptions(n),
          t = ve(this, Rn).build(this, e),
          r = t.state.data;
        return r === void 0
          ? this.fetchQuery(n)
          : (n.revalidateIfStale &&
              t.isStaleByTime(Yb(e.staleTime, t)) &&
              this.prefetchQuery(e),
            Promise.resolve(r));
      }
      getQueriesData(n) {
        return ve(this, Rn)
          .findAll(n)
          .map(({ queryKey: e, state: t }) => {
            const r = t.data;
            return [e, r];
          });
      }
      setQueryData(n, e, t) {
        const r = this.defaultQueryOptions({ queryKey: n }),
          i = ve(this, Rn).get(r.queryHash),
          s = i == null ? void 0 : i.state.data,
          o = z9(e, s);
        if (o !== void 0)
          return ve(this, Rn)
            .build(this, r)
            .setData(o, { ...t, manual: !0 });
      }
      setQueriesData(n, e, t) {
        return $r.batch(() =>
          ve(this, Rn)
            .findAll(n)
            .map(({ queryKey: r }) => [r, this.setQueryData(r, e, t)])
        );
      }
      getQueryState(n) {
        var t;
        const e = this.defaultQueryOptions({ queryKey: n });
        return (t = ve(this, Rn).get(e.queryHash)) == null ? void 0 : t.state;
      }
      removeQueries(n) {
        const e = ve(this, Rn);
        $r.batch(() => {
          e.findAll(n).forEach((t) => {
            e.remove(t);
          });
        });
      }
      resetQueries(n, e) {
        const t = ve(this, Rn);
        return $r.batch(
          () => (
            t.findAll(n).forEach((r) => {
              r.reset();
            }),
            this.refetchQueries({ type: "active", ...n }, e)
          )
        );
      }
      cancelQueries(n, e = {}) {
        const t = { revert: !0, ...e },
          r = $r.batch(() =>
            ve(this, Rn)
              .findAll(n)
              .map((i) => i.cancel(t))
          );
        return Promise.all(r).then(bs).catch(bs);
      }
      invalidateQueries(n, e = {}) {
        return $r.batch(
          () => (
            ve(this, Rn)
              .findAll(n)
              .forEach((t) => {
                t.invalidate();
              }),
            (n == null ? void 0 : n.refetchType) === "none"
              ? Promise.resolve()
              : this.refetchQueries(
                  {
                    ...n,
                    type:
                      (n == null ? void 0 : n.refetchType) ??
                      (n == null ? void 0 : n.type) ??
                      "active",
                  },
                  e
                )
          )
        );
      }
      refetchQueries(n, e = {}) {
        const t = { ...e, cancelRefetch: e.cancelRefetch ?? !0 },
          r = $r.batch(() =>
            ve(this, Rn)
              .findAll(n)
              .filter((i) => !i.isDisabled() && !i.isStatic())
              .map((i) => {
                let s = i.fetch(void 0, t);
                return (
                  t.throwOnError || (s = s.catch(bs)),
                  i.state.fetchStatus === "paused" ? Promise.resolve() : s
                );
              })
          );
        return Promise.all(r).then(bs);
      }
      fetchQuery(n) {
        const e = this.defaultQueryOptions(n);
        e.retry === void 0 && (e.retry = !1);
        const t = ve(this, Rn).build(this, e);
        return t.isStaleByTime(Yb(e.staleTime, t))
          ? t.fetch(e)
          : Promise.resolve(t.state.data);
      }
      prefetchQuery(n) {
        return this.fetchQuery(n).then(bs).catch(bs);
      }
      fetchInfiniteQuery(n) {
        return (n.behavior = RI(n.pages)), this.fetchQuery(n);
      }
      prefetchInfiniteQuery(n) {
        return this.fetchInfiniteQuery(n).then(bs).catch(bs);
      }
      ensureInfiniteQueryData(n) {
        return (n.behavior = RI(n.pages)), this.ensureQueryData(n);
      }
      resumePausedMutations() {
        return c0.isOnline()
          ? ve(this, Wa).resumePausedMutations()
          : Promise.resolve();
      }
      getQueryCache() {
        return ve(this, Rn);
      }
      getMutationCache() {
        return ve(this, Wa);
      }
      getDefaultOptions() {
        return ve(this, Ga);
      }
      setDefaultOptions(n) {
        It(this, Ga, n);
      }
      setQueryDefaults(n, e) {
        ve(this, Vd).set(Ip(n), { queryKey: n, defaultOptions: e });
      }
      getQueryDefaults(n) {
        const e = [...ve(this, Vd).values()],
          t = {};
        return (
          e.forEach((r) => {
            Np(n, r.queryKey) && Object.assign(t, r.defaultOptions);
          }),
          t
        );
      }
      setMutationDefaults(n, e) {
        ve(this, jd).set(Ip(n), { mutationKey: n, defaultOptions: e });
      }
      getMutationDefaults(n) {
        const e = [...ve(this, jd).values()],
          t = {};
        return (
          e.forEach((r) => {
            Np(n, r.mutationKey) && Object.assign(t, r.defaultOptions);
          }),
          t
        );
      }
      defaultQueryOptions(n) {
        if (n._defaulted) return n;
        const e = {
          ...ve(this, Ga).queries,
          ...this.getQueryDefaults(n.queryKey),
          ...n,
          _defaulted: !0,
        };
        return (
          e.queryHash || (e.queryHash = SM(e.queryKey, e)),
          e.refetchOnReconnect === void 0 &&
            (e.refetchOnReconnect = e.networkMode !== "always"),
          e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
          !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
          e.queryFn === bM && (e.enabled = !1),
          e
        );
      }
      defaultMutationOptions(n) {
        return n != null && n._defaulted
          ? n
          : {
              ...ve(this, Ga).mutations,
              ...((n == null ? void 0 : n.mutationKey) &&
                this.getMutationDefaults(n.mutationKey)),
              ...n,
              _defaulted: !0,
            };
      }
      clear() {
        ve(this, Rn).clear(), ve(this, Wa).clear();
      }
    }),
    (Rn = new WeakMap()),
    (Wa = new WeakMap()),
    (Ga = new WeakMap()),
    (Vd = new WeakMap()),
    (jd = new WeakMap()),
    ($a = new WeakMap()),
    (Hd = new WeakMap()),
    (Wd = new WeakMap()),
    VO),
  c7 = P.createContext(void 0),
  u7 = ({ client: n, children: e }) => (
    P.useEffect(
      () => (
        n.mount(),
        () => {
          n.unmount();
        }
      ),
      [n]
    ),
    T.jsx(c7.Provider, { value: n, children: e })
  );
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Lp() {
  return (
    (Lp = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Lp.apply(this, arguments)
  );
}
var Ka;
(function (n) {
  (n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE");
})(Ka || (Ka = {}));
const II = "popstate";
function d7(n) {
  n === void 0 && (n = {});
  function e(r, i) {
    let { pathname: s, search: o, hash: a } = r.location;
    return Zb(
      "",
      { pathname: s, search: o, hash: a },
      (i.state && i.state.usr) || null,
      (i.state && i.state.key) || "default"
    );
  }
  function t(r, i) {
    return typeof i == "string" ? i : u0(i);
  }
  return f7(e, t, null, n);
}
function Xn(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function DU(n, e) {
  if (!n) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function h7() {
  return Math.random().toString(36).substr(2, 8);
}
function NI(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function Zb(n, e, t, r) {
  return (
    t === void 0 && (t = null),
    Lp(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? bh(e) : e,
      { state: t, key: (e && e.key) || r || h7() }
    )
  );
}
function u0(n) {
  let { pathname: e = "/", search: t = "", hash: r = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r),
    e
  );
}
function bh(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let r = n.indexOf("?");
    r >= 0 && ((e.search = n.substr(r)), (n = n.substr(0, r))),
      n && (e.pathname = n);
  }
  return e;
}
function f7(n, e, t, r) {
  r === void 0 && (r = {});
  let { window: i = document.defaultView, v5Compat: s = !1 } = r,
    o = i.history,
    a = Ka.Pop,
    l = null,
    c = u();
  c == null && ((c = 0), o.replaceState(Lp({}, o.state, { idx: c }), ""));
  function u() {
    return (o.state || { idx: null }).idx;
  }
  function f() {
    a = Ka.Pop;
    let x = u(),
      g = x == null ? null : x - c;
    (c = x), l && l({ action: a, location: y.location, delta: g });
  }
  function p(x, g) {
    a = Ka.Push;
    let _ = Zb(y.location, x, g);
    c = u() + 1;
    let S = NI(_, c),
      b = y.createHref(_);
    try {
      o.pushState(S, "", b);
    } catch (C) {
      if (C instanceof DOMException && C.name === "DataCloneError") throw C;
      i.location.assign(b);
    }
    s && l && l({ action: a, location: y.location, delta: 1 });
  }
  function m(x, g) {
    a = Ka.Replace;
    let _ = Zb(y.location, x, g);
    c = u();
    let S = NI(_, c),
      b = y.createHref(_);
    o.replaceState(S, "", b),
      s && l && l({ action: a, location: y.location, delta: 0 });
  }
  function v(x) {
    let g = i.location.origin !== "null" ? i.location.origin : i.location.href,
      _ = typeof x == "string" ? x : u0(x);
    return (
      (_ = _.replace(/ $/, "%20")),
      Xn(
        g,
        "No window.location.(origin|href) available to create URL for href: " +
          _
      ),
      new URL(_, g)
    );
  }
  let y = {
    get action() {
      return a;
    },
    get location() {
      return n(i, o);
    },
    listen(x) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        i.addEventListener(II, f),
        (l = x),
        () => {
          i.removeEventListener(II, f), (l = null);
        }
      );
    },
    createHref(x) {
      return e(i, x);
    },
    createURL: v,
    encodeLocation(x) {
      let g = v(x);
      return { pathname: g.pathname, search: g.search, hash: g.hash };
    },
    push: p,
    replace: m,
    go(x) {
      return o.go(x);
    },
  };
  return y;
}
var LI;
(function (n) {
  (n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error");
})(LI || (LI = {}));
function p7(n, e, t) {
  return t === void 0 && (t = "/"), m7(n, e, t, !1);
}
function m7(n, e, t, r) {
  let i = typeof e == "string" ? bh(e) : e,
    s = EM(i.pathname || "/", t);
  if (s == null) return null;
  let o = kU(n);
  g7(o);
  let a = null;
  for (let l = 0; a == null && l < o.length; ++l) {
    let c = C7(s);
    a = T7(o[l], c, r);
  }
  return a;
}
function kU(n, e, t, r) {
  e === void 0 && (e = []), t === void 0 && (t = []), r === void 0 && (r = "");
  let i = (s, o, a) => {
    let l = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (Xn(
        l.relativePath.startsWith(r),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + r + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (l.relativePath = l.relativePath.slice(r.length)));
    let c = sl([r, l.relativePath]),
      u = t.concat(l);
    s.children &&
      s.children.length > 0 &&
      (Xn(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + c + '".')
      ),
      kU(s.children, e, u, c)),
      !(s.path == null && !s.index) &&
        e.push({ path: c, score: b7(c, s.index), routesMeta: u });
  };
  return (
    n.forEach((s, o) => {
      var a;
      if (s.path === "" || !((a = s.path) != null && a.includes("?"))) i(s, o);
      else for (let l of UU(s.path)) i(s, o, l);
    }),
    e
  );
}
function UU(n) {
  let e = n.split("/");
  if (e.length === 0) return [];
  let [t, ...r] = e,
    i = t.endsWith("?"),
    s = t.replace(/\?$/, "");
  if (r.length === 0) return i ? [s, ""] : [s];
  let o = UU(r.join("/")),
    a = [];
  return (
    a.push(...o.map((l) => (l === "" ? s : [s, l].join("/")))),
    i && a.push(...o),
    a.map((l) => (n.startsWith("/") && l === "" ? "/" : l))
  );
}
function g7(n) {
  n.sort((e, t) =>
    e.score !== t.score
      ? t.score - e.score
      : E7(
          e.routesMeta.map((r) => r.childrenIndex),
          t.routesMeta.map((r) => r.childrenIndex)
        )
  );
}
const v7 = /^:[\w-]+$/,
  y7 = 3,
  x7 = 2,
  _7 = 1,
  w7 = 10,
  S7 = -2,
  OI = (n) => n === "*";
function b7(n, e) {
  let t = n.split("/"),
    r = t.length;
  return (
    t.some(OI) && (r += S7),
    e && (r += x7),
    t
      .filter((i) => !OI(i))
      .reduce((i, s) => i + (v7.test(s) ? y7 : s === "" ? _7 : w7), r)
  );
}
function E7(n, e) {
  return n.length === e.length && n.slice(0, -1).every((r, i) => r === e[i])
    ? n[n.length - 1] - e[e.length - 1]
    : 0;
}
function T7(n, e, t) {
  let { routesMeta: r } = n,
    i = {},
    s = "/",
    o = [];
  for (let a = 0; a < r.length; ++a) {
    let l = r[a],
      c = a === r.length - 1,
      u = s === "/" ? e : e.slice(s.length) || "/",
      f = DI(
        { path: l.relativePath, caseSensitive: l.caseSensitive, end: c },
        u
      ),
      p = l.route;
    if (
      (!f &&
        c &&
        t &&
        !r[r.length - 1].route.index &&
        (f = DI(
          { path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 },
          u
        )),
      !f)
    )
      return null;
    Object.assign(i, f.params),
      o.push({
        params: i,
        pathname: sl([s, f.pathname]),
        pathnameBase: I7(sl([s, f.pathnameBase])),
        route: p,
      }),
      f.pathnameBase !== "/" && (s = sl([s, f.pathnameBase]));
  }
  return o;
}
function DI(n, e) {
  typeof n == "string" && (n = { path: n, caseSensitive: !1, end: !0 });
  let [t, r] = M7(n.path, n.caseSensitive, n.end),
    i = e.match(t);
  if (!i) return null;
  let s = i[0],
    o = s.replace(/(.)\/+$/, "$1"),
    a = i.slice(1);
  return {
    params: r.reduce((c, u, f) => {
      let { paramName: p, isOptional: m } = u;
      if (p === "*") {
        let y = a[f] || "";
        o = s.slice(0, s.length - y.length).replace(/(.)\/+$/, "$1");
      }
      const v = a[f];
      return (
        m && !v ? (c[p] = void 0) : (c[p] = (v || "").replace(/%2F/g, "/")), c
      );
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: n,
  };
}
function M7(n, e, t) {
  e === void 0 && (e = !1),
    t === void 0 && (t = !0),
    DU(
      n === "*" || !n.endsWith("*") || n.endsWith("/*"),
      'Route path "' +
        n +
        '" will be treated as if it were ' +
        ('"' + n.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + n.replace(/\*$/, "/*") + '".')
    );
  let r = [],
    i =
      "^" +
      n
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (o, a, l) => (
            r.push({ paramName: a, isOptional: l != null }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    n.endsWith("*")
      ? (r.push({ paramName: "*" }),
        (i += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : t
      ? (i += "\\/*$")
      : n !== "" && n !== "/" && (i += "(?:(?=\\/|$))"),
    [new RegExp(i, e ? void 0 : "i"), r]
  );
}
function C7(n) {
  try {
    return n
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      DU(
        !1,
        'The URL path "' +
          n +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      n
    );
  }
}
function EM(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    r = n.charAt(t);
  return r && r !== "/" ? null : n.slice(t) || "/";
}
function A7(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: r = "",
    hash: i = "",
  } = typeof n == "string" ? bh(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : R7(t, e)) : e,
    search: N7(r),
    hash: L7(i),
  };
}
function R7(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((i) => {
      i === ".." ? t.length > 1 && t.pop() : i !== "." && t.push(i);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function vS(n, e, t, r) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(r) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function P7(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function FU(n, e) {
  let t = P7(n);
  return e
    ? t.map((r, i) => (i === t.length - 1 ? r.pathname : r.pathnameBase))
    : t.map((r) => r.pathnameBase);
}
function BU(n, e, t, r) {
  r === void 0 && (r = !1);
  let i;
  typeof n == "string"
    ? (i = bh(n))
    : ((i = Lp({}, n)),
      Xn(
        !i.pathname || !i.pathname.includes("?"),
        vS("?", "pathname", "search", i)
      ),
      Xn(
        !i.pathname || !i.pathname.includes("#"),
        vS("#", "pathname", "hash", i)
      ),
      Xn(!i.search || !i.search.includes("#"), vS("#", "search", "hash", i)));
  let s = n === "" || i.pathname === "",
    o = s ? "/" : i.pathname,
    a;
  if (o == null) a = t;
  else {
    let f = e.length - 1;
    if (!r && o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) p.shift(), (f -= 1);
      i.pathname = p.join("/");
    }
    a = f >= 0 ? e[f] : "/";
  }
  let l = A7(i, a),
    c = o && o !== "/" && o.endsWith("/"),
    u = (s || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const sl = (n) => n.join("/").replace(/\/\/+/g, "/"),
  I7 = (n) => n.replace(/\/+$/, "").replace(/^\/*/, "/"),
  N7 = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  L7 = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n);
function O7(n) {
  return (
    n != null &&
    typeof n.status == "number" &&
    typeof n.statusText == "string" &&
    typeof n.internal == "boolean" &&
    "data" in n
  );
}
const zU = ["post", "put", "patch", "delete"];
new Set(zU);
const D7 = ["get", ...zU];
new Set(D7);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Op() {
  return (
    (Op = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    Op.apply(this, arguments)
  );
}
const TM = P.createContext(null),
  k7 = P.createContext(null),
  Kc = P.createContext(null),
  Fx = P.createContext(null),
  Yc = P.createContext({ outlet: null, matches: [], isDataRoute: !1 }),
  VU = P.createContext(null);
function U7(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  vm() || Xn(!1);
  let { basename: r, navigator: i } = P.useContext(Kc),
    { hash: s, pathname: o, search: a } = WU(n, { relative: t }),
    l = o;
  return (
    r !== "/" && (l = o === "/" ? r : sl([r, o])),
    i.createHref({ pathname: l, search: a, hash: s })
  );
}
function vm() {
  return P.useContext(Fx) != null;
}
function Jc() {
  return vm() || Xn(!1), P.useContext(Fx).location;
}
function jU(n) {
  P.useContext(Kc).static || P.useLayoutEffect(n);
}
function HU() {
  let { isDataRoute: n } = P.useContext(Yc);
  return n ? Y7() : F7();
}
function F7() {
  vm() || Xn(!1);
  let n = P.useContext(TM),
    { basename: e, future: t, navigator: r } = P.useContext(Kc),
    { matches: i } = P.useContext(Yc),
    { pathname: s } = Jc(),
    o = JSON.stringify(FU(i, t.v7_relativeSplatPath)),
    a = P.useRef(!1);
  return (
    jU(() => {
      a.current = !0;
    }),
    P.useCallback(
      function (c, u) {
        if ((u === void 0 && (u = {}), !a.current)) return;
        if (typeof c == "number") {
          r.go(c);
          return;
        }
        let f = BU(c, JSON.parse(o), s, u.relative === "path");
        n == null &&
          e !== "/" &&
          (f.pathname = f.pathname === "/" ? e : sl([e, f.pathname])),
          (u.replace ? r.replace : r.push)(f, u.state, u);
      },
      [e, r, o, s, n]
    )
  );
}
function WU(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { future: r } = P.useContext(Kc),
    { matches: i } = P.useContext(Yc),
    { pathname: s } = Jc(),
    o = JSON.stringify(FU(i, r.v7_relativeSplatPath));
  return P.useMemo(() => BU(n, JSON.parse(o), s, t === "path"), [n, o, s, t]);
}
function B7(n, e) {
  return z7(n, e);
}
function z7(n, e, t, r) {
  vm() || Xn(!1);
  let { navigator: i } = P.useContext(Kc),
    { matches: s } = P.useContext(Yc),
    o = s[s.length - 1],
    a = o ? o.params : {};
  o && o.pathname;
  let l = o ? o.pathnameBase : "/";
  o && o.route;
  let c = Jc(),
    u;
  if (e) {
    var f;
    let x = typeof e == "string" ? bh(e) : e;
    l === "/" || ((f = x.pathname) != null && f.startsWith(l)) || Xn(!1),
      (u = x);
  } else u = c;
  let p = u.pathname || "/",
    m = p;
  if (l !== "/") {
    let x = l.replace(/^\//, "").split("/");
    m = "/" + p.replace(/^\//, "").split("/").slice(x.length).join("/");
  }
  let v = p7(n, { pathname: m }),
    y = G7(
      v &&
        v.map((x) =>
          Object.assign({}, x, {
            params: Object.assign({}, a, x.params),
            pathname: sl([
              l,
              i.encodeLocation
                ? i.encodeLocation(x.pathname).pathname
                : x.pathname,
            ]),
            pathnameBase:
              x.pathnameBase === "/"
                ? l
                : sl([
                    l,
                    i.encodeLocation
                      ? i.encodeLocation(x.pathnameBase).pathname
                      : x.pathnameBase,
                  ]),
          })
        ),
      s,
      t,
      r
    );
  return e && y
    ? P.createElement(
        Fx.Provider,
        {
          value: {
            location: Op(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              u
            ),
            navigationType: Ka.Pop,
          },
        },
        y
      )
    : y;
}
function V7() {
  let n = K7(),
    e = O7(n)
      ? n.status + " " + n.statusText
      : n instanceof Error
      ? n.message
      : JSON.stringify(n),
    t = n instanceof Error ? n.stack : null,
    i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" };
  return P.createElement(
    P.Fragment,
    null,
    P.createElement("h2", null, "Unexpected Application Error!"),
    P.createElement("h3", { style: { fontStyle: "italic" } }, e),
    t ? P.createElement("pre", { style: i }, t) : null,
    null
  );
}
const j7 = P.createElement(V7, null);
class H7 extends P.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ||
      (t.revalidation !== "idle" && e.revalidation === "idle")
      ? { error: e.error, location: e.location, revalidation: e.revalidation }
      : {
          error: e.error !== void 0 ? e.error : t.error,
          location: t.location,
          revalidation: e.revalidation || t.revalidation,
        };
  }
  componentDidCatch(e, t) {
    console.error(
      "React Router caught the following error during render",
      e,
      t
    );
  }
  render() {
    return this.state.error !== void 0
      ? P.createElement(
          Yc.Provider,
          { value: this.props.routeContext },
          P.createElement(VU.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function W7(n) {
  let { routeContext: e, match: t, children: r } = n,
    i = P.useContext(TM);
  return (
    i &&
      i.static &&
      i.staticContext &&
      (t.route.errorElement || t.route.ErrorBoundary) &&
      (i.staticContext._deepestRenderedBoundaryId = t.route.id),
    P.createElement(Yc.Provider, { value: e }, r)
  );
}
function G7(n, e, t, r) {
  var i;
  if (
    (e === void 0 && (e = []),
    t === void 0 && (t = null),
    r === void 0 && (r = null),
    n == null)
  ) {
    var s;
    if (!t) return null;
    if (t.errors) n = t.matches;
    else if (
      (s = r) != null &&
      s.v7_partialHydration &&
      e.length === 0 &&
      !t.initialized &&
      t.matches.length > 0
    )
      n = t.matches;
    else return null;
  }
  let o = n,
    a = (i = t) == null ? void 0 : i.errors;
  if (a != null) {
    let u = o.findIndex(
      (f) => f.route.id && (a == null ? void 0 : a[f.route.id]) !== void 0
    );
    u >= 0 || Xn(!1), (o = o.slice(0, Math.min(o.length, u + 1)));
  }
  let l = !1,
    c = -1;
  if (t && r && r.v7_partialHydration)
    for (let u = 0; u < o.length; u++) {
      let f = o[u];
      if (
        ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (c = u),
        f.route.id)
      ) {
        let { loaderData: p, errors: m } = t,
          v =
            f.route.loader &&
            p[f.route.id] === void 0 &&
            (!m || m[f.route.id] === void 0);
        if (f.route.lazy || v) {
          (l = !0), c >= 0 ? (o = o.slice(0, c + 1)) : (o = [o[0]]);
          break;
        }
      }
    }
  return o.reduceRight((u, f, p) => {
    let m,
      v = !1,
      y = null,
      x = null;
    t &&
      ((m = a && f.route.id ? a[f.route.id] : void 0),
      (y = f.route.errorElement || j7),
      l &&
        (c < 0 && p === 0
          ? ((v = !0), (x = null))
          : c === p &&
            ((v = !0), (x = f.route.hydrateFallbackElement || null))));
    let g = e.concat(o.slice(0, p + 1)),
      _ = () => {
        let S;
        return (
          m
            ? (S = y)
            : v
            ? (S = x)
            : f.route.Component
            ? (S = P.createElement(f.route.Component, null))
            : f.route.element
            ? (S = f.route.element)
            : (S = u),
          P.createElement(W7, {
            match: f,
            routeContext: { outlet: u, matches: g, isDataRoute: t != null },
            children: S,
          })
        );
      };
    return t && (f.route.ErrorBoundary || f.route.errorElement || p === 0)
      ? P.createElement(H7, {
          location: t.location,
          revalidation: t.revalidation,
          component: y,
          error: m,
          children: _(),
          routeContext: { outlet: null, matches: g, isDataRoute: !0 },
        })
      : _();
  }, null);
}
var GU = (function (n) {
    return (
      (n.UseBlocker = "useBlocker"),
      (n.UseRevalidator = "useRevalidator"),
      (n.UseNavigateStable = "useNavigate"),
      n
    );
  })(GU || {}),
  d0 = (function (n) {
    return (
      (n.UseBlocker = "useBlocker"),
      (n.UseLoaderData = "useLoaderData"),
      (n.UseActionData = "useActionData"),
      (n.UseRouteError = "useRouteError"),
      (n.UseNavigation = "useNavigation"),
      (n.UseRouteLoaderData = "useRouteLoaderData"),
      (n.UseMatches = "useMatches"),
      (n.UseRevalidator = "useRevalidator"),
      (n.UseNavigateStable = "useNavigate"),
      (n.UseRouteId = "useRouteId"),
      n
    );
  })(d0 || {});
function $7(n) {
  let e = P.useContext(TM);
  return e || Xn(!1), e;
}
function X7(n) {
  let e = P.useContext(k7);
  return e || Xn(!1), e;
}
function q7(n) {
  let e = P.useContext(Yc);
  return e || Xn(!1), e;
}
function $U(n) {
  let e = q7(),
    t = e.matches[e.matches.length - 1];
  return t.route.id || Xn(!1), t.route.id;
}
function K7() {
  var n;
  let e = P.useContext(VU),
    t = X7(d0.UseRouteError),
    r = $U(d0.UseRouteError);
  return e !== void 0 ? e : (n = t.errors) == null ? void 0 : n[r];
}
function Y7() {
  let { router: n } = $7(GU.UseNavigateStable),
    e = $U(d0.UseNavigateStable),
    t = P.useRef(!1);
  return (
    jU(() => {
      t.current = !0;
    }),
    P.useCallback(
      function (i, s) {
        s === void 0 && (s = {}),
          t.current &&
            (typeof i == "number"
              ? n.navigate(i)
              : n.navigate(i, Op({ fromRouteId: e }, s)));
      },
      [n, e]
    )
  );
}
function J7(n, e) {
  n == null || n.v7_startTransition, n == null || n.v7_relativeSplatPath;
}
function Ku(n) {
  Xn(!1);
}
function Z7(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: r,
    navigationType: i = Ka.Pop,
    navigator: s,
    static: o = !1,
    future: a,
  } = n;
  vm() && Xn(!1);
  let l = e.replace(/^\/*/, "/"),
    c = P.useMemo(
      () => ({
        basename: l,
        navigator: s,
        static: o,
        future: Op({ v7_relativeSplatPath: !1 }, a),
      }),
      [l, a, s, o]
    );
  typeof r == "string" && (r = bh(r));
  let {
      pathname: u = "/",
      search: f = "",
      hash: p = "",
      state: m = null,
      key: v = "default",
    } = r,
    y = P.useMemo(() => {
      let x = EM(u, l);
      return x == null
        ? null
        : {
            location: { pathname: x, search: f, hash: p, state: m, key: v },
            navigationType: i,
          };
    }, [l, u, f, p, m, v, i]);
  return y == null
    ? null
    : P.createElement(
        Kc.Provider,
        { value: c },
        P.createElement(Fx.Provider, { children: t, value: y })
      );
}
function Q7(n) {
  let { children: e, location: t } = n;
  return B7(Qb(e), t);
}
new Promise(() => {});
function Qb(n, e) {
  e === void 0 && (e = []);
  let t = [];
  return (
    P.Children.forEach(n, (r, i) => {
      if (!P.isValidElement(r)) return;
      let s = [...e, i];
      if (r.type === P.Fragment) {
        t.push.apply(t, Qb(r.props.children, s));
        return;
      }
      r.type !== Ku && Xn(!1), !r.props.index || !r.props.children || Xn(!1);
      let o = {
        id: r.props.id || s.join("-"),
        caseSensitive: r.props.caseSensitive,
        element: r.props.element,
        Component: r.props.Component,
        index: r.props.index,
        path: r.props.path,
        loader: r.props.loader,
        action: r.props.action,
        errorElement: r.props.errorElement,
        ErrorBoundary: r.props.ErrorBoundary,
        hasErrorBoundary:
          r.props.ErrorBoundary != null || r.props.errorElement != null,
        shouldRevalidate: r.props.shouldRevalidate,
        handle: r.props.handle,
        lazy: r.props.lazy,
      };
      r.props.children && (o.children = Qb(r.props.children, s)), t.push(o);
    }),
    t
  );
}
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function eE() {
  return (
    (eE = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r in t)
              Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
          }
          return n;
        }),
    eE.apply(this, arguments)
  );
}
function eX(n, e) {
  if (n == null) return {};
  var t = {},
    r = Object.keys(n),
    i,
    s;
  for (s = 0; s < r.length; s++)
    (i = r[s]), !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function tX(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function nX(n, e) {
  return n.button === 0 && (!e || e === "_self") && !tX(n);
}
const rX = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "viewTransition",
  ],
  iX = "6";
try {
  window.__reactRouterVersion = iX;
} catch {}
const sX = "startTransition",
  kI = pT[sX];
function oX(n) {
  let { basename: e, children: t, future: r, window: i } = n,
    s = P.useRef();
  s.current == null && (s.current = d7({ window: i, v5Compat: !0 }));
  let o = s.current,
    [a, l] = P.useState({ action: o.action, location: o.location }),
    { v7_startTransition: c } = r || {},
    u = P.useCallback(
      (f) => {
        c && kI ? kI(() => l(f)) : l(f);
      },
      [l, c]
    );
  return (
    P.useLayoutEffect(() => o.listen(u), [o, u]),
    P.useEffect(() => J7(r), [r]),
    P.createElement(Z7, {
      basename: e,
      children: t,
      location: a.location,
      navigationType: a.action,
      navigator: o,
      future: r,
    })
  );
}
const aX =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  lX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  yS = P.forwardRef(function (e, t) {
    let {
        onClick: r,
        relative: i,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: c,
        preventScrollReset: u,
        viewTransition: f,
      } = e,
      p = eX(e, rX),
      { basename: m } = P.useContext(Kc),
      v,
      y = !1;
    if (typeof c == "string" && lX.test(c) && ((v = c), aX))
      try {
        let S = new URL(window.location.href),
          b = c.startsWith("//") ? new URL(S.protocol + c) : new URL(c),
          C = EM(b.pathname, m);
        b.origin === S.origin && C != null
          ? (c = C + b.search + b.hash)
          : (y = !0);
      } catch {}
    let x = U7(c, { relative: i }),
      g = cX(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: u,
        relative: i,
        viewTransition: f,
      });
    function _(S) {
      r && r(S), S.defaultPrevented || g(S);
    }
    return P.createElement(
      "a",
      eE({}, p, { href: v || x, onClick: y || s ? r : _, ref: t, target: l })
    );
  });
var UI;
(function (n) {
  (n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmit = "useSubmit"),
    (n.UseSubmitFetcher = "useSubmitFetcher"),
    (n.UseFetcher = "useFetcher"),
    (n.useViewTransitionState = "useViewTransitionState");
})(UI || (UI = {}));
var FI;
(function (n) {
  (n.UseFetcher = "useFetcher"),
    (n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration");
})(FI || (FI = {}));
function cX(n, e) {
  let {
      target: t,
      replace: r,
      state: i,
      preventScrollReset: s,
      relative: o,
      viewTransition: a,
    } = e === void 0 ? {} : e,
    l = HU(),
    c = Jc(),
    u = WU(n, { relative: o });
  return P.useCallback(
    (f) => {
      if (nX(f, t)) {
        f.preventDefault();
        let p = r !== void 0 ? r : u0(c) === u0(u);
        l(n, {
          replace: p,
          state: i,
          preventScrollReset: s,
          relative: o,
          viewTransition: a,
        });
      }
    },
    [c, l, u, r, i, t, n, s, o, a]
  );
}
const BI = (n) => {
    let e;
    const t = new Set(),
      r = (c, u) => {
        const f = typeof c == "function" ? c(e) : c;
        if (!Object.is(f, e)) {
          const p = e;
          (e =
            u ?? (typeof f != "object" || f === null)
              ? f
              : Object.assign({}, e, f)),
            t.forEach((m) => m(e, p));
        }
      },
      i = () => e,
      a = {
        setState: r,
        getState: i,
        getInitialState: () => l,
        subscribe: (c) => (t.add(c), () => t.delete(c)),
      },
      l = (e = n(r, i, a));
    return a;
  },
  uX = (n) => (n ? BI(n) : BI),
  dX = (n) => n;
function hX(n, e = dX) {
  const t = Le.useSyncExternalStore(
    n.subscribe,
    Le.useCallback(() => e(n.getState()), [n, e]),
    Le.useCallback(() => e(n.getInitialState()), [n, e])
  );
  return Le.useDebugValue(t), t;
}
const zI = (n) => {
    const e = uX(n),
      t = (r) => hX(e, r);
    return Object.assign(t, e), t;
  },
  XU = (n) => (n ? zI(n) : zI);
var tE = function (n, e) {
  return (
    (tE =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (t, r) {
          t.__proto__ = r;
        }) ||
      function (t, r) {
        for (var i in r)
          Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
      }),
    tE(n, e)
  );
};
function qU(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError(
      "Class extends value " + String(e) + " is not a constructor or null"
    );
  tE(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype =
    e === null ? Object.create(e) : ((t.prototype = e.prototype), new t());
}
var ts = function () {
  return (
    (ts =
      Object.assign ||
      function (e) {
        for (var t, r = 1, i = arguments.length; r < i; r++) {
          t = arguments[r];
          for (var s in t)
            Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
        }
        return e;
      }),
    ts.apply(this, arguments)
  );
};
function yl(n, e) {
  var t = {};
  for (var r in n)
    Object.prototype.hasOwnProperty.call(n, r) &&
      e.indexOf(r) < 0 &&
      (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(n, r[i]) &&
        (t[r[i]] = n[r[i]]);
  return t;
}
function KU(n, e, t, r) {
  var i = arguments.length,
    s =
      i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
    o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var a = n.length - 1; a >= 0; a--)
      (o = n[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(e, t, s) : o(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function YU(n, e) {
  return function (t, r) {
    e(t, r, n);
  };
}
function JU(n, e, t, r, i, s) {
  function o(g) {
    if (g !== void 0 && typeof g != "function")
      throw new TypeError("Function expected");
    return g;
  }
  for (
    var a = r.kind,
      l = a === "getter" ? "get" : a === "setter" ? "set" : "value",
      c = !e && n ? (r.static ? n : n.prototype) : null,
      u = e || (c ? Object.getOwnPropertyDescriptor(c, r.name) : {}),
      f,
      p = !1,
      m = t.length - 1;
    m >= 0;
    m--
  ) {
    var v = {};
    for (var y in r) v[y] = y === "access" ? {} : r[y];
    for (var y in r.access) v.access[y] = r.access[y];
    v.addInitializer = function (g) {
      if (p)
        throw new TypeError(
          "Cannot add initializers after decoration has completed"
        );
      s.push(o(g || null));
    };
    var x = (0, t[m])(a === "accessor" ? { get: u.get, set: u.set } : u[l], v);
    if (a === "accessor") {
      if (x === void 0) continue;
      if (x === null || typeof x != "object")
        throw new TypeError("Object expected");
      (f = o(x.get)) && (u.get = f),
        (f = o(x.set)) && (u.set = f),
        (f = o(x.init)) && i.unshift(f);
    } else (f = o(x)) && (a === "field" ? i.unshift(f) : (u[l] = f));
  }
  c && Object.defineProperty(c, r.name, u), (p = !0);
}
function ZU(n, e, t) {
  for (var r = arguments.length > 2, i = 0; i < e.length; i++)
    t = r ? e[i].call(n, t) : e[i].call(n);
  return r ? t : void 0;
}
function QU(n) {
  return typeof n == "symbol" ? n : "".concat(n);
}
function eF(n, e, t) {
  return (
    typeof e == "symbol" &&
      (e = e.description ? "[".concat(e.description, "]") : ""),
    Object.defineProperty(n, "name", {
      configurable: !0,
      value: t ? "".concat(t, " ", e) : e,
    })
  );
}
function tF(n, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(n, e);
}
function ct(n, e, t, r) {
  function i(s) {
    return s instanceof t
      ? s
      : new t(function (o) {
          o(s);
        });
  }
  return new (t || (t = Promise))(function (s, o) {
    function a(u) {
      try {
        c(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      u.done ? s(u.value) : i(u.value).then(a, l);
    }
    c((r = r.apply(n, e || [])).next());
  });
}
function nF(n, e) {
  var t = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o = Object.create(
      (typeof Iterator == "function" ? Iterator : Object).prototype
    );
  return (
    (o.next = a(0)),
    (o.throw = a(1)),
    (o.return = a(2)),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(c) {
    return function (u) {
      return l([c, u]);
    };
  }
  function l(c) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && ((o = 0), c[0] && (t = 0)), t; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              c[0] & 2
                ? i.return
                : c[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, c[1])).done)
        )
          return s;
        switch (((i = 0), s && (c = [c[0] & 2, s.value]), c[0])) {
          case 0:
          case 1:
            s = c;
            break;
          case 4:
            return t.label++, { value: c[1], done: !1 };
          case 5:
            t.label++, (i = c[1]), (c = [0]);
            continue;
          case 7:
            (c = t.ops.pop()), t.trys.pop();
            continue;
          default:
            if (
              ((s = t.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (c[0] === 6 || c[0] === 2))
            ) {
              t = 0;
              continue;
            }
            if (c[0] === 3 && (!s || (c[1] > s[0] && c[1] < s[3]))) {
              t.label = c[1];
              break;
            }
            if (c[0] === 6 && t.label < s[1]) {
              (t.label = s[1]), (s = c);
              break;
            }
            if (s && t.label < s[2]) {
              (t.label = s[2]), t.ops.push(c);
              break;
            }
            s[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        c = e.call(n, t);
      } catch (u) {
        (c = [6, u]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (c[0] & 5) throw c[1];
    return { value: c[0] ? c[1] : void 0, done: !0 };
  }
}
var Bx = Object.create
  ? function (n, e, t, r) {
      r === void 0 && (r = t);
      var i = Object.getOwnPropertyDescriptor(e, t);
      (!i || ("get" in i ? !e.__esModule : i.writable || i.configurable)) &&
        (i = {
          enumerable: !0,
          get: function () {
            return e[t];
          },
        }),
        Object.defineProperty(n, r, i);
    }
  : function (n, e, t, r) {
      r === void 0 && (r = t), (n[r] = e[t]);
    };
function rF(n, e) {
  for (var t in n)
    t !== "default" &&
      !Object.prototype.hasOwnProperty.call(e, t) &&
      Bx(e, n, t);
}
function h0(n) {
  var e = typeof Symbol == "function" && Symbol.iterator,
    t = e && n[e],
    r = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number")
    return {
      next: function () {
        return (
          n && r >= n.length && (n = void 0), { value: n && n[r++], done: !n }
        );
      },
    };
  throw new TypeError(
    e ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function MM(n, e) {
  var t = typeof Symbol == "function" && n[Symbol.iterator];
  if (!t) return n;
  var r = t.call(n),
    i,
    s = [],
    o;
  try {
    for (; (e === void 0 || e-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (t = r.return) && t.call(r);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function iF() {
  for (var n = [], e = 0; e < arguments.length; e++)
    n = n.concat(MM(arguments[e]));
  return n;
}
function sF() {
  for (var n = 0, e = 0, t = arguments.length; e < t; e++)
    n += arguments[e].length;
  for (var r = Array(n), i = 0, e = 0; e < t; e++)
    for (var s = arguments[e], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
function CM(n, e, t) {
  if (t || arguments.length === 2)
    for (var r = 0, i = e.length, s; r < i; r++)
      (s || !(r in e)) &&
        (s || (s = Array.prototype.slice.call(e, 0, r)), (s[r] = e[r]));
  return n.concat(s || Array.prototype.slice.call(e));
}
function th(n) {
  return this instanceof th ? ((this.v = n), this) : new th(n);
}
function oF(n, e, t) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = t.apply(n, e || []),
    i,
    s = [];
  return (
    (i = Object.create(
      (typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype
    )),
    a("next"),
    a("throw"),
    a("return", o),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function o(m) {
    return function (v) {
      return Promise.resolve(v).then(m, f);
    };
  }
  function a(m, v) {
    r[m] &&
      ((i[m] = function (y) {
        return new Promise(function (x, g) {
          s.push([m, y, x, g]) > 1 || l(m, y);
        });
      }),
      v && (i[m] = v(i[m])));
  }
  function l(m, v) {
    try {
      c(r[m](v));
    } catch (y) {
      p(s[0][3], y);
    }
  }
  function c(m) {
    m.value instanceof th
      ? Promise.resolve(m.value.v).then(u, f)
      : p(s[0][2], m);
  }
  function u(m) {
    l("next", m);
  }
  function f(m) {
    l("throw", m);
  }
  function p(m, v) {
    m(v), s.shift(), s.length && l(s[0][0], s[0][1]);
  }
}
function aF(n) {
  var e, t;
  return (
    (e = {}),
    r("next"),
    r("throw", function (i) {
      throw i;
    }),
    r("return"),
    (e[Symbol.iterator] = function () {
      return this;
    }),
    e
  );
  function r(i, s) {
    e[i] = n[i]
      ? function (o) {
          return (t = !t) ? { value: th(n[i](o)), done: !1 } : s ? s(o) : o;
        }
      : s;
  }
}
function lF(n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var e = n[Symbol.asyncIterator],
    t;
  return e
    ? e.call(n)
    : ((n = typeof h0 == "function" ? h0(n) : n[Symbol.iterator]()),
      (t = {}),
      r("next"),
      r("throw"),
      r("return"),
      (t[Symbol.asyncIterator] = function () {
        return this;
      }),
      t);
  function r(s) {
    t[s] =
      n[s] &&
      function (o) {
        return new Promise(function (a, l) {
          (o = n[s](o)), i(a, l, o.done, o.value);
        });
      };
  }
  function i(s, o, a, l) {
    Promise.resolve(l).then(function (c) {
      s({ value: c, done: a });
    }, o);
  }
}
function cF(n, e) {
  return (
    Object.defineProperty
      ? Object.defineProperty(n, "raw", { value: e })
      : (n.raw = e),
    n
  );
}
var fX = Object.create
    ? function (n, e) {
        Object.defineProperty(n, "default", { enumerable: !0, value: e });
      }
    : function (n, e) {
        n.default = e;
      },
  nE = function (n) {
    return (
      (nE =
        Object.getOwnPropertyNames ||
        function (e) {
          var t = [];
          for (var r in e)
            Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
          return t;
        }),
      nE(n)
    );
  };
function uF(n) {
  if (n && n.__esModule) return n;
  var e = {};
  if (n != null)
    for (var t = nE(n), r = 0; r < t.length; r++)
      t[r] !== "default" && Bx(e, n, t[r]);
  return fX(e, n), e;
}
function dF(n) {
  return n && n.__esModule ? n : { default: n };
}
function hF(n, e, t, r) {
  if (t === "a" && !r)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof e == "function" ? n !== e || !r : !e.has(n))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n);
}
function fF(n, e, t, r, i) {
  if (r === "m") throw new TypeError("Private method is not writable");
  if (r === "a" && !i)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof e == "function" ? n !== e || !i : !e.has(n))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return r === "a" ? i.call(n, t) : i ? (i.value = t) : e.set(n, t), t;
}
function pF(n, e) {
  if (e === null || (typeof e != "object" && typeof e != "function"))
    throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof n == "function" ? e === n : n.has(e);
}
function mF(n, e, t) {
  if (e != null) {
    if (typeof e != "object" && typeof e != "function")
      throw new TypeError("Object expected.");
    var r, i;
    if (t) {
      if (!Symbol.asyncDispose)
        throw new TypeError("Symbol.asyncDispose is not defined.");
      r = e[Symbol.asyncDispose];
    }
    if (r === void 0) {
      if (!Symbol.dispose)
        throw new TypeError("Symbol.dispose is not defined.");
      (r = e[Symbol.dispose]), t && (i = r);
    }
    if (typeof r != "function") throw new TypeError("Object not disposable.");
    i &&
      (r = function () {
        try {
          i.call(this);
        } catch (s) {
          return Promise.reject(s);
        }
      }),
      n.stack.push({ value: e, dispose: r, async: t });
  } else t && n.stack.push({ async: !0 });
  return e;
}
var pX =
  typeof SuppressedError == "function"
    ? SuppressedError
    : function (n, e, t) {
        var r = new Error(t);
        return (
          (r.name = "SuppressedError"), (r.error = n), (r.suppressed = e), r
        );
      };
function gF(n) {
  function e(s) {
    (n.error = n.hasError
      ? new pX(s, n.error, "An error was suppressed during disposal.")
      : s),
      (n.hasError = !0);
  }
  var t,
    r = 0;
  function i() {
    for (; (t = n.stack.pop()); )
      try {
        if (!t.async && r === 1)
          return (r = 0), n.stack.push(t), Promise.resolve().then(i);
        if (t.dispose) {
          var s = t.dispose.call(t.value);
          if (t.async)
            return (
              (r |= 2),
              Promise.resolve(s).then(i, function (o) {
                return e(o), i();
              })
            );
        } else r |= 1;
      } catch (o) {
        e(o);
      }
    if (r === 1)
      return n.hasError ? Promise.reject(n.error) : Promise.resolve();
    if (n.hasError) throw n.error;
  }
  return i();
}
function vF(n, e) {
  return typeof n == "string" && /^\.\.?\//.test(n)
    ? n.replace(
        /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
        function (t, r, i, s, o) {
          return r
            ? e
              ? ".jsx"
              : ".js"
            : i && (!s || !o)
            ? t
            : i + s + "." + o.toLowerCase() + "js";
        }
      )
    : n;
}
const mX = {
    __extends: qU,
    __assign: ts,
    __rest: yl,
    __decorate: KU,
    __param: YU,
    __esDecorate: JU,
    __runInitializers: ZU,
    __propKey: QU,
    __setFunctionName: eF,
    __metadata: tF,
    __awaiter: ct,
    __generator: nF,
    __createBinding: Bx,
    __exportStar: rF,
    __values: h0,
    __read: MM,
    __spread: iF,
    __spreadArrays: sF,
    __spreadArray: CM,
    __await: th,
    __asyncGenerator: oF,
    __asyncDelegator: aF,
    __asyncValues: lF,
    __makeTemplateObject: cF,
    __importStar: uF,
    __importDefault: dF,
    __classPrivateFieldGet: hF,
    __classPrivateFieldSet: fF,
    __classPrivateFieldIn: pF,
    __addDisposableResource: mF,
    __disposeResources: gF,
    __rewriteRelativeImportExtension: vF,
  },
  gX = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        __addDisposableResource: mF,
        get __assign() {
          return ts;
        },
        __asyncDelegator: aF,
        __asyncGenerator: oF,
        __asyncValues: lF,
        __await: th,
        __awaiter: ct,
        __classPrivateFieldGet: hF,
        __classPrivateFieldIn: pF,
        __classPrivateFieldSet: fF,
        __createBinding: Bx,
        __decorate: KU,
        __disposeResources: gF,
        __esDecorate: JU,
        __exportStar: rF,
        __extends: qU,
        __generator: nF,
        __importDefault: dF,
        __importStar: uF,
        __makeTemplateObject: cF,
        __metadata: tF,
        __param: YU,
        __propKey: QU,
        __read: MM,
        __rest: yl,
        __rewriteRelativeImportExtension: vF,
        __runInitializers: ZU,
        __setFunctionName: eF,
        __spread: iF,
        __spreadArray: CM,
        __spreadArrays: sF,
        __values: h0,
        default: mX,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  vX = "modulepreload",
  yX = function (n) {
    return "/" + n;
  },
  VI = {},
  Eh = function (e, t, r) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
      document.getElementsByTagName("link");
      const o = document.querySelector("meta[property=csp-nonce]"),
        a =
          (o == null ? void 0 : o.nonce) ||
          (o == null ? void 0 : o.getAttribute("nonce"));
      i = Promise.allSettled(
        t.map((l) => {
          if (((l = yX(l)), l in VI)) return;
          VI[l] = !0;
          const c = l.endsWith(".css"),
            u = c ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${l}"]${u}`)) return;
          const f = document.createElement("link");
          if (
            ((f.rel = c ? "stylesheet" : vX),
            c || (f.as = "script"),
            (f.crossOrigin = ""),
            (f.href = l),
            a && f.setAttribute("nonce", a),
            document.head.appendChild(f),
            c)
          )
            return new Promise((p, m) => {
              f.addEventListener("load", p),
                f.addEventListener("error", () =>
                  m(new Error(`Unable to preload CSS for ${l}`))
                );
            });
        })
      );
    }
    function s(o) {
      const a = new Event("vite:preloadError", { cancelable: !0 });
      if (((a.payload = o), window.dispatchEvent(a), !a.defaultPrevented))
        throw o;
    }
    return i.then((o) => {
      for (const a of o || []) a.status === "rejected" && s(a.reason);
      return e().catch(s);
    });
  },
  xX = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Eh(async () => {
              const { default: r } = await Promise.resolve().then(() => Zc);
              return { default: r };
            }, void 0).then(({ default: r }) => r(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  };
class AM extends Error {
  constructor(e, t = "FunctionsError", r) {
    super(e), (this.name = t), (this.context = r);
  }
}
class jI extends AM {
  constructor(e) {
    super(
      "Failed to send a request to the Edge Function",
      "FunctionsFetchError",
      e
    );
  }
}
class HI extends AM {
  constructor(e) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", e);
  }
}
class WI extends AM {
  constructor(e) {
    super(
      "Edge Function returned a non-2xx status code",
      "FunctionsHttpError",
      e
    );
  }
}
var rE;
(function (n) {
  (n.Any = "any"),
    (n.ApNortheast1 = "ap-northeast-1"),
    (n.ApNortheast2 = "ap-northeast-2"),
    (n.ApSouth1 = "ap-south-1"),
    (n.ApSoutheast1 = "ap-southeast-1"),
    (n.ApSoutheast2 = "ap-southeast-2"),
    (n.CaCentral1 = "ca-central-1"),
    (n.EuCentral1 = "eu-central-1"),
    (n.EuWest1 = "eu-west-1"),
    (n.EuWest2 = "eu-west-2"),
    (n.EuWest3 = "eu-west-3"),
    (n.SaEast1 = "sa-east-1"),
    (n.UsEast1 = "us-east-1"),
    (n.UsWest1 = "us-west-1"),
    (n.UsWest2 = "us-west-2");
})(rE || (rE = {}));
class _X {
  constructor(e, { headers: t = {}, customFetch: r, region: i = rE.Any } = {}) {
    (this.url = e), (this.headers = t), (this.region = i), (this.fetch = xX(r));
  }
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`;
  }
  invoke(e) {
    return ct(this, arguments, void 0, function* (t, r = {}) {
      var i;
      try {
        const { headers: s, method: o, body: a, signal: l } = r;
        let c = {},
          { region: u } = r;
        u || (u = this.region);
        const f = new URL(`${this.url}/${t}`);
        u &&
          u !== "any" &&
          ((c["x-region"] = u), f.searchParams.set("forceFunctionRegion", u));
        let p;
        a &&
        ((s && !Object.prototype.hasOwnProperty.call(s, "Content-Type")) || !s)
          ? (typeof Blob < "u" && a instanceof Blob) || a instanceof ArrayBuffer
            ? ((c["Content-Type"] = "application/octet-stream"), (p = a))
            : typeof a == "string"
            ? ((c["Content-Type"] = "text/plain"), (p = a))
            : typeof FormData < "u" && a instanceof FormData
            ? (p = a)
            : ((c["Content-Type"] = "application/json"),
              (p = JSON.stringify(a)))
          : (p = a);
        const m = yield this.fetch(f.toString(), {
            method: o || "POST",
            headers: Object.assign(
              Object.assign(Object.assign({}, c), this.headers),
              s
            ),
            body: p,
            signal: l,
          }).catch((g) => {
            throw g.name === "AbortError" ? g : new jI(g);
          }),
          v = m.headers.get("x-relay-error");
        if (v && v === "true") throw new HI(m);
        if (!m.ok) throw new WI(m);
        let y = (
            (i = m.headers.get("Content-Type")) !== null && i !== void 0
              ? i
              : "text/plain"
          )
            .split(";")[0]
            .trim(),
          x;
        return (
          y === "application/json"
            ? (x = yield m.json())
            : y === "application/octet-stream" || y === "application/pdf"
            ? (x = yield m.blob())
            : y === "text/event-stream"
            ? (x = m)
            : y === "multipart/form-data"
            ? (x = yield m.formData())
            : (x = yield m.text()),
          { data: x, error: null, response: m }
        );
      } catch (s) {
        return s instanceof Error && s.name === "AbortError"
          ? { data: null, error: new jI(s) }
          : {
              data: null,
              error: s,
              response: s instanceof WI || s instanceof HI ? s.context : void 0,
            };
      }
    });
  }
}
var Xr = {};
const Th = HO(gX);
var Qg = {},
  ev = {},
  tv = {},
  nv = {},
  rv = {},
  wX = function () {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  },
  nh = wX();
const SX = nh.fetch,
  yF = nh.fetch.bind(nh),
  xF = nh.Headers,
  bX = nh.Request,
  EX = nh.Response,
  Zc = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Headers: xF,
        Request: bX,
        Response: EX,
        default: yF,
        fetch: SX,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  TX = HO(Zc);
var iv = {},
  GI;
function _F() {
  if (GI) return iv;
  (GI = 1), Object.defineProperty(iv, "__esModule", { value: !0 });
  class n extends Error {
    constructor(t) {
      super(t.message),
        (this.name = "PostgrestError"),
        (this.details = t.details),
        (this.hint = t.hint),
        (this.code = t.code);
    }
  }
  return (iv.default = n), iv;
}
var $I;
function wF() {
  if ($I) return rv;
  ($I = 1), Object.defineProperty(rv, "__esModule", { value: !0 });
  const n = Th,
    e = n.__importDefault(TX),
    t = n.__importDefault(_F());
  class r {
    constructor(s) {
      var o, a;
      (this.shouldThrowOnError = !1),
        (this.method = s.method),
        (this.url = s.url),
        (this.headers = new Headers(s.headers)),
        (this.schema = s.schema),
        (this.body = s.body),
        (this.shouldThrowOnError =
          (o = s.shouldThrowOnError) !== null && o !== void 0 ? o : !1),
        (this.signal = s.signal),
        (this.isMaybeSingle =
          (a = s.isMaybeSingle) !== null && a !== void 0 ? a : !1),
        s.fetch
          ? (this.fetch = s.fetch)
          : typeof fetch > "u"
          ? (this.fetch = e.default)
          : (this.fetch = fetch);
    }
    throwOnError() {
      return (this.shouldThrowOnError = !0), this;
    }
    setHeader(s, o) {
      return (
        (this.headers = new Headers(this.headers)), this.headers.set(s, o), this
      );
    }
    then(s, o) {
      this.schema === void 0 ||
        (["GET", "HEAD"].includes(this.method)
          ? this.headers.set("Accept-Profile", this.schema)
          : this.headers.set("Content-Profile", this.schema)),
        this.method !== "GET" &&
          this.method !== "HEAD" &&
          this.headers.set("Content-Type", "application/json");
      const a = this.fetch;
      let l = a(this.url.toString(), {
        method: this.method,
        headers: this.headers,
        body: JSON.stringify(this.body),
        signal: this.signal,
      }).then(async (c) => {
        var u, f, p, m;
        let v = null,
          y = null,
          x = null,
          g = c.status,
          _ = c.statusText;
        if (c.ok) {
          if (this.method !== "HEAD") {
            const A = await c.text();
            A === "" ||
              (this.headers.get("Accept") === "text/csv" ||
              (this.headers.get("Accept") &&
                !((u = this.headers.get("Accept")) === null || u === void 0) &&
                u.includes("application/vnd.pgrst.plan+text"))
                ? (y = A)
                : (y = JSON.parse(A)));
          }
          const b =
              (f = this.headers.get("Prefer")) === null || f === void 0
                ? void 0
                : f.match(/count=(exact|planned|estimated)/),
            C =
              (p = c.headers.get("content-range")) === null || p === void 0
                ? void 0
                : p.split("/");
          b && C && C.length > 1 && (x = parseInt(C[1])),
            this.isMaybeSingle &&
              this.method === "GET" &&
              Array.isArray(y) &&
              (y.length > 1
                ? ((v = {
                    code: "PGRST116",
                    details: `Results contain ${y.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message:
                      "JSON object requested, multiple (or no) rows returned",
                  }),
                  (y = null),
                  (x = null),
                  (g = 406),
                  (_ = "Not Acceptable"))
                : y.length === 1
                ? (y = y[0])
                : (y = null));
        } else {
          const b = await c.text();
          try {
            (v = JSON.parse(b)),
              Array.isArray(v) &&
                c.status === 404 &&
                ((y = []), (v = null), (g = 200), (_ = "OK"));
          } catch {
            c.status === 404 && b === ""
              ? ((g = 204), (_ = "No Content"))
              : (v = { message: b });
          }
          if (
            (v &&
              this.isMaybeSingle &&
              !(
                (m = v == null ? void 0 : v.details) === null || m === void 0
              ) &&
              m.includes("0 rows") &&
              ((v = null), (g = 200), (_ = "OK")),
            v && this.shouldThrowOnError)
          )
            throw new t.default(v);
        }
        return { error: v, data: y, count: x, status: g, statusText: _ };
      });
      return (
        this.shouldThrowOnError ||
          (l = l.catch((c) => {
            var u, f, p;
            return {
              error: {
                message: `${
                  (u = c == null ? void 0 : c.name) !== null && u !== void 0
                    ? u
                    : "FetchError"
                }: ${c == null ? void 0 : c.message}`,
                details: `${
                  (f = c == null ? void 0 : c.stack) !== null && f !== void 0
                    ? f
                    : ""
                }`,
                hint: "",
                code: `${
                  (p = c == null ? void 0 : c.code) !== null && p !== void 0
                    ? p
                    : ""
                }`,
              },
              data: null,
              count: null,
              status: 0,
              statusText: "",
            };
          })),
        l.then(s, o)
      );
    }
    returns() {
      return this;
    }
    overrideTypes() {
      return this;
    }
  }
  return (rv.default = r), rv;
}
var XI;
function SF() {
  if (XI) return nv;
  (XI = 1), Object.defineProperty(nv, "__esModule", { value: !0 });
  const e = Th.__importDefault(wF());
  class t extends e.default {
    select(i) {
      let s = !1;
      const o = (i ?? "*")
        .split("")
        .map((a) => (/\s/.test(a) && !s ? "" : (a === '"' && (s = !s), a)))
        .join("");
      return (
        this.url.searchParams.set("select", o),
        this.headers.append("Prefer", "return=representation"),
        this
      );
    }
    order(
      i,
      {
        ascending: s = !0,
        nullsFirst: o,
        foreignTable: a,
        referencedTable: l = a,
      } = {}
    ) {
      const c = l ? `${l}.order` : "order",
        u = this.url.searchParams.get(c);
      return (
        this.url.searchParams.set(
          c,
          `${u ? `${u},` : ""}${i}.${s ? "asc" : "desc"}${
            o === void 0 ? "" : o ? ".nullsfirst" : ".nullslast"
          }`
        ),
        this
      );
    }
    limit(i, { foreignTable: s, referencedTable: o = s } = {}) {
      const a = typeof o > "u" ? "limit" : `${o}.limit`;
      return this.url.searchParams.set(a, `${i}`), this;
    }
    range(i, s, { foreignTable: o, referencedTable: a = o } = {}) {
      const l = typeof a > "u" ? "offset" : `${a}.offset`,
        c = typeof a > "u" ? "limit" : `${a}.limit`;
      return (
        this.url.searchParams.set(l, `${i}`),
        this.url.searchParams.set(c, `${s - i + 1}`),
        this
      );
    }
    abortSignal(i) {
      return (this.signal = i), this;
    }
    single() {
      return (
        this.headers.set("Accept", "application/vnd.pgrst.object+json"), this
      );
    }
    maybeSingle() {
      return (
        this.method === "GET"
          ? this.headers.set("Accept", "application/json")
          : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        (this.isMaybeSingle = !0),
        this
      );
    }
    csv() {
      return this.headers.set("Accept", "text/csv"), this;
    }
    geojson() {
      return this.headers.set("Accept", "application/geo+json"), this;
    }
    explain({
      analyze: i = !1,
      verbose: s = !1,
      settings: o = !1,
      buffers: a = !1,
      wal: l = !1,
      format: c = "text",
    } = {}) {
      var u;
      const f = [
          i ? "analyze" : null,
          s ? "verbose" : null,
          o ? "settings" : null,
          a ? "buffers" : null,
          l ? "wal" : null,
        ]
          .filter(Boolean)
          .join("|"),
        p =
          (u = this.headers.get("Accept")) !== null && u !== void 0
            ? u
            : "application/json";
      return (
        this.headers.set(
          "Accept",
          `application/vnd.pgrst.plan+${c}; for="${p}"; options=${f};`
        ),
        c === "json" ? this : this
      );
    }
    rollback() {
      return this.headers.append("Prefer", "tx=rollback"), this;
    }
    returns() {
      return this;
    }
    maxAffected(i) {
      return (
        this.headers.append("Prefer", "handling=strict"),
        this.headers.append("Prefer", `max-affected=${i}`),
        this
      );
    }
  }
  return (nv.default = t), nv;
}
var qI;
function RM() {
  if (qI) return tv;
  (qI = 1), Object.defineProperty(tv, "__esModule", { value: !0 });
  const e = Th.__importDefault(SF()),
    t = new RegExp("[,()]");
  class r extends e.default {
    eq(s, o) {
      return this.url.searchParams.append(s, `eq.${o}`), this;
    }
    neq(s, o) {
      return this.url.searchParams.append(s, `neq.${o}`), this;
    }
    gt(s, o) {
      return this.url.searchParams.append(s, `gt.${o}`), this;
    }
    gte(s, o) {
      return this.url.searchParams.append(s, `gte.${o}`), this;
    }
    lt(s, o) {
      return this.url.searchParams.append(s, `lt.${o}`), this;
    }
    lte(s, o) {
      return this.url.searchParams.append(s, `lte.${o}`), this;
    }
    like(s, o) {
      return this.url.searchParams.append(s, `like.${o}`), this;
    }
    likeAllOf(s, o) {
      return (
        this.url.searchParams.append(s, `like(all).{${o.join(",")}}`), this
      );
    }
    likeAnyOf(s, o) {
      return (
        this.url.searchParams.append(s, `like(any).{${o.join(",")}}`), this
      );
    }
    ilike(s, o) {
      return this.url.searchParams.append(s, `ilike.${o}`), this;
    }
    ilikeAllOf(s, o) {
      return (
        this.url.searchParams.append(s, `ilike(all).{${o.join(",")}}`), this
      );
    }
    ilikeAnyOf(s, o) {
      return (
        this.url.searchParams.append(s, `ilike(any).{${o.join(",")}}`), this
      );
    }
    is(s, o) {
      return this.url.searchParams.append(s, `is.${o}`), this;
    }
    in(s, o) {
      const a = Array.from(new Set(o))
        .map((l) => (typeof l == "string" && t.test(l) ? `"${l}"` : `${l}`))
        .join(",");
      return this.url.searchParams.append(s, `in.(${a})`), this;
    }
    contains(s, o) {
      return (
        typeof o == "string"
          ? this.url.searchParams.append(s, `cs.${o}`)
          : Array.isArray(o)
          ? this.url.searchParams.append(s, `cs.{${o.join(",")}}`)
          : this.url.searchParams.append(s, `cs.${JSON.stringify(o)}`),
        this
      );
    }
    containedBy(s, o) {
      return (
        typeof o == "string"
          ? this.url.searchParams.append(s, `cd.${o}`)
          : Array.isArray(o)
          ? this.url.searchParams.append(s, `cd.{${o.join(",")}}`)
          : this.url.searchParams.append(s, `cd.${JSON.stringify(o)}`),
        this
      );
    }
    rangeGt(s, o) {
      return this.url.searchParams.append(s, `sr.${o}`), this;
    }
    rangeGte(s, o) {
      return this.url.searchParams.append(s, `nxl.${o}`), this;
    }
    rangeLt(s, o) {
      return this.url.searchParams.append(s, `sl.${o}`), this;
    }
    rangeLte(s, o) {
      return this.url.searchParams.append(s, `nxr.${o}`), this;
    }
    rangeAdjacent(s, o) {
      return this.url.searchParams.append(s, `adj.${o}`), this;
    }
    overlaps(s, o) {
      return (
        typeof o == "string"
          ? this.url.searchParams.append(s, `ov.${o}`)
          : this.url.searchParams.append(s, `ov.{${o.join(",")}}`),
        this
      );
    }
    textSearch(s, o, { config: a, type: l } = {}) {
      let c = "";
      l === "plain"
        ? (c = "pl")
        : l === "phrase"
        ? (c = "ph")
        : l === "websearch" && (c = "w");
      const u = a === void 0 ? "" : `(${a})`;
      return this.url.searchParams.append(s, `${c}fts${u}.${o}`), this;
    }
    match(s) {
      return (
        Object.entries(s).forEach(([o, a]) => {
          this.url.searchParams.append(o, `eq.${a}`);
        }),
        this
      );
    }
    not(s, o, a) {
      return this.url.searchParams.append(s, `not.${o}.${a}`), this;
    }
    or(s, { foreignTable: o, referencedTable: a = o } = {}) {
      const l = a ? `${a}.or` : "or";
      return this.url.searchParams.append(l, `(${s})`), this;
    }
    filter(s, o, a) {
      return this.url.searchParams.append(s, `${o}.${a}`), this;
    }
  }
  return (tv.default = r), tv;
}
var KI;
function bF() {
  if (KI) return ev;
  (KI = 1), Object.defineProperty(ev, "__esModule", { value: !0 });
  const e = Th.__importDefault(RM());
  class t {
    constructor(i, { headers: s = {}, schema: o, fetch: a }) {
      (this.url = i),
        (this.headers = new Headers(s)),
        (this.schema = o),
        (this.fetch = a);
    }
    select(i, s) {
      const { head: o = !1, count: a } = s ?? {},
        l = o ? "HEAD" : "GET";
      let c = !1;
      const u = (i ?? "*")
        .split("")
        .map((f) => (/\s/.test(f) && !c ? "" : (f === '"' && (c = !c), f)))
        .join("");
      return (
        this.url.searchParams.set("select", u),
        a && this.headers.append("Prefer", `count=${a}`),
        new e.default({
          method: l,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: this.fetch,
        })
      );
    }
    insert(i, { count: s, defaultToNull: o = !0 } = {}) {
      var a;
      const l = "POST";
      if (
        (s && this.headers.append("Prefer", `count=${s}`),
        o || this.headers.append("Prefer", "missing=default"),
        Array.isArray(i))
      ) {
        const c = i.reduce((u, f) => u.concat(Object.keys(f)), []);
        if (c.length > 0) {
          const u = [...new Set(c)].map((f) => `"${f}"`);
          this.url.searchParams.set("columns", u.join(","));
        }
      }
      return new e.default({
        method: l,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: i,
        fetch: (a = this.fetch) !== null && a !== void 0 ? a : fetch,
      });
    }
    upsert(
      i,
      {
        onConflict: s,
        ignoreDuplicates: o = !1,
        count: a,
        defaultToNull: l = !0,
      } = {}
    ) {
      var c;
      const u = "POST";
      if (
        (this.headers.append(
          "Prefer",
          `resolution=${o ? "ignore" : "merge"}-duplicates`
        ),
        s !== void 0 && this.url.searchParams.set("on_conflict", s),
        a && this.headers.append("Prefer", `count=${a}`),
        l || this.headers.append("Prefer", "missing=default"),
        Array.isArray(i))
      ) {
        const f = i.reduce((p, m) => p.concat(Object.keys(m)), []);
        if (f.length > 0) {
          const p = [...new Set(f)].map((m) => `"${m}"`);
          this.url.searchParams.set("columns", p.join(","));
        }
      }
      return new e.default({
        method: u,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: i,
        fetch: (c = this.fetch) !== null && c !== void 0 ? c : fetch,
      });
    }
    update(i, { count: s } = {}) {
      var o;
      const a = "PATCH";
      return (
        s && this.headers.append("Prefer", `count=${s}`),
        new e.default({
          method: a,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          body: i,
          fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch,
        })
      );
    }
    delete({ count: i } = {}) {
      var s;
      const o = "DELETE";
      return (
        i && this.headers.append("Prefer", `count=${i}`),
        new e.default({
          method: o,
          url: this.url,
          headers: this.headers,
          schema: this.schema,
          fetch: (s = this.fetch) !== null && s !== void 0 ? s : fetch,
        })
      );
    }
  }
  return (ev.default = t), ev;
}
var YI;
function MX() {
  if (YI) return Qg;
  (YI = 1), Object.defineProperty(Qg, "__esModule", { value: !0 });
  const n = Th,
    e = n.__importDefault(bF()),
    t = n.__importDefault(RM());
  class r {
    constructor(s, { headers: o = {}, schema: a, fetch: l } = {}) {
      (this.url = s),
        (this.headers = new Headers(o)),
        (this.schemaName = a),
        (this.fetch = l);
    }
    from(s) {
      const o = new URL(`${this.url}/${s}`);
      return new e.default(o, {
        headers: new Headers(this.headers),
        schema: this.schemaName,
        fetch: this.fetch,
      });
    }
    schema(s) {
      return new r(this.url, {
        headers: this.headers,
        schema: s,
        fetch: this.fetch,
      });
    }
    rpc(s, o = {}, { head: a = !1, get: l = !1, count: c } = {}) {
      var u;
      let f;
      const p = new URL(`${this.url}/rpc/${s}`);
      let m;
      a || l
        ? ((f = a ? "HEAD" : "GET"),
          Object.entries(o)
            .filter(([y, x]) => x !== void 0)
            .map(([y, x]) => [
              y,
              Array.isArray(x) ? `{${x.join(",")}}` : `${x}`,
            ])
            .forEach(([y, x]) => {
              p.searchParams.append(y, x);
            }))
        : ((f = "POST"), (m = o));
      const v = new Headers(this.headers);
      return (
        c && v.set("Prefer", `count=${c}`),
        new t.default({
          method: f,
          url: p,
          headers: v,
          schema: this.schemaName,
          body: m,
          fetch: (u = this.fetch) !== null && u !== void 0 ? u : fetch,
        })
      );
    }
  }
  return (Qg.default = r), Qg;
}
Object.defineProperty(Xr, "__esModule", { value: !0 });
var EF =
  (Xr.PostgrestError =
  OF =
  Xr.PostgrestBuilder =
  NF =
  Xr.PostgrestTransformBuilder =
  PF =
  Xr.PostgrestFilterBuilder =
  AF =
  Xr.PostgrestQueryBuilder =
  MF =
  Xr.PostgrestClient =
    void 0);
const Mh = Th,
  TF = Mh.__importDefault(MX());
var MF = (Xr.PostgrestClient = TF.default);
const CF = Mh.__importDefault(bF());
var AF = (Xr.PostgrestQueryBuilder = CF.default);
const RF = Mh.__importDefault(RM());
var PF = (Xr.PostgrestFilterBuilder = RF.default);
const IF = Mh.__importDefault(SF());
var NF = (Xr.PostgrestTransformBuilder = IF.default);
const LF = Mh.__importDefault(wF());
var OF = (Xr.PostgrestBuilder = LF.default);
const DF = Mh.__importDefault(_F());
EF = Xr.PostgrestError = DF.default;
var kF = (Xr.default = {
  PostgrestClient: TF.default,
  PostgrestQueryBuilder: CF.default,
  PostgrestFilterBuilder: RF.default,
  PostgrestTransformBuilder: IF.default,
  PostgrestBuilder: LF.default,
  PostgrestError: DF.default,
});
const CX = jO(
    {
      __proto__: null,
      get PostgrestBuilder() {
        return OF;
      },
      get PostgrestClient() {
        return MF;
      },
      get PostgrestError() {
        return EF;
      },
      get PostgrestFilterBuilder() {
        return PF;
      },
      get PostgrestQueryBuilder() {
        return AF;
      },
      get PostgrestTransformBuilder() {
        return NF;
      },
      default: kF,
    },
    [Xr]
  ),
  {
    PostgrestClient: AX,
    PostgrestQueryBuilder: ehe,
    PostgrestFilterBuilder: the,
    PostgrestTransformBuilder: nhe,
    PostgrestBuilder: rhe,
    PostgrestError: ihe,
  } = kF || CX;
class RX {
  static detectEnvironment() {
    var e;
    if (typeof WebSocket < "u")
      return { type: "native", constructor: WebSocket };
    if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
      return { type: "native", constructor: globalThis.WebSocket };
    if (typeof global < "u" && typeof global.WebSocket < "u")
      return { type: "native", constructor: global.WebSocket };
    if (
      typeof globalThis < "u" &&
      typeof globalThis.WebSocketPair < "u" &&
      typeof globalThis.WebSocket > "u"
    )
      return {
        type: "cloudflare",
        error:
          "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
        workaround:
          "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.",
      };
    if (
      (typeof globalThis < "u" && globalThis.EdgeRuntime) ||
      (typeof navigator < "u" &&
        !((e = navigator.userAgent) === null || e === void 0) &&
        e.includes("Vercel-Edge"))
    )
      return {
        type: "unsupported",
        error:
          "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
        workaround:
          "Use serverless functions or a different deployment target for WebSocket functionality.",
      };
    if (typeof process < "u") {
      const t = process.versions;
      if (t && t.node) {
        const r = t.node,
          i = parseInt(r.replace(/^v/, "").split(".")[0]);
        return i >= 22
          ? typeof globalThis.WebSocket < "u"
            ? { type: "native", constructor: globalThis.WebSocket }
            : {
                type: "unsupported",
                error: `Node.js ${i} detected but native WebSocket not found.`,
                workaround:
                  "Provide a WebSocket implementation via the transport option.",
              }
          : {
              type: "unsupported",
              error: `Node.js ${i} detected without native WebSocket support.`,
              workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`,
            };
      }
    }
    return {
      type: "unsupported",
      error: "Unknown JavaScript runtime without WebSocket support.",
      workaround:
        "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.",
    };
  }
  static getWebSocketConstructor() {
    const e = this.detectEnvironment();
    if (e.constructor) return e.constructor;
    let t = e.error || "WebSocket not supported in this environment.";
    throw (
      (e.workaround &&
        (t += `

Suggested solution: ${e.workaround}`),
      new Error(t))
    );
  }
  static createWebSocket(e, t) {
    const r = this.getWebSocketConstructor();
    return new r(e, t);
  }
  static isWebSocketSupported() {
    try {
      const e = this.detectEnvironment();
      return e.type === "native" || e.type === "ws";
    } catch {
      return !1;
    }
  }
}
const PX = "2.78.0",
  IX = `realtime-js/${PX}`,
  NX = "1.0.0",
  iE = 1e4,
  LX = 1e3,
  OX = 100;
var qf;
(function (n) {
  (n[(n.connecting = 0)] = "connecting"),
    (n[(n.open = 1)] = "open"),
    (n[(n.closing = 2)] = "closing"),
    (n[(n.closed = 3)] = "closed");
})(qf || (qf = {}));
var Kn;
(function (n) {
  (n.closed = "closed"),
    (n.errored = "errored"),
    (n.joined = "joined"),
    (n.joining = "joining"),
    (n.leaving = "leaving");
})(Kn || (Kn = {}));
var Rs;
(function (n) {
  (n.close = "phx_close"),
    (n.error = "phx_error"),
    (n.join = "phx_join"),
    (n.reply = "phx_reply"),
    (n.leave = "phx_leave"),
    (n.access_token = "access_token");
})(Rs || (Rs = {}));
var sE;
(function (n) {
  n.websocket = "websocket";
})(sE || (sE = {}));
var ac;
(function (n) {
  (n.Connecting = "connecting"),
    (n.Open = "open"),
    (n.Closing = "closing"),
    (n.Closed = "closed");
})(ac || (ac = {}));
class DX {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(e, t) {
    return e.constructor === ArrayBuffer
      ? t(this._binaryDecode(e))
      : t(typeof e == "string" ? JSON.parse(e) : {});
  }
  _binaryDecode(e) {
    const t = new DataView(e),
      r = new TextDecoder();
    return this._decodeBroadcast(e, t, r);
  }
  _decodeBroadcast(e, t, r) {
    const i = t.getUint8(1),
      s = t.getUint8(2);
    let o = this.HEADER_LENGTH + 2;
    const a = r.decode(e.slice(o, o + i));
    o = o + i;
    const l = r.decode(e.slice(o, o + s));
    o = o + s;
    const c = JSON.parse(r.decode(e.slice(o, e.byteLength)));
    return { ref: null, topic: a, event: l, payload: c };
  }
}
let UF = class {
  constructor(e, t) {
    (this.callback = e),
      (this.timerCalc = t),
      (this.timer = void 0),
      (this.tries = 0),
      (this.callback = e),
      (this.timerCalc = t);
  }
  reset() {
    (this.tries = 0), clearTimeout(this.timer), (this.timer = void 0);
  }
  scheduleTimeout() {
    clearTimeout(this.timer),
      (this.timer = setTimeout(() => {
        (this.tries = this.tries + 1), this.callback();
      }, this.timerCalc(this.tries + 1)));
  }
};
var ln;
(function (n) {
  (n.abstime = "abstime"),
    (n.bool = "bool"),
    (n.date = "date"),
    (n.daterange = "daterange"),
    (n.float4 = "float4"),
    (n.float8 = "float8"),
    (n.int2 = "int2"),
    (n.int4 = "int4"),
    (n.int4range = "int4range"),
    (n.int8 = "int8"),
    (n.int8range = "int8range"),
    (n.json = "json"),
    (n.jsonb = "jsonb"),
    (n.money = "money"),
    (n.numeric = "numeric"),
    (n.oid = "oid"),
    (n.reltime = "reltime"),
    (n.text = "text"),
    (n.time = "time"),
    (n.timestamp = "timestamp"),
    (n.timestamptz = "timestamptz"),
    (n.timetz = "timetz"),
    (n.tsrange = "tsrange"),
    (n.tstzrange = "tstzrange");
})(ln || (ln = {}));
const JI = (n, e, t = {}) => {
    var r;
    const i = (r = t.skipTypes) !== null && r !== void 0 ? r : [];
    return e
      ? Object.keys(e).reduce((s, o) => ((s[o] = kX(o, n, e, i)), s), {})
      : {};
  },
  kX = (n, e, t, r) => {
    const i = e.find((a) => a.name === n),
      s = i == null ? void 0 : i.type,
      o = t[n];
    return s && !r.includes(s) ? FF(s, o) : oE(o);
  },
  FF = (n, e) => {
    if (n.charAt(0) === "_") {
      const t = n.slice(1, n.length);
      return zX(e, t);
    }
    switch (n) {
      case ln.bool:
        return UX(e);
      case ln.float4:
      case ln.float8:
      case ln.int2:
      case ln.int4:
      case ln.int8:
      case ln.numeric:
      case ln.oid:
        return FX(e);
      case ln.json:
      case ln.jsonb:
        return BX(e);
      case ln.timestamp:
        return VX(e);
      case ln.abstime:
      case ln.date:
      case ln.daterange:
      case ln.int4range:
      case ln.int8range:
      case ln.money:
      case ln.reltime:
      case ln.text:
      case ln.time:
      case ln.timestamptz:
      case ln.timetz:
      case ln.tsrange:
      case ln.tstzrange:
        return oE(e);
      default:
        return oE(e);
    }
  },
  oE = (n) => n,
  UX = (n) => {
    switch (n) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return n;
    }
  },
  FX = (n) => {
    if (typeof n == "string") {
      const e = parseFloat(n);
      if (!Number.isNaN(e)) return e;
    }
    return n;
  },
  BX = (n) => {
    if (typeof n == "string")
      try {
        return JSON.parse(n);
      } catch (e) {
        return console.log(`JSON parse error: ${e}`), n;
      }
    return n;
  },
  zX = (n, e) => {
    if (typeof n != "string") return n;
    const t = n.length - 1,
      r = n[t];
    if (n[0] === "{" && r === "}") {
      let s;
      const o = n.slice(1, t);
      try {
        s = JSON.parse("[" + o + "]");
      } catch {
        s = o ? o.split(",") : [];
      }
      return s.map((a) => FF(e, a));
    }
    return n;
  },
  VX = (n) => (typeof n == "string" ? n.replace(" ", "T") : n),
  BF = (n) => {
    const e = new URL(n);
    return (
      (e.protocol = e.protocol.replace(/^ws/i, "http")),
      (e.pathname = e.pathname
        .replace(/\/+$/, "")
        .replace(/\/socket\/websocket$/i, "")
        .replace(/\/socket$/i, "")
        .replace(/\/websocket$/i, "")),
      e.pathname === "" || e.pathname === "/"
        ? (e.pathname = "/api/broadcast")
        : (e.pathname = e.pathname + "/api/broadcast"),
      e.href
    );
  };
class xS {
  constructor(e, t, r = {}, i = iE) {
    (this.channel = e),
      (this.event = t),
      (this.payload = r),
      (this.timeout = i),
      (this.sent = !1),
      (this.timeoutTimer = void 0),
      (this.ref = ""),
      (this.receivedResp = null),
      (this.recHooks = []),
      (this.refEvent = null);
  }
  resend(e) {
    (this.timeout = e),
      this._cancelRefEvent(),
      (this.ref = ""),
      (this.refEvent = null),
      (this.receivedResp = null),
      (this.sent = !1),
      this.send();
  }
  send() {
    this._hasReceived("timeout") ||
      (this.startTimeout(),
      (this.sent = !0),
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef(),
      }));
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e);
  }
  receive(e, t) {
    var r;
    return (
      this._hasReceived(e) &&
        t(
          (r = this.receivedResp) === null || r === void 0 ? void 0 : r.response
        ),
      this.recHooks.push({ status: e, callback: t }),
      this
    );
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    (this.ref = this.channel.socket._makeRef()),
      (this.refEvent = this.channel._replyEventName(this.ref));
    const e = (t) => {
      this._cancelRefEvent(),
        this._cancelTimeout(),
        (this.receivedResp = t),
        this._matchReceive(t);
    };
    this.channel._on(this.refEvent, {}, e),
      (this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout));
  }
  trigger(e, t) {
    this.refEvent &&
      this.channel._trigger(this.refEvent, { status: e, response: t });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0);
  }
  _matchReceive({ status: e, response: t }) {
    this.recHooks.filter((r) => r.status === e).forEach((r) => r.callback(t));
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
}
var ZI;
(function (n) {
  (n.SYNC = "sync"), (n.JOIN = "join"), (n.LEAVE = "leave");
})(ZI || (ZI = {}));
class Kf {
  constructor(e, t) {
    (this.channel = e),
      (this.state = {}),
      (this.pendingDiffs = []),
      (this.joinRef = null),
      (this.enabled = !1),
      (this.caller = { onJoin: () => {}, onLeave: () => {}, onSync: () => {} });
    const r = (t == null ? void 0 : t.events) || {
      state: "presence_state",
      diff: "presence_diff",
    };
    this.channel._on(r.state, {}, (i) => {
      const { onJoin: s, onLeave: o, onSync: a } = this.caller;
      (this.joinRef = this.channel._joinRef()),
        (this.state = Kf.syncState(this.state, i, s, o)),
        this.pendingDiffs.forEach((l) => {
          this.state = Kf.syncDiff(this.state, l, s, o);
        }),
        (this.pendingDiffs = []),
        a();
    }),
      this.channel._on(r.diff, {}, (i) => {
        const { onJoin: s, onLeave: o, onSync: a } = this.caller;
        this.inPendingSyncState()
          ? this.pendingDiffs.push(i)
          : ((this.state = Kf.syncDiff(this.state, i, s, o)), a());
      }),
      this.onJoin((i, s, o) => {
        this.channel._trigger("presence", {
          event: "join",
          key: i,
          currentPresences: s,
          newPresences: o,
        });
      }),
      this.onLeave((i, s, o) => {
        this.channel._trigger("presence", {
          event: "leave",
          key: i,
          currentPresences: s,
          leftPresences: o,
        });
      }),
      this.onSync(() => {
        this.channel._trigger("presence", { event: "sync" });
      });
  }
  static syncState(e, t, r, i) {
    const s = this.cloneDeep(e),
      o = this.transformState(t),
      a = {},
      l = {};
    return (
      this.map(s, (c, u) => {
        o[c] || (l[c] = u);
      }),
      this.map(o, (c, u) => {
        const f = s[c];
        if (f) {
          const p = u.map((x) => x.presence_ref),
            m = f.map((x) => x.presence_ref),
            v = u.filter((x) => m.indexOf(x.presence_ref) < 0),
            y = f.filter((x) => p.indexOf(x.presence_ref) < 0);
          v.length > 0 && (a[c] = v), y.length > 0 && (l[c] = y);
        } else a[c] = u;
      }),
      this.syncDiff(s, { joins: a, leaves: l }, r, i)
    );
  }
  static syncDiff(e, t, r, i) {
    const { joins: s, leaves: o } = {
      joins: this.transformState(t.joins),
      leaves: this.transformState(t.leaves),
    };
    return (
      r || (r = () => {}),
      i || (i = () => {}),
      this.map(s, (a, l) => {
        var c;
        const u = (c = e[a]) !== null && c !== void 0 ? c : [];
        if (((e[a] = this.cloneDeep(l)), u.length > 0)) {
          const f = e[a].map((m) => m.presence_ref),
            p = u.filter((m) => f.indexOf(m.presence_ref) < 0);
          e[a].unshift(...p);
        }
        r(a, u, l);
      }),
      this.map(o, (a, l) => {
        let c = e[a];
        if (!c) return;
        const u = l.map((f) => f.presence_ref);
        (c = c.filter((f) => u.indexOf(f.presence_ref) < 0)),
          (e[a] = c),
          i(a, c, l),
          c.length === 0 && delete e[a];
      }),
      e
    );
  }
  static map(e, t) {
    return Object.getOwnPropertyNames(e).map((r) => t(r, e[r]));
  }
  static transformState(e) {
    return (
      (e = this.cloneDeep(e)),
      Object.getOwnPropertyNames(e).reduce((t, r) => {
        const i = e[r];
        return (
          "metas" in i
            ? (t[r] = i.metas.map(
                (s) => (
                  (s.presence_ref = s.phx_ref),
                  delete s.phx_ref,
                  delete s.phx_ref_prev,
                  s
                )
              ))
            : (t[r] = i),
          t
        );
      }, {})
    );
  }
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e));
  }
  onJoin(e) {
    this.caller.onJoin = e;
  }
  onLeave(e) {
    this.caller.onLeave = e;
  }
  onSync(e) {
    this.caller.onSync = e;
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var QI;
(function (n) {
  (n.ALL = "*"),
    (n.INSERT = "INSERT"),
    (n.UPDATE = "UPDATE"),
    (n.DELETE = "DELETE");
})(QI || (QI = {}));
var Yf;
(function (n) {
  (n.BROADCAST = "broadcast"),
    (n.PRESENCE = "presence"),
    (n.POSTGRES_CHANGES = "postgres_changes"),
    (n.SYSTEM = "system");
})(Yf || (Yf = {}));
var Bo;
(function (n) {
  (n.SUBSCRIBED = "SUBSCRIBED"),
    (n.TIMED_OUT = "TIMED_OUT"),
    (n.CLOSED = "CLOSED"),
    (n.CHANNEL_ERROR = "CHANNEL_ERROR");
})(Bo || (Bo = {}));
class PM {
  constructor(e, t = { config: {} }, r) {
    var i, s;
    if (
      ((this.topic = e),
      (this.params = t),
      (this.socket = r),
      (this.bindings = {}),
      (this.state = Kn.closed),
      (this.joinedOnce = !1),
      (this.pushBuffer = []),
      (this.subTopic = e.replace(/^realtime:/i, "")),
      (this.params.config = Object.assign(
        {
          broadcast: { ack: !1, self: !1 },
          presence: { key: "", enabled: !1 },
          private: !1,
        },
        t.config
      )),
      (this.timeout = this.socket.timeout),
      (this.joinPush = new xS(this, Rs.join, this.params, this.timeout)),
      (this.rejoinTimer = new UF(
        () => this._rejoinUntilConnected(),
        this.socket.reconnectAfterMs
      )),
      this.joinPush.receive("ok", () => {
        (this.state = Kn.joined),
          this.rejoinTimer.reset(),
          this.pushBuffer.forEach((o) => o.send()),
          (this.pushBuffer = []);
      }),
      this._onClose(() => {
        this.rejoinTimer.reset(),
          this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
          (this.state = Kn.closed),
          this.socket._remove(this);
      }),
      this._onError((o) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log("channel", `error ${this.topic}`, o),
          (this.state = Kn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive("timeout", () => {
        this._isJoining() &&
          (this.socket.log(
            "channel",
            `timeout ${this.topic}`,
            this.joinPush.timeout
          ),
          (this.state = Kn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive("error", (o) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log("channel", `error ${this.topic}`, o),
          (this.state = Kn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this._on(Rs.reply, {}, (o, a) => {
        this._trigger(this._replyEventName(a), o);
      }),
      (this.presence = new Kf(this)),
      (this.broadcastEndpointURL = BF(this.socket.endPoint)),
      (this.private = this.params.config.private || !1),
      !this.private &&
        !(
          (s =
            (i = this.params.config) === null || i === void 0
              ? void 0
              : i.broadcast) === null || s === void 0
        ) &&
        s.replay)
    )
      throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;
  }
  subscribe(e, t = this.timeout) {
    var r, i, s;
    if (
      (this.socket.isConnected() || this.socket.connect(),
      this.state == Kn.closed)
    ) {
      const {
          config: { broadcast: o, presence: a, private: l },
        } = this.params,
        c =
          (i =
            (r = this.bindings.postgres_changes) === null || r === void 0
              ? void 0
              : r.map((m) => m.filter)) !== null && i !== void 0
            ? i
            : [],
        u =
          (!!this.bindings[Yf.PRESENCE] &&
            this.bindings[Yf.PRESENCE].length > 0) ||
          ((s = this.params.config.presence) === null || s === void 0
            ? void 0
            : s.enabled) === !0,
        f = {},
        p = {
          broadcast: o,
          presence: Object.assign(Object.assign({}, a), { enabled: u }),
          postgres_changes: c,
          private: l,
        };
      this.socket.accessTokenValue &&
        (f.access_token = this.socket.accessTokenValue),
        this._onError((m) => (e == null ? void 0 : e(Bo.CHANNEL_ERROR, m))),
        this._onClose(() => (e == null ? void 0 : e(Bo.CLOSED))),
        this.updateJoinPayload(Object.assign({ config: p }, f)),
        (this.joinedOnce = !0),
        this._rejoin(t),
        this.joinPush
          .receive("ok", async ({ postgres_changes: m }) => {
            var v;
            if ((this.socket.setAuth(), m === void 0)) {
              e == null || e(Bo.SUBSCRIBED);
              return;
            } else {
              const y = this.bindings.postgres_changes,
                x =
                  (v = y == null ? void 0 : y.length) !== null && v !== void 0
                    ? v
                    : 0,
                g = [];
              for (let _ = 0; _ < x; _++) {
                const S = y[_],
                  {
                    filter: { event: b, schema: C, table: A, filter: R },
                  } = S,
                  O = m && m[_];
                if (
                  O &&
                  O.event === b &&
                  O.schema === C &&
                  O.table === A &&
                  O.filter === R
                )
                  g.push(Object.assign(Object.assign({}, S), { id: O.id }));
                else {
                  this.unsubscribe(),
                    (this.state = Kn.errored),
                    e == null ||
                      e(
                        Bo.CHANNEL_ERROR,
                        new Error(
                          "mismatch between server and client bindings for postgres changes"
                        )
                      );
                  return;
                }
              }
              (this.bindings.postgres_changes = g), e && e(Bo.SUBSCRIBED);
              return;
            }
          })
          .receive("error", (m) => {
            (this.state = Kn.errored),
              e == null ||
                e(
                  Bo.CHANNEL_ERROR,
                  new Error(
                    JSON.stringify(Object.values(m).join(", ") || "error")
                  )
                );
          })
          .receive("timeout", () => {
            e == null || e(Bo.TIMED_OUT);
          });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(e, t = {}) {
    return await this.send(
      { type: "presence", event: "track", payload: e },
      t.timeout || this.timeout
    );
  }
  async untrack(e = {}) {
    return await this.send({ type: "presence", event: "untrack" }, e);
  }
  on(e, t, r) {
    return (
      this.state === Kn.joined &&
        e === Yf.PRESENCE &&
        (this.socket.log(
          "channel",
          `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`
        ),
        this.unsubscribe().then(() => this.subscribe())),
      this._on(e, t, r)
    );
  }
  async httpSend(e, t, r = {}) {
    var i;
    const s = this.socket.accessTokenValue
      ? `Bearer ${this.socket.accessTokenValue}`
      : "";
    if (t == null) return Promise.reject("Payload is required for httpSend()");
    const o = {
        method: "POST",
        headers: {
          Authorization: s,
          apikey: this.socket.apiKey ? this.socket.apiKey : "",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          messages: [
            {
              topic: this.subTopic,
              event: e,
              payload: t,
              private: this.private,
            },
          ],
        }),
      },
      a = await this._fetchWithTimeout(
        this.broadcastEndpointURL,
        o,
        (i = r.timeout) !== null && i !== void 0 ? i : this.timeout
      );
    if (a.status === 202) return { success: !0 };
    let l = a.statusText;
    try {
      const c = await a.json();
      l = c.error || c.message || l;
    } catch {}
    return Promise.reject(new Error(l));
  }
  async send(e, t = {}) {
    var r, i;
    if (!this._canPush() && e.type === "broadcast") {
      console.warn(
        "Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery."
      );
      const { event: s, payload: o } = e,
        l = {
          method: "POST",
          headers: {
            Authorization: this.socket.accessTokenValue
              ? `Bearer ${this.socket.accessTokenValue}`
              : "",
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event: s,
                payload: o,
                private: this.private,
              },
            ],
          }),
        };
      try {
        const c = await this._fetchWithTimeout(
          this.broadcastEndpointURL,
          l,
          (r = t.timeout) !== null && r !== void 0 ? r : this.timeout
        );
        return (
          await ((i = c.body) === null || i === void 0 ? void 0 : i.cancel()),
          c.ok ? "ok" : "error"
        );
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((s) => {
        var o, a, l;
        const c = this._push(e.type, e, t.timeout || this.timeout);
        e.type === "broadcast" &&
          !(
            !(
              (l =
                (a =
                  (o = this.params) === null || o === void 0
                    ? void 0
                    : o.config) === null || a === void 0
                  ? void 0
                  : a.broadcast) === null || l === void 0
            ) && l.ack
          ) &&
          s("ok"),
          c.receive("ok", () => s("ok")),
          c.receive("error", () => s("error")),
          c.receive("timeout", () => s("timed out"));
      });
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e);
  }
  unsubscribe(e = this.timeout) {
    this.state = Kn.leaving;
    const t = () => {
      this.socket.log("channel", `leave ${this.topic}`),
        this._trigger(Rs.close, "leave", this._joinRef());
    };
    this.joinPush.destroy();
    let r = null;
    return new Promise((i) => {
      (r = new xS(this, Rs.leave, {}, e)),
        r
          .receive("ok", () => {
            t(), i("ok");
          })
          .receive("timeout", () => {
            t(), i("timed out");
          })
          .receive("error", () => {
            i("error");
          }),
        r.send(),
        this._canPush() || r.trigger("ok", {});
    }).finally(() => {
      r == null || r.destroy();
    });
  }
  teardown() {
    this.pushBuffer.forEach((e) => e.destroy()),
      (this.pushBuffer = []),
      this.rejoinTimer.reset(),
      this.joinPush.destroy(),
      (this.state = Kn.closed),
      (this.bindings = {});
  }
  async _fetchWithTimeout(e, t, r) {
    const i = new AbortController(),
      s = setTimeout(() => i.abort(), r),
      o = await this.socket.fetch(
        e,
        Object.assign(Object.assign({}, t), { signal: i.signal })
      );
    return clearTimeout(s), o;
  }
  _push(e, t, r = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let i = new xS(this, e, t, r);
    return this._canPush() ? i.send() : this._addToPushBuffer(i), i;
  }
  _addToPushBuffer(e) {
    if (
      (e.startTimeout(), this.pushBuffer.push(e), this.pushBuffer.length > OX)
    ) {
      const t = this.pushBuffer.shift();
      t &&
        (t.destroy(),
        this.socket.log(
          "channel",
          `discarded push due to buffer overflow: ${t.event}`,
          t.payload
        ));
    }
  }
  _onMessage(e, t, r) {
    return t;
  }
  _isMember(e) {
    return this.topic === e;
  }
  _joinRef() {
    return this.joinPush.ref;
  }
  _trigger(e, t, r) {
    var i, s;
    const o = e.toLocaleLowerCase(),
      { close: a, error: l, leave: c, join: u } = Rs;
    if (r && [a, l, c, u].indexOf(o) >= 0 && r !== this._joinRef()) return;
    let p = this._onMessage(o, t, r);
    if (t && !p)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(o)
      ? (i = this.bindings.postgres_changes) === null ||
        i === void 0 ||
        i
          .filter((m) => {
            var v, y, x;
            return (
              ((v = m.filter) === null || v === void 0 ? void 0 : v.event) ===
                "*" ||
              ((x =
                (y = m.filter) === null || y === void 0 ? void 0 : y.event) ===
                null || x === void 0
                ? void 0
                : x.toLocaleLowerCase()) === o
            );
          })
          .map((m) => m.callback(p, r))
      : (s = this.bindings[o]) === null ||
        s === void 0 ||
        s
          .filter((m) => {
            var v, y, x, g, _, S;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
              if ("id" in m) {
                const b = m.id,
                  C =
                    (v = m.filter) === null || v === void 0 ? void 0 : v.event;
                return (
                  b &&
                  ((y = t.ids) === null || y === void 0
                    ? void 0
                    : y.includes(b)) &&
                  (C === "*" ||
                    (C == null ? void 0 : C.toLocaleLowerCase()) ===
                      ((x = t.data) === null || x === void 0
                        ? void 0
                        : x.type.toLocaleLowerCase()))
                );
              } else {
                const b =
                  (_ =
                    (g = m == null ? void 0 : m.filter) === null || g === void 0
                      ? void 0
                      : g.event) === null || _ === void 0
                    ? void 0
                    : _.toLocaleLowerCase();
                return (
                  b === "*" ||
                  b ===
                    ((S = t == null ? void 0 : t.event) === null || S === void 0
                      ? void 0
                      : S.toLocaleLowerCase())
                );
              }
            else return m.type.toLocaleLowerCase() === o;
          })
          .map((m) => {
            if (typeof p == "object" && "ids" in p) {
              const v = p.data,
                {
                  schema: y,
                  table: x,
                  commit_timestamp: g,
                  type: _,
                  errors: S,
                } = v;
              p = Object.assign(
                Object.assign(
                  {},
                  {
                    schema: y,
                    table: x,
                    commit_timestamp: g,
                    eventType: _,
                    new: {},
                    old: {},
                    errors: S,
                  }
                ),
                this._getPayloadRecords(v)
              );
            }
            m.callback(p, r);
          });
  }
  _isClosed() {
    return this.state === Kn.closed;
  }
  _isJoined() {
    return this.state === Kn.joined;
  }
  _isJoining() {
    return this.state === Kn.joining;
  }
  _isLeaving() {
    return this.state === Kn.leaving;
  }
  _replyEventName(e) {
    return `chan_reply_${e}`;
  }
  _on(e, t, r) {
    const i = e.toLocaleLowerCase(),
      s = { type: i, filter: t, callback: r };
    return (
      this.bindings[i] ? this.bindings[i].push(s) : (this.bindings[i] = [s]),
      this
    );
  }
  _off(e, t) {
    const r = e.toLocaleLowerCase();
    return (
      this.bindings[r] &&
        (this.bindings[r] = this.bindings[r].filter((i) => {
          var s;
          return !(
            ((s = i.type) === null || s === void 0
              ? void 0
              : s.toLocaleLowerCase()) === r && PM.isEqual(i.filter, t)
          );
        })),
      this
    );
  }
  static isEqual(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length) return !1;
    for (const r in e) if (e[r] !== t[r]) return !1;
    return !0;
  }
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(),
      this.socket.isConnected() && this._rejoin();
  }
  _onClose(e) {
    this._on(Rs.close, {}, e);
  }
  _onError(e) {
    this._on(Rs.error, {}, (t) => e(t));
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  _rejoin(e = this.timeout) {
    this._isLeaving() ||
      (this.socket._leaveOpenTopic(this.topic),
      (this.state = Kn.joining),
      this.joinPush.resend(e));
  }
  _getPayloadRecords(e) {
    const t = { new: {}, old: {} };
    return (
      (e.type === "INSERT" || e.type === "UPDATE") &&
        (t.new = JI(e.columns, e.record)),
      (e.type === "UPDATE" || e.type === "DELETE") &&
        (t.old = JI(e.columns, e.old_record)),
      t
    );
  }
}
const _S = () => {},
  sv = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100,
  },
  jX = [1e3, 2e3, 5e3, 1e4],
  HX = 1e4,
  WX = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class GX {
  constructor(e, t) {
    var r;
    if (
      ((this.accessTokenValue = null),
      (this.apiKey = null),
      (this.channels = new Array()),
      (this.endPoint = ""),
      (this.httpEndpoint = ""),
      (this.headers = {}),
      (this.params = {}),
      (this.timeout = iE),
      (this.transport = null),
      (this.heartbeatIntervalMs = sv.HEARTBEAT_INTERVAL),
      (this.heartbeatTimer = void 0),
      (this.pendingHeartbeatRef = null),
      (this.heartbeatCallback = _S),
      (this.ref = 0),
      (this.reconnectTimer = null),
      (this.logger = _S),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.serializer = new DX()),
      (this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: [],
      }),
      (this.accessToken = null),
      (this._connectionState = "disconnected"),
      (this._wasManualDisconnect = !1),
      (this._authPromise = null),
      (this._resolveFetch = (i) => {
        let s;
        return (
          i
            ? (s = i)
            : typeof fetch > "u"
            ? (s = (...o) =>
                Eh(async () => {
                  const { default: a } = await Promise.resolve().then(() => Zc);
                  return { default: a };
                }, void 0)
                  .then(({ default: a }) => a(...o))
                  .catch((a) => {
                    throw new Error(
                      `Failed to load @supabase/node-fetch: ${a.message}. This is required for HTTP requests in Node.js environments without native fetch.`
                    );
                  }))
            : (s = fetch),
          (...o) => s(...o)
        );
      }),
      !(
        !((r = t == null ? void 0 : t.params) === null || r === void 0) &&
        r.apikey
      ))
    )
      throw new Error("API key is required to connect to Realtime");
    (this.apiKey = t.params.apikey),
      (this.endPoint = `${e}/${sE.websocket}`),
      (this.httpEndpoint = BF(e)),
      this._initializeOptions(t),
      this._setupReconnectionTimer(),
      (this.fetch = this._resolveFetch(t == null ? void 0 : t.fetch));
  }
  connect() {
    if (
      !(
        this.isConnecting() ||
        this.isDisconnecting() ||
        (this.conn !== null && this.isConnected())
      )
    ) {
      if (
        (this._setConnectionState("connecting"),
        this._setAuthSafely("connect"),
        this.transport)
      )
        this.conn = new this.transport(this.endpointURL());
      else
        try {
          this.conn = RX.createWebSocket(this.endpointURL());
        } catch (e) {
          this._setConnectionState("disconnected");
          const t = e.message;
          throw t.includes("Node.js")
            ? new Error(`${t}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`)
            : new Error(`WebSocket not available: ${t}`);
        }
      this._setupConnectionHandlers();
    }
  }
  endpointURL() {
    return this._appendParams(
      this.endPoint,
      Object.assign({}, this.params, { vsn: NX })
    );
  }
  disconnect(e, t) {
    if (!this.isDisconnecting())
      if ((this._setConnectionState("disconnecting", !0), this.conn)) {
        const r = setTimeout(() => {
          this._setConnectionState("disconnected");
        }, 100);
        (this.conn.onclose = () => {
          clearTimeout(r), this._setConnectionState("disconnected");
        }),
          e ? this.conn.close(e, t ?? "") : this.conn.close(),
          this._teardownConnection();
      } else this._setConnectionState("disconnected");
  }
  getChannels() {
    return this.channels;
  }
  async removeChannel(e) {
    const t = await e.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), t;
  }
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map((t) => t.unsubscribe()));
    return (this.channels = []), this.disconnect(), e;
  }
  log(e, t, r) {
    this.logger(e, t, r);
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case qf.connecting:
        return ac.Connecting;
      case qf.open:
        return ac.Open;
      case qf.closing:
        return ac.Closing;
      default:
        return ac.Closed;
    }
  }
  isConnected() {
    return this.connectionState() === ac.Open;
  }
  isConnecting() {
    return this._connectionState === "connecting";
  }
  isDisconnecting() {
    return this._connectionState === "disconnecting";
  }
  channel(e, t = { config: {} }) {
    const r = `realtime:${e}`,
      i = this.getChannels().find((s) => s.topic === r);
    if (i) return i;
    {
      const s = new PM(`realtime:${e}`, t, this);
      return this.channels.push(s), s;
    }
  }
  push(e) {
    const { topic: t, event: r, payload: i, ref: s } = e,
      o = () => {
        this.encode(e, (a) => {
          var l;
          (l = this.conn) === null || l === void 0 || l.send(a);
        });
      };
    this.log("push", `${t} ${r} (${s})`, i),
      this.isConnected() ? o() : this.sendBuffer.push(o);
  }
  async setAuth(e = null) {
    this._authPromise = this._performAuth(e);
    try {
      await this._authPromise;
    } finally {
      this._authPromise = null;
    }
  }
  async sendHeartbeat() {
    var e;
    if (!this.isConnected()) {
      try {
        this.heartbeatCallback("disconnected");
      } catch (t) {
        this.log("error", "error in heartbeat callback", t);
      }
      return;
    }
    if (this.pendingHeartbeatRef) {
      (this.pendingHeartbeatRef = null),
        this.log(
          "transport",
          "heartbeat timeout. Attempting to re-establish connection"
        );
      try {
        this.heartbeatCallback("timeout");
      } catch (t) {
        this.log("error", "error in heartbeat callback", t);
      }
      (this._wasManualDisconnect = !1),
        (e = this.conn) === null ||
          e === void 0 ||
          e.close(LX, "heartbeat timeout"),
        setTimeout(() => {
          var t;
          this.isConnected() ||
            (t = this.reconnectTimer) === null ||
            t === void 0 ||
            t.scheduleTimeout();
        }, sv.HEARTBEAT_TIMEOUT_FALLBACK);
      return;
    }
    (this.pendingHeartbeatRef = this._makeRef()),
      this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef,
      });
    try {
      this.heartbeatCallback("sent");
    } catch (t) {
      this.log("error", "error in heartbeat callback", t);
    }
    this._setAuthSafely("heartbeat");
  }
  onHeartbeat(e) {
    this.heartbeatCallback = e;
  }
  flushSendBuffer() {
    this.isConnected() &&
      this.sendBuffer.length > 0 &&
      (this.sendBuffer.forEach((e) => e()), (this.sendBuffer = []));
  }
  _makeRef() {
    let e = this.ref + 1;
    return (
      e === this.ref ? (this.ref = 0) : (this.ref = e), this.ref.toString()
    );
  }
  _leaveOpenTopic(e) {
    let t = this.channels.find(
      (r) => r.topic === e && (r._isJoined() || r._isJoining())
    );
    t &&
      (this.log("transport", `leaving duplicate topic "${e}"`),
      t.unsubscribe());
  }
  _remove(e) {
    this.channels = this.channels.filter((t) => t.topic !== e.topic);
  }
  _onConnMessage(e) {
    this.decode(e.data, (t) => {
      if (t.topic === "phoenix" && t.event === "phx_reply")
        try {
          this.heartbeatCallback(t.payload.status === "ok" ? "ok" : "error");
        } catch (c) {
          this.log("error", "error in heartbeat callback", c);
        }
      t.ref &&
        t.ref === this.pendingHeartbeatRef &&
        (this.pendingHeartbeatRef = null);
      const { topic: r, event: i, payload: s, ref: o } = t,
        a = o ? `(${o})` : "",
        l = s.status || "";
      this.log("receive", `${l} ${r} ${i} ${a}`.trim(), s),
        this.channels
          .filter((c) => c._isMember(r))
          .forEach((c) => c._trigger(i, s, o)),
        this._triggerStateCallbacks("message", t);
    });
  }
  _clearTimer(e) {
    var t;
    e === "heartbeat" && this.heartbeatTimer
      ? (clearInterval(this.heartbeatTimer), (this.heartbeatTimer = void 0))
      : e === "reconnect" &&
        ((t = this.reconnectTimer) === null || t === void 0 || t.reset());
  }
  _clearAllTimers() {
    this._clearTimer("heartbeat"), this._clearTimer("reconnect");
  }
  _setupConnectionHandlers() {
    this.conn &&
      ("binaryType" in this.conn && (this.conn.binaryType = "arraybuffer"),
      (this.conn.onopen = () => this._onConnOpen()),
      (this.conn.onerror = (e) => this._onConnError(e)),
      (this.conn.onmessage = (e) => this._onConnMessage(e)),
      (this.conn.onclose = (e) => this._onConnClose(e)));
  }
  _teardownConnection() {
    this.conn &&
      ((this.conn.onopen = null),
      (this.conn.onerror = null),
      (this.conn.onmessage = null),
      (this.conn.onclose = null),
      (this.conn = null)),
      this._clearAllTimers(),
      this.channels.forEach((e) => e.teardown());
  }
  _onConnOpen() {
    this._setConnectionState("connected"),
      this.log("transport", `connected to ${this.endpointURL()}`),
      this.flushSendBuffer(),
      this._clearTimer("reconnect"),
      this.worker
        ? this.workerRef || this._startWorkerHeartbeat()
        : this._startHeartbeat(),
      this._triggerStateCallbacks("open");
  }
  _startHeartbeat() {
    this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      (this.heartbeatTimer = setInterval(
        () => this.sendHeartbeat(),
        this.heartbeatIntervalMs
      ));
  }
  _startWorkerHeartbeat() {
    this.workerUrl
      ? this.log("worker", `starting worker for from ${this.workerUrl}`)
      : this.log("worker", "starting default worker");
    const e = this._workerObjectUrl(this.workerUrl);
    (this.workerRef = new Worker(e)),
      (this.workerRef.onerror = (t) => {
        this.log("worker", "worker error", t.message),
          this.workerRef.terminate();
      }),
      (this.workerRef.onmessage = (t) => {
        t.data.event === "keepAlive" && this.sendHeartbeat();
      }),
      this.workerRef.postMessage({
        event: "start",
        interval: this.heartbeatIntervalMs,
      });
  }
  _onConnClose(e) {
    var t;
    this._setConnectionState("disconnected"),
      this.log("transport", "close", e),
      this._triggerChanError(),
      this._clearTimer("heartbeat"),
      this._wasManualDisconnect ||
        (t = this.reconnectTimer) === null ||
        t === void 0 ||
        t.scheduleTimeout(),
      this._triggerStateCallbacks("close", e);
  }
  _onConnError(e) {
    this._setConnectionState("disconnected"),
      this.log("transport", `${e}`),
      this._triggerChanError(),
      this._triggerStateCallbacks("error", e);
  }
  _triggerChanError() {
    this.channels.forEach((e) => e._trigger(Rs.error));
  }
  _appendParams(e, t) {
    if (Object.keys(t).length === 0) return e;
    const r = e.match(/\?/) ? "&" : "?",
      i = new URLSearchParams(t);
    return `${e}${r}${i}`;
  }
  _workerObjectUrl(e) {
    let t;
    if (e) t = e;
    else {
      const r = new Blob([WX], { type: "application/javascript" });
      t = URL.createObjectURL(r);
    }
    return t;
  }
  _setConnectionState(e, t = !1) {
    (this._connectionState = e),
      e === "connecting"
        ? (this._wasManualDisconnect = !1)
        : e === "disconnecting" && (this._wasManualDisconnect = t);
  }
  async _performAuth(e = null) {
    let t;
    e
      ? (t = e)
      : this.accessToken
      ? (t = await this.accessToken())
      : (t = this.accessTokenValue),
      this.accessTokenValue != t &&
        ((this.accessTokenValue = t),
        this.channels.forEach((r) => {
          const i = { access_token: t, version: IX };
          t && r.updateJoinPayload(i),
            r.joinedOnce &&
              r._isJoined() &&
              r._push(Rs.access_token, { access_token: t });
        }));
  }
  async _waitForAuthIfNeeded() {
    this._authPromise && (await this._authPromise);
  }
  _setAuthSafely(e = "general") {
    this.setAuth().catch((t) => {
      this.log("error", `error setting auth in ${e}`, t);
    });
  }
  _triggerStateCallbacks(e, t) {
    try {
      this.stateChangeCallbacks[e].forEach((r) => {
        try {
          r(t);
        } catch (i) {
          this.log("error", `error in ${e} callback`, i);
        }
      });
    } catch (r) {
      this.log("error", `error triggering ${e} callbacks`, r);
    }
  }
  _setupReconnectionTimer() {
    this.reconnectTimer = new UF(async () => {
      setTimeout(async () => {
        await this._waitForAuthIfNeeded(), this.isConnected() || this.connect();
      }, sv.RECONNECT_DELAY);
    }, this.reconnectAfterMs);
  }
  _initializeOptions(e) {
    var t, r, i, s, o, a, l, c, u;
    if (
      ((this.transport =
        (t = e == null ? void 0 : e.transport) !== null && t !== void 0
          ? t
          : null),
      (this.timeout =
        (r = e == null ? void 0 : e.timeout) !== null && r !== void 0 ? r : iE),
      (this.heartbeatIntervalMs =
        (i = e == null ? void 0 : e.heartbeatIntervalMs) !== null &&
        i !== void 0
          ? i
          : sv.HEARTBEAT_INTERVAL),
      (this.worker =
        (s = e == null ? void 0 : e.worker) !== null && s !== void 0 ? s : !1),
      (this.accessToken =
        (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0
          ? o
          : null),
      (this.heartbeatCallback =
        (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0
          ? a
          : _S),
      e != null && e.params && (this.params = e.params),
      e != null && e.logger && (this.logger = e.logger),
      ((e != null && e.logLevel) || (e != null && e.log_level)) &&
        ((this.logLevel = e.logLevel || e.log_level),
        (this.params = Object.assign(Object.assign({}, this.params), {
          log_level: this.logLevel,
        }))),
      (this.reconnectAfterMs =
        (l = e == null ? void 0 : e.reconnectAfterMs) !== null && l !== void 0
          ? l
          : (f) => jX[f - 1] || HX),
      (this.encode =
        (c = e == null ? void 0 : e.encode) !== null && c !== void 0
          ? c
          : (f, p) => p(JSON.stringify(f))),
      (this.decode =
        (u = e == null ? void 0 : e.decode) !== null && u !== void 0
          ? u
          : this.serializer.decode.bind(this.serializer)),
      this.worker)
    ) {
      if (typeof window < "u" && !window.Worker)
        throw new Error("Web Worker is not supported");
      this.workerUrl = e == null ? void 0 : e.workerUrl;
    }
  }
}
class IM extends Error {
  constructor(e) {
    super(e), (this.__isStorageError = !0), (this.name = "StorageError");
  }
}
function wn(n) {
  return typeof n == "object" && n !== null && "__isStorageError" in n;
}
class $X extends IM {
  constructor(e, t, r) {
    super(e),
      (this.name = "StorageApiError"),
      (this.status = t),
      (this.statusCode = r);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode,
    };
  }
}
class aE extends IM {
  constructor(e, t) {
    super(e), (this.name = "StorageUnknownError"), (this.originalError = t);
  }
}
const NM = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Eh(async () => {
              const { default: r } = await Promise.resolve().then(() => Zc);
              return { default: r };
            }, void 0).then(({ default: r }) => r(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  },
  XX = () =>
    ct(void 0, void 0, void 0, function* () {
      return typeof Response > "u"
        ? (yield Eh(() => Promise.resolve().then(() => Zc), void 0)).Response
        : Response;
    }),
  lE = (n) => {
    if (Array.isArray(n)) return n.map((t) => lE(t));
    if (typeof n == "function" || n !== Object(n)) return n;
    const e = {};
    return (
      Object.entries(n).forEach(([t, r]) => {
        const i = t.replace(/([-_][a-z])/gi, (s) =>
          s.toUpperCase().replace(/[-_]/g, "")
        );
        e[i] = lE(r);
      }),
      e
    );
  },
  qX = (n) => {
    if (typeof n != "object" || n === null) return !1;
    const e = Object.getPrototypeOf(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  wS = (n) => {
    var e;
    return (
      n.msg ||
      n.message ||
      n.error_description ||
      (typeof n.error == "string"
        ? n.error
        : (e = n.error) === null || e === void 0
        ? void 0
        : e.message) ||
      JSON.stringify(n)
    );
  },
  KX = (n, e, t) =>
    ct(void 0, void 0, void 0, function* () {
      const r = yield XX();
      n instanceof r && !(t != null && t.noResolveJson)
        ? n
            .json()
            .then((i) => {
              const s = n.status || 500,
                o = (i == null ? void 0 : i.statusCode) || s + "";
              e(new $X(wS(i), s, o));
            })
            .catch((i) => {
              e(new aE(wS(i), i));
            })
        : e(new aE(wS(n), n));
    }),
  YX = (n, e, t, r) => {
    const i = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
    return n === "GET" || !r
      ? i
      : (qX(r)
          ? ((i.headers = Object.assign(
              { "Content-Type": "application/json" },
              e == null ? void 0 : e.headers
            )),
            (i.body = JSON.stringify(r)))
          : (i.body = r),
        e != null && e.duplex && (i.duplex = e.duplex),
        Object.assign(Object.assign({}, i), t));
  };
function ym(n, e, t, r, i, s) {
  return ct(this, void 0, void 0, function* () {
    return new Promise((o, a) => {
      n(t, YX(e, r, i, s))
        .then((l) => {
          if (!l.ok) throw l;
          return r != null && r.noResolveJson ? l : l.json();
        })
        .then((l) => o(l))
        .catch((l) => KX(l, a, r));
    });
  });
}
function Dp(n, e, t, r) {
  return ct(this, void 0, void 0, function* () {
    return ym(n, "GET", e, t, r);
  });
}
function Es(n, e, t, r, i) {
  return ct(this, void 0, void 0, function* () {
    return ym(n, "POST", e, r, i, t);
  });
}
function cE(n, e, t, r, i) {
  return ct(this, void 0, void 0, function* () {
    return ym(n, "PUT", e, r, i, t);
  });
}
function JX(n, e, t, r) {
  return ct(this, void 0, void 0, function* () {
    return ym(
      n,
      "HEAD",
      e,
      Object.assign(Object.assign({}, t), { noResolveJson: !0 }),
      r
    );
  });
}
function LM(n, e, t, r, i) {
  return ct(this, void 0, void 0, function* () {
    return ym(n, "DELETE", e, r, i, t);
  });
}
class ZX {
  constructor(e, t) {
    (this.downloadFn = e), (this.shouldThrowOnError = t);
  }
  then(e, t) {
    return this.execute().then(e, t);
  }
  execute() {
    return ct(this, void 0, void 0, function* () {
      try {
        return { data: (yield this.downloadFn()).body, error: null };
      } catch (e) {
        if (this.shouldThrowOnError) throw e;
        if (wn(e)) return { data: null, error: e };
        throw e;
      }
    });
  }
}
var zF;
class QX {
  constructor(e, t) {
    (this.downloadFn = e),
      (this.shouldThrowOnError = t),
      (this[zF] = "BlobDownloadBuilder"),
      (this.promise = null);
  }
  asStream() {
    return new ZX(this.downloadFn, this.shouldThrowOnError);
  }
  then(e, t) {
    return this.getPromise().then(e, t);
  }
  catch(e) {
    return this.getPromise().catch(e);
  }
  finally(e) {
    return this.getPromise().finally(e);
  }
  getPromise() {
    return this.promise || (this.promise = this.execute()), this.promise;
  }
  execute() {
    return ct(this, void 0, void 0, function* () {
      try {
        return { data: yield (yield this.downloadFn()).blob(), error: null };
      } catch (e) {
        if (this.shouldThrowOnError) throw e;
        if (wn(e)) return { data: null, error: e };
        throw e;
      }
    });
  }
}
zF = Symbol.toStringTag;
const eq = { limit: 100, offset: 0, sortBy: { column: "name", order: "asc" } },
  e2 = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1,
  };
class tq {
  constructor(e, t = {}, r, i) {
    (this.shouldThrowOnError = !1),
      (this.url = e),
      (this.headers = t),
      (this.bucketId = r),
      (this.fetch = NM(i));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  uploadOrUpdate(e, t, r, i) {
    return ct(this, void 0, void 0, function* () {
      try {
        let s;
        const o = Object.assign(Object.assign({}, e2), i);
        let a = Object.assign(
          Object.assign({}, this.headers),
          e === "POST" && { "x-upsert": String(o.upsert) }
        );
        const l = o.metadata;
        typeof Blob < "u" && r instanceof Blob
          ? ((s = new FormData()),
            s.append("cacheControl", o.cacheControl),
            l && s.append("metadata", this.encodeMetadata(l)),
            s.append("", r))
          : typeof FormData < "u" && r instanceof FormData
          ? ((s = r),
            s.append("cacheControl", o.cacheControl),
            l && s.append("metadata", this.encodeMetadata(l)))
          : ((s = r),
            (a["cache-control"] = `max-age=${o.cacheControl}`),
            (a["content-type"] = o.contentType),
            l && (a["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
          i != null &&
            i.headers &&
            (a = Object.assign(Object.assign({}, a), i.headers));
        const c = this._removeEmptyFolders(t),
          u = this._getFinalPath(c),
          f = yield (e == "PUT" ? cE : Es)(
            this.fetch,
            `${this.url}/object/${u}`,
            s,
            Object.assign(
              { headers: a },
              o != null && o.duplex ? { duplex: o.duplex } : {}
            )
          );
        return { data: { path: c, id: f.Id, fullPath: f.Key }, error: null };
      } catch (s) {
        if (this.shouldThrowOnError) throw s;
        if (wn(s)) return { data: null, error: s };
        throw s;
      }
    });
  }
  upload(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", e, t, r);
    });
  }
  uploadToSignedUrl(e, t, r, i) {
    return ct(this, void 0, void 0, function* () {
      const s = this._removeEmptyFolders(e),
        o = this._getFinalPath(s),
        a = new URL(this.url + `/object/upload/sign/${o}`);
      a.searchParams.set("token", t);
      try {
        let l;
        const c = Object.assign({ upsert: e2.upsert }, i),
          u = Object.assign(Object.assign({}, this.headers), {
            "x-upsert": String(c.upsert),
          });
        typeof Blob < "u" && r instanceof Blob
          ? ((l = new FormData()),
            l.append("cacheControl", c.cacheControl),
            l.append("", r))
          : typeof FormData < "u" && r instanceof FormData
          ? ((l = r), l.append("cacheControl", c.cacheControl))
          : ((l = r),
            (u["cache-control"] = `max-age=${c.cacheControl}`),
            (u["content-type"] = c.contentType));
        const f = yield cE(this.fetch, a.toString(), l, { headers: u });
        return { data: { path: s, fullPath: f.Key }, error: null };
      } catch (l) {
        if (this.shouldThrowOnError) throw l;
        if (wn(l)) return { data: null, error: l };
        throw l;
      }
    });
  }
  createSignedUploadUrl(e, t) {
    return ct(this, void 0, void 0, function* () {
      try {
        let r = this._getFinalPath(e);
        const i = Object.assign({}, this.headers);
        t != null && t.upsert && (i["x-upsert"] = "true");
        const s = yield Es(
            this.fetch,
            `${this.url}/object/upload/sign/${r}`,
            {},
            { headers: i }
          ),
          o = new URL(this.url + s.url),
          a = o.searchParams.get("token");
        if (!a) throw new IM("No token returned by API");
        return {
          data: { signedUrl: o.toString(), path: e, token: a },
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (wn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  update(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", e, t, r);
    });
  }
  move(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/object/move`,
            {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: t,
              destinationBucket: r == null ? void 0 : r.destinationBucket,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  copy(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield Es(
              this.fetch,
              `${this.url}/object/copy`,
              {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: t,
                destinationBucket: r == null ? void 0 : r.destinationBucket,
              },
              { headers: this.headers }
            )).Key,
          },
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  createSignedUrl(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      try {
        let i = this._getFinalPath(e),
          s = yield Es(
            this.fetch,
            `${this.url}/object/sign/${i}`,
            Object.assign(
              { expiresIn: t },
              r != null && r.transform ? { transform: r.transform } : {}
            ),
            { headers: this.headers }
          );
        const o =
          r != null && r.download
            ? `&download=${r.download === !0 ? "" : r.download}`
            : "";
        return (
          (s = { signedUrl: encodeURI(`${this.url}${s.signedURL}${o}`) }),
          { data: s, error: null }
        );
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  createSignedUrls(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      try {
        const i = yield Es(
            this.fetch,
            `${this.url}/object/sign/${this.bucketId}`,
            { expiresIn: t, paths: e },
            { headers: this.headers }
          ),
          s =
            r != null && r.download
              ? `&download=${r.download === !0 ? "" : r.download}`
              : "";
        return {
          data: i.map((o) =>
            Object.assign(Object.assign({}, o), {
              signedUrl: o.signedURL
                ? encodeURI(`${this.url}${o.signedURL}${s}`)
                : null,
            })
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  download(e, t) {
    const i =
        typeof (t == null ? void 0 : t.transform) < "u"
          ? "render/image/authenticated"
          : "object",
      s = this.transformOptsToQueryString(
        (t == null ? void 0 : t.transform) || {}
      ),
      o = s ? `?${s}` : "",
      a = this._getFinalPath(e),
      l = () =>
        Dp(this.fetch, `${this.url}/${i}/${a}${o}`, {
          headers: this.headers,
          noResolveJson: !0,
        });
    return new QX(l, this.shouldThrowOnError);
  }
  info(e) {
    return ct(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        const r = yield Dp(this.fetch, `${this.url}/object/info/${t}`, {
          headers: this.headers,
        });
        return { data: lE(r), error: null };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (wn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  exists(e) {
    return ct(this, void 0, void 0, function* () {
      const t = this._getFinalPath(e);
      try {
        return (
          yield JX(this.fetch, `${this.url}/object/${t}`, {
            headers: this.headers,
          }),
          { data: !0, error: null }
        );
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (wn(r) && r instanceof aE) {
          const i = r.originalError;
          if ([400, 404].includes(i == null ? void 0 : i.status))
            return { data: !1, error: r };
        }
        throw r;
      }
    });
  }
  getPublicUrl(e, t) {
    const r = this._getFinalPath(e),
      i = [],
      s =
        t != null && t.download
          ? `download=${t.download === !0 ? "" : t.download}`
          : "";
    s !== "" && i.push(s);
    const a =
        typeof (t == null ? void 0 : t.transform) < "u"
          ? "render/image"
          : "object",
      l = this.transformOptsToQueryString(
        (t == null ? void 0 : t.transform) || {}
      );
    l !== "" && i.push(l);
    let c = i.join("&");
    return (
      c !== "" && (c = `?${c}`),
      { data: { publicUrl: encodeURI(`${this.url}/${a}/public/${r}${c}`) } }
    );
  }
  remove(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield LM(
            this.fetch,
            `${this.url}/object/${this.bucketId}`,
            { prefixes: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  list(e, t, r) {
    return ct(this, void 0, void 0, function* () {
      try {
        const i = Object.assign(Object.assign(Object.assign({}, eq), t), {
          prefix: e || "",
        });
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/object/list/${this.bucketId}`,
            i,
            { headers: this.headers },
            r
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  listV2(e, t) {
    return ct(this, void 0, void 0, function* () {
      try {
        const r = Object.assign({}, e);
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/object/list-v2/${this.bucketId}`,
            r,
            { headers: this.headers },
            t
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (wn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  encodeMetadata(e) {
    return JSON.stringify(e);
  }
  toBase64(e) {
    return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e);
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e.replace(/^\/+/, "")}`;
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(e) {
    const t = [];
    return (
      e.width && t.push(`width=${e.width}`),
      e.height && t.push(`height=${e.height}`),
      e.resize && t.push(`resize=${e.resize}`),
      e.format && t.push(`format=${e.format}`),
      e.quality && t.push(`quality=${e.quality}`),
      t.join("&")
    );
  }
}
const VF = "2.78.0",
  jF = { "X-Client-Info": `storage-js/${VF}` };
class nq {
  constructor(e, t = {}, r, i) {
    this.shouldThrowOnError = !1;
    const s = new URL(e);
    i != null &&
      i.useNewHostname &&
      /supabase\.(co|in|red)$/.test(s.hostname) &&
      !s.hostname.includes("storage.supabase.") &&
      (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")),
      (this.url = s.href.replace(/\/$/, "")),
      (this.headers = Object.assign(Object.assign({}, jF), t)),
      (this.fetch = NM(r));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  listBuckets(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        const t = this.listBucketOptionsToQueryString(e);
        return {
          data: yield Dp(this.fetch, `${this.url}/bucket${t}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Dp(this.fetch, `${this.url}/bucket/${e}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  createBucket(e) {
    return ct(this, arguments, void 0, function* (t, r = { public: !1 }) {
      try {
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/bucket`,
            {
              id: t,
              name: t,
              type: r.type,
              public: r.public,
              file_size_limit: r.fileSizeLimit,
              allowed_mime_types: r.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (i) {
        if (this.shouldThrowOnError) throw i;
        if (wn(i)) return { data: null, error: i };
        throw i;
      }
    });
  }
  updateBucket(e, t) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield cE(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {
              id: e,
              name: e,
              public: t.public,
              file_size_limit: t.fileSizeLimit,
              allowed_mime_types: t.allowedMimeTypes,
            },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (wn(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  emptyBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/bucket/${e}/empty`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield LM(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBucketOptionsToQueryString(e) {
    const t = {};
    return (
      e &&
        ("limit" in e && (t.limit = String(e.limit)),
        "offset" in e && (t.offset = String(e.offset)),
        e.search && (t.search = e.search),
        e.sortColumn && (t.sortColumn = e.sortColumn),
        e.sortOrder && (t.sortOrder = e.sortOrder)),
      Object.keys(t).length > 0 ? "?" + new URLSearchParams(t).toString() : ""
    );
  }
}
class rq {
  constructor(e, t = {}, r) {
    (this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, "")),
      (this.headers = Object.assign(Object.assign({}, jF), t)),
      (this.fetch = NM(r));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  createBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Es(
            this.fetch,
            `${this.url}/bucket`,
            { name: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBuckets(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        const t = new URLSearchParams();
        (e == null ? void 0 : e.limit) !== void 0 &&
          t.set("limit", e.limit.toString()),
          (e == null ? void 0 : e.offset) !== void 0 &&
            t.set("offset", e.offset.toString()),
          e != null && e.sortColumn && t.set("sortColumn", e.sortColumn),
          e != null && e.sortOrder && t.set("sortOrder", e.sortOrder),
          e != null && e.search && t.set("search", e.search);
        const r = t.toString(),
          i = r ? `${this.url}/bucket?${r}` : `${this.url}/bucket`;
        return {
          data: yield Dp(this.fetch, i, { headers: this.headers }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield LM(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (wn(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
const OM = {
  "X-Client-Info": `storage-js/${VF}`,
  "Content-Type": "application/json",
};
class HF extends Error {
  constructor(e) {
    super(e),
      (this.__isStorageVectorsError = !0),
      (this.name = "StorageVectorsError");
  }
}
function Ci(n) {
  return typeof n == "object" && n !== null && "__isStorageVectorsError" in n;
}
class SS extends HF {
  constructor(e, t, r) {
    super(e),
      (this.name = "StorageVectorsApiError"),
      (this.status = t),
      (this.statusCode = r);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      statusCode: this.statusCode,
    };
  }
}
class iq extends HF {
  constructor(e, t) {
    super(e),
      (this.name = "StorageVectorsUnknownError"),
      (this.originalError = t);
  }
}
var t2;
(function (n) {
  (n.InternalError = "InternalError"),
    (n.S3VectorConflictException = "S3VectorConflictException"),
    (n.S3VectorNotFoundException = "S3VectorNotFoundException"),
    (n.S3VectorBucketNotEmpty = "S3VectorBucketNotEmpty"),
    (n.S3VectorMaxBucketsExceeded = "S3VectorMaxBucketsExceeded"),
    (n.S3VectorMaxIndexesExceeded = "S3VectorMaxIndexesExceeded");
})(t2 || (t2 = {}));
const DM = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Eh(async () => {
              const { default: r } = await Promise.resolve().then(() => Zc);
              return { default: r };
            }, void 0).then(({ default: r }) => r(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  },
  sq = (n) => {
    if (typeof n != "object" || n === null) return !1;
    const e = Object.getPrototypeOf(n);
    return (
      (e === null ||
        e === Object.prototype ||
        Object.getPrototypeOf(e) === null) &&
      !(Symbol.toStringTag in n) &&
      !(Symbol.iterator in n)
    );
  },
  n2 = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  oq = (n, e, t) =>
    ct(void 0, void 0, void 0, function* () {
      if (
        n &&
        typeof n == "object" &&
        "status" in n &&
        "ok" in n &&
        typeof n.status == "number" &&
        !(t != null && t.noResolveJson)
      ) {
        const i = n.status || 500,
          s = n;
        if (typeof s.json == "function")
          s.json()
            .then((o) => {
              const a =
                (o == null ? void 0 : o.statusCode) ||
                (o == null ? void 0 : o.code) ||
                i + "";
              e(new SS(n2(o), i, a));
            })
            .catch(() => {
              const o = i + "",
                a = s.statusText || `HTTP ${i} error`;
              e(new SS(a, i, o));
            });
        else {
          const o = i + "",
            a = s.statusText || `HTTP ${i} error`;
          e(new SS(a, i, o));
        }
      } else e(new iq(n2(n), n));
    }),
  aq = (n, e, t, r) => {
    const i = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
    return r
      ? (sq(r)
          ? ((i.headers = Object.assign(
              { "Content-Type": "application/json" },
              e == null ? void 0 : e.headers
            )),
            (i.body = JSON.stringify(r)))
          : (i.body = r),
        Object.assign(Object.assign({}, i), t))
      : i;
  };
function lq(n, e, t, r, i, s) {
  return ct(this, void 0, void 0, function* () {
    return new Promise((o, a) => {
      n(t, aq(e, r, i, s))
        .then((l) => {
          if (!l.ok) throw l;
          if (r != null && r.noResolveJson) return l;
          const c = l.headers.get("content-type");
          return !c || !c.includes("application/json") ? {} : l.json();
        })
        .then((l) => o(l))
        .catch((l) => oq(l, a, r));
    });
  });
}
function Ai(n, e, t, r, i) {
  return ct(this, void 0, void 0, function* () {
    return lq(n, "POST", e, r, i, t);
  });
}
class cq {
  constructor(e, t = {}, r) {
    (this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, "")),
      (this.headers = Object.assign(Object.assign({}, OM), t)),
      (this.fetch = DM(r));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  createIndex(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Ai(this.fetch, `${this.url}/CreateIndex`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getIndex(e, t) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Ai(
            this.fetch,
            `${this.url}/GetIndex`,
            { vectorBucketName: e, indexName: t },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (Ci(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
  listIndexes(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Ai(this.fetch, `${this.url}/ListIndexes`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteIndex(e, t) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Ai(
              this.fetch,
              `${this.url}/DeleteIndex`,
              { vectorBucketName: e, indexName: t },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (r) {
        if (this.shouldThrowOnError) throw r;
        if (Ci(r)) return { data: null, error: r };
        throw r;
      }
    });
  }
}
class uq {
  constructor(e, t = {}, r) {
    (this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, "")),
      (this.headers = Object.assign(Object.assign({}, OM), t)),
      (this.fetch = DM(r));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  putVectors(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        if (e.vectors.length < 1 || e.vectors.length > 500)
          throw new Error("Vector batch size must be between 1 and 500 items");
        return {
          data:
            (yield Ai(this.fetch, `${this.url}/PutVectors`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getVectors(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Ai(this.fetch, `${this.url}/GetVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listVectors(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        if (e.segmentCount !== void 0) {
          if (e.segmentCount < 1 || e.segmentCount > 16)
            throw new Error("segmentCount must be between 1 and 16");
          if (
            e.segmentIndex !== void 0 &&
            (e.segmentIndex < 0 || e.segmentIndex >= e.segmentCount)
          )
            throw new Error(
              `segmentIndex must be between 0 and ${e.segmentCount - 1}`
            );
        }
        return {
          data: yield Ai(this.fetch, `${this.url}/ListVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  queryVectors(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Ai(this.fetch, `${this.url}/QueryVectors`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteVectors(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        if (e.keys.length < 1 || e.keys.length > 500)
          throw new Error("Keys batch size must be between 1 and 500 items");
        return {
          data:
            (yield Ai(this.fetch, `${this.url}/DeleteVectors`, e, {
              headers: this.headers,
            })) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
class dq {
  constructor(e, t = {}, r) {
    (this.shouldThrowOnError = !1),
      (this.url = e.replace(/\/$/, "")),
      (this.headers = Object.assign(Object.assign({}, OM), t)),
      (this.fetch = DM(r));
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  createBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Ai(
              this.fetch,
              `${this.url}/CreateVectorBucket`,
              { vectorBucketName: e },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  getBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Ai(
            this.fetch,
            `${this.url}/GetVectorBucket`,
            { vectorBucketName: e },
            { headers: this.headers }
          ),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  listBuckets() {
    return ct(this, arguments, void 0, function* (e = {}) {
      try {
        return {
          data: yield Ai(this.fetch, `${this.url}/ListVectorBuckets`, e, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  deleteBucket(e) {
    return ct(this, void 0, void 0, function* () {
      try {
        return {
          data:
            (yield Ai(
              this.fetch,
              `${this.url}/DeleteVectorBucket`,
              { vectorBucketName: e },
              { headers: this.headers }
            )) || {},
          error: null,
        };
      } catch (t) {
        if (this.shouldThrowOnError) throw t;
        if (Ci(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
}
class hq extends dq {
  constructor(e, t = {}) {
    super(e, t.headers || {}, t.fetch);
  }
  from(e) {
    return new fq(this.url, this.headers, e, this.fetch);
  }
}
class fq extends cq {
  constructor(e, t, r, i) {
    super(e, t, i), (this.vectorBucketName = r);
  }
  createIndex(e) {
    const t = Object.create(null, {
      createIndex: { get: () => super.createIndex },
    });
    return ct(this, void 0, void 0, function* () {
      return t.createIndex.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
        })
      );
    });
  }
  listIndexes() {
    const e = Object.create(null, {
      listIndexes: { get: () => super.listIndexes },
    });
    return ct(this, arguments, void 0, function* (t = {}) {
      return e.listIndexes.call(
        this,
        Object.assign(Object.assign({}, t), {
          vectorBucketName: this.vectorBucketName,
        })
      );
    });
  }
  getIndex(e) {
    const t = Object.create(null, { getIndex: { get: () => super.getIndex } });
    return ct(this, void 0, void 0, function* () {
      return t.getIndex.call(this, this.vectorBucketName, e);
    });
  }
  deleteIndex(e) {
    const t = Object.create(null, {
      deleteIndex: { get: () => super.deleteIndex },
    });
    return ct(this, void 0, void 0, function* () {
      return t.deleteIndex.call(this, this.vectorBucketName, e);
    });
  }
  index(e) {
    return new pq(this.url, this.headers, this.vectorBucketName, e, this.fetch);
  }
}
class pq extends uq {
  constructor(e, t, r, i, s) {
    super(e, t, s), (this.vectorBucketName = r), (this.indexName = i);
  }
  putVectors(e) {
    const t = Object.create(null, {
      putVectors: { get: () => super.putVectors },
    });
    return ct(this, void 0, void 0, function* () {
      return t.putVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  getVectors(e) {
    const t = Object.create(null, {
      getVectors: { get: () => super.getVectors },
    });
    return ct(this, void 0, void 0, function* () {
      return t.getVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  listVectors() {
    const e = Object.create(null, {
      listVectors: { get: () => super.listVectors },
    });
    return ct(this, arguments, void 0, function* (t = {}) {
      return e.listVectors.call(
        this,
        Object.assign(Object.assign({}, t), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  queryVectors(e) {
    const t = Object.create(null, {
      queryVectors: { get: () => super.queryVectors },
    });
    return ct(this, void 0, void 0, function* () {
      return t.queryVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
  deleteVectors(e) {
    const t = Object.create(null, {
      deleteVectors: { get: () => super.deleteVectors },
    });
    return ct(this, void 0, void 0, function* () {
      return t.deleteVectors.call(
        this,
        Object.assign(Object.assign({}, e), {
          vectorBucketName: this.vectorBucketName,
          indexName: this.indexName,
        })
      );
    });
  }
}
class mq extends nq {
  constructor(e, t = {}, r, i) {
    super(e, t, r, i);
  }
  from(e) {
    return new tq(this.url, this.headers, e, this.fetch);
  }
  get vectors() {
    return new hq(this.url + "/vector", {
      headers: this.headers,
      fetch: this.fetch,
    });
  }
  get analytics() {
    return new rq(this.url + "/iceberg", this.headers, this.fetch);
  }
}
const gq = "2.78.0";
let Nf = "";
typeof Deno < "u"
  ? (Nf = "deno")
  : typeof document < "u"
  ? (Nf = "web")
  : typeof navigator < "u" && navigator.product === "ReactNative"
  ? (Nf = "react-native")
  : (Nf = "node");
const vq = { "X-Client-Info": `supabase-js-${Nf}/${gq}` },
  yq = { headers: vq },
  xq = { schema: "public" },
  _q = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit",
  },
  wq = {},
  Sq = (n) => {
    let e;
    return (
      n ? (e = n) : typeof fetch > "u" ? (e = yF) : (e = fetch),
      (...t) => e(...t)
    );
  },
  bq = () => (typeof Headers > "u" ? xF : Headers),
  Eq = (n, e, t) => {
    const r = Sq(t),
      i = bq();
    return async (s, o) => {
      var a;
      const l = (a = await e()) !== null && a !== void 0 ? a : n;
      let c = new i(o == null ? void 0 : o.headers);
      return (
        c.has("apikey") || c.set("apikey", n),
        c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
        r(s, Object.assign(Object.assign({}, o), { headers: c }))
      );
    };
  };
function Tq(n) {
  return n.endsWith("/") ? n : n + "/";
}
function Mq(n, e) {
  var t, r;
  const { db: i, auth: s, realtime: o, global: a } = n,
    { db: l, auth: c, realtime: u, global: f } = e,
    p = {
      db: Object.assign(Object.assign({}, l), i),
      auth: Object.assign(Object.assign({}, c), s),
      realtime: Object.assign(Object.assign({}, u), o),
      storage: {},
      global: Object.assign(Object.assign(Object.assign({}, f), a), {
        headers: Object.assign(
          Object.assign(
            {},
            (t = f == null ? void 0 : f.headers) !== null && t !== void 0
              ? t
              : {}
          ),
          (r = a == null ? void 0 : a.headers) !== null && r !== void 0 ? r : {}
        ),
      }),
      accessToken: async () => "",
    };
  return (
    n.accessToken ? (p.accessToken = n.accessToken) : delete p.accessToken, p
  );
}
function Cq(n) {
  const e = n == null ? void 0 : n.trim();
  if (!e) throw new Error("supabaseUrl is required.");
  if (!e.match(/^https?:\/\//i))
    throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
  try {
    return new URL(Tq(e));
  } catch {
    throw Error("Invalid supabaseUrl: Provided URL is malformed.");
  }
}
const WF = "2.78.0",
  Yu = 30 * 1e3,
  uE = 3,
  bS = uE * Yu,
  Aq = "http://localhost:9999",
  Rq = "supabase.auth.token",
  Pq = { "X-Client-Info": `gotrue-js/${WF}` },
  dE = "X-Supabase-Api-Version",
  GF = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01",
    },
  },
  Iq = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  Nq = 10 * 60 * 1e3;
class kp extends Error {
  constructor(e, t, r) {
    super(e),
      (this.__isAuthError = !0),
      (this.name = "AuthError"),
      (this.status = t),
      (this.code = r);
  }
}
function ft(n) {
  return typeof n == "object" && n !== null && "__isAuthError" in n;
}
class Lq extends kp {
  constructor(e, t, r) {
    super(e, t, r),
      (this.name = "AuthApiError"),
      (this.status = t),
      (this.code = r);
  }
}
function Oq(n) {
  return ft(n) && n.name === "AuthApiError";
}
class lc extends kp {
  constructor(e, t) {
    super(e), (this.name = "AuthUnknownError"), (this.originalError = t);
  }
}
class xl extends kp {
  constructor(e, t, r, i) {
    super(e, r, i), (this.name = t), (this.status = r);
  }
}
class ys extends xl {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function Dq(n) {
  return ft(n) && n.name === "AuthSessionMissingError";
}
class yu extends xl {
  constructor() {
    super(
      "Auth session or user missing",
      "AuthInvalidTokenResponseError",
      500,
      void 0
    );
  }
}
class ov extends xl {
  constructor(e) {
    super(e, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class av extends xl {
  constructor(e, t = null) {
    super(e, "AuthImplicitGrantRedirectError", 500, void 0),
      (this.details = null),
      (this.details = t);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
function kq(n) {
  return ft(n) && n.name === "AuthImplicitGrantRedirectError";
}
class r2 extends xl {
  constructor(e, t = null) {
    super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
      (this.details = null),
      (this.details = t);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
class hE extends xl {
  constructor(e, t) {
    super(e, "AuthRetryableFetchError", t, void 0);
  }
}
function ES(n) {
  return ft(n) && n.name === "AuthRetryableFetchError";
}
class i2 extends xl {
  constructor(e, t, r) {
    super(e, "AuthWeakPasswordError", t, "weak_password"), (this.reasons = r);
  }
}
class fE extends xl {
  constructor(e) {
    super(e, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const f0 =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(
      ""
    ),
  s2 = ` 	
\r=`.split(""),
  Uq = (() => {
    const n = new Array(128);
    for (let e = 0; e < n.length; e += 1) n[e] = -1;
    for (let e = 0; e < s2.length; e += 1) n[s2[e].charCodeAt(0)] = -2;
    for (let e = 0; e < f0.length; e += 1) n[f0[e].charCodeAt(0)] = e;
    return n;
  })();
function o2(n, e, t) {
  if (n !== null)
    for (e.queue = (e.queue << 8) | n, e.queuedBits += 8; e.queuedBits >= 6; ) {
      const r = (e.queue >> (e.queuedBits - 6)) & 63;
      t(f0[r]), (e.queuedBits -= 6);
    }
  else if (e.queuedBits > 0)
    for (
      e.queue = e.queue << (6 - e.queuedBits), e.queuedBits = 6;
      e.queuedBits >= 6;

    ) {
      const r = (e.queue >> (e.queuedBits - 6)) & 63;
      t(f0[r]), (e.queuedBits -= 6);
    }
}
function $F(n, e, t) {
  const r = Uq[n];
  if (r > -1)
    for (e.queue = (e.queue << 6) | r, e.queuedBits += 6; e.queuedBits >= 8; )
      t((e.queue >> (e.queuedBits - 8)) & 255), (e.queuedBits -= 8);
  else {
    if (r === -2) return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(n)}"`);
  }
}
function a2(n) {
  const e = [],
    t = (o) => {
      e.push(String.fromCodePoint(o));
    },
    r = { utf8seq: 0, codepoint: 0 },
    i = { queue: 0, queuedBits: 0 },
    s = (o) => {
      zq(o, r, t);
    };
  for (let o = 0; o < n.length; o += 1) $F(n.charCodeAt(o), i, s);
  return e.join("");
}
function Fq(n, e) {
  if (n <= 127) {
    e(n);
    return;
  } else if (n <= 2047) {
    e(192 | (n >> 6)), e(128 | (n & 63));
    return;
  } else if (n <= 65535) {
    e(224 | (n >> 12)), e(128 | ((n >> 6) & 63)), e(128 | (n & 63));
    return;
  } else if (n <= 1114111) {
    e(240 | (n >> 18)),
      e(128 | ((n >> 12) & 63)),
      e(128 | ((n >> 6) & 63)),
      e(128 | (n & 63));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${n.toString(16)}`);
}
function Bq(n, e) {
  for (let t = 0; t < n.length; t += 1) {
    let r = n.charCodeAt(t);
    if (r > 55295 && r <= 56319) {
      const i = ((r - 55296) * 1024) & 65535;
      (r = (((n.charCodeAt(t + 1) - 56320) & 65535) | i) + 65536), (t += 1);
    }
    Fq(r, e);
  }
}
function zq(n, e, t) {
  if (e.utf8seq === 0) {
    if (n <= 127) {
      t(n);
      return;
    }
    for (let r = 1; r < 6; r += 1)
      if (!((n >> (7 - r)) & 1)) {
        e.utf8seq = r;
        break;
      }
    if (e.utf8seq === 2) e.codepoint = n & 31;
    else if (e.utf8seq === 3) e.codepoint = n & 15;
    else if (e.utf8seq === 4) e.codepoint = n & 7;
    else throw new Error("Invalid UTF-8 sequence");
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (n <= 127) throw new Error("Invalid UTF-8 sequence");
    (e.codepoint = (e.codepoint << 6) | (n & 63)),
      (e.utf8seq -= 1),
      e.utf8seq === 0 && t(e.codepoint);
  }
}
function Nd(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    r = (i) => {
      e.push(i);
    };
  for (let i = 0; i < n.length; i += 1) $F(n.charCodeAt(i), t, r);
  return new Uint8Array(e);
}
function Vq(n) {
  const e = [];
  return Bq(n, (t) => e.push(t)), new Uint8Array(e);
}
function fc(n) {
  const e = [],
    t = { queue: 0, queuedBits: 0 },
    r = (i) => {
      e.push(i);
    };
  return n.forEach((i) => o2(i, t, r)), o2(null, t, r), e.join("");
}
function jq(n) {
  return Math.round(Date.now() / 1e3) + n;
}
function Hq() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (n) {
    const e = (Math.random() * 16) | 0;
    return (n == "x" ? e : (e & 3) | 8).toString(16);
  });
}
const jr = () => typeof window < "u" && typeof document < "u",
  kl = { tested: !1, writable: !1 },
  XF = () => {
    if (!jr()) return !1;
    try {
      if (typeof globalThis.localStorage != "object") return !1;
    } catch {
      return !1;
    }
    if (kl.tested) return kl.writable;
    const n = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(n, n),
        globalThis.localStorage.removeItem(n),
        (kl.tested = !0),
        (kl.writable = !0);
    } catch {
      (kl.tested = !0), (kl.writable = !1);
    }
    return kl.writable;
  };
function Wq(n) {
  const e = {},
    t = new URL(n);
  if (t.hash && t.hash[0] === "#")
    try {
      new URLSearchParams(t.hash.substring(1)).forEach((i, s) => {
        e[s] = i;
      });
    } catch {}
  return (
    t.searchParams.forEach((r, i) => {
      e[i] = r;
    }),
    e
  );
}
const qF = (n) => {
    let e;
    return (
      n
        ? (e = n)
        : typeof fetch > "u"
        ? (e = (...t) =>
            Eh(async () => {
              const { default: r } = await Promise.resolve().then(() => Zc);
              return { default: r };
            }, void 0).then(({ default: r }) => r(...t)))
        : (e = fetch),
      (...t) => e(...t)
    );
  },
  Gq = (n) =>
    typeof n == "object" &&
    n !== null &&
    "status" in n &&
    "ok" in n &&
    "json" in n &&
    typeof n.json == "function",
  Ju = async (n, e, t) => {
    await n.setItem(e, JSON.stringify(t));
  },
  Ul = async (n, e) => {
    const t = await n.getItem(e);
    if (!t) return null;
    try {
      return JSON.parse(t);
    } catch {
      return t;
    }
  },
  wa = async (n, e) => {
    await n.removeItem(e);
  };
class zx {
  constructor() {
    this.promise = new zx.promiseConstructor((e, t) => {
      (this.resolve = e), (this.reject = t);
    });
  }
}
zx.promiseConstructor = Promise;
function TS(n) {
  const e = n.split(".");
  if (e.length !== 3) throw new fE("Invalid JWT structure");
  for (let r = 0; r < e.length; r++)
    if (!Iq.test(e[r])) throw new fE("JWT not in base64url format");
  return {
    header: JSON.parse(a2(e[0])),
    payload: JSON.parse(a2(e[1])),
    signature: Nd(e[2]),
    raw: { header: e[0], payload: e[1] },
  };
}
async function $q(n) {
  return await new Promise((e) => {
    setTimeout(() => e(null), n);
  });
}
function Xq(n, e) {
  return new Promise((r, i) => {
    (async () => {
      for (let s = 0; s < 1 / 0; s++)
        try {
          const o = await n(s);
          if (!e(s, null, o)) {
            r(o);
            return;
          }
        } catch (o) {
          if (!e(s, o)) {
            i(o);
            return;
          }
        }
    })();
  });
}
function qq(n) {
  return ("0" + n.toString(16)).substr(-2);
}
function Kq() {
  const e = new Uint32Array(56);
  if (typeof crypto > "u") {
    const t =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
      r = t.length;
    let i = "";
    for (let s = 0; s < 56; s++) i += t.charAt(Math.floor(Math.random() * r));
    return i;
  }
  return crypto.getRandomValues(e), Array.from(e, qq).join("");
}
async function Yq(n) {
  const t = new TextEncoder().encode(n),
    r = await crypto.subtle.digest("SHA-256", t),
    i = new Uint8Array(r);
  return Array.from(i)
    .map((s) => String.fromCharCode(s))
    .join("");
}
async function Jq(n) {
  if (
    !(
      typeof crypto < "u" &&
      typeof crypto.subtle < "u" &&
      typeof TextEncoder < "u"
    )
  )
    return (
      console.warn(
        "WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."
      ),
      n
    );
  const t = await Yq(n);
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function xu(n, e, t = !1) {
  const r = Kq();
  let i = r;
  t && (i += "/PASSWORD_RECOVERY"), await Ju(n, `${e}-code-verifier`, i);
  const s = await Jq(r);
  return [s, r === s ? "plain" : "s256"];
}
const Zq = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function Qq(n) {
  const e = n.headers.get(dE);
  if (!e || !e.match(Zq)) return null;
  try {
    return new Date(`${e}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function eK(n) {
  if (!n) throw new Error("Missing exp claim");
  const e = Math.floor(Date.now() / 1e3);
  if (n <= e) throw new Error("JWT has expired");
}
function tK(n) {
  switch (n) {
    case "RS256":
      return { name: "RSASSA-PKCS1-v1_5", hash: { name: "SHA-256" } };
    case "ES256":
      return { name: "ECDSA", namedCurve: "P-256", hash: { name: "SHA-256" } };
    default:
      throw new Error("Invalid alg claim");
  }
}
const nK = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function _u(n) {
  if (!nK.test(n))
    throw new Error(
      "@supabase/auth-js: Expected parameter to be UUID but is not"
    );
}
function MS() {
  const n = {};
  return new Proxy(n, {
    get: (e, t) => {
      if (t === "__isUserNotAvailableProxy") return !0;
      if (typeof t == "symbol") {
        const r = t.toString();
        if (
          r === "Symbol(Symbol.toPrimitive)" ||
          r === "Symbol(Symbol.toStringTag)" ||
          r === "Symbol(util.inspect.custom)"
        )
          return;
      }
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${t}" property of the session object is not supported. Please use getUser() instead.`
      );
    },
    set: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
    deleteProperty: (e, t) => {
      throw new Error(
        `@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${t}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`
      );
    },
  });
}
function rK(n, e) {
  return new Proxy(n, {
    get: (t, r, i) => {
      if (r === "__isInsecureUserWarningProxy") return !0;
      if (typeof r == "symbol") {
        const s = r.toString();
        if (
          s === "Symbol(Symbol.toPrimitive)" ||
          s === "Symbol(Symbol.toStringTag)" ||
          s === "Symbol(util.inspect.custom)" ||
          s === "Symbol(nodejs.util.inspect.custom)"
        )
          return Reflect.get(t, r, i);
      }
      return (
        !e.value &&
          typeof r == "string" &&
          (console.warn(
            "Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."
          ),
          (e.value = !0)),
        Reflect.get(t, r, i)
      );
    },
  });
}
function l2(n) {
  return JSON.parse(JSON.stringify(n));
}
const tc = (n) =>
    n.msg || n.message || n.error_description || n.error || JSON.stringify(n),
  iK = [502, 503, 504];
async function c2(n) {
  var e;
  if (!Gq(n)) throw new hE(tc(n), 0);
  if (iK.includes(n.status)) throw new hE(tc(n), n.status);
  let t;
  try {
    t = await n.json();
  } catch (s) {
    throw new lc(tc(s), s);
  }
  let r;
  const i = Qq(n);
  if (
    (i &&
    i.getTime() >= GF["2024-01-01"].timestamp &&
    typeof t == "object" &&
    t &&
    typeof t.code == "string"
      ? (r = t.code)
      : typeof t == "object" &&
        t &&
        typeof t.error_code == "string" &&
        (r = t.error_code),
    r)
  ) {
    if (r === "weak_password")
      throw new i2(
        tc(t),
        n.status,
        ((e = t.weak_password) === null || e === void 0 ? void 0 : e.reasons) ||
          []
      );
    if (r === "session_not_found") throw new ys();
  } else if (
    typeof t == "object" &&
    t &&
    typeof t.weak_password == "object" &&
    t.weak_password &&
    Array.isArray(t.weak_password.reasons) &&
    t.weak_password.reasons.length &&
    t.weak_password.reasons.reduce((s, o) => s && typeof o == "string", !0)
  )
    throw new i2(tc(t), n.status, t.weak_password.reasons);
  throw new Lq(tc(t), n.status || 500, r);
}
const sK = (n, e, t, r) => {
  const i = { method: n, headers: (e == null ? void 0 : e.headers) || {} };
  return n === "GET"
    ? i
    : ((i.headers = Object.assign(
        { "Content-Type": "application/json;charset=UTF-8" },
        e == null ? void 0 : e.headers
      )),
      (i.body = JSON.stringify(r)),
      Object.assign(Object.assign({}, i), t));
};
async function bt(n, e, t, r) {
  var i;
  const s = Object.assign({}, r == null ? void 0 : r.headers);
  s[dE] || (s[dE] = GF["2024-01-01"].name),
    r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`);
  const o =
    (i = r == null ? void 0 : r.query) !== null && i !== void 0 ? i : {};
  r != null && r.redirectTo && (o.redirect_to = r.redirectTo);
  const a = Object.keys(o).length
      ? "?" + new URLSearchParams(o).toString()
      : "",
    l = await oK(
      n,
      e,
      t + a,
      { headers: s, noResolveJson: r == null ? void 0 : r.noResolveJson },
      {},
      r == null ? void 0 : r.body
    );
  return r != null && r.xform
    ? r == null
      ? void 0
      : r.xform(l)
    : { data: Object.assign({}, l), error: null };
}
async function oK(n, e, t, r, i, s) {
  const o = sK(e, r, i, s);
  let a;
  try {
    a = await n(t, Object.assign({}, o));
  } catch (l) {
    throw (console.error(l), new hE(tc(l), 0));
  }
  if ((a.ok || (await c2(a)), r != null && r.noResolveJson)) return a;
  try {
    return await a.json();
  } catch (l) {
    await c2(l);
  }
}
function xs(n) {
  var e;
  let t = null;
  cK(n) &&
    ((t = Object.assign({}, n)),
    n.expires_at || (t.expires_at = jq(n.expires_in)));
  const r = (e = n.user) !== null && e !== void 0 ? e : n;
  return { data: { session: t, user: r }, error: null };
}
function u2(n) {
  const e = xs(n);
  return (
    !e.error &&
      n.weak_password &&
      typeof n.weak_password == "object" &&
      Array.isArray(n.weak_password.reasons) &&
      n.weak_password.reasons.length &&
      n.weak_password.message &&
      typeof n.weak_password.message == "string" &&
      n.weak_password.reasons.reduce((t, r) => t && typeof r == "string", !0) &&
      (e.data.weak_password = n.weak_password),
    e
  );
}
function za(n) {
  var e;
  return {
    data: { user: (e = n.user) !== null && e !== void 0 ? e : n },
    error: null,
  };
}
function aK(n) {
  return { data: n, error: null };
}
function lK(n) {
  const {
      action_link: e,
      email_otp: t,
      hashed_token: r,
      redirect_to: i,
      verification_type: s,
    } = n,
    o = yl(n, [
      "action_link",
      "email_otp",
      "hashed_token",
      "redirect_to",
      "verification_type",
    ]),
    a = {
      action_link: e,
      email_otp: t,
      hashed_token: r,
      redirect_to: i,
      verification_type: s,
    },
    l = Object.assign({}, o);
  return { data: { properties: a, user: l }, error: null };
}
function d2(n) {
  return n;
}
function cK(n) {
  return n.access_token && n.refresh_token && n.expires_in;
}
const CS = ["global", "local", "others"];
class uK {
  constructor({ url: e = "", headers: t = {}, fetch: r }) {
    (this.url = e),
      (this.headers = t),
      (this.fetch = qF(r)),
      (this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this),
      }),
      (this.oauth = {
        listClients: this._listOAuthClients.bind(this),
        createClient: this._createOAuthClient.bind(this),
        getClient: this._getOAuthClient.bind(this),
        updateClient: this._updateOAuthClient.bind(this),
        deleteClient: this._deleteOAuthClient.bind(this),
        regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this),
      });
  }
  async signOut(e, t = CS[0]) {
    if (CS.indexOf(t) < 0)
      throw new Error(
        `@supabase/auth-js: Parameter scope must be one of ${CS.join(", ")}`
      );
    try {
      return (
        await bt(this.fetch, "POST", `${this.url}/logout?scope=${t}`, {
          headers: this.headers,
          jwt: e,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (r) {
      if (ft(r)) return { data: null, error: r };
      throw r;
    }
  }
  async inviteUserByEmail(e, t = {}) {
    try {
      return await bt(this.fetch, "POST", `${this.url}/invite`, {
        body: { email: e, data: t.data },
        headers: this.headers,
        redirectTo: t.redirectTo,
        xform: za,
      });
    } catch (r) {
      if (ft(r)) return { data: { user: null }, error: r };
      throw r;
    }
  }
  async generateLink(e) {
    try {
      const { options: t } = e,
        r = yl(e, ["options"]),
        i = Object.assign(Object.assign({}, r), t);
      return (
        "newEmail" in r &&
          ((i.new_email = r == null ? void 0 : r.newEmail), delete i.newEmail),
        await bt(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: i,
          headers: this.headers,
          xform: lK,
          redirectTo: t == null ? void 0 : t.redirectTo,
        })
      );
    } catch (t) {
      if (ft(t)) return { data: { properties: null, user: null }, error: t };
      throw t;
    }
  }
  async createUser(e) {
    try {
      return await bt(this.fetch, "POST", `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: za,
      });
    } catch (t) {
      if (ft(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async listUsers(e) {
    var t, r, i, s, o, a, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        u = await bt(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (r =
                (t = e == null ? void 0 : e.page) === null || t === void 0
                  ? void 0
                  : t.toString()) !== null && r !== void 0
                ? r
                : "",
            per_page:
              (s =
                (i = e == null ? void 0 : e.perPage) === null || i === void 0
                  ? void 0
                  : i.toString()) !== null && s !== void 0
                ? s
                : "",
          },
          xform: d2,
        });
      if (u.error) throw u.error;
      const f = await u.json(),
        p =
          (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0,
        m =
          (l =
            (a = u.headers.get("link")) === null || a === void 0
              ? void 0
              : a.split(",")) !== null && l !== void 0
            ? l
            : [];
      return (
        m.length > 0 &&
          (m.forEach((v) => {
            const y = parseInt(v.split(";")[0].split("=")[1].substring(0, 1)),
              x = JSON.parse(v.split(";")[1].split("=")[1]);
            c[`${x}Page`] = y;
          }),
          (c.total = parseInt(p))),
        { data: Object.assign(Object.assign({}, f), c), error: null }
      );
    } catch (c) {
      if (ft(c)) return { data: { users: [] }, error: c };
      throw c;
    }
  }
  async getUserById(e) {
    _u(e);
    try {
      return await bt(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: za,
      });
    } catch (t) {
      if (ft(t)) return { data: { user: null }, error: t };
      throw t;
    }
  }
  async updateUserById(e, t) {
    _u(e);
    try {
      return await bt(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
        body: t,
        headers: this.headers,
        xform: za,
      });
    } catch (r) {
      if (ft(r)) return { data: { user: null }, error: r };
      throw r;
    }
  }
  async deleteUser(e, t = !1) {
    _u(e);
    try {
      return await bt(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: { should_soft_delete: t },
        xform: za,
      });
    } catch (r) {
      if (ft(r)) return { data: { user: null }, error: r };
      throw r;
    }
  }
  async _listFactors(e) {
    _u(e.userId);
    try {
      const { data: t, error: r } = await bt(
        this.fetch,
        "GET",
        `${this.url}/admin/users/${e.userId}/factors`,
        {
          headers: this.headers,
          xform: (i) => ({ data: { factors: i }, error: null }),
        }
      );
      return { data: t, error: r };
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _deleteFactor(e) {
    _u(e.userId), _u(e.id);
    try {
      return {
        data: await bt(
          this.fetch,
          "DELETE",
          `${this.url}/admin/users/${e.userId}/factors/${e.id}`,
          { headers: this.headers }
        ),
        error: null,
      };
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _listOAuthClients(e) {
    var t, r, i, s, o, a, l;
    try {
      const c = { nextPage: null, lastPage: 0, total: 0 },
        u = await bt(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (r =
                (t = e == null ? void 0 : e.page) === null || t === void 0
                  ? void 0
                  : t.toString()) !== null && r !== void 0
                ? r
                : "",
            per_page:
              (s =
                (i = e == null ? void 0 : e.perPage) === null || i === void 0
                  ? void 0
                  : i.toString()) !== null && s !== void 0
                ? s
                : "",
          },
          xform: d2,
        });
      if (u.error) throw u.error;
      const f = await u.json(),
        p =
          (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0,
        m =
          (l =
            (a = u.headers.get("link")) === null || a === void 0
              ? void 0
              : a.split(",")) !== null && l !== void 0
            ? l
            : [];
      return (
        m.length > 0 &&
          (m.forEach((v) => {
            const y = parseInt(v.split(";")[0].split("=")[1].substring(0, 1)),
              x = JSON.parse(v.split(";")[1].split("=")[1]);
            c[`${x}Page`] = y;
          }),
          (c.total = parseInt(p))),
        { data: Object.assign(Object.assign({}, f), c), error: null }
      );
    } catch (c) {
      if (ft(c)) return { data: { clients: [] }, error: c };
      throw c;
    }
  }
  async _createOAuthClient(e) {
    try {
      return await bt(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
        body: e,
        headers: this.headers,
        xform: (t) => ({ data: t, error: null }),
      });
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _getOAuthClient(e) {
    try {
      return await bt(
        this.fetch,
        "GET",
        `${this.url}/admin/oauth/clients/${e}`,
        { headers: this.headers, xform: (t) => ({ data: t, error: null }) }
      );
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _updateOAuthClient(e, t) {
    try {
      return await bt(
        this.fetch,
        "PUT",
        `${this.url}/admin/oauth/clients/${e}`,
        {
          body: t,
          headers: this.headers,
          xform: (r) => ({ data: r, error: null }),
        }
      );
    } catch (r) {
      if (ft(r)) return { data: null, error: r };
      throw r;
    }
  }
  async _deleteOAuthClient(e) {
    try {
      return (
        await bt(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
          headers: this.headers,
          noResolveJson: !0,
        }),
        { data: null, error: null }
      );
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _regenerateOAuthClientSecret(e) {
    try {
      return await bt(
        this.fetch,
        "POST",
        `${this.url}/admin/oauth/clients/${e}/regenerate_secret`,
        { headers: this.headers, xform: (t) => ({ data: t, error: null }) }
      );
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
}
function h2(n = {}) {
  return {
    getItem: (e) => n[e] || null,
    setItem: (e, t) => {
      n[e] = t;
    },
    removeItem: (e) => {
      delete n[e];
    },
  };
}
const wu = {
  debug: !!(
    globalThis &&
    XF() &&
    globalThis.localStorage &&
    globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true"
  ),
};
class KF extends Error {
  constructor(e) {
    super(e), (this.isAcquireTimeout = !0);
  }
}
class dK extends KF {}
async function hK(n, e, t) {
  wu.debug &&
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", n, e);
  const r = new globalThis.AbortController();
  return (
    e > 0 &&
      setTimeout(() => {
        r.abort(),
          wu.debug &&
            console.log(
              "@supabase/gotrue-js: navigatorLock acquire timed out",
              n
            );
      }, e),
    await Promise.resolve().then(() =>
      globalThis.navigator.locks.request(
        n,
        e === 0
          ? { mode: "exclusive", ifAvailable: !0 }
          : { mode: "exclusive", signal: r.signal },
        async (i) => {
          if (i) {
            wu.debug &&
              console.log(
                "@supabase/gotrue-js: navigatorLock: acquired",
                n,
                i.name
              );
            try {
              return await t();
            } finally {
              wu.debug &&
                console.log(
                  "@supabase/gotrue-js: navigatorLock: released",
                  n,
                  i.name
                );
            }
          } else {
            if (e === 0)
              throw (
                (wu.debug &&
                  console.log(
                    "@supabase/gotrue-js: navigatorLock: not immediately available",
                    n
                  ),
                new dK(
                  `Acquiring an exclusive Navigator LockManager lock "${n}" immediately failed`
                ))
              );
            if (wu.debug)
              try {
                const s = await globalThis.navigator.locks.query();
                console.log(
                  "@supabase/gotrue-js: Navigator LockManager state",
                  JSON.stringify(s, null, "  ")
                );
              } catch (s) {
                console.warn(
                  "@supabase/gotrue-js: Error when querying Navigator LockManager state",
                  s
                );
              }
            return (
              console.warn(
                "@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"
              ),
              await t()
            );
          }
        }
      )
    )
  );
}
function fK() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function () {
          return this;
        },
        configurable: !0,
      }),
        (__magic__.globalThis = __magic__),
        delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
function YF(n) {
  if (!/^0x[a-fA-F0-9]{40}$/.test(n))
    throw new Error(`@supabase/auth-js: Address "${n}" is invalid.`);
  return n.toLowerCase();
}
function pK(n) {
  return parseInt(n, 16);
}
function mK(n) {
  const e = new TextEncoder().encode(n);
  return "0x" + Array.from(e, (r) => r.toString(16).padStart(2, "0")).join("");
}
function gK(n) {
  var e;
  const {
    chainId: t,
    domain: r,
    expirationTime: i,
    issuedAt: s = new Date(),
    nonce: o,
    notBefore: a,
    requestId: l,
    resources: c,
    scheme: u,
    uri: f,
    version: p,
  } = n;
  {
    if (!Number.isInteger(t))
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${t}`
      );
    if (!r)
      throw new Error(
        '@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.'
      );
    if (o && o.length < 8)
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`
      );
    if (!f)
      throw new Error(
        '@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.'
      );
    if (p !== "1")
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${p}`
      );
    if (
      !((e = n.statement) === null || e === void 0) &&
      e.includes(`
`)
    )
      throw new Error(
        `@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${n.statement}`
      );
  }
  const m = YF(n.address),
    v = u ? `${u}://${r}` : r,
    y = n.statement
      ? `${n.statement}
`
      : "",
    x = `${v} wants you to sign in with your Ethereum account:
${m}

${y}`;
  let g = `URI: ${f}
Version: ${p}
Chain ID: ${t}${
    o
      ? `
Nonce: ${o}`
      : ""
  }
Issued At: ${s.toISOString()}`;
  if (
    (i &&
      (g += `
Expiration Time: ${i.toISOString()}`),
    a &&
      (g += `
Not Before: ${a.toISOString()}`),
    l &&
      (g += `
Request ID: ${l}`),
    c)
  ) {
    let _ = `
Resources:`;
    for (const S of c) {
      if (!S || typeof S != "string")
        throw new Error(
          `@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${S}`
        );
      _ += `
- ${S}`;
    }
    g += _;
  }
  return `${x}
${g}`;
}
class Hn extends Error {
  constructor({ message: e, code: t, cause: r, name: i }) {
    var s;
    super(e, { cause: r }),
      (this.__isWebAuthnError = !0),
      (this.name =
        (s = i ?? (r instanceof Error ? r.name : void 0)) !== null &&
        s !== void 0
          ? s
          : "Unknown Error"),
      (this.code = t);
  }
}
class p0 extends Hn {
  constructor(e, t) {
    super({
      code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
      cause: t,
      message: e,
    }),
      (this.name = "WebAuthnUnknownError"),
      (this.originalError = t);
  }
}
function vK({ error: n, options: e }) {
  var t, r, i;
  const { publicKey: s } = e;
  if (!s) throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new Hn({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: n,
      });
  } else if (n.name === "ConstraintError") {
    if (
      ((t = s.authenticatorSelection) === null || t === void 0
        ? void 0
        : t.requireResidentKey) === !0
    )
      return new Hn({
        message:
          "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: n,
      });
    if (
      e.mediation === "conditional" &&
      ((r = s.authenticatorSelection) === null || r === void 0
        ? void 0
        : r.userVerification) === "required"
    )
      return new Hn({
        message:
          "User verification was required during automatic registration but it could not be performed",
        code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
        cause: n,
      });
    if (
      ((i = s.authenticatorSelection) === null || i === void 0
        ? void 0
        : i.userVerification) === "required"
    )
      return new Hn({
        message:
          "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: n,
      });
  } else {
    if (n.name === "InvalidStateError")
      return new Hn({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: n,
      });
    if (n.name === "NotAllowedError")
      return new Hn({
        message: n.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: n,
      });
    if (n.name === "NotSupportedError")
      return s.pubKeyCredParams.filter((a) => a.type === "public-key")
        .length === 0
        ? new Hn({
            message: 'No entry in pubKeyCredParams was of type "public-key"',
            code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
            cause: n,
          })
        : new Hn({
            message:
              "No available authenticator supported any of the specified pubKeyCredParams algorithms",
            code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
            cause: n,
          });
    if (n.name === "SecurityError") {
      const o = window.location.hostname;
      if (JF(o)) {
        if (s.rp.id !== o)
          return new Hn({
            message: `The RP ID "${s.rp.id}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: n,
          });
      } else
        return new Hn({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: n,
        });
    } else if (n.name === "TypeError") {
      if (s.user.id.byteLength < 1 || s.user.id.byteLength > 64)
        return new Hn({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: n,
        });
    } else if (n.name === "UnknownError")
      return new Hn({
        message:
          "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: n,
      });
  }
  return new Hn({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: n,
  });
}
function yK({ error: n, options: e }) {
  const { publicKey: t } = e;
  if (!t) throw Error("options was missing required publicKey property");
  if (n.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new Hn({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: n,
      });
  } else {
    if (n.name === "NotAllowedError")
      return new Hn({
        message: n.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: n,
      });
    if (n.name === "SecurityError") {
      const r = window.location.hostname;
      if (JF(r)) {
        if (t.rpId !== r)
          return new Hn({
            message: `The RP ID "${t.rpId}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: n,
          });
      } else
        return new Hn({
          message: `${window.location.hostname} is an invalid domain`,
          code: "ERROR_INVALID_DOMAIN",
          cause: n,
        });
    } else if (n.name === "UnknownError")
      return new Hn({
        message:
          "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: n,
      });
  }
  return new Hn({
    message: "a Non-Webauthn related error has occurred",
    code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
    cause: n,
  });
}
class xK {
  createNewAbortSignal() {
    if (this.controller) {
      const t = new Error("Cancelling existing WebAuthn API call for new one");
      (t.name = "AbortError"), this.controller.abort(t);
    }
    const e = new AbortController();
    return (this.controller = e), e.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const e = new Error("Manually cancelling existing WebAuthn API call");
      (e.name = "AbortError"),
        this.controller.abort(e),
        (this.controller = void 0);
    }
  }
}
const _K = new xK();
function wK(n) {
  if (!n) throw new Error("Credential creation options are required");
  if (
    typeof PublicKeyCredential < "u" &&
    "parseCreationOptionsFromJSON" in PublicKeyCredential &&
    typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function"
  )
    return PublicKeyCredential.parseCreationOptionsFromJSON(n);
  const { challenge: e, user: t, excludeCredentials: r } = n,
    i = yl(n, ["challenge", "user", "excludeCredentials"]),
    s = Nd(e).buffer,
    o = Object.assign(Object.assign({}, t), { id: Nd(t.id).buffer }),
    a = Object.assign(Object.assign({}, i), { challenge: s, user: o });
  if (r && r.length > 0) {
    a.excludeCredentials = new Array(r.length);
    for (let l = 0; l < r.length; l++) {
      const c = r[l];
      a.excludeCredentials[l] = Object.assign(Object.assign({}, c), {
        id: Nd(c.id).buffer,
        type: c.type || "public-key",
        transports: c.transports,
      });
    }
  }
  return a;
}
function SK(n) {
  if (!n) throw new Error("Credential request options are required");
  if (
    typeof PublicKeyCredential < "u" &&
    "parseRequestOptionsFromJSON" in PublicKeyCredential &&
    typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function"
  )
    return PublicKeyCredential.parseRequestOptionsFromJSON(n);
  const { challenge: e, allowCredentials: t } = n,
    r = yl(n, ["challenge", "allowCredentials"]),
    i = Nd(e).buffer,
    s = Object.assign(Object.assign({}, r), { challenge: i });
  if (t && t.length > 0) {
    s.allowCredentials = new Array(t.length);
    for (let o = 0; o < t.length; o++) {
      const a = t[o];
      s.allowCredentials[o] = Object.assign(Object.assign({}, a), {
        id: Nd(a.id).buffer,
        type: a.type || "public-key",
        transports: a.transports,
      });
    }
  }
  return s;
}
function bK(n) {
  var e;
  if ("toJSON" in n && typeof n.toJSON == "function") return n.toJSON();
  const t = n;
  return {
    id: n.id,
    rawId: n.id,
    response: {
      attestationObject: fc(new Uint8Array(n.response.attestationObject)),
      clientDataJSON: fc(new Uint8Array(n.response.clientDataJSON)),
    },
    type: "public-key",
    clientExtensionResults: n.getClientExtensionResults(),
    authenticatorAttachment:
      (e = t.authenticatorAttachment) !== null && e !== void 0 ? e : void 0,
  };
}
function EK(n) {
  var e;
  if ("toJSON" in n && typeof n.toJSON == "function") return n.toJSON();
  const t = n,
    r = n.getClientExtensionResults(),
    i = n.response;
  return {
    id: n.id,
    rawId: n.id,
    response: {
      authenticatorData: fc(new Uint8Array(i.authenticatorData)),
      clientDataJSON: fc(new Uint8Array(i.clientDataJSON)),
      signature: fc(new Uint8Array(i.signature)),
      userHandle: i.userHandle ? fc(new Uint8Array(i.userHandle)) : void 0,
    },
    type: "public-key",
    clientExtensionResults: r,
    authenticatorAttachment:
      (e = t.authenticatorAttachment) !== null && e !== void 0 ? e : void 0,
  };
}
function JF(n) {
  return n === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(n);
}
function f2() {
  var n, e;
  return !!(
    jr() &&
    "PublicKeyCredential" in window &&
    window.PublicKeyCredential &&
    "credentials" in navigator &&
    typeof ((n = navigator == null ? void 0 : navigator.credentials) === null ||
    n === void 0
      ? void 0
      : n.create) == "function" &&
    typeof ((e = navigator == null ? void 0 : navigator.credentials) === null ||
    e === void 0
      ? void 0
      : e.get) == "function"
  );
}
async function TK(n) {
  try {
    const e = await navigator.credentials.create(n);
    return e
      ? e instanceof PublicKeyCredential
        ? { data: e, error: null }
        : {
            data: null,
            error: new p0("Browser returned unexpected credential type", e),
          }
      : { data: null, error: new p0("Empty credential response", e) };
  } catch (e) {
    return { data: null, error: vK({ error: e, options: n }) };
  }
}
async function MK(n) {
  try {
    const e = await navigator.credentials.get(n);
    return e
      ? e instanceof PublicKeyCredential
        ? { data: e, error: null }
        : {
            data: null,
            error: new p0("Browser returned unexpected credential type", e),
          }
      : { data: null, error: new p0("Empty credential response", e) };
  } catch (e) {
    return { data: null, error: yK({ error: e, options: n }) };
  }
}
const CK = {
    hints: ["security-key"],
    authenticatorSelection: {
      authenticatorAttachment: "cross-platform",
      requireResidentKey: !1,
      userVerification: "preferred",
      residentKey: "discouraged",
    },
    attestation: "none",
  },
  AK = { userVerification: "preferred", hints: ["security-key"] };
function m0(...n) {
  const e = (i) => i !== null && typeof i == "object" && !Array.isArray(i),
    t = (i) => i instanceof ArrayBuffer || ArrayBuffer.isView(i),
    r = {};
  for (const i of n)
    if (i)
      for (const s in i) {
        const o = i[s];
        if (o !== void 0)
          if (Array.isArray(o)) r[s] = o;
          else if (t(o)) r[s] = o;
          else if (e(o)) {
            const a = r[s];
            e(a) ? (r[s] = m0(a, o)) : (r[s] = m0(o));
          } else r[s] = o;
      }
  return r;
}
function RK(n, e) {
  return m0(CK, n, e || {});
}
function PK(n, e) {
  return m0(AK, n, e || {});
}
class IK {
  constructor(e) {
    (this.client = e),
      (this.enroll = this._enroll.bind(this)),
      (this.challenge = this._challenge.bind(this)),
      (this.verify = this._verify.bind(this)),
      (this.authenticate = this._authenticate.bind(this)),
      (this.register = this._register.bind(this));
  }
  async _enroll(e) {
    return this.client.mfa.enroll(
      Object.assign(Object.assign({}, e), { factorType: "webauthn" })
    );
  }
  async _challenge(
    { factorId: e, webauthn: t, friendlyName: r, signal: i },
    s
  ) {
    try {
      const { data: o, error: a } = await this.client.mfa.challenge({
        factorId: e,
        webauthn: t,
      });
      if (!o) return { data: null, error: a };
      const l = i ?? _K.createNewAbortSignal();
      if (o.webauthn.type === "create") {
        const { user: c } = o.webauthn.credential_options.publicKey;
        c.name || (c.name = `${c.id}:${r}`),
          c.displayName || (c.displayName = c.name);
      }
      switch (o.webauthn.type) {
        case "create": {
          const c = RK(
              o.webauthn.credential_options.publicKey,
              s == null ? void 0 : s.create
            ),
            { data: u, error: f } = await TK({ publicKey: c, signal: l });
          return u
            ? {
                data: {
                  factorId: e,
                  challengeId: o.id,
                  webauthn: { type: o.webauthn.type, credential_response: u },
                },
                error: null,
              }
            : { data: null, error: f };
        }
        case "request": {
          const c = PK(
              o.webauthn.credential_options.publicKey,
              s == null ? void 0 : s.request
            ),
            { data: u, error: f } = await MK(
              Object.assign(Object.assign({}, o.webauthn.credential_options), {
                publicKey: c,
                signal: l,
              })
            );
          return u
            ? {
                data: {
                  factorId: e,
                  challengeId: o.id,
                  webauthn: { type: o.webauthn.type, credential_response: u },
                },
                error: null,
              }
            : { data: null, error: f };
        }
      }
    } catch (o) {
      return ft(o)
        ? { data: null, error: o }
        : { data: null, error: new lc("Unexpected error in challenge", o) };
    }
  }
  async _verify({ challengeId: e, factorId: t, webauthn: r }) {
    return this.client.mfa.verify({ factorId: t, challengeId: e, webauthn: r });
  }
  async _authenticate(
    {
      factorId: e,
      webauthn: {
        rpId: t = typeof window < "u" ? window.location.hostname : void 0,
        rpOrigins: r = typeof window < "u" ? [window.location.origin] : void 0,
        signal: i,
      },
    },
    s
  ) {
    if (!t)
      return {
        data: null,
        error: new kp("rpId is required for WebAuthn authentication"),
      };
    try {
      if (!f2())
        return {
          data: null,
          error: new lc("Browser does not support WebAuthn", null),
        };
      const { data: o, error: a } = await this.challenge(
        { factorId: e, webauthn: { rpId: t, rpOrigins: r }, signal: i },
        { request: s }
      );
      if (!o) return { data: null, error: a };
      const { webauthn: l } = o;
      return this._verify({
        factorId: e,
        challengeId: o.challengeId,
        webauthn: {
          type: l.type,
          rpId: t,
          rpOrigins: r,
          credential_response: l.credential_response,
        },
      });
    } catch (o) {
      return ft(o)
        ? { data: null, error: o }
        : { data: null, error: new lc("Unexpected error in authenticate", o) };
    }
  }
  async _register(
    {
      friendlyName: e,
      rpId: t = typeof window < "u" ? window.location.hostname : void 0,
      rpOrigins: r = typeof window < "u" ? [window.location.origin] : void 0,
      signal: i,
    },
    s
  ) {
    if (!t)
      return {
        data: null,
        error: new kp("rpId is required for WebAuthn registration"),
      };
    try {
      if (!f2())
        return {
          data: null,
          error: new lc("Browser does not support WebAuthn", null),
        };
      const { data: o, error: a } = await this._enroll({ friendlyName: e });
      if (!o)
        return (
          await this.client.mfa
            .listFactors()
            .then((u) => {
              var f;
              return (f = u.data) === null || f === void 0
                ? void 0
                : f.all.find(
                    (p) =>
                      p.factor_type === "webauthn" &&
                      p.friendly_name === e &&
                      p.status !== "unverified"
                  );
            })
            .then((u) =>
              u
                ? this.client.mfa.unenroll({
                    factorId: u == null ? void 0 : u.id,
                  })
                : void 0
            ),
          { data: null, error: a }
        );
      const { data: l, error: c } = await this._challenge(
        {
          factorId: o.id,
          friendlyName: o.friendly_name,
          webauthn: { rpId: t, rpOrigins: r },
          signal: i,
        },
        { create: s }
      );
      return l
        ? this._verify({
            factorId: o.id,
            challengeId: l.challengeId,
            webauthn: {
              rpId: t,
              rpOrigins: r,
              type: l.webauthn.type,
              credential_response: l.webauthn.credential_response,
            },
          })
        : { data: null, error: c };
    } catch (o) {
      return ft(o)
        ? { data: null, error: o }
        : { data: null, error: new lc("Unexpected error in register", o) };
    }
  }
}
fK();
const NK = {
  url: Aq,
  storageKey: Rq,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: Pq,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
};
async function p2(n, e, t) {
  return await t();
}
const Su = {};
class Up {
  get jwks() {
    var e, t;
    return (t =
      (e = Su[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !==
      null && t !== void 0
      ? t
      : { keys: [] };
  }
  set jwks(e) {
    Su[this.storageKey] = Object.assign(
      Object.assign({}, Su[this.storageKey]),
      { jwks: e }
    );
  }
  get jwks_cached_at() {
    var e, t;
    return (t =
      (e = Su[this.storageKey]) === null || e === void 0
        ? void 0
        : e.cachedAt) !== null && t !== void 0
      ? t
      : Number.MIN_SAFE_INTEGER;
  }
  set jwks_cached_at(e) {
    Su[this.storageKey] = Object.assign(
      Object.assign({}, Su[this.storageKey]),
      { cachedAt: e }
    );
  }
  constructor(e) {
    var t, r;
    (this.userStorage = null),
      (this.memoryStorage = null),
      (this.stateChangeEmitters = new Map()),
      (this.autoRefreshTicker = null),
      (this.visibilityChangedCallback = null),
      (this.refreshingDeferred = null),
      (this.initializePromise = null),
      (this.detectSessionInUrl = !0),
      (this.hasCustomAuthorizationHeader = !1),
      (this.suppressGetSessionWarning = !1),
      (this.lockAcquired = !1),
      (this.pendingInLock = []),
      (this.broadcastChannel = null),
      (this.logger = console.log),
      (this.instanceID = Up.nextInstanceID),
      (Up.nextInstanceID += 1),
      this.instanceID > 0 &&
        jr() &&
        console.warn(
          "Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."
        );
    const i = Object.assign(Object.assign({}, NK), e);
    if (
      ((this.logDebugMessages = !!i.debug),
      typeof i.debug == "function" && (this.logger = i.debug),
      (this.persistSession = i.persistSession),
      (this.storageKey = i.storageKey),
      (this.autoRefreshToken = i.autoRefreshToken),
      (this.admin = new uK({ url: i.url, headers: i.headers, fetch: i.fetch })),
      (this.url = i.url),
      (this.headers = i.headers),
      (this.fetch = qF(i.fetch)),
      (this.lock = i.lock || p2),
      (this.detectSessionInUrl = i.detectSessionInUrl),
      (this.flowType = i.flowType),
      (this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader),
      i.lock
        ? (this.lock = i.lock)
        : jr() &&
          !(
            (t = globalThis == null ? void 0 : globalThis.navigator) === null ||
            t === void 0
          ) &&
          t.locks
        ? (this.lock = hK)
        : (this.lock = p2),
      this.jwks ||
        ((this.jwks = { keys: [] }),
        (this.jwks_cached_at = Number.MIN_SAFE_INTEGER)),
      (this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel:
          this._getAuthenticatorAssuranceLevel.bind(this),
        webauthn: new IK(this),
      }),
      (this.oauth = {
        getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
        approveAuthorization: this._approveAuthorization.bind(this),
        denyAuthorization: this._denyAuthorization.bind(this),
      }),
      this.persistSession
        ? (i.storage
            ? (this.storage = i.storage)
            : XF()
            ? (this.storage = globalThis.localStorage)
            : ((this.memoryStorage = {}),
              (this.storage = h2(this.memoryStorage))),
          i.userStorage && (this.userStorage = i.userStorage))
        : ((this.memoryStorage = {}), (this.storage = h2(this.memoryStorage))),
      jr() &&
        globalThis.BroadcastChannel &&
        this.persistSession &&
        this.storageKey)
    ) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(
          this.storageKey
        );
      } catch (s) {
        console.error(
          "Failed to create a new BroadcastChannel, multi-tab state changes will not be available",
          s
        );
      }
      (r = this.broadcastChannel) === null ||
        r === void 0 ||
        r.addEventListener("message", async (s) => {
          this._debug(
            "received broadcast notification from other tab or client",
            s
          ),
            await this._notifyAllSubscribers(s.data.event, s.data.session, !1);
        });
    }
    this.initialize();
  }
  _debug(...e) {
    return (
      this.logDebugMessages &&
        this.logger(
          `GoTrueClient@${this.instanceID} (${WF}) ${new Date().toISOString()}`,
          ...e
        ),
      this
    );
  }
  async initialize() {
    return this.initializePromise
      ? await this.initializePromise
      : ((this.initializePromise = (async () =>
          await this._acquireLock(-1, async () => await this._initialize()))()),
        await this.initializePromise);
  }
  async _initialize() {
    var e;
    try {
      const t = Wq(window.location.href);
      let r = "none";
      if (
        (this._isImplicitGrantCallback(t)
          ? (r = "implicit")
          : (await this._isPKCECallback(t)) && (r = "pkce"),
        jr() && this.detectSessionInUrl && r !== "none")
      ) {
        const { data: i, error: s } = await this._getSessionFromURL(t, r);
        if (s) {
          if (
            (this._debug(
              "#_initialize()",
              "error detecting session from URL",
              s
            ),
            kq(s))
          ) {
            const l =
              (e = s.details) === null || e === void 0 ? void 0 : e.code;
            if (
              l === "identity_already_exists" ||
              l === "identity_not_found" ||
              l === "single_identity_not_deletable"
            )
              return { error: s };
          }
          return await this._removeSession(), { error: s };
        }
        const { session: o, redirectType: a } = i;
        return (
          this._debug(
            "#_initialize()",
            "detected session in URL",
            o,
            "redirect type",
            a
          ),
          await this._saveSession(o),
          setTimeout(async () => {
            a === "recovery"
              ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o)
              : await this._notifyAllSubscribers("SIGNED_IN", o);
          }, 0),
          { error: null }
        );
      }
      return await this._recoverAndRefresh(), { error: null };
    } catch (t) {
      return ft(t)
        ? { error: t }
        : { error: new lc("Unexpected error during initialization", t) };
    } finally {
      await this._handleVisibilityChange(),
        this._debug("#_initialize()", "end");
    }
  }
  async signInAnonymously(e) {
    var t, r, i;
    try {
      const s = await bt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data:
              (r =
                (t = e == null ? void 0 : e.options) === null || t === void 0
                  ? void 0
                  : t.data) !== null && r !== void 0
                ? r
                : {},
            gotrue_meta_security: {
              captcha_token:
                (i = e == null ? void 0 : e.options) === null || i === void 0
                  ? void 0
                  : i.captchaToken,
            },
          },
          xform: xs,
        }),
        { data: o, error: a } = s;
      if (a || !o) return { data: { user: null, session: null }, error: a };
      const l = o.session,
        c = o.user;
      return (
        o.session &&
          (await this._saveSession(o.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (s) {
      if (ft(s)) return { data: { user: null, session: null }, error: s };
      throw s;
    }
  }
  async signUp(e) {
    var t, r, i;
    try {
      let s;
      if ("email" in e) {
        const { email: u, password: f, options: p } = e;
        let m = null,
          v = null;
        this.flowType === "pkce" &&
          ([m, v] = await xu(this.storage, this.storageKey)),
          (s = await bt(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: p == null ? void 0 : p.emailRedirectTo,
            body: {
              email: u,
              password: f,
              data:
                (t = p == null ? void 0 : p.data) !== null && t !== void 0
                  ? t
                  : {},
              gotrue_meta_security: {
                captcha_token: p == null ? void 0 : p.captchaToken,
              },
              code_challenge: m,
              code_challenge_method: v,
            },
            xform: xs,
          }));
      } else if ("phone" in e) {
        const { phone: u, password: f, options: p } = e;
        s = await bt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: u,
            password: f,
            data:
              (r = p == null ? void 0 : p.data) !== null && r !== void 0
                ? r
                : {},
            channel:
              (i = p == null ? void 0 : p.channel) !== null && i !== void 0
                ? i
                : "sms",
            gotrue_meta_security: {
              captcha_token: p == null ? void 0 : p.captchaToken,
            },
          },
          xform: xs,
        });
      } else
        throw new ov(
          "You must provide either an email or phone number and a password"
        );
      const { data: o, error: a } = s;
      if (a || !o) return { data: { user: null, session: null }, error: a };
      const l = o.session,
        c = o.user;
      return (
        o.session &&
          (await this._saveSession(o.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        { data: { user: c, session: l }, error: null }
      );
    } catch (s) {
      if (ft(s)) return { data: { user: null, session: null }, error: s };
      throw s;
    }
  }
  async signInWithPassword(e) {
    try {
      let t;
      if ("email" in e) {
        const { email: s, password: o, options: a } = e;
        t = await bt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              email: s,
              password: o,
              gotrue_meta_security: {
                captcha_token: a == null ? void 0 : a.captchaToken,
              },
            },
            xform: u2,
          }
        );
      } else if ("phone" in e) {
        const { phone: s, password: o, options: a } = e;
        t = await bt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              phone: s,
              password: o,
              gotrue_meta_security: {
                captcha_token: a == null ? void 0 : a.captchaToken,
              },
            },
            xform: u2,
          }
        );
      } else
        throw new ov(
          "You must provide either an email or phone number and a password"
        );
      const { data: r, error: i } = t;
      return i
        ? { data: { user: null, session: null }, error: i }
        : !r || !r.session || !r.user
        ? { data: { user: null, session: null }, error: new yu() }
        : (r.session &&
            (await this._saveSession(r.session),
            await this._notifyAllSubscribers("SIGNED_IN", r.session)),
          {
            data: Object.assign(
              { user: r.user, session: r.session },
              r.weak_password ? { weakPassword: r.weak_password } : null
            ),
            error: i,
          });
    } catch (t) {
      if (ft(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async signInWithOAuth(e) {
    var t, r, i, s;
    return await this._handleProviderSignIn(e.provider, {
      redirectTo:
        (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo,
      scopes: (r = e.options) === null || r === void 0 ? void 0 : r.scopes,
      queryParams:
        (i = e.options) === null || i === void 0 ? void 0 : i.queryParams,
      skipBrowserRedirect:
        (s = e.options) === null || s === void 0
          ? void 0
          : s.skipBrowserRedirect,
    });
  }
  async exchangeCodeForSession(e) {
    return (
      await this.initializePromise,
      this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    );
  }
  async signInWithWeb3(e) {
    const { chain: t } = e;
    switch (t) {
      case "ethereum":
        return await this.signInWithEthereum(e);
      case "solana":
        return await this.signInWithSolana(e);
      default:
        throw new Error(`@supabase/auth-js: Unsupported chain "${t}"`);
    }
  }
  async signInWithEthereum(e) {
    var t, r, i, s, o, a, l, c, u, f, p;
    let m, v;
    if ("message" in e) (m = e.message), (v = e.signature);
    else {
      const { chain: y, wallet: x, statement: g, options: _ } = e;
      let S;
      if (jr())
        if (typeof x == "object") S = x;
        else {
          const I = window;
          if (
            "ethereum" in I &&
            typeof I.ethereum == "object" &&
            "request" in I.ethereum &&
            typeof I.ethereum.request == "function"
          )
            S = I.ethereum;
          else
            throw new Error(
              "@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead."
            );
        }
      else {
        if (typeof x != "object" || !(_ != null && _.url))
          throw new Error(
            "@supabase/auth-js: Both wallet and url must be specified in non-browser environments."
          );
        S = x;
      }
      const b = new URL(
          (t = _ == null ? void 0 : _.url) !== null && t !== void 0
            ? t
            : window.location.href
        ),
        C = await S.request({ method: "eth_requestAccounts" })
          .then((I) => I)
          .catch(() => {
            throw new Error(
              "@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid"
            );
          });
      if (!C || C.length === 0)
        throw new Error(
          "@supabase/auth-js: No accounts available. Please ensure the wallet is connected."
        );
      const A = YF(C[0]);
      let R =
        (r = _ == null ? void 0 : _.signInWithEthereum) === null || r === void 0
          ? void 0
          : r.chainId;
      if (!R) {
        const I = await S.request({ method: "eth_chainId" });
        R = pK(I);
      }
      const O = {
        domain: b.host,
        address: A,
        statement: g,
        uri: b.href,
        version: "1",
        chainId: R,
        nonce:
          (i = _ == null ? void 0 : _.signInWithEthereum) === null ||
          i === void 0
            ? void 0
            : i.nonce,
        issuedAt:
          (o =
            (s = _ == null ? void 0 : _.signInWithEthereum) === null ||
            s === void 0
              ? void 0
              : s.issuedAt) !== null && o !== void 0
            ? o
            : new Date(),
        expirationTime:
          (a = _ == null ? void 0 : _.signInWithEthereum) === null ||
          a === void 0
            ? void 0
            : a.expirationTime,
        notBefore:
          (l = _ == null ? void 0 : _.signInWithEthereum) === null ||
          l === void 0
            ? void 0
            : l.notBefore,
        requestId:
          (c = _ == null ? void 0 : _.signInWithEthereum) === null ||
          c === void 0
            ? void 0
            : c.requestId,
        resources:
          (u = _ == null ? void 0 : _.signInWithEthereum) === null ||
          u === void 0
            ? void 0
            : u.resources,
      };
      (m = gK(O)),
        (v = await S.request({ method: "personal_sign", params: [mK(m), A] }));
    }
    try {
      const { data: y, error: x } = await bt(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=web3`,
        {
          headers: this.headers,
          body: Object.assign(
            { chain: "ethereum", message: m, signature: v },
            !((f = e.options) === null || f === void 0) && f.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token:
                      (p = e.options) === null || p === void 0
                        ? void 0
                        : p.captchaToken,
                  },
                }
              : null
          ),
          xform: xs,
        }
      );
      if (x) throw x;
      return !y || !y.session || !y.user
        ? { data: { user: null, session: null }, error: new yu() }
        : (y.session &&
            (await this._saveSession(y.session),
            await this._notifyAllSubscribers("SIGNED_IN", y.session)),
          { data: Object.assign({}, y), error: x });
    } catch (y) {
      if (ft(y)) return { data: { user: null, session: null }, error: y };
      throw y;
    }
  }
  async signInWithSolana(e) {
    var t, r, i, s, o, a, l, c, u, f, p, m;
    let v, y;
    if ("message" in e) (v = e.message), (y = e.signature);
    else {
      const { chain: x, wallet: g, statement: _, options: S } = e;
      let b;
      if (jr())
        if (typeof g == "object") b = g;
        else {
          const A = window;
          if (
            "solana" in A &&
            typeof A.solana == "object" &&
            (("signIn" in A.solana && typeof A.solana.signIn == "function") ||
              ("signMessage" in A.solana &&
                typeof A.solana.signMessage == "function"))
          )
            b = A.solana;
          else
            throw new Error(
              "@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead."
            );
        }
      else {
        if (typeof g != "object" || !(S != null && S.url))
          throw new Error(
            "@supabase/auth-js: Both wallet and url must be specified in non-browser environments."
          );
        b = g;
      }
      const C = new URL(
        (t = S == null ? void 0 : S.url) !== null && t !== void 0
          ? t
          : window.location.href
      );
      if ("signIn" in b && b.signIn) {
        const A = await b.signIn(
          Object.assign(
            Object.assign(
              Object.assign(
                { issuedAt: new Date().toISOString() },
                S == null ? void 0 : S.signInWithSolana
              ),
              { version: "1", domain: C.host, uri: C.href }
            ),
            _ ? { statement: _ } : null
          )
        );
        let R;
        if (Array.isArray(A) && A[0] && typeof A[0] == "object") R = A[0];
        else if (
          A &&
          typeof A == "object" &&
          "signedMessage" in A &&
          "signature" in A
        )
          R = A;
        else
          throw new Error(
            "@supabase/auth-js: Wallet method signIn() returned unrecognized value"
          );
        if (
          "signedMessage" in R &&
          "signature" in R &&
          (typeof R.signedMessage == "string" ||
            R.signedMessage instanceof Uint8Array) &&
          R.signature instanceof Uint8Array
        )
          (v =
            typeof R.signedMessage == "string"
              ? R.signedMessage
              : new TextDecoder().decode(R.signedMessage)),
            (y = R.signature);
        else
          throw new Error(
            "@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields"
          );
      } else {
        if (
          !("signMessage" in b) ||
          typeof b.signMessage != "function" ||
          !("publicKey" in b) ||
          typeof b != "object" ||
          !b.publicKey ||
          !("toBase58" in b.publicKey) ||
          typeof b.publicKey.toBase58 != "function"
        )
          throw new Error(
            "@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API"
          );
        v = [
          `${C.host} wants you to sign in with your Solana account:`,
          b.publicKey.toBase58(),
          ...(_ ? ["", _, ""] : [""]),
          "Version: 1",
          `URI: ${C.href}`,
          `Issued At: ${
            (i =
              (r = S == null ? void 0 : S.signInWithSolana) === null ||
              r === void 0
                ? void 0
                : r.issuedAt) !== null && i !== void 0
              ? i
              : new Date().toISOString()
          }`,
          ...(!(
            (s = S == null ? void 0 : S.signInWithSolana) === null ||
            s === void 0
          ) && s.notBefore
            ? [`Not Before: ${S.signInWithSolana.notBefore}`]
            : []),
          ...(!(
            (o = S == null ? void 0 : S.signInWithSolana) === null ||
            o === void 0
          ) && o.expirationTime
            ? [`Expiration Time: ${S.signInWithSolana.expirationTime}`]
            : []),
          ...(!(
            (a = S == null ? void 0 : S.signInWithSolana) === null ||
            a === void 0
          ) && a.chainId
            ? [`Chain ID: ${S.signInWithSolana.chainId}`]
            : []),
          ...(!(
            (l = S == null ? void 0 : S.signInWithSolana) === null ||
            l === void 0
          ) && l.nonce
            ? [`Nonce: ${S.signInWithSolana.nonce}`]
            : []),
          ...(!(
            (c = S == null ? void 0 : S.signInWithSolana) === null ||
            c === void 0
          ) && c.requestId
            ? [`Request ID: ${S.signInWithSolana.requestId}`]
            : []),
          ...(!(
            (f =
              (u = S == null ? void 0 : S.signInWithSolana) === null ||
              u === void 0
                ? void 0
                : u.resources) === null || f === void 0
          ) && f.length
            ? [
                "Resources",
                ...S.signInWithSolana.resources.map((R) => `- ${R}`),
              ]
            : []),
        ].join(`
`);
        const A = await b.signMessage(new TextEncoder().encode(v), "utf8");
        if (!A || !(A instanceof Uint8Array))
          throw new Error(
            "@supabase/auth-js: Wallet signMessage() API returned an recognized value"
          );
        y = A;
      }
    }
    try {
      const { data: x, error: g } = await bt(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=web3`,
        {
          headers: this.headers,
          body: Object.assign(
            { chain: "solana", message: v, signature: fc(y) },
            !((p = e.options) === null || p === void 0) && p.captchaToken
              ? {
                  gotrue_meta_security: {
                    captcha_token:
                      (m = e.options) === null || m === void 0
                        ? void 0
                        : m.captchaToken,
                  },
                }
              : null
          ),
          xform: xs,
        }
      );
      if (g) throw g;
      return !x || !x.session || !x.user
        ? { data: { user: null, session: null }, error: new yu() }
        : (x.session &&
            (await this._saveSession(x.session),
            await this._notifyAllSubscribers("SIGNED_IN", x.session)),
          { data: Object.assign({}, x), error: g });
    } catch (x) {
      if (ft(x)) return { data: { user: null, session: null }, error: x };
      throw x;
    }
  }
  async _exchangeCodeForSession(e) {
    const t = await Ul(this.storage, `${this.storageKey}-code-verifier`),
      [r, i] = (t ?? "").split("/");
    try {
      const { data: s, error: o } = await bt(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=pkce`,
        {
          headers: this.headers,
          body: { auth_code: e, code_verifier: r },
          xform: xs,
        }
      );
      if ((await wa(this.storage, `${this.storageKey}-code-verifier`), o))
        throw o;
      return !s || !s.session || !s.user
        ? {
            data: { user: null, session: null, redirectType: null },
            error: new yu(),
          }
        : (s.session &&
            (await this._saveSession(s.session),
            await this._notifyAllSubscribers("SIGNED_IN", s.session)),
          {
            data: Object.assign(Object.assign({}, s), {
              redirectType: i ?? null,
            }),
            error: o,
          });
    } catch (s) {
      if (ft(s))
        return {
          data: { user: null, session: null, redirectType: null },
          error: s,
        };
      throw s;
    }
  }
  async signInWithIdToken(e) {
    try {
      const {
          options: t,
          provider: r,
          token: i,
          access_token: s,
          nonce: o,
        } = e,
        a = await bt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=id_token`,
          {
            headers: this.headers,
            body: {
              provider: r,
              id_token: i,
              access_token: s,
              nonce: o,
              gotrue_meta_security: {
                captcha_token: t == null ? void 0 : t.captchaToken,
              },
            },
            xform: xs,
          }
        ),
        { data: l, error: c } = a;
      return c
        ? { data: { user: null, session: null }, error: c }
        : !l || !l.session || !l.user
        ? { data: { user: null, session: null }, error: new yu() }
        : (l.session &&
            (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
          { data: l, error: c });
    } catch (t) {
      if (ft(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async signInWithOtp(e) {
    var t, r, i, s, o;
    try {
      if ("email" in e) {
        const { email: a, options: l } = e;
        let c = null,
          u = null;
        this.flowType === "pkce" &&
          ([c, u] = await xu(this.storage, this.storageKey));
        const { error: f } = await bt(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: a,
            data:
              (t = l == null ? void 0 : l.data) !== null && t !== void 0
                ? t
                : {},
            create_user:
              (r = l == null ? void 0 : l.shouldCreateUser) !== null &&
              r !== void 0
                ? r
                : !0,
            gotrue_meta_security: {
              captcha_token: l == null ? void 0 : l.captchaToken,
            },
            code_challenge: c,
            code_challenge_method: u,
          },
          redirectTo: l == null ? void 0 : l.emailRedirectTo,
        });
        return { data: { user: null, session: null }, error: f };
      }
      if ("phone" in e) {
        const { phone: a, options: l } = e,
          { data: c, error: u } = await bt(
            this.fetch,
            "POST",
            `${this.url}/otp`,
            {
              headers: this.headers,
              body: {
                phone: a,
                data:
                  (i = l == null ? void 0 : l.data) !== null && i !== void 0
                    ? i
                    : {},
                create_user:
                  (s = l == null ? void 0 : l.shouldCreateUser) !== null &&
                  s !== void 0
                    ? s
                    : !0,
                gotrue_meta_security: {
                  captcha_token: l == null ? void 0 : l.captchaToken,
                },
                channel:
                  (o = l == null ? void 0 : l.channel) !== null && o !== void 0
                    ? o
                    : "sms",
              },
            }
          );
        return {
          data: {
            user: null,
            session: null,
            messageId: c == null ? void 0 : c.message_id,
          },
          error: u,
        };
      }
      throw new ov("You must provide either an email or phone number.");
    } catch (a) {
      if (ft(a)) return { data: { user: null, session: null }, error: a };
      throw a;
    }
  }
  async verifyOtp(e) {
    var t, r;
    try {
      let i, s;
      "options" in e &&
        ((i = (t = e.options) === null || t === void 0 ? void 0 : t.redirectTo),
        (s =
          (r = e.options) === null || r === void 0 ? void 0 : r.captchaToken));
      const { data: o, error: a } = await bt(
        this.fetch,
        "POST",
        `${this.url}/verify`,
        {
          headers: this.headers,
          body: Object.assign(Object.assign({}, e), {
            gotrue_meta_security: { captcha_token: s },
          }),
          redirectTo: i,
          xform: xs,
        }
      );
      if (a) throw a;
      if (!o) throw new Error("An error occurred on token verification.");
      const l = o.session,
        c = o.user;
      return (
        l != null &&
          l.access_token &&
          (await this._saveSession(l),
          await this._notifyAllSubscribers(
            e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN",
            l
          )),
        { data: { user: c, session: l }, error: null }
      );
    } catch (i) {
      if (ft(i)) return { data: { user: null, session: null }, error: i };
      throw i;
    }
  }
  async signInWithSSO(e) {
    var t, r, i;
    try {
      let s = null,
        o = null;
      return (
        this.flowType === "pkce" &&
          ([s, o] = await xu(this.storage, this.storageKey)),
        await bt(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    {},
                    "providerId" in e ? { provider_id: e.providerId } : null
                  ),
                  "domain" in e ? { domain: e.domain } : null
                ),
                {
                  redirect_to:
                    (r =
                      (t = e.options) === null || t === void 0
                        ? void 0
                        : t.redirectTo) !== null && r !== void 0
                      ? r
                      : void 0,
                }
              ),
              !(
                (i = e == null ? void 0 : e.options) === null || i === void 0
              ) && i.captchaToken
                ? {
                    gotrue_meta_security: {
                      captcha_token: e.options.captchaToken,
                    },
                  }
                : null
            ),
            {
              skip_http_redirect: !0,
              code_challenge: s,
              code_challenge_method: o,
            }
          ),
          headers: this.headers,
          xform: aK,
        })
      );
    } catch (s) {
      if (ft(s)) return { data: null, error: s };
      throw s;
    }
  }
  async reauthenticate() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._reauthenticate())
    );
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (e) => {
        const {
          data: { session: t },
          error: r,
        } = e;
        if (r) throw r;
        if (!t) throw new ys();
        const { error: i } = await bt(
          this.fetch,
          "GET",
          `${this.url}/reauthenticate`,
          { headers: this.headers, jwt: t.access_token }
        );
        return { data: { user: null, session: null }, error: i };
      });
    } catch (e) {
      if (ft(e)) return { data: { user: null, session: null }, error: e };
      throw e;
    }
  }
  async resend(e) {
    try {
      const t = `${this.url}/resend`;
      if ("email" in e) {
        const { email: r, type: i, options: s } = e,
          { error: o } = await bt(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              email: r,
              type: i,
              gotrue_meta_security: {
                captcha_token: s == null ? void 0 : s.captchaToken,
              },
            },
            redirectTo: s == null ? void 0 : s.emailRedirectTo,
          });
        return { data: { user: null, session: null }, error: o };
      } else if ("phone" in e) {
        const { phone: r, type: i, options: s } = e,
          { data: o, error: a } = await bt(this.fetch, "POST", t, {
            headers: this.headers,
            body: {
              phone: r,
              type: i,
              gotrue_meta_security: {
                captcha_token: s == null ? void 0 : s.captchaToken,
              },
            },
          });
        return {
          data: {
            user: null,
            session: null,
            messageId: o == null ? void 0 : o.message_id,
          },
          error: a,
        };
      }
      throw new ov(
        "You must provide either an email or phone number and a type"
      );
    } catch (t) {
      if (ft(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async getSession() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => this._useSession(async (t) => t))
    );
  }
  async _acquireLock(e, t) {
    this._debug("#_acquireLock", "begin", e);
    try {
      if (this.lockAcquired) {
        const r = this.pendingInLock.length
            ? this.pendingInLock[this.pendingInLock.length - 1]
            : Promise.resolve(),
          i = (async () => (await r, await t()))();
        return (
          this.pendingInLock.push(
            (async () => {
              try {
                await i;
              } catch {}
            })()
          ),
          i
        );
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug(
          "#_acquireLock",
          "lock acquired for storage key",
          this.storageKey
        );
        try {
          this.lockAcquired = !0;
          const r = t();
          for (
            this.pendingInLock.push(
              (async () => {
                try {
                  await r;
                } catch {}
              })()
            ),
              await r;
            this.pendingInLock.length;

          ) {
            const i = [...this.pendingInLock];
            await Promise.all(i), this.pendingInLock.splice(0, i.length);
          }
          return await r;
        } finally {
          this._debug(
            "#_acquireLock",
            "lock released for storage key",
            this.storageKey
          ),
            (this.lockAcquired = !1);
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  async _useSession(e) {
    this._debug("#_useSession", "begin");
    try {
      const t = await this.__loadSession();
      return await e(t);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  async __loadSession() {
    this._debug("#__loadSession()", "begin"),
      this.lockAcquired ||
        this._debug(
          "#__loadSession()",
          "used outside of an acquired lock!",
          new Error().stack
        );
    try {
      let e = null;
      const t = await Ul(this.storage, this.storageKey);
      if (
        (this._debug("#getSession()", "session from storage", t),
        t !== null &&
          (this._isValidSession(t)
            ? (e = t)
            : (this._debug(
                "#getSession()",
                "session from storage is not valid"
              ),
              await this._removeSession())),
        !e)
      )
        return { data: { session: null }, error: null };
      const r = e.expires_at ? e.expires_at * 1e3 - Date.now() < bS : !1;
      if (
        (this._debug(
          "#__loadSession()",
          `session has${r ? "" : " not"} expired`,
          "expires_at",
          e.expires_at
        ),
        !r)
      ) {
        if (this.userStorage) {
          const o = await Ul(this.userStorage, this.storageKey + "-user");
          o != null && o.user ? (e.user = o.user) : (e.user = MS());
        }
        if (
          this.storage.isServer &&
          e.user &&
          !e.user.__isUserNotAvailableProxy
        ) {
          const o = { value: this.suppressGetSessionWarning };
          (e.user = rK(e.user, o)),
            o.value && (this.suppressGetSessionWarning = !0);
        }
        return { data: { session: e }, error: null };
      }
      const { data: i, error: s } = await this._callRefreshToken(
        e.refresh_token
      );
      return s
        ? { data: { session: null }, error: s }
        : { data: { session: i }, error: null };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  async getUser(e) {
    return e
      ? await this._getUser(e)
      : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(e) {
    try {
      return e
        ? await bt(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: e,
            xform: za,
          })
        : await this._useSession(async (t) => {
            var r, i, s;
            const { data: o, error: a } = t;
            if (a) throw a;
            return !(
              !((r = o.session) === null || r === void 0) && r.access_token
            ) && !this.hasCustomAuthorizationHeader
              ? { data: { user: null }, error: new ys() }
              : await bt(this.fetch, "GET", `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    (s =
                      (i = o.session) === null || i === void 0
                        ? void 0
                        : i.access_token) !== null && s !== void 0
                      ? s
                      : void 0,
                  xform: za,
                });
          });
    } catch (t) {
      if (ft(t))
        return (
          Dq(t) &&
            (await this._removeSession(),
            await wa(this.storage, `${this.storageKey}-code-verifier`)),
          { data: { user: null }, error: t }
        );
      throw t;
    }
  }
  async updateUser(e, t = {}) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._updateUser(e, t))
    );
  }
  async _updateUser(e, t = {}) {
    try {
      return await this._useSession(async (r) => {
        const { data: i, error: s } = r;
        if (s) throw s;
        if (!i.session) throw new ys();
        const o = i.session;
        let a = null,
          l = null;
        this.flowType === "pkce" &&
          e.email != null &&
          ([a, l] = await xu(this.storage, this.storageKey));
        const { data: c, error: u } = await bt(
          this.fetch,
          "PUT",
          `${this.url}/user`,
          {
            headers: this.headers,
            redirectTo: t == null ? void 0 : t.emailRedirectTo,
            body: Object.assign(Object.assign({}, e), {
              code_challenge: a,
              code_challenge_method: l,
            }),
            jwt: o.access_token,
            xform: za,
          }
        );
        if (u) throw u;
        return (
          (o.user = c.user),
          await this._saveSession(o),
          await this._notifyAllSubscribers("USER_UPDATED", o),
          { data: { user: o.user }, error: null }
        );
      });
    } catch (r) {
      if (ft(r)) return { data: { user: null }, error: r };
      throw r;
    }
  }
  async setSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._setSession(e))
    );
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token) throw new ys();
      const t = Date.now() / 1e3;
      let r = t,
        i = !0,
        s = null;
      const { payload: o } = TS(e.access_token);
      if ((o.exp && ((r = o.exp), (i = r <= t)), i)) {
        const { data: a, error: l } = await this._callRefreshToken(
          e.refresh_token
        );
        if (l) return { data: { user: null, session: null }, error: l };
        if (!a) return { data: { user: null, session: null }, error: null };
        s = a;
      } else {
        const { data: a, error: l } = await this._getUser(e.access_token);
        if (l) throw l;
        (s = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: a.user,
          token_type: "bearer",
          expires_in: r - t,
          expires_at: r,
        }),
          await this._saveSession(s),
          await this._notifyAllSubscribers("SIGNED_IN", s);
      }
      return { data: { user: s.user, session: s }, error: null };
    } catch (t) {
      if (ft(t)) return { data: { session: null, user: null }, error: t };
      throw t;
    }
  }
  async refreshSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._refreshSession(e))
    );
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async (t) => {
        var r;
        if (!e) {
          const { data: o, error: a } = t;
          if (a) throw a;
          e = (r = o.session) !== null && r !== void 0 ? r : void 0;
        }
        if (!(e != null && e.refresh_token)) throw new ys();
        const { data: i, error: s } = await this._callRefreshToken(
          e.refresh_token
        );
        return s
          ? { data: { user: null, session: null }, error: s }
          : i
          ? { data: { user: i.user, session: i }, error: null }
          : { data: { user: null, session: null }, error: null };
      });
    } catch (t) {
      if (ft(t)) return { data: { user: null, session: null }, error: t };
      throw t;
    }
  }
  async _getSessionFromURL(e, t) {
    try {
      if (!jr()) throw new av("No browser detected.");
      if (e.error || e.error_description || e.error_code)
        throw new av(
          e.error_description ||
            "Error in URL with unspecified error_description",
          {
            error: e.error || "unspecified_error",
            code: e.error_code || "unspecified_code",
          }
        );
      switch (t) {
        case "implicit":
          if (this.flowType === "pkce")
            throw new r2("Not a valid PKCE flow url.");
          break;
        case "pkce":
          if (this.flowType === "implicit")
            throw new av("Not a valid implicit grant flow url.");
          break;
        default:
      }
      if (t === "pkce") {
        if (
          (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !e.code)
        )
          throw new r2("No code detected.");
        const { data: _, error: S } = await this._exchangeCodeForSession(
          e.code
        );
        if (S) throw S;
        const b = new URL(window.location.href);
        return (
          b.searchParams.delete("code"),
          window.history.replaceState(window.history.state, "", b.toString()),
          { data: { session: _.session, redirectType: null }, error: null }
        );
      }
      const {
        provider_token: r,
        provider_refresh_token: i,
        access_token: s,
        refresh_token: o,
        expires_in: a,
        expires_at: l,
        token_type: c,
      } = e;
      if (!s || !a || !o || !c) throw new av("No session defined in URL");
      const u = Math.round(Date.now() / 1e3),
        f = parseInt(a);
      let p = u + f;
      l && (p = parseInt(l));
      const m = p - u;
      m * 1e3 <= Yu &&
        console.warn(
          `@supabase/gotrue-js: Session as retrieved from URL expires in ${m}s, should have been closer to ${f}s`
        );
      const v = p - f;
      u - v >= 120
        ? console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",
            v,
            p,
            u
          )
        : u - v < 0 &&
          console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",
            v,
            p,
            u
          );
      const { data: y, error: x } = await this._getUser(s);
      if (x) throw x;
      const g = {
        provider_token: r,
        provider_refresh_token: i,
        access_token: s,
        expires_in: f,
        expires_at: p,
        refresh_token: o,
        token_type: c,
        user: y.user,
      };
      return (
        (window.location.hash = ""),
        this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
        { data: { session: g, redirectType: e.type }, error: null }
      );
    } catch (r) {
      if (ft(r))
        return { data: { session: null, redirectType: null }, error: r };
      throw r;
    }
  }
  _isImplicitGrantCallback(e) {
    return !!(e.access_token || e.error_description);
  }
  async _isPKCECallback(e) {
    const t = await Ul(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && t);
  }
  async signOut(e = { scope: "global" }) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._signOut(e))
    );
  }
  async _signOut({ scope: e } = { scope: "global" }) {
    return await this._useSession(async (t) => {
      var r;
      const { data: i, error: s } = t;
      if (s) return { error: s };
      const o =
        (r = i.session) === null || r === void 0 ? void 0 : r.access_token;
      if (o) {
        const { error: a } = await this.admin.signOut(o, e);
        if (
          a &&
          !(Oq(a) && (a.status === 404 || a.status === 401 || a.status === 403))
        )
          return { error: a };
      }
      return (
        e !== "others" &&
          (await this._removeSession(),
          await wa(this.storage, `${this.storageKey}-code-verifier`)),
        { error: null }
      );
    });
  }
  onAuthStateChange(e) {
    const t = Hq(),
      r = {
        id: t,
        callback: e,
        unsubscribe: () => {
          this._debug(
            "#unsubscribe()",
            "state change callback with id removed",
            t
          ),
            this.stateChangeEmitters.delete(t);
        },
      };
    return (
      this._debug("#onAuthStateChange()", "registered callback with id", t),
      this.stateChangeEmitters.set(t, r),
      (async () => (
        await this.initializePromise,
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(t);
        })
      ))(),
      { data: { subscription: r } }
    );
  }
  async _emitInitialSession(e) {
    return await this._useSession(async (t) => {
      var r, i;
      try {
        const {
          data: { session: s },
          error: o,
        } = t;
        if (o) throw o;
        await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0
          ? void 0
          : r.callback("INITIAL_SESSION", s)),
          this._debug("INITIAL_SESSION", "callback id", e, "session", s);
      } catch (s) {
        await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0
          ? void 0
          : i.callback("INITIAL_SESSION", null)),
          this._debug("INITIAL_SESSION", "callback id", e, "error", s),
          console.error(s);
      }
    });
  }
  async resetPasswordForEmail(e, t = {}) {
    let r = null,
      i = null;
    this.flowType === "pkce" &&
      ([r, i] = await xu(this.storage, this.storageKey, !0));
    try {
      return await bt(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: r,
          code_challenge_method: i,
          gotrue_meta_security: { captcha_token: t.captchaToken },
        },
        headers: this.headers,
        redirectTo: t.redirectTo,
      });
    } catch (s) {
      if (ft(s)) return { data: null, error: s };
      throw s;
    }
  }
  async getUserIdentities() {
    var e;
    try {
      const { data: t, error: r } = await this.getUser();
      if (r) throw r;
      return {
        data: {
          identities: (e = t.user.identities) !== null && e !== void 0 ? e : [],
        },
        error: null,
      };
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async linkIdentity(e) {
    return "token" in e
      ? this.linkIdentityIdToken(e)
      : this.linkIdentityOAuth(e);
  }
  async linkIdentityOAuth(e) {
    var t;
    try {
      const { data: r, error: i } = await this._useSession(async (s) => {
        var o, a, l, c, u;
        const { data: f, error: p } = s;
        if (p) throw p;
        const m = await this._getUrlForProvider(
          `${this.url}/user/identities/authorize`,
          e.provider,
          {
            redirectTo:
              (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
            scopes:
              (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
            queryParams:
              (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
            skipBrowserRedirect: !0,
          }
        );
        return await bt(this.fetch, "GET", m, {
          headers: this.headers,
          jwt:
            (u =
              (c = f.session) === null || c === void 0
                ? void 0
                : c.access_token) !== null && u !== void 0
              ? u
              : void 0,
        });
      });
      if (i) throw i;
      return (
        jr() &&
          !(
            !((t = e.options) === null || t === void 0) && t.skipBrowserRedirect
          ) &&
          window.location.assign(r == null ? void 0 : r.url),
        {
          data: { provider: e.provider, url: r == null ? void 0 : r.url },
          error: null,
        }
      );
    } catch (r) {
      if (ft(r)) return { data: { provider: e.provider, url: null }, error: r };
      throw r;
    }
  }
  async linkIdentityIdToken(e) {
    return await this._useSession(async (t) => {
      var r;
      try {
        const {
          error: i,
          data: { session: s },
        } = t;
        if (i) throw i;
        const {
            options: o,
            provider: a,
            token: l,
            access_token: c,
            nonce: u,
          } = e,
          f = await bt(
            this.fetch,
            "POST",
            `${this.url}/token?grant_type=id_token`,
            {
              headers: this.headers,
              jwt:
                (r = s == null ? void 0 : s.access_token) !== null &&
                r !== void 0
                  ? r
                  : void 0,
              body: {
                provider: a,
                id_token: l,
                access_token: c,
                nonce: u,
                link_identity: !0,
                gotrue_meta_security: {
                  captcha_token: o == null ? void 0 : o.captchaToken,
                },
              },
              xform: xs,
            }
          ),
          { data: p, error: m } = f;
        return m
          ? { data: { user: null, session: null }, error: m }
          : !p || !p.session || !p.user
          ? { data: { user: null, session: null }, error: new yu() }
          : (p.session &&
              (await this._saveSession(p.session),
              await this._notifyAllSubscribers("USER_UPDATED", p.session)),
            { data: p, error: m });
      } catch (i) {
        if (ft(i)) return { data: { user: null, session: null }, error: i };
        throw i;
      }
    });
  }
  async unlinkIdentity(e) {
    try {
      return await this._useSession(async (t) => {
        var r, i;
        const { data: s, error: o } = t;
        if (o) throw o;
        return await bt(
          this.fetch,
          "DELETE",
          `${this.url}/user/identities/${e.identity_id}`,
          {
            headers: this.headers,
            jwt:
              (i =
                (r = s.session) === null || r === void 0
                  ? void 0
                  : r.access_token) !== null && i !== void 0
                ? i
                : void 0,
          }
        );
      });
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _refreshAccessToken(e) {
    const t = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
    this._debug(t, "begin");
    try {
      const r = Date.now();
      return await Xq(
        async (i) => (
          i > 0 && (await $q(200 * Math.pow(2, i - 1))),
          this._debug(t, "refreshing attempt", i),
          await bt(
            this.fetch,
            "POST",
            `${this.url}/token?grant_type=refresh_token`,
            { body: { refresh_token: e }, headers: this.headers, xform: xs }
          )
        ),
        (i, s) => {
          const o = 200 * Math.pow(2, i);
          return s && ES(s) && Date.now() + o - r < Yu;
        }
      );
    } catch (r) {
      if ((this._debug(t, "error", r), ft(r)))
        return { data: { session: null, user: null }, error: r };
      throw r;
    } finally {
      this._debug(t, "end");
    }
  }
  _isValidSession(e) {
    return (
      typeof e == "object" &&
      e !== null &&
      "access_token" in e &&
      "refresh_token" in e &&
      "expires_at" in e
    );
  }
  async _handleProviderSignIn(e, t) {
    const r = await this._getUrlForProvider(`${this.url}/authorize`, e, {
      redirectTo: t.redirectTo,
      scopes: t.scopes,
      queryParams: t.queryParams,
    });
    return (
      this._debug(
        "#_handleProviderSignIn()",
        "provider",
        e,
        "options",
        t,
        "url",
        r
      ),
      jr() && !t.skipBrowserRedirect && window.location.assign(r),
      { data: { provider: e, url: r }, error: null }
    );
  }
  async _recoverAndRefresh() {
    var e, t;
    const r = "#_recoverAndRefresh()";
    this._debug(r, "begin");
    try {
      const i = await Ul(this.storage, this.storageKey);
      if (i && this.userStorage) {
        let o = await Ul(this.userStorage, this.storageKey + "-user");
        !this.storage.isServer &&
          Object.is(this.storage, this.userStorage) &&
          !o &&
          ((o = { user: i.user }),
          await Ju(this.userStorage, this.storageKey + "-user", o)),
          (i.user =
            (e = o == null ? void 0 : o.user) !== null && e !== void 0
              ? e
              : MS());
      } else if (i && !i.user && !i.user) {
        const o = await Ul(this.storage, this.storageKey + "-user");
        o && o != null && o.user
          ? ((i.user = o.user),
            await wa(this.storage, this.storageKey + "-user"),
            await Ju(this.storage, this.storageKey, i))
          : (i.user = MS());
      }
      if (
        (this._debug(r, "session from storage", i), !this._isValidSession(i))
      ) {
        this._debug(r, "session is not valid"),
          i !== null && (await this._removeSession());
        return;
      }
      const s =
        ((t = i.expires_at) !== null && t !== void 0 ? t : 1 / 0) * 1e3 -
          Date.now() <
        bS;
      if (
        (this._debug(
          r,
          `session has${s ? "" : " not"} expired with margin of ${bS}s`
        ),
        s)
      ) {
        if (this.autoRefreshToken && i.refresh_token) {
          const { error: o } = await this._callRefreshToken(i.refresh_token);
          o &&
            (console.error(o),
            ES(o) ||
              (this._debug(
                r,
                "refresh failed with a non-retryable error, removing the session",
                o
              ),
              await this._removeSession()));
        }
      } else if (i.user && i.user.__isUserNotAvailableProxy === !0)
        try {
          const { data: o, error: a } = await this._getUser(i.access_token);
          !a && o != null && o.user
            ? ((i.user = o.user),
              await this._saveSession(i),
              await this._notifyAllSubscribers("SIGNED_IN", i))
            : this._debug(
                r,
                "could not get user data, skipping SIGNED_IN notification"
              );
        } catch (o) {
          console.error("Error getting user data:", o),
            this._debug(
              r,
              "error getting user data, skipping SIGNED_IN notification",
              o
            );
        }
      else await this._notifyAllSubscribers("SIGNED_IN", i);
    } catch (i) {
      this._debug(r, "error", i), console.error(i);
      return;
    } finally {
      this._debug(r, "end");
    }
  }
  async _callRefreshToken(e) {
    var t, r;
    if (!e) throw new ys();
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const i = `#_callRefreshToken(${e.substring(0, 5)}...)`;
    this._debug(i, "begin");
    try {
      this.refreshingDeferred = new zx();
      const { data: s, error: o } = await this._refreshAccessToken(e);
      if (o) throw o;
      if (!s.session) throw new ys();
      await this._saveSession(s.session),
        await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
      const a = { data: s.session, error: null };
      return this.refreshingDeferred.resolve(a), a;
    } catch (s) {
      if ((this._debug(i, "error", s), ft(s))) {
        const o = { data: null, error: s };
        return (
          ES(s) || (await this._removeSession()),
          (t = this.refreshingDeferred) === null ||
            t === void 0 ||
            t.resolve(o),
          o
        );
      }
      throw (
        ((r = this.refreshingDeferred) === null || r === void 0 || r.reject(s),
        s)
      );
    } finally {
      (this.refreshingDeferred = null), this._debug(i, "end");
    }
  }
  async _notifyAllSubscribers(e, t, r = !0) {
    const i = `#_notifyAllSubscribers(${e})`;
    this._debug(i, "begin", t, `broadcast = ${r}`);
    try {
      this.broadcastChannel &&
        r &&
        this.broadcastChannel.postMessage({ event: e, session: t });
      const s = [],
        o = Array.from(this.stateChangeEmitters.values()).map(async (a) => {
          try {
            await a.callback(e, t);
          } catch (l) {
            s.push(l);
          }
        });
      if ((await Promise.all(o), s.length > 0)) {
        for (let a = 0; a < s.length; a += 1) console.error(s[a]);
        throw s[0];
      }
    } finally {
      this._debug(i, "end");
    }
  }
  async _saveSession(e) {
    this._debug("#_saveSession()", e), (this.suppressGetSessionWarning = !0);
    const t = Object.assign({}, e),
      r = t.user && t.user.__isUserNotAvailableProxy === !0;
    if (this.userStorage) {
      !r &&
        t.user &&
        (await Ju(this.userStorage, this.storageKey + "-user", {
          user: t.user,
        }));
      const i = Object.assign({}, t);
      delete i.user;
      const s = l2(i);
      await Ju(this.storage, this.storageKey, s);
    } else {
      const i = l2(t);
      await Ju(this.storage, this.storageKey, i);
    }
  }
  async _removeSession() {
    this._debug("#_removeSession()"),
      await wa(this.storage, this.storageKey),
      await wa(this.storage, this.storageKey + "-code-verifier"),
      await wa(this.storage, this.storageKey + "-user"),
      this.userStorage &&
        (await wa(this.userStorage, this.storageKey + "-user")),
      await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e &&
        jr() &&
        window != null &&
        window.removeEventListener &&
        window.removeEventListener("visibilitychange", e);
    } catch (t) {
      console.error("removing visibilitychange callback failed", t);
    }
  }
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const e = setInterval(() => this._autoRefreshTokenTick(), Yu);
    (this.autoRefreshTicker = e),
      e && typeof e == "object" && typeof e.unref == "function"
        ? e.unref()
        : typeof Deno < "u" &&
          typeof Deno.unrefTimer == "function" &&
          Deno.unrefTimer(e),
      setTimeout(async () => {
        await this.initializePromise, await this._autoRefreshTokenTick();
      }, 0);
  }
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const e = this.autoRefreshTicker;
    (this.autoRefreshTicker = null), e && clearInterval(e);
  }
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async (t) => {
              const {
                data: { session: r },
              } = t;
              if (!r || !r.refresh_token || !r.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const i = Math.floor((r.expires_at * 1e3 - e) / Yu);
              this._debug(
                "#_autoRefreshTokenTick()",
                `access token expires in ${i} ticks, a tick lasts ${Yu}ms, refresh threshold is ${uE} ticks`
              ),
                i <= uE && (await this._callRefreshToken(r.refresh_token));
            });
          } catch (t) {
            console.error(
              "Auto refresh tick failed with error. This is likely a transient error.",
              t
            );
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof KF)
        this._debug("auto refresh token tick lock not available");
      else throw e;
    }
  }
  async _handleVisibilityChange() {
    if (
      (this._debug("#_handleVisibilityChange()"),
      !jr() || !(window != null && window.addEventListener))
    )
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      (this.visibilityChangedCallback = async () =>
        await this._onVisibilityChanged(!1)),
        window == null ||
          window.addEventListener(
            "visibilitychange",
            this.visibilityChangedCallback
          ),
        await this._onVisibilityChanged(!0);
    } catch (e) {
      console.error("_handleVisibilityChange", e);
    }
  }
  async _onVisibilityChanged(e) {
    const t = `#_onVisibilityChanged(${e})`;
    this._debug(t, "visibilityState", document.visibilityState),
      document.visibilityState === "visible"
        ? (this.autoRefreshToken && this._startAutoRefresh(),
          e ||
            (await this.initializePromise,
            await this._acquireLock(-1, async () => {
              if (document.visibilityState !== "visible") {
                this._debug(
                  t,
                  "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"
                );
                return;
              }
              await this._recoverAndRefresh();
            })))
        : document.visibilityState === "hidden" &&
          this.autoRefreshToken &&
          this._stopAutoRefresh();
  }
  async _getUrlForProvider(e, t, r) {
    const i = [`provider=${encodeURIComponent(t)}`];
    if (
      (r != null &&
        r.redirectTo &&
        i.push(`redirect_to=${encodeURIComponent(r.redirectTo)}`),
      r != null && r.scopes && i.push(`scopes=${encodeURIComponent(r.scopes)}`),
      this.flowType === "pkce")
    ) {
      const [s, o] = await xu(this.storage, this.storageKey),
        a = new URLSearchParams({
          code_challenge: `${encodeURIComponent(s)}`,
          code_challenge_method: `${encodeURIComponent(o)}`,
        });
      i.push(a.toString());
    }
    if (r != null && r.queryParams) {
      const s = new URLSearchParams(r.queryParams);
      i.push(s.toString());
    }
    return (
      r != null &&
        r.skipBrowserRedirect &&
        i.push(`skip_http_redirect=${r.skipBrowserRedirect}`),
      `${e}?${i.join("&")}`
    );
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async (t) => {
        var r;
        const { data: i, error: s } = t;
        return s
          ? { data: null, error: s }
          : await bt(
              this.fetch,
              "DELETE",
              `${this.url}/factors/${e.factorId}`,
              {
                headers: this.headers,
                jwt:
                  (r = i == null ? void 0 : i.session) === null || r === void 0
                    ? void 0
                    : r.access_token,
              }
            );
      });
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async (t) => {
        var r, i;
        const { data: s, error: o } = t;
        if (o) return { data: null, error: o };
        const a = Object.assign(
            { friendly_name: e.friendlyName, factor_type: e.factorType },
            e.factorType === "phone"
              ? { phone: e.phone }
              : e.factorType === "totp"
              ? { issuer: e.issuer }
              : {}
          ),
          { data: l, error: c } = await bt(
            this.fetch,
            "POST",
            `${this.url}/factors`,
            {
              body: a,
              headers: this.headers,
              jwt:
                (r = s == null ? void 0 : s.session) === null || r === void 0
                  ? void 0
                  : r.access_token,
            }
          );
        return c
          ? { data: null, error: c }
          : (e.factorType === "totp" &&
              l.type === "totp" &&
              !((i = l == null ? void 0 : l.totp) === null || i === void 0) &&
              i.qr_code &&
              (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
            { data: l, error: null });
      });
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var r;
          const { data: i, error: s } = t;
          if (s) return { data: null, error: s };
          const o = Object.assign(
              { challenge_id: e.challengeId },
              "webauthn" in e
                ? {
                    webauthn: Object.assign(Object.assign({}, e.webauthn), {
                      credential_response:
                        e.webauthn.type === "create"
                          ? bK(e.webauthn.credential_response)
                          : EK(e.webauthn.credential_response),
                    }),
                  }
                : { code: e.code }
            ),
            { data: a, error: l } = await bt(
              this.fetch,
              "POST",
              `${this.url}/factors/${e.factorId}/verify`,
              {
                body: o,
                headers: this.headers,
                jwt:
                  (r = i == null ? void 0 : i.session) === null || r === void 0
                    ? void 0
                    : r.access_token,
              }
            );
          return l
            ? { data: null, error: l }
            : (await this._saveSession(
                Object.assign(
                  { expires_at: Math.round(Date.now() / 1e3) + a.expires_in },
                  a
                )
              ),
              await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
              { data: a, error: l });
        });
      } catch (t) {
        if (ft(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (t) => {
          var r;
          const { data: i, error: s } = t;
          if (s) return { data: null, error: s };
          const o = await bt(
            this.fetch,
            "POST",
            `${this.url}/factors/${e.factorId}/challenge`,
            {
              body: e,
              headers: this.headers,
              jwt:
                (r = i == null ? void 0 : i.session) === null || r === void 0
                  ? void 0
                  : r.access_token,
            }
          );
          if (o.error) return o;
          const { data: a } = o;
          if (a.type !== "webauthn") return { data: a, error: null };
          switch (a.webauthn.type) {
            case "create":
              return {
                data: Object.assign(Object.assign({}, a), {
                  webauthn: Object.assign(Object.assign({}, a.webauthn), {
                    credential_options: Object.assign(
                      Object.assign({}, a.webauthn.credential_options),
                      { publicKey: wK(a.webauthn.credential_options.publicKey) }
                    ),
                  }),
                }),
                error: null,
              };
            case "request":
              return {
                data: Object.assign(Object.assign({}, a), {
                  webauthn: Object.assign(Object.assign({}, a.webauthn), {
                    credential_options: Object.assign(
                      Object.assign({}, a.webauthn.credential_options),
                      { publicKey: SK(a.webauthn.credential_options.publicKey) }
                    ),
                  }),
                }),
                error: null,
              };
          }
        });
      } catch (t) {
        if (ft(t)) return { data: null, error: t };
        throw t;
      }
    });
  }
  async _challengeAndVerify(e) {
    const { data: t, error: r } = await this._challenge({
      factorId: e.factorId,
    });
    return r
      ? { data: null, error: r }
      : await this._verify({
          factorId: e.factorId,
          challengeId: t.id,
          code: e.code,
        });
  }
  async _listFactors() {
    var e;
    const {
      data: { user: t },
      error: r,
    } = await this.getUser();
    if (r) return { data: null, error: r };
    const i = { all: [], phone: [], totp: [], webauthn: [] };
    for (const s of (e = t == null ? void 0 : t.factors) !== null &&
    e !== void 0
      ? e
      : [])
      i.all.push(s), s.status === "verified" && i[s.factor_type].push(s);
    return { data: i, error: null };
  }
  async _getAuthenticatorAssuranceLevel() {
    var e, t;
    const {
      data: { session: r },
      error: i,
    } = await this.getSession();
    if (i) return { data: null, error: i };
    if (!r)
      return {
        data: {
          currentLevel: null,
          nextLevel: null,
          currentAuthenticationMethods: [],
        },
        error: null,
      };
    const { payload: s } = TS(r.access_token);
    let o = null;
    s.aal && (o = s.aal);
    let a = o;
    ((t =
      (e = r.user.factors) === null || e === void 0
        ? void 0
        : e.filter((u) => u.status === "verified")) !== null && t !== void 0
      ? t
      : []
    ).length > 0 && (a = "aal2");
    const c = s.amr || [];
    return {
      data: { currentLevel: o, nextLevel: a, currentAuthenticationMethods: c },
      error: null,
    };
  }
  async _getAuthorizationDetails(e) {
    try {
      return await this._useSession(async (t) => {
        const {
          data: { session: r },
          error: i,
        } = t;
        return i
          ? { data: null, error: i }
          : r
          ? await bt(
              this.fetch,
              "GET",
              `${this.url}/oauth/authorizations/${e}`,
              {
                headers: this.headers,
                jwt: r.access_token,
                xform: (s) => ({ data: s, error: null }),
              }
            )
          : { data: null, error: new ys() };
      });
    } catch (t) {
      if (ft(t)) return { data: null, error: t };
      throw t;
    }
  }
  async _approveAuthorization(e, t) {
    try {
      return await this._useSession(async (r) => {
        const {
          data: { session: i },
          error: s,
        } = r;
        if (s) return { data: null, error: s };
        if (!i) return { data: null, error: new ys() };
        const o = await bt(
          this.fetch,
          "POST",
          `${this.url}/oauth/authorizations/${e}/consent`,
          {
            headers: this.headers,
            jwt: i.access_token,
            body: { action: "approve" },
            xform: (a) => ({ data: a, error: null }),
          }
        );
        return (
          o.data &&
            o.data.redirect_url &&
            jr() &&
            !(t != null && t.skipBrowserRedirect) &&
            window.location.assign(o.data.redirect_url),
          o
        );
      });
    } catch (r) {
      if (ft(r)) return { data: null, error: r };
      throw r;
    }
  }
  async _denyAuthorization(e, t) {
    try {
      return await this._useSession(async (r) => {
        const {
          data: { session: i },
          error: s,
        } = r;
        if (s) return { data: null, error: s };
        if (!i) return { data: null, error: new ys() };
        const o = await bt(
          this.fetch,
          "POST",
          `${this.url}/oauth/authorizations/${e}/consent`,
          {
            headers: this.headers,
            jwt: i.access_token,
            body: { action: "deny" },
            xform: (a) => ({ data: a, error: null }),
          }
        );
        return (
          o.data &&
            o.data.redirect_url &&
            jr() &&
            !(t != null && t.skipBrowserRedirect) &&
            window.location.assign(o.data.redirect_url),
          o
        );
      });
    } catch (r) {
      if (ft(r)) return { data: null, error: r };
      throw r;
    }
  }
  async fetchJwk(e, t = { keys: [] }) {
    let r = t.keys.find((a) => a.kid === e);
    if (r) return r;
    const i = Date.now();
    if (
      ((r = this.jwks.keys.find((a) => a.kid === e)),
      r && this.jwks_cached_at + Nq > i)
    )
      return r;
    const { data: s, error: o } = await bt(
      this.fetch,
      "GET",
      `${this.url}/.well-known/jwks.json`,
      { headers: this.headers }
    );
    if (o) throw o;
    return !s.keys ||
      s.keys.length === 0 ||
      ((this.jwks = s),
      (this.jwks_cached_at = i),
      (r = s.keys.find((a) => a.kid === e)),
      !r)
      ? null
      : r;
  }
  async getClaims(e, t = {}) {
    try {
      let r = e;
      if (!r) {
        const { data: m, error: v } = await this.getSession();
        if (v || !m.session) return { data: null, error: v };
        r = m.session.access_token;
      }
      const {
        header: i,
        payload: s,
        signature: o,
        raw: { header: a, payload: l },
      } = TS(r);
      (t != null && t.allowExpired) || eK(s.exp);
      const c =
        !i.alg ||
        i.alg.startsWith("HS") ||
        !i.kid ||
        !("crypto" in globalThis && "subtle" in globalThis.crypto)
          ? null
          : await this.fetchJwk(
              i.kid,
              t != null && t.keys
                ? { keys: t.keys }
                : t == null
                ? void 0
                : t.jwks
            );
      if (!c) {
        const { error: m } = await this.getUser(r);
        if (m) throw m;
        return { data: { claims: s, header: i, signature: o }, error: null };
      }
      const u = tK(i.alg),
        f = await crypto.subtle.importKey("jwk", c, u, !0, ["verify"]);
      if (!(await crypto.subtle.verify(u, f, o, Vq(`${a}.${l}`))))
        throw new fE("Invalid JWT signature");
      return { data: { claims: s, header: i, signature: o }, error: null };
    } catch (r) {
      if (ft(r)) return { data: null, error: r };
      throw r;
    }
  }
}
Up.nextInstanceID = 0;
const LK = Up;
class OK extends LK {
  constructor(e) {
    super(e);
  }
}
class DK {
  constructor(e, t, r) {
    var i, s, o;
    (this.supabaseUrl = e), (this.supabaseKey = t);
    const a = Cq(e);
    if (!t) throw new Error("supabaseKey is required.");
    (this.realtimeUrl = new URL("realtime/v1", a)),
      (this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(
        "http",
        "ws"
      )),
      (this.authUrl = new URL("auth/v1", a)),
      (this.storageUrl = new URL("storage/v1", a)),
      (this.functionsUrl = new URL("functions/v1", a));
    const l = `sb-${a.hostname.split(".")[0]}-auth-token`,
      c = {
        db: xq,
        realtime: wq,
        auth: Object.assign(Object.assign({}, _q), { storageKey: l }),
        global: yq,
      },
      u = Mq(r ?? {}, c);
    (this.storageKey =
      (i = u.auth.storageKey) !== null && i !== void 0 ? i : ""),
      (this.headers = (s = u.global.headers) !== null && s !== void 0 ? s : {}),
      u.accessToken
        ? ((this.accessToken = u.accessToken),
          (this.auth = new Proxy(
            {},
            {
              get: (f, p) => {
                throw new Error(
                  `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(
                    p
                  )} is not possible`
                );
              },
            }
          )))
        : (this.auth = this._initSupabaseAuthClient(
            (o = u.auth) !== null && o !== void 0 ? o : {},
            this.headers,
            u.global.fetch
          )),
      (this.fetch = Eq(t, this._getAccessToken.bind(this), u.global.fetch)),
      (this.realtime = this._initRealtimeClient(
        Object.assign(
          {
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this),
          },
          u.realtime
        )
      )),
      (this.rest = new AX(new URL("rest/v1", a).href, {
        headers: this.headers,
        schema: u.db.schema,
        fetch: this.fetch,
      })),
      (this.storage = new mq(
        this.storageUrl.href,
        this.headers,
        this.fetch,
        r == null ? void 0 : r.storage
      )),
      u.accessToken || this._listenForAuthEvents();
  }
  get functions() {
    return new _X(this.functionsUrl.href, {
      headers: this.headers,
      customFetch: this.fetch,
    });
  }
  from(e) {
    return this.rest.from(e);
  }
  schema(e) {
    return this.rest.schema(e);
  }
  rpc(e, t = {}, r = { head: !1, get: !1, count: void 0 }) {
    return this.rest.rpc(e, t, r);
  }
  channel(e, t = { config: {} }) {
    return this.realtime.channel(e, t);
  }
  getChannels() {
    return this.realtime.getChannels();
  }
  removeChannel(e) {
    return this.realtime.removeChannel(e);
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  async _getAccessToken() {
    var e, t;
    if (this.accessToken) return await this.accessToken();
    const { data: r } = await this.auth.getSession();
    return (t =
      (e = r.session) === null || e === void 0 ? void 0 : e.access_token) !==
      null && t !== void 0
      ? t
      : this.supabaseKey;
  }
  _initSupabaseAuthClient(
    {
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: r,
      storage: i,
      userStorage: s,
      storageKey: o,
      flowType: a,
      lock: l,
      debug: c,
    },
    u,
    f
  ) {
    const p = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`,
    };
    return new OK({
      url: this.authUrl.href,
      headers: Object.assign(Object.assign({}, p), u),
      storageKey: o,
      autoRefreshToken: e,
      persistSession: t,
      detectSessionInUrl: r,
      storage: i,
      userStorage: s,
      flowType: a,
      lock: l,
      debug: c,
      fetch: f,
      hasCustomAuthorizationHeader: Object.keys(this.headers).some(
        (m) => m.toLowerCase() === "authorization"
      ),
    });
  }
  _initRealtimeClient(e) {
    return new GX(
      this.realtimeUrl.href,
      Object.assign(Object.assign({}, e), {
        params: Object.assign(
          { apikey: this.supabaseKey },
          e == null ? void 0 : e.params
        ),
      })
    );
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((t, r) => {
      this._handleTokenChanged(
        t,
        "CLIENT",
        r == null ? void 0 : r.access_token
      );
    });
  }
  _handleTokenChanged(e, t, r) {
    (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") &&
    this.changedAccessToken !== r
      ? ((this.changedAccessToken = r), this.realtime.setAuth(r))
      : e === "SIGNED_OUT" &&
        (this.realtime.setAuth(),
        t == "STORAGE" && this.auth.signOut(),
        (this.changedAccessToken = void 0));
  }
}
const kK = (n, e, t) => new DK(n, e, t);
function UK() {
  if (typeof window < "u" || typeof process > "u") return !1;
  const n = process.version;
  if (n == null) return !1;
  const e = n.match(/^v(\d+)\./);
  return e ? parseInt(e[1], 10) <= 18 : !1;
}
UK() &&
  console.warn(
    "  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217"
  );
const FK = "https://upqsrajvvepoghmfoilf.supabase.co",
  BK =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVwcXNyYWp2dmVwb2dobWZvaWxmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjIyNTk0MTgsImV4cCI6MjA3NzgzNTQxOH0.PBVoquLFbokDtAOUdKkOFuxwFQ3OyD2VVhxMXc03gok",
  or = kK(FK, BK, {
    auth: { storage: localStorage, persistSession: !0, autoRefreshToken: !0 },
  }),
  zK = async (n) => {
    const t = new TextEncoder().encode(n + "zPush-salt-2024"),
      r = await crypto.subtle.digest("SHA-256", t);
    return Array.from(new Uint8Array(r))
      .map((s) => s.toString(16).padStart(2, "0"))
      .join("");
  },
  m2 = async () => {
    let n = sessionStorage.getItem("zPush-session-hash");
    if (!n) {
      const e = `192.168.1.${Math.floor(Math.random() * 255)}`;
      (n = await zK(e)), sessionStorage.setItem("zPush-session-hash", n);
    }
    return n;
  };
class VK {
  static async clickTile(e, t) {
    console.log(`[zPush API] POST /api/grid/click - Position: (${e}, ${t})`);
    try {
      const r = await m2(),
        { error: i } = await or
          .from("grid_clicks")
          .insert({ grid_x: e, grid_y: t, ip_hash: r });
      if (i) {
        console.error("[zPush API] Grid click failed:", i.message);
        return;
      }
      console.log("[zPush API] Grid click recorded successfully");
    } catch (r) {
      console.error("[zPush API] Grid click error:", r);
    }
  }
  static async startConversation(e, t) {
    console.log(
      `[zPush API] POST /api/conversations/create - Position: (${e}, ${t})`
    );
    try {
      const r = await m2(),
        i = `zPush-${new Date()
          .toISOString()
          .slice(0, 19)
          .replace(/[-:]/g, "")
          .replace("T", "-")}-${Math.random()
          .toString(36)
          .substr(2, 3)
          .toUpperCase()}`,
        { error: s } = await or
          .from("conversations")
          .insert({
            id: i,
            grid_x: e,
            grid_y: t,
            ip_hash: r,
            user_agent: navigator.userAgent,
          });
      if (s)
        throw (
          (console.error("[zPush API] Conversation creation failed:", s.message),
          new Error(
            `Failed to start conversation: ${s.message}. Please check your connection and try again.`
          ))
        );
      return console.log(`[zPush API] Conversation created: ${i}`), i;
    } catch (r) {
      throw (
        (console.error("[zPush API] Conversation error:", r),
        new Error(r.message || "Failed to connect to zPush. Please try again."))
      );
    }
  }
  static async sendMessage(e, t, r) {
    console.log(
      `[zPush API] POST /api/messages/send - Conversation: ${e}, Sender: ${r}`
    );
    try {
      const { error: i } = await or
        .from("messages")
        .insert({ conversation_id: e, sender: r, content: t });
      if (i)
        throw (
          (console.error("[zPush API] Message send failed:", i.message),
          new Error(`Failed to send message: ${i.message}`))
        );
      console.log("[zPush API] Message sent successfully");
    } catch (i) {
      throw (
        (console.error("[zPush API] Message error:", i),
        new Error(i.message || "Failed to send message to zPush."))
      );
    }
  }
  static async getConversations() {
    console.log("[zPush API] GET /api/conversations");
    const { data: e, error: t } = await or
      .from("conversations")
      .select("*")
      .order("created_at", { ascending: !1 });
    if (t)
      throw (console.error("[zPush API] Failed to fetch conversations:", t), t);
    return (
      console.log(
        `[zPush API] Retrieved ${
          (e == null ? void 0 : e.length) || 0
        } conversations`
      ),
      e || []
    );
  }
  static async getMessages(e) {
    console.log(`[zPush API] GET /api/messages/${e}`);
    const { data: t, error: r } = await or
      .from("messages")
      .select("*")
      .eq("conversation_id", e)
      .order("created_at", { ascending: !0 });
    if (r) throw (console.error("[zPush API] Failed to fetch messages:", r), r);
    const i = (t || []).map((s) => ({ ...s, sender: s.sender }));
    return (
      console.log(
        `[zPush API] Retrieved ${i.length} messages for conversation ${e}`
      ),
      i
    );
  }
  static async initializeRealtimeConnection() {
    return (
      console.log("[zPush API] Initializing real-time connection..."),
      or.channel("zPush-realtime-connection")
    );
  }
  static async trackPresence(e) {
    return console.log("[zPush API] POST /api/presence/track"), e;
  }
  static async healthCheck() {
    console.log("[zPush API] GET /api/health");
    try {
      const { data: e, error: t } = await or
        .from("conversations")
        .select("count")
        .limit(1);
      if (t) throw t;
      const r = { status: "healthy", timestamp: new Date().toISOString() };
      return console.log("[zPush API] Health check passed:", r), r;
    } catch (e) {
      throw (
        (console.error("[zPush API] Health check failed:", e),
        new Error("zPush API unhealthy"))
      );
    }
  }
}
const Zu = VK,
  ol = {
    async clickTile(n, e) {
      return Zu.clickTile(n, e);
    },
    async startConversation(n, e, t = "zPush") {
      const r = await Zu.startConversation(n, e);
      return `${t}-${r}`;
    },
    async sendMessage(n, e, t, r = "zPush") {
      const i = n.includes("-") ? n.split("-").slice(1).join("-") : n;
      return Zu.sendMessage(i, e, t);
    },
    async getConversations(n = "zPush") {
      return (await Zu.getConversations()).map((t) => ({
        ...t,
        id: t.id.includes("-") ? t.id : `${n}-${t.id}`,
      }));
    },
    async getMessages(n) {
      const e = n.includes("-") ? n.split("-").slice(1).join("-") : n;
      return Zu.getMessages(e);
    },
  },
  la = XU((n, e) => ({
    isConnected: !1,
    presenceCount: 0,
    gridTiles: new Map(),
    gridWidth: 80,
    gridHeight: 40,
    conversations: [],
    messages: new Map(),
    activeConversationId: null,
    currentMode: "zPush",
    setConnected: (t) => n({ isConnected: t }),
    setPresenceCount: (t) => n({ presenceCount: t }),
    updateGridTile: (t, r, i) => {
      const s = e().getGridKey(t, r),
        o = new Map(e().gridTiles),
        a = o.get(s) || { x: t, y: r, heat: 0 };
      o.set(s, { ...a, ...i }), n({ gridTiles: o });
    },
    addConversation: (t) =>
      n((r) => {
        if (r.conversations.some((o) => o.id === t.id)) return r;
        const s = {
          ...t,
          id: t.id.includes("-") ? t.id : `${r.currentMode}-${t.id}`,
        };
        return { conversations: [...r.conversations, s] };
      }),
    addMessage: (t) => {
      const r = new Map(e().messages),
        i = r.get(t.conversation_id) || [];
      i.some((o) => o.id === t.id) ||
        (r.set(t.conversation_id, [...i, t]), n({ messages: r }));
    },
    setActiveConversation: (t) => n({ activeConversationId: t }),
    initializeGrid: (t, r) => {
      const i = e().gridTiles,
        s = new Map();
      for (let o = 0; o < t; o++)
        for (let a = 0; a < r; a++) {
          const l = `${o}-${a}`,
            c = i.get(l);
          c ? s.set(l, c) : s.set(l, { x: o, y: a, heat: 0 });
        }
      n({ gridTiles: s, gridWidth: t, gridHeight: r });
    },
    getGridKey: (t, r) => `${t}-${r}`,
    getTileHeat: (t, r) => {
      var s;
      const i = e().getGridKey(t, r);
      return ((s = e().gridTiles.get(i)) == null ? void 0 : s.heat) || 0;
    },
    setCurrentMode: (t) => n({ currentMode: t }),
    getModeFilteredConversations: () => {
      const t = e();
      return t.conversations.filter(
        (r) =>
          (r.id.includes("-") ? r.id.split("-")[0] : "zPush") === t.currentMode
      );
    },
    getModeFilteredTiles: () => {
      const t = e(),
        r = new Map();
      return (
        t.gridTiles.forEach((i, s) => {
          i.conversationId || i.heat > 0
            ? r.set(s, i)
            : r.set(s, { ...i, heat: 0 });
        }),
        r
      );
    },
    getModeFilteredMessages: (t) => e().messages.get(t) || [],
    loadModeData: async (t) => {},
  })),
  ZF = () => {
    console.log("[zPush API] Initializing real-time subscriptions...");
    const n = la.getState(),
      e = or
        .channel("zPush-conversations-realtime")
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "conversations" },
          (a) => {
            console.log("[zPush API] New conversation detected:", a.new);
            const l = a.new;
            n.addConversation(l);
            const c = n.gridTiles.get(n.getGridKey(l.grid_x, l.grid_y)),
              u = Math.max(((c == null ? void 0 : c.heat) || 0) + 2, 3);
            n.updateGridTile(l.grid_x, l.grid_y, {
              conversationId: l.id,
              heat: u,
              lastActivity: new Date(l.created_at),
            });
          }
        )
        .subscribe(),
      t = or
        .channel("zPush-messages-realtime")
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "messages" },
          (a) => {
            console.log("[zPush API] New message detected:", a.new);
            const l = a.new;
            n.addMessage(l);
            const c = n.conversations.find((u) => u.id === l.conversation_id);
            if (c) {
              const u = n.gridTiles.get(n.getGridKey(c.grid_x, c.grid_y)),
                f = Math.max(((u == null ? void 0 : u.heat) || 0) + 1, 3);
              n.updateGridTile(c.grid_x, c.grid_y, {
                heat: f,
                lastActivity: new Date(l.created_at),
              });
            }
          }
        )
        .subscribe(),
      r = or
        .channel("zPush-grid-clicks-realtime")
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "grid_clicks" },
          (a) => {
            console.log("[zPush API] Grid click detected:", a.new);
            const l = a.new,
              c = n.gridTiles.get(n.getGridKey(l.grid_x, l.grid_y)),
              u = ((c == null ? void 0 : c.heat) || 0) + 0.5;
            n.updateGridTile(l.grid_x, l.grid_y, {
              hasClick: !0,
              heat: u,
              lastActivity: new Date(l.created_at),
            });
          }
        )
        .subscribe();
    let i = sessionStorage.getItem("zPush-presence-key");
    i ||
      ((i = Math.random().toString(36).slice(2)),
      sessionStorage.setItem("zPush-presence-key", i)),
      console.log("[zPush API] Setting up presence tracking with key:", i);
    const s = or.channel("zPush-presence-realtime", {
      config: { presence: { key: i } },
    });
    s.on("presence", { event: "sync" }, () => {
      const a = s.presenceState(),
        l = Object.values(a).reduce(
          (c, u) => c + (Array.isArray(u) ? u.length : 0),
          0
        );
      n.setPresenceCount(l);
    })
      .on("presence", { event: "join" }, ({ key: a, newPresences: l }) => {
        console.log("User joined:", a, l);
      })
      .on("presence", { event: "leave" }, ({ key: a, leftPresences: l }) => {
        console.log("User left:", a, l);
      })
      .subscribe(async (a) => {
        if (a === "SUBSCRIBED") {
          const l = {
            user_id: Math.random().toString(36).substr(2, 9),
            online_at: new Date().toISOString(),
          };
          await s.track(l);
        }
      });
    const o = async (a) => {
      console.log("[zPush API] Loading ALL conversations for display...");
      try {
        const { data: l, error: c } = await or
          .from("conversations")
          .select("*")
          .order("created_at", { ascending: !1 });
        if (c) throw c;
        for (const u of l || []) {
          const f = { ...u, id: u.id };
          n.addConversation(f);
          const { data: p } = await or
              .from("messages")
              .select("*")
              .eq("conversation_id", u.id),
            m = (p == null ? void 0 : p.length) || 0,
            v = 2,
            y = m * 0.5,
            x = v + y;
          n.updateGridTile(u.grid_x, u.grid_y, {
            conversationId: u.id,
            heat: x,
            lastActivity: new Date(u.updated_at || u.created_at),
          }),
            p &&
              p.forEach((g) => {
                n.addMessage(g);
              });
        }
        console.log("[zPush API] All conversations loaded successfully");
      } catch (l) {
        console.error("[zPush API] Failed to load conversations:", l);
      }
    };
    return (
      (n.loadModeData = o),
      o(n.currentMode),
      console.log("[zPush API] Connection established"),
      n.setConnected(!0),
      () => {
        or.removeChannel(e),
          or.removeChannel(t),
          or.removeChannel(r),
          or.removeChannel(s),
          n.setConnected(!1),
          console.log("[zPush API] Real-time subscriptions cleaned up");
      }
    );
  };
function QF(n, e) {
  let t;
  try {
    t = n();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var s;
      const o = (l) => (l === null ? null : JSON.parse(l, void 0)),
        a = (s = t.getItem(i)) != null ? s : null;
      return a instanceof Promise ? a.then(o) : o(a);
    },
    setItem: (i, s) => t.setItem(i, JSON.stringify(s, void 0)),
    removeItem: (i) => t.removeItem(i),
  };
}
const pE = (n) => (e) => {
    try {
      const t = n(e);
      return t instanceof Promise
        ? t
        : {
            then(r) {
              return pE(r)(t);
            },
            catch(r) {
              return this;
            },
          };
    } catch (t) {
      return {
        then(r) {
          return this;
        },
        catch(r) {
          return pE(r)(t);
        },
      };
    }
  },
  jK = (n, e) => (t, r, i) => {
    let s = {
        storage: QF(() => localStorage),
        partialize: (y) => y,
        version: 0,
        merge: (y, x) => ({ ...x, ...y }),
        ...e,
      },
      o = !1;
    const a = new Set(),
      l = new Set();
    let c = s.storage;
    if (!c)
      return n(
        (...y) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            t(...y);
        },
        r,
        i
      );
    const u = () => {
        const y = s.partialize({ ...r() });
        return c.setItem(s.name, { state: y, version: s.version });
      },
      f = i.setState;
    i.setState = (y, x) => {
      f(y, x), u();
    };
    const p = n(
      (...y) => {
        t(...y), u();
      },
      r,
      i
    );
    i.getInitialState = () => p;
    let m;
    const v = () => {
      var y, x;
      if (!c) return;
      (o = !1),
        a.forEach((_) => {
          var S;
          return _((S = r()) != null ? S : p);
        });
      const g =
        ((x = s.onRehydrateStorage) == null
          ? void 0
          : x.call(s, (y = r()) != null ? y : p)) || void 0;
      return pE(c.getItem.bind(c))(s.name)
        .then((_) => {
          if (_)
            if (typeof _.version == "number" && _.version !== s.version) {
              if (s.migrate) {
                const S = s.migrate(_.state, _.version);
                return S instanceof Promise ? S.then((b) => [!0, b]) : [!0, S];
              }
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return [!1, _.state];
          return [!1, void 0];
        })
        .then((_) => {
          var S;
          const [b, C] = _;
          if (((m = s.merge(C, (S = r()) != null ? S : p)), t(m, !0), b))
            return u();
        })
        .then(() => {
          g == null || g(m, void 0),
            (m = r()),
            (o = !0),
            l.forEach((_) => _(m));
        })
        .catch((_) => {
          g == null || g(void 0, _);
        });
    };
    return (
      (i.persist = {
        setOptions: (y) => {
          (s = { ...s, ...y }), y.storage && (c = y.storage);
        },
        clearStorage: () => {
          c == null || c.removeItem(s.name);
        },
        getOptions: () => s,
        rehydrate: () => v(),
        hasHydrated: () => o,
        onHydrate: (y) => (
          a.add(y),
          () => {
            a.delete(y);
          }
        ),
        onFinishHydration: (y) => (
          l.add(y),
          () => {
            l.delete(y);
          }
        ),
      }),
      s.skipHydration || v(),
      m || p
    );
  },
  HK = jK,
  kM = XU()(
    HK(
      (n) => ({
        currentMode: "zPush",
        setMode: (e) => {
          n({ currentMode: e });
        },
      }),
      { name: "app-mode", storage: QF(() => localStorage) }
    )
  ),
  g2 = () => {
    const { isConnected: n, presenceCount: e } = la(),
      [t, r] = P.useState("connecting");
    P.useEffect(() => {
      r(n ? "online" : "offline");
    }, [n]);
    const i = {
      connecting: "status-connecting",
      online: "status-online",
      offline: "status-offline",
    }[t];
    return T.jsxs("div", {
      className: "flex items-center space-x-2 text-xs font-mono",
      children: [
        T.jsx("div", { className: `w-2 h-2 rounded-full ${i}` }),
        T.jsxs("span", {
          className: "text-muted-foreground",
          children: [
            t === "connecting" && "CONNECTING",
            t === "online" && `ONLINE  ${e} active`,
            t === "offline" && "OFFLINE",
          ],
        }),
      ],
    });
  },
  WK = () =>
    T.jsx("div", {
      className:
        "flex items-center space-x-3 bg-card border border-border rounded-lg px-3 py-2",
      children: T.jsxs("div", {
        className: "flex items-center space-x-2",
        children: [
          T.jsx("img", {
            src: "/zPush-icon.png",
            alt: "zPush Logo",
            className: "w-6 h-6 rounded-full object-cover",
          }),
          T.jsx("span", {
            className: "text-sm font-medium font-mono text-foreground",
            children: "zPush",
          }),
        ],
      }),
    }),
  GK = () => {
    const n = Jc(),
      e = (r) => (r === "/" ? n.pathname === "/" : n.pathname.startsWith(r)),
      t = [
        { path: "/", label: "DASH" },
        { path: "/chat", label: "CHAT" },
        { path: "/logs", label: "LOGS" },
        { path: "/docs", label: "DOCS" },
      ];
    return T.jsx("nav", {
      className: "zPush-nav sticky top-0 z-50",
      children: T.jsxs("div", {
        className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8",
        children: [
          T.jsxs("div", {
            className: "flex items-center justify-between h-16",
            children: [
              T.jsx("div", {
                className: "flex items-center space-x-4",
                children: T.jsxs(yS, {
                  to: "/",
                  className: "flex items-center space-x-2 group",
                  children: [
                    T.jsx("div", {
                      className:
                        "w-8 h-8 rounded-full overflow-hidden group-hover:scale-110 transition-transform",
                      children: T.jsx("img", {
                        src: "/zPush-icon.png",
                        alt: "zPush Logo",
                        className: "w-full h-full object-cover",
                      }),
                    }),
                    T.jsxs("div", {
                      className: "font-mono",
                      children: [
                        T.jsx("span", {
                          className: "font-bold text-lg text-black",
                          children: "zPush",
                        }),
                        T.jsx("div", {
                          className: "mt-1",
                          children: T.jsx(g2, {}),
                        }),
                      ],
                    }),
                  ],
                }),
              }),
              T.jsx("div", {
                className: "hidden md:block",
                children: T.jsx("div", {
                  className: "ml-10 flex items-baseline space-x-8",
                  children: t.map(({ path: r, label: i }) =>
                    T.jsx(
                      yS,
                      {
                        to: r,
                        className: qt("zPush-nav-link", e(r) && "active"),
                        children: i,
                      },
                      r
                    )
                  ),
                }),
              }),
              T.jsxs("div", {
                className: "flex items-center space-x-4",
                children: [
                  T.jsx(WK, {}),
                  T.jsxs("a", {
                    href: "https://x.com/zPush_fun",
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className:
                      "flex items-center space-x-1 text-muted-foreground hover:text-primary transition-colors",
                    children: [
                      T.jsx("span", {
                        className: "font-mono text-sm",
                        children: "X",
                      }),
                      T.jsx(k3, { className: "w-3 h-3" }),
                    ],
                  }),
                  T.jsx("div", {
                    className:
                      "inline-flex items-center px-2 py-1 bg-muted/50 border border-border rounded text-xs font-mono text-muted-foreground",
                    children: T.jsx("span", { children: "CA: SOON" }),
                  }),
                  T.jsx(g2, {}),
                ],
              }),
            ],
          }),
          T.jsx("div", {
            className: "md:hidden pb-3",
            children: T.jsx("div", {
              className: "flex space-x-6",
              children: t.map(({ path: r, label: i }) =>
                T.jsx(
                  yS,
                  {
                    to: r,
                    className: qt("zPush-nav-link", e(r) && "active"),
                    children: i,
                  },
                  r
                )
              ),
            }),
          }),
        ],
      }),
    });
  },
  $K = () => {
    const [n, e] = P.useState({ x: 0, y: 0 }),
      [t, r] = P.useState([]),
      i = P.useRef(0),
      s = P.useRef(0);
    return (
      P.useEffect(() => {
        const o = (l) => {
            e({ x: l.clientX, y: l.clientY });
            const c = Date.now();
            if (c - s.current > 50) {
              s.current = c;
              const u = {
                id: i.current++,
                x: l.clientX + (Math.random() - 0.5) * 20,
                y: l.clientY + (Math.random() - 0.5) * 20,
                size: Math.random() * 8 + 4,
                opacity: 0.7,
                life: 1,
              };
              r((f) => [...f.slice(-10), u]);
            }
          },
          a = (l) => {
            const c = [];
            for (let u = 0; u < 5; u++)
              c.push({
                id: i.current++,
                x: l.clientX + (Math.random() - 0.5) * 40,
                y: l.clientY + (Math.random() - 0.5) * 40,
                size: Math.random() * 12 + 6,
                opacity: 0.9,
                life: 1,
              });
            r((u) => [...u, ...c]);
          };
        return (
          document.addEventListener("mousemove", o),
          document.addEventListener("click", a),
          () => {
            document.removeEventListener("mousemove", o),
              document.removeEventListener("click", a);
          }
        );
      }, []),
      P.useEffect(() => {
        const o = setInterval(() => {
          r((a) =>
            a
              .map((l) => ({
                ...l,
                life: l.life - 0.02,
                opacity: l.opacity * 0.98,
                y: l.y - 0.5,
                size: l.size * 1.01,
              }))
              .filter((l) => l.life > 0 && l.opacity > 0.1)
          );
        }, 16);
        return () => clearInterval(o);
      }, []),
      T.jsxs("div", {
        className: "fixed inset-0 pointer-events-none z-[9999] overflow-hidden",
        children: [
          T.jsx("div", {
            className:
              "fixed w-4 h-4 rounded-full border-2 border-primary/60 transition-transform duration-100 ease-out",
            style: {
              left: n.x - 8,
              top: n.y - 8,
              transform: "translate(0, 0)",
            },
          }),
          t.map((o) =>
            T.jsx(
              "div",
              {
                className: "fixed rounded-full bg-primary/40 animate-pulse",
                style: {
                  left: o.x - o.size / 2,
                  top: o.y - o.size / 2,
                  width: o.size,
                  height: o.size,
                  opacity: o.opacity,
                  transform: `scale(${o.life})`,
                  background: `radial-gradient(circle, hsl(var(--primary) / ${
                    o.opacity
                  }), hsl(var(--primary) / ${o.opacity * 0.3}))`,
                },
              },
              o.id
            )
          ),
          T.jsx("div", {
            className:
              "fixed w-2 h-2 rounded-full bg-primary/30 transition-all duration-200 ease-out",
            style: {
              left: n.x - 4,
              top: n.y - 4,
              transform: "translate(0, 0)",
            },
          }),
        ],
      })
    );
  };
var AS = "focusScope.autoFocusOnMount",
  RS = "focusScope.autoFocusOnUnmount",
  v2 = { bubbles: !1, cancelable: !0 },
  XK = "FocusScope",
  UM = P.forwardRef((n, e) => {
    const {
        loop: t = !1,
        trapped: r = !1,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        ...o
      } = n,
      [a, l] = P.useState(null),
      c = ks(i),
      u = ks(s),
      f = P.useRef(null),
      p = pn(e, (y) => l(y)),
      m = P.useRef({
        paused: !1,
        pause() {
          this.paused = !0;
        },
        resume() {
          this.paused = !1;
        },
      }).current;
    P.useEffect(() => {
      if (r) {
        let y = function (S) {
            if (m.paused || !a) return;
            const b = S.target;
            a.contains(b) ? (f.current = b) : Pa(f.current, { select: !0 });
          },
          x = function (S) {
            if (m.paused || !a) return;
            const b = S.relatedTarget;
            b !== null && (a.contains(b) || Pa(f.current, { select: !0 }));
          },
          g = function (S) {
            if (document.activeElement === document.body)
              for (const C of S) C.removedNodes.length > 0 && Pa(a);
          };
        document.addEventListener("focusin", y),
          document.addEventListener("focusout", x);
        const _ = new MutationObserver(g);
        return (
          a && _.observe(a, { childList: !0, subtree: !0 }),
          () => {
            document.removeEventListener("focusin", y),
              document.removeEventListener("focusout", x),
              _.disconnect();
          }
        );
      }
    }, [r, a, m.paused]),
      P.useEffect(() => {
        if (a) {
          x2.add(m);
          const y = document.activeElement;
          if (!a.contains(y)) {
            const g = new CustomEvent(AS, v2);
            a.addEventListener(AS, c),
              a.dispatchEvent(g),
              g.defaultPrevented ||
                (qK(QK(eB(a)), { select: !0 }),
                document.activeElement === y && Pa(a));
          }
          return () => {
            a.removeEventListener(AS, c),
              setTimeout(() => {
                const g = new CustomEvent(RS, v2);
                a.addEventListener(RS, u),
                  a.dispatchEvent(g),
                  g.defaultPrevented || Pa(y ?? document.body, { select: !0 }),
                  a.removeEventListener(RS, u),
                  x2.remove(m);
              }, 0);
          };
        }
      }, [a, c, u, m]);
    const v = P.useCallback(
      (y) => {
        if ((!t && !r) || m.paused) return;
        const x = y.key === "Tab" && !y.altKey && !y.ctrlKey && !y.metaKey,
          g = document.activeElement;
        if (x && g) {
          const _ = y.currentTarget,
            [S, b] = KK(_);
          S && b
            ? !y.shiftKey && g === b
              ? (y.preventDefault(), t && Pa(S, { select: !0 }))
              : y.shiftKey &&
                g === S &&
                (y.preventDefault(), t && Pa(b, { select: !0 }))
            : g === _ && y.preventDefault();
        }
      },
      [t, r, m.paused]
    );
    return T.jsx(Kt.div, { tabIndex: -1, ...o, ref: p, onKeyDown: v });
  });
UM.displayName = XK;
function qK(n, { select: e = !1 } = {}) {
  const t = document.activeElement;
  for (const r of n)
    if ((Pa(r, { select: e }), document.activeElement !== t)) return;
}
function KK(n) {
  const e = eB(n),
    t = y2(e, n),
    r = y2(e.reverse(), n);
  return [t, r];
}
function eB(n) {
  const e = [],
    t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const i = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || i
          ? NodeFilter.FILTER_SKIP
          : r.tabIndex >= 0
          ? NodeFilter.FILTER_ACCEPT
          : NodeFilter.FILTER_SKIP;
      },
    });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function y2(n, e) {
  for (const t of n) if (!YK(t, { upTo: e })) return t;
}
function YK(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function JK(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function Pa(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== t && JK(n) && e && n.select();
  }
}
var x2 = ZK();
function ZK() {
  let n = [];
  return {
    add(e) {
      const t = n[0];
      e !== t && (t == null || t.pause()), (n = _2(n, e)), n.unshift(e);
    },
    remove(e) {
      var t;
      (n = _2(n, e)), (t = n[0]) == null || t.resume();
    },
  };
}
function _2(n, e) {
  const t = [...n],
    r = t.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
function QK(n) {
  return n.filter((e) => e.tagName !== "A");
}
var PS = 0;
function tB() {
  P.useEffect(() => {
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return (
      document.body.insertAdjacentElement("afterbegin", n[0] ?? w2()),
      document.body.insertAdjacentElement("beforeend", n[1] ?? w2()),
      PS++,
      () => {
        PS === 1 &&
          document
            .querySelectorAll("[data-radix-focus-guard]")
            .forEach((e) => e.remove()),
          PS--;
      }
    );
  }, []);
}
function w2() {
  const n = document.createElement("span");
  return (
    n.setAttribute("data-radix-focus-guard", ""),
    (n.tabIndex = 0),
    (n.style.outline = "none"),
    (n.style.opacity = "0"),
    (n.style.position = "fixed"),
    (n.style.pointerEvents = "none"),
    n
  );
}
var Ey = "right-scroll-bar-position",
  Ty = "width-before-scroll-bar",
  eY = "with-scroll-bars-hidden",
  tY = "--removed-body-scroll-bar-size";
function IS(n, e) {
  return typeof n == "function" ? n(e) : n && (n.current = e), n;
}
function nY(n, e) {
  var t = P.useState(function () {
    return {
      value: n,
      callback: e,
      facade: {
        get current() {
          return t.value;
        },
        set current(r) {
          var i = t.value;
          i !== r && ((t.value = r), t.callback(r, i));
        },
      },
    };
  })[0];
  return (t.callback = e), t.facade;
}
var rY = typeof window < "u" ? P.useLayoutEffect : P.useEffect,
  S2 = new WeakMap();
function iY(n, e) {
  var t = nY(null, function (r) {
    return n.forEach(function (i) {
      return IS(i, r);
    });
  });
  return (
    rY(
      function () {
        var r = S2.get(t);
        if (r) {
          var i = new Set(r),
            s = new Set(n),
            o = t.current;
          i.forEach(function (a) {
            s.has(a) || IS(a, null);
          }),
            s.forEach(function (a) {
              i.has(a) || IS(a, o);
            });
        }
        S2.set(t, n);
      },
      [n]
    ),
    t
  );
}
function sY(n) {
  return n;
}
function oY(n, e) {
  e === void 0 && (e = sY);
  var t = [],
    r = !1,
    i = {
      read: function () {
        if (r)
          throw new Error(
            "Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."
          );
        return t.length ? t[t.length - 1] : n;
      },
      useMedium: function (s) {
        var o = e(s, r);
        return (
          t.push(o),
          function () {
            t = t.filter(function (a) {
              return a !== o;
            });
          }
        );
      },
      assignSyncMedium: function (s) {
        for (r = !0; t.length; ) {
          var o = t;
          (t = []), o.forEach(s);
        }
        t = {
          push: function (a) {
            return s(a);
          },
          filter: function () {
            return t;
          },
        };
      },
      assignMedium: function (s) {
        r = !0;
        var o = [];
        if (t.length) {
          var a = t;
          (t = []), a.forEach(s), (o = t);
        }
        var l = function () {
            var u = o;
            (o = []), u.forEach(s);
          },
          c = function () {
            return Promise.resolve().then(l);
          };
        c(),
          (t = {
            push: function (u) {
              o.push(u), c();
            },
            filter: function (u) {
              return (o = o.filter(u)), t;
            },
          });
      },
    };
  return i;
}
function aY(n) {
  n === void 0 && (n = {});
  var e = oY(null);
  return (e.options = ts({ async: !0, ssr: !1 }, n)), e;
}
var nB = function (n) {
  var e = n.sideCar,
    t = yl(n, ["sideCar"]);
  if (!e)
    throw new Error(
      "Sidecar: please provide `sideCar` property to import the right car"
    );
  var r = e.read();
  if (!r) throw new Error("Sidecar medium not found");
  return P.createElement(r, ts({}, t));
};
nB.isSideCarExport = !0;
function lY(n, e) {
  return n.useMedium(e), nB;
}
var rB = aY(),
  NS = function () {},
  Vx = P.forwardRef(function (n, e) {
    var t = P.useRef(null),
      r = P.useState({
        onScrollCapture: NS,
        onWheelCapture: NS,
        onTouchMoveCapture: NS,
      }),
      i = r[0],
      s = r[1],
      o = n.forwardProps,
      a = n.children,
      l = n.className,
      c = n.removeScrollBar,
      u = n.enabled,
      f = n.shards,
      p = n.sideCar,
      m = n.noRelative,
      v = n.noIsolation,
      y = n.inert,
      x = n.allowPinchZoom,
      g = n.as,
      _ = g === void 0 ? "div" : g,
      S = n.gapMode,
      b = yl(n, [
        "forwardProps",
        "children",
        "className",
        "removeScrollBar",
        "enabled",
        "shards",
        "sideCar",
        "noRelative",
        "noIsolation",
        "inert",
        "allowPinchZoom",
        "as",
        "gapMode",
      ]),
      C = p,
      A = iY([t, e]),
      R = ts(ts({}, b), i);
    return P.createElement(
      P.Fragment,
      null,
      u &&
        P.createElement(C, {
          sideCar: rB,
          removeScrollBar: c,
          shards: f,
          noRelative: m,
          noIsolation: v,
          inert: y,
          setCallbacks: s,
          allowPinchZoom: !!x,
          lockRef: t,
          gapMode: S,
        }),
      o
        ? P.cloneElement(P.Children.only(a), ts(ts({}, R), { ref: A }))
        : P.createElement(_, ts({}, R, { className: l, ref: A }), a)
    );
  });
Vx.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 };
Vx.classNames = { fullWidth: Ty, zeroRight: Ey };
var cY = function () {
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__;
};
function uY() {
  if (!document) return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var e = cY();
  return e && n.setAttribute("nonce", e), n;
}
function dY(n, e) {
  n.styleSheet
    ? (n.styleSheet.cssText = e)
    : n.appendChild(document.createTextNode(e));
}
function hY(n) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(n);
}
var fY = function () {
    var n = 0,
      e = null;
    return {
      add: function (t) {
        n == 0 && (e = uY()) && (dY(e, t), hY(e)), n++;
      },
      remove: function () {
        n--,
          !n && e && (e.parentNode && e.parentNode.removeChild(e), (e = null));
      },
    };
  },
  pY = function () {
    var n = fY();
    return function (e, t) {
      P.useEffect(
        function () {
          return (
            n.add(e),
            function () {
              n.remove();
            }
          );
        },
        [e && t]
      );
    };
  },
  iB = function () {
    var n = pY(),
      e = function (t) {
        var r = t.styles,
          i = t.dynamic;
        return n(r, i), null;
      };
    return e;
  },
  mY = { left: 0, top: 0, right: 0, gap: 0 },
  LS = function (n) {
    return parseInt(n || "", 10) || 0;
  },
  gY = function (n) {
    var e = window.getComputedStyle(document.body),
      t = e[n === "padding" ? "paddingLeft" : "marginLeft"],
      r = e[n === "padding" ? "paddingTop" : "marginTop"],
      i = e[n === "padding" ? "paddingRight" : "marginRight"];
    return [LS(t), LS(r), LS(i)];
  },
  vY = function (n) {
    if ((n === void 0 && (n = "margin"), typeof window > "u")) return mY;
    var e = gY(n),
      t = document.documentElement.clientWidth,
      r = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, r - t + e[2] - e[0]),
    };
  },
  yY = iB(),
  Ld = "data-scroll-locked",
  xY = function (n, e, t, r) {
    var i = n.left,
      s = n.top,
      o = n.right,
      a = n.gap;
    return (
      t === void 0 && (t = "margin"),
      `
  .`
        .concat(
          eY,
          ` {
   overflow: hidden `
        )
        .concat(
          r,
          `;
   padding-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  body[`
        )
        .concat(
          Ld,
          `] {
    overflow: hidden `
        )
        .concat(
          r,
          `;
    overscroll-behavior: contain;
    `
        )
        .concat(
          [
            e && "position: relative ".concat(r, ";"),
            t === "margin" &&
              `
    padding-left: `
                .concat(
                  i,
                  `px;
    padding-top: `
                )
                .concat(
                  s,
                  `px;
    padding-right: `
                )
                .concat(
                  o,
                  `px;
    margin-left:0;
    margin-top:0;
    margin-right: `
                )
                .concat(a, "px ")
                .concat(
                  r,
                  `;
    `
                ),
            t === "padding" &&
              "padding-right: ".concat(a, "px ").concat(r, ";"),
          ]
            .filter(Boolean)
            .join(""),
          `
  }
  
  .`
        )
        .concat(
          Ey,
          ` {
    right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(
          Ty,
          ` {
    margin-right: `
        )
        .concat(a, "px ")
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Ey, " .")
        .concat(
          Ey,
          ` {
    right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  .`
        )
        .concat(Ty, " .")
        .concat(
          Ty,
          ` {
    margin-right: 0 `
        )
        .concat(
          r,
          `;
  }
  
  body[`
        )
        .concat(
          Ld,
          `] {
    `
        )
        .concat(tY, ": ")
        .concat(
          a,
          `px;
  }
`
        )
    );
  },
  b2 = function () {
    var n = parseInt(document.body.getAttribute(Ld) || "0", 10);
    return isFinite(n) ? n : 0;
  },
  _Y = function () {
    P.useEffect(function () {
      return (
        document.body.setAttribute(Ld, (b2() + 1).toString()),
        function () {
          var n = b2() - 1;
          n <= 0
            ? document.body.removeAttribute(Ld)
            : document.body.setAttribute(Ld, n.toString());
        }
      );
    }, []);
  },
  wY = function (n) {
    var e = n.noRelative,
      t = n.noImportant,
      r = n.gapMode,
      i = r === void 0 ? "margin" : r;
    _Y();
    var s = P.useMemo(
      function () {
        return vY(i);
      },
      [i]
    );
    return P.createElement(yY, { styles: xY(s, !e, i, t ? "" : "!important") });
  },
  mE = !1;
if (typeof window < "u")
  try {
    var lv = Object.defineProperty({}, "passive", {
      get: function () {
        return (mE = !0), !0;
      },
    });
    window.addEventListener("test", lv, lv),
      window.removeEventListener("test", lv, lv);
  } catch {
    mE = !1;
  }
var bu = mE ? { passive: !1 } : !1,
  SY = function (n) {
    return n.tagName === "TEXTAREA";
  },
  sB = function (n, e) {
    if (!(n instanceof Element)) return !1;
    var t = window.getComputedStyle(n);
    return (
      t[e] !== "hidden" &&
      !(t.overflowY === t.overflowX && !SY(n) && t[e] === "visible")
    );
  },
  bY = function (n) {
    return sB(n, "overflowY");
  },
  EY = function (n) {
    return sB(n, "overflowX");
  },
  E2 = function (n, e) {
    var t = e.ownerDocument,
      r = e;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var i = oB(n, r);
      if (i) {
        var s = aB(n, r),
          o = s[1],
          a = s[2];
        if (o > a) return !0;
      }
      r = r.parentNode;
    } while (r && r !== t.body);
    return !1;
  },
  TY = function (n) {
    var e = n.scrollTop,
      t = n.scrollHeight,
      r = n.clientHeight;
    return [e, t, r];
  },
  MY = function (n) {
    var e = n.scrollLeft,
      t = n.scrollWidth,
      r = n.clientWidth;
    return [e, t, r];
  },
  oB = function (n, e) {
    return n === "v" ? bY(e) : EY(e);
  },
  aB = function (n, e) {
    return n === "v" ? TY(e) : MY(e);
  },
  CY = function (n, e) {
    return n === "h" && e === "rtl" ? -1 : 1;
  },
  AY = function (n, e, t, r, i) {
    var s = CY(n, window.getComputedStyle(e).direction),
      o = s * r,
      a = t.target,
      l = e.contains(a),
      c = !1,
      u = o > 0,
      f = 0,
      p = 0;
    do {
      if (!a) break;
      var m = aB(n, a),
        v = m[0],
        y = m[1],
        x = m[2],
        g = y - x - s * v;
      (v || g) && oB(n, a) && ((f += g), (p += v));
      var _ = a.parentNode;
      a = _ && _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? _.host : _;
    } while ((!l && a !== document.body) || (l && (e.contains(a) || e === a)));
    return (
      ((u && (Math.abs(f) < 1 || !i)) || (!u && (Math.abs(p) < 1 || !i))) &&
        (c = !0),
      c
    );
  },
  cv = function (n) {
    return "changedTouches" in n
      ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY]
      : [0, 0];
  },
  T2 = function (n) {
    return [n.deltaX, n.deltaY];
  },
  M2 = function (n) {
    return n && "current" in n ? n.current : n;
  },
  RY = function (n, e) {
    return n[0] === e[0] && n[1] === e[1];
  },
  PY = function (n) {
    return `
  .block-interactivity-`
      .concat(
        n,
        ` {pointer-events: none;}
  .allow-interactivity-`
      )
      .concat(
        n,
        ` {pointer-events: all;}
`
      );
  },
  IY = 0,
  Eu = [];
function NY(n) {
  var e = P.useRef([]),
    t = P.useRef([0, 0]),
    r = P.useRef(),
    i = P.useState(IY++)[0],
    s = P.useState(iB)[0],
    o = P.useRef(n);
  P.useEffect(
    function () {
      o.current = n;
    },
    [n]
  ),
    P.useEffect(
      function () {
        if (n.inert) {
          document.body.classList.add("block-interactivity-".concat(i));
          var y = CM([n.lockRef.current], (n.shards || []).map(M2), !0).filter(
            Boolean
          );
          return (
            y.forEach(function (x) {
              return x.classList.add("allow-interactivity-".concat(i));
            }),
            function () {
              document.body.classList.remove("block-interactivity-".concat(i)),
                y.forEach(function (x) {
                  return x.classList.remove("allow-interactivity-".concat(i));
                });
            }
          );
        }
      },
      [n.inert, n.lockRef.current, n.shards]
    );
  var a = P.useCallback(function (y, x) {
      if (
        ("touches" in y && y.touches.length === 2) ||
        (y.type === "wheel" && y.ctrlKey)
      )
        return !o.current.allowPinchZoom;
      var g = cv(y),
        _ = t.current,
        S = "deltaX" in y ? y.deltaX : _[0] - g[0],
        b = "deltaY" in y ? y.deltaY : _[1] - g[1],
        C,
        A = y.target,
        R = Math.abs(S) > Math.abs(b) ? "h" : "v";
      if ("touches" in y && R === "h" && A.type === "range") return !1;
      var O = E2(R, A);
      if (!O) return !0;
      if ((O ? (C = R) : ((C = R === "v" ? "h" : "v"), (O = E2(R, A))), !O))
        return !1;
      if (
        (!r.current && "changedTouches" in y && (S || b) && (r.current = C), !C)
      )
        return !0;
      var I = r.current || C;
      return AY(I, x, y, I === "h" ? S : b, !0);
    }, []),
    l = P.useCallback(function (y) {
      var x = y;
      if (!(!Eu.length || Eu[Eu.length - 1] !== s)) {
        var g = "deltaY" in x ? T2(x) : cv(x),
          _ = e.current.filter(function (C) {
            return (
              C.name === x.type &&
              (C.target === x.target || x.target === C.shadowParent) &&
              RY(C.delta, g)
            );
          })[0];
        if (_ && _.should) {
          x.cancelable && x.preventDefault();
          return;
        }
        if (!_) {
          var S = (o.current.shards || [])
              .map(M2)
              .filter(Boolean)
              .filter(function (C) {
                return C.contains(x.target);
              }),
            b = S.length > 0 ? a(x, S[0]) : !o.current.noIsolation;
          b && x.cancelable && x.preventDefault();
        }
      }
    }, []),
    c = P.useCallback(function (y, x, g, _) {
      var S = { name: y, delta: x, target: g, should: _, shadowParent: LY(g) };
      e.current.push(S),
        setTimeout(function () {
          e.current = e.current.filter(function (b) {
            return b !== S;
          });
        }, 1);
    }, []),
    u = P.useCallback(function (y) {
      (t.current = cv(y)), (r.current = void 0);
    }, []),
    f = P.useCallback(function (y) {
      c(y.type, T2(y), y.target, a(y, n.lockRef.current));
    }, []),
    p = P.useCallback(function (y) {
      c(y.type, cv(y), y.target, a(y, n.lockRef.current));
    }, []);
  P.useEffect(function () {
    return (
      Eu.push(s),
      n.setCallbacks({
        onScrollCapture: f,
        onWheelCapture: f,
        onTouchMoveCapture: p,
      }),
      document.addEventListener("wheel", l, bu),
      document.addEventListener("touchmove", l, bu),
      document.addEventListener("touchstart", u, bu),
      function () {
        (Eu = Eu.filter(function (y) {
          return y !== s;
        })),
          document.removeEventListener("wheel", l, bu),
          document.removeEventListener("touchmove", l, bu),
          document.removeEventListener("touchstart", u, bu);
      }
    );
  }, []);
  var m = n.removeScrollBar,
    v = n.inert;
  return P.createElement(
    P.Fragment,
    null,
    v ? P.createElement(s, { styles: PY(i) }) : null,
    m
      ? P.createElement(wY, { noRelative: n.noRelative, gapMode: n.gapMode })
      : null
  );
}
function LY(n) {
  for (var e = null; n !== null; )
    n instanceof ShadowRoot && ((e = n.host), (n = n.host)), (n = n.parentNode);
  return e;
}
const OY = lY(rB, NY);
var FM = P.forwardRef(function (n, e) {
  return P.createElement(Vx, ts({}, n, { ref: e, sideCar: OY }));
});
FM.classNames = Vx.classNames;
var DY = function (n) {
    if (typeof document > "u") return null;
    var e = Array.isArray(n) ? n[0] : n;
    return e.ownerDocument.body;
  },
  Tu = new WeakMap(),
  uv = new WeakMap(),
  dv = {},
  OS = 0,
  lB = function (n) {
    return n && (n.host || lB(n.parentNode));
  },
  kY = function (n, e) {
    return e
      .map(function (t) {
        if (n.contains(t)) return t;
        var r = lB(t);
        return r && n.contains(r)
          ? r
          : (console.error(
              "aria-hidden",
              t,
              "in not contained inside",
              n,
              ". Doing nothing"
            ),
            null);
      })
      .filter(function (t) {
        return !!t;
      });
  },
  UY = function (n, e, t, r) {
    var i = kY(e, Array.isArray(n) ? n : [n]);
    dv[t] || (dv[t] = new WeakMap());
    var s = dv[t],
      o = [],
      a = new Set(),
      l = new Set(i),
      c = function (f) {
        !f || a.has(f) || (a.add(f), c(f.parentNode));
      };
    i.forEach(c);
    var u = function (f) {
      !f ||
        l.has(f) ||
        Array.prototype.forEach.call(f.children, function (p) {
          if (a.has(p)) u(p);
          else
            try {
              var m = p.getAttribute(r),
                v = m !== null && m !== "false",
                y = (Tu.get(p) || 0) + 1,
                x = (s.get(p) || 0) + 1;
              Tu.set(p, y),
                s.set(p, x),
                o.push(p),
                y === 1 && v && uv.set(p, !0),
                x === 1 && p.setAttribute(t, "true"),
                v || p.setAttribute(r, "true");
            } catch (g) {
              console.error("aria-hidden: cannot operate on ", p, g);
            }
        });
    };
    return (
      u(e),
      a.clear(),
      OS++,
      function () {
        o.forEach(function (f) {
          var p = Tu.get(f) - 1,
            m = s.get(f) - 1;
          Tu.set(f, p),
            s.set(f, m),
            p || (uv.has(f) || f.removeAttribute(r), uv.delete(f)),
            m || f.removeAttribute(t);
        }),
          OS--,
          OS ||
            ((Tu = new WeakMap()),
            (Tu = new WeakMap()),
            (uv = new WeakMap()),
            (dv = {}));
      }
    );
  },
  cB = function (n, e, t) {
    t === void 0 && (t = "data-aria-hidden");
    var r = Array.from(Array.isArray(n) ? n : [n]),
      i = DY(n);
    return i
      ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))),
        UY(r, i, t, "aria-hidden"))
      : function () {
          return null;
        };
  },
  jx = "Dialog",
  [uB, ohe] = yh(jx),
  [FY, Bs] = uB(jx),
  dB = (n) => {
    const {
        __scopeDialog: e,
        children: t,
        open: r,
        defaultOpen: i,
        onOpenChange: s,
        modal: o = !0,
      } = n,
      a = P.useRef(null),
      l = P.useRef(null),
      [c, u] = i0({ prop: r, defaultProp: i ?? !1, onChange: s, caller: jx });
    return T.jsx(FY, {
      scope: e,
      triggerRef: a,
      contentRef: l,
      contentId: Pd(),
      titleId: Pd(),
      descriptionId: Pd(),
      open: c,
      onOpenChange: u,
      onOpenToggle: P.useCallback(() => u((f) => !f), [u]),
      modal: o,
      children: t,
    });
  };
dB.displayName = jx;
var hB = "DialogTrigger",
  fB = P.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      i = Bs(hB, t),
      s = pn(e, i.triggerRef);
    return T.jsx(Kt.button, {
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": i.open,
      "aria-controls": i.contentId,
      "data-state": VM(i.open),
      ...r,
      ref: s,
      onClick: Bt(n.onClick, i.onOpenToggle),
    });
  });
fB.displayName = hB;
var BM = "DialogPortal",
  [BY, pB] = uB(BM, { forceMount: void 0 }),
  mB = (n) => {
    const { __scopeDialog: e, forceMount: t, children: r, container: i } = n,
      s = Bs(BM, e);
    return T.jsx(BY, {
      scope: e,
      forceMount: t,
      children: P.Children.map(r, (o) =>
        T.jsx(xh, {
          present: t || s.open,
          children: T.jsx(Cx, { asChild: !0, container: i, children: o }),
        })
      ),
    });
  };
mB.displayName = BM;
var g0 = "DialogOverlay",
  gB = P.forwardRef((n, e) => {
    const t = pB(g0, n.__scopeDialog),
      { forceMount: r = t.forceMount, ...i } = n,
      s = Bs(g0, n.__scopeDialog);
    return s.modal
      ? T.jsx(xh, {
          present: r || s.open,
          children: T.jsx(VY, { ...i, ref: e }),
        })
      : null;
  });
gB.displayName = g0;
var zY = Zd("DialogOverlay.RemoveScroll"),
  VY = P.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      i = Bs(g0, t);
    return T.jsx(FM, {
      as: zY,
      allowPinchZoom: !0,
      shards: [i.contentRef],
      children: T.jsx(Kt.div, {
        "data-state": VM(i.open),
        ...r,
        ref: e,
        style: { pointerEvents: "auto", ...r.style },
      }),
    });
  }),
  Bc = "DialogContent",
  vB = P.forwardRef((n, e) => {
    const t = pB(Bc, n.__scopeDialog),
      { forceMount: r = t.forceMount, ...i } = n,
      s = Bs(Bc, n.__scopeDialog);
    return T.jsx(xh, {
      present: r || s.open,
      children: s.modal
        ? T.jsx(jY, { ...i, ref: e })
        : T.jsx(HY, { ...i, ref: e }),
    });
  });
vB.displayName = Bc;
var jY = P.forwardRef((n, e) => {
    const t = Bs(Bc, n.__scopeDialog),
      r = P.useRef(null),
      i = pn(e, t.contentRef, r);
    return (
      P.useEffect(() => {
        const s = r.current;
        if (s) return cB(s);
      }, []),
      T.jsx(yB, {
        ...n,
        ref: i,
        trapFocus: t.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Bt(n.onCloseAutoFocus, (s) => {
          var o;
          s.preventDefault(), (o = t.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Bt(n.onPointerDownOutside, (s) => {
          const o = s.detail.originalEvent,
            a = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || a) && s.preventDefault();
        }),
        onFocusOutside: Bt(n.onFocusOutside, (s) => s.preventDefault()),
      })
    );
  }),
  HY = P.forwardRef((n, e) => {
    const t = Bs(Bc, n.__scopeDialog),
      r = P.useRef(!1),
      i = P.useRef(!1);
    return T.jsx(yB, {
      ...n,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: (s) => {
        var o, a;
        (o = n.onCloseAutoFocus) == null || o.call(n, s),
          s.defaultPrevented ||
            (r.current || (a = t.triggerRef.current) == null || a.focus(),
            s.preventDefault()),
          (r.current = !1),
          (i.current = !1);
      },
      onInteractOutside: (s) => {
        var l, c;
        (l = n.onInteractOutside) == null || l.call(n, s),
          s.defaultPrevented ||
            ((r.current = !0),
            s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
        const o = s.target;
        ((c = t.triggerRef.current) == null ? void 0 : c.contains(o)) &&
          s.preventDefault(),
          s.detail.originalEvent.type === "focusin" &&
            i.current &&
            s.preventDefault();
      },
    });
  }),
  yB = P.forwardRef((n, e) => {
    const {
        __scopeDialog: t,
        trapFocus: r,
        onOpenAutoFocus: i,
        onCloseAutoFocus: s,
        ...o
      } = n,
      a = Bs(Bc, t),
      l = P.useRef(null),
      c = pn(e, l);
    return (
      tB(),
      T.jsxs(T.Fragment, {
        children: [
          T.jsx(UM, {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: i,
            onUnmountAutoFocus: s,
            children: T.jsx(pm, {
              role: "dialog",
              id: a.contentId,
              "aria-describedby": a.descriptionId,
              "aria-labelledby": a.titleId,
              "data-state": VM(a.open),
              ...o,
              ref: c,
              onDismiss: () => a.onOpenChange(!1),
            }),
          }),
          T.jsxs(T.Fragment, {
            children: [
              T.jsx(WY, { titleId: a.titleId }),
              T.jsx($Y, { contentRef: l, descriptionId: a.descriptionId }),
            ],
          }),
        ],
      })
    );
  }),
  zM = "DialogTitle",
  xB = P.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      i = Bs(zM, t);
    return T.jsx(Kt.h2, { id: i.titleId, ...r, ref: e });
  });
xB.displayName = zM;
var _B = "DialogDescription",
  wB = P.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      i = Bs(_B, t);
    return T.jsx(Kt.p, { id: i.descriptionId, ...r, ref: e });
  });
wB.displayName = _B;
var SB = "DialogClose",
  bB = P.forwardRef((n, e) => {
    const { __scopeDialog: t, ...r } = n,
      i = Bs(SB, t);
    return T.jsx(Kt.button, {
      type: "button",
      ...r,
      ref: e,
      onClick: Bt(n.onClick, () => i.onOpenChange(!1)),
    });
  });
bB.displayName = SB;
function VM(n) {
  return n ? "open" : "closed";
}
var EB = "DialogTitleWarning",
  [ahe, TB] = NG(EB, { contentName: Bc, titleName: zM, docsSlug: "dialog" }),
  WY = ({ titleId: n }) => {
    const e = TB(EB),
      t = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
    return (
      P.useEffect(() => {
        n && (document.getElementById(n) || console.error(t));
      }, [t, n]),
      null
    );
  },
  GY = "DialogDescriptionWarning",
  $Y = ({ contentRef: n, descriptionId: e }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${
      TB(GY).contentName
    }}.`;
    return (
      P.useEffect(() => {
        var s;
        const i =
          (s = n.current) == null ? void 0 : s.getAttribute("aria-describedby");
        e && i && (document.getElementById(e) || console.warn(r));
      }, [r, n, e]),
      null
    );
  },
  XY = dB,
  qY = fB,
  KY = mB,
  MB = gB,
  CB = vB,
  AB = xB,
  RB = wB,
  YY = bB;
const PB = XY,
  JY = qY,
  ZY = KY,
  IB = P.forwardRef(({ className: n, ...e }, t) =>
    T.jsx(MB, {
      ref: t,
      className: qt(
        "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        n
      ),
      ...e,
    })
  );
IB.displayName = MB.displayName;
const jM = P.forwardRef(({ className: n, children: e, ...t }, r) =>
  T.jsxs(ZY, {
    children: [
      T.jsx(IB, {}),
      T.jsxs(CB, {
        ref: r,
        className: qt(
          "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
          n
        ),
        ...t,
        children: [
          e,
          T.jsxs(YY, {
            className:
              "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",
            children: [
              T.jsx(B3, { className: "h-4 w-4" }),
              T.jsx("span", { className: "sr-only", children: "Close" }),
            ],
          }),
        ],
      }),
    ],
  })
);
jM.displayName = CB.displayName;
const HM = ({ className: n, ...e }) =>
  T.jsx("div", {
    className: qt("flex flex-col space-y-1.5 text-center sm:text-left", n),
    ...e,
  });
HM.displayName = "DialogHeader";
const WM = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(AB, {
    ref: t,
    className: qt("text-lg font-semibold leading-none tracking-tight", n),
    ...e,
  })
);
WM.displayName = AB.displayName;
const QY = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(RB, { ref: t, className: qt("text-sm text-muted-foreground", n), ...e })
);
QY.displayName = RB.displayName;
const eJ = lM(
    "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
    {
      variants: {
        variant: {
          default: "bg-primary text-primary-foreground hover:bg-primary/90",
          destructive:
            "bg-destructive text-destructive-foreground hover:bg-destructive/90",
          outline:
            "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
          secondary:
            "bg-secondary text-secondary-foreground hover:bg-secondary/80",
          ghost: "hover:bg-accent hover:text-accent-foreground",
          link: "text-primary underline-offset-4 hover:underline",
        },
        size: {
          default: "h-10 px-4 py-2",
          sm: "h-9 rounded-md px-3",
          lg: "h-11 rounded-md px-8",
          icon: "h-10 w-10",
        },
      },
      defaultVariants: { variant: "default", size: "default" },
    }
  ),
  ho = P.forwardRef(
    ({ className: n, variant: e, size: t, asChild: r = !1, ...i }, s) => {
      const o = r ? OG : "button";
      return T.jsx(o, {
        className: qt(eJ({ variant: e, size: t, className: n })),
        ref: s,
        ...i,
      });
    }
  );
ho.displayName = "Button";
const tJ = ({ x: n, y: e, isOpen: t, onClose: r }) => {
    const {
        getModeFilteredTiles: i,
        setActiveConversation: s,
        messages: o,
      } = la(),
      { currentMode: a } = kM(),
      [l, c] = P.useState([]),
      [u, f] = P.useState(!1),
      p = i(),
      m = `${n}-${e}`,
      v = p.get(m);
    P.useEffect(() => {
      t &&
        (async () => {
          if (!(v != null && v.conversationId)) {
            c([]);
            return;
          }
          f(!0);
          try {
            const _ = o.get(v.conversationId);
            if (_ && _.length > 0) {
              console.log("Using stored messages:", _.length), c(_), f(!1);
              return;
            }
            console.log(
              "Fetching messages for conversation:",
              v.conversationId
            );
            const S = await ol.getMessages(v.conversationId);
            console.log("Fetched messages:", S.length), c(S);
          } catch (_) {
            console.error("Failed to load messages:", _), c([]);
          } finally {
            f(!1);
          }
        })();
    }, [t, v == null ? void 0 : v.conversationId, o]);
    const y = async () => {
        try {
          const g = await ol.startConversation(n, e, a);
          s(g),
            es.success("New conversation started!"),
            r(),
            (window.location.href = "/chat");
        } catch (g) {
          es.error("Failed to start conversation"),
            console.error("Start chat error:", g);
        }
      },
      x = (g) => new Date(g).toLocaleString();
    return T.jsx(PB, {
      open: t,
      onOpenChange: r,
      children: T.jsxs(jM, {
        className: "max-w-md",
        children: [
          T.jsx(HM, {
            children: T.jsxs(WM, {
              className: "flex items-center space-x-2",
              children: [
                T.jsx(cM, { className: "w-4 h-4 text-primary" }),
                T.jsxs("span", {
                  className: "font-mono",
                  children: ["Tile (", n, ", ", e, ")"],
                }),
              ],
            }),
          }),
          T.jsxs("div", {
            className: "space-y-4",
            children: [
              T.jsx("div", {
                className: "zPush-card bg-secondary/20 p-4",
                children: T.jsxs("div", {
                  className: "grid grid-cols-3 gap-4 text-sm",
                  children: [
                    T.jsxs("div", {
                      className: "text-center",
                      children: [
                        T.jsx("div", {
                          className: "font-mono text-xs text-muted-foreground",
                          children: "HEAT",
                        }),
                        T.jsx("div", {
                          className: "font-bold text-primary",
                          children: (v == null ? void 0 : v.heat) || 0,
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "text-center",
                      children: [
                        T.jsx("div", {
                          className: "font-mono text-xs text-muted-foreground",
                          children: "CLICKS",
                        }),
                        T.jsx("div", {
                          className: "font-bold",
                          children: v != null && v.hasClick ? "YES" : "NO",
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "text-center",
                      children: [
                        T.jsx("div", {
                          className: "font-mono text-xs text-muted-foreground",
                          children: "ACTIVE",
                        }),
                        T.jsx("div", {
                          className: "font-bold",
                          children:
                            v != null &&
                            v.lastActivity &&
                            Date.now() - v.lastActivity.getTime() < 6e5
                              ? "YES"
                              : "NO",
                        }),
                      ],
                    }),
                  ],
                }),
              }),
              v != null && v.conversationId
                ? T.jsxs("div", {
                    className: "space-y-3",
                    children: [
                      T.jsxs("div", {
                        className: "flex items-center space-x-2 text-sm",
                        children: [
                          T.jsx(uM, { className: "w-4 h-4 text-primary" }),
                          T.jsxs("span", {
                            className: "font-mono",
                            children: ["CONVERSATION: ", v.conversationId],
                          }),
                        ],
                      }),
                      u
                        ? T.jsx("div", {
                            className: "text-center text-muted-foreground py-4",
                            children: "Loading messages...",
                          })
                        : l.length > 0
                        ? T.jsxs("div", {
                            className: "space-y-2 max-h-48 overflow-y-auto",
                            children: [
                              l
                                .slice(0, 3)
                                .map((g) =>
                                  T.jsxs(
                                    "div",
                                    {
                                      className: "zPush-message p-3 rounded",
                                      children: [
                                        T.jsxs("div", {
                                          className:
                                            "flex items-center justify-between mb-1",
                                          children: [
                                            T.jsxs("div", {
                                              className:
                                                "flex items-center space-x-2",
                                              children: [
                                                T.jsx(F3, {
                                                  className: "w-3 h-3",
                                                }),
                                                T.jsx("span", {
                                                  className:
                                                    "text-xs font-mono font-semibold uppercase",
                                                  children: g.sender,
                                                }),
                                              ],
                                            }),
                                            T.jsxs("div", {
                                              className:
                                                "flex items-center space-x-1 text-xs text-muted-foreground",
                                              children: [
                                                T.jsx(D3, {
                                                  className: "w-3 h-3",
                                                }),
                                                T.jsx("span", {
                                                  children: x(g.created_at),
                                                }),
                                              ],
                                            }),
                                          ],
                                        }),
                                        T.jsx("p", {
                                          className:
                                            "text-sm text-foreground line-clamp-2",
                                          children: g.content,
                                        }),
                                      ],
                                    },
                                    g.id
                                  )
                                ),
                              l.length > 3 &&
                                T.jsxs("div", {
                                  className:
                                    "text-center text-xs text-muted-foreground py-2",
                                  children: [
                                    "... and ",
                                    l.length - 3,
                                    " more messages",
                                  ],
                                }),
                            ],
                          })
                        : T.jsx("div", {
                            className: "text-center text-muted-foreground py-4",
                            children: "No messages yet",
                          }),
                      T.jsx(ho, {
                        onClick: () => {
                          s(v.conversationId),
                            r(),
                            (window.location.href = "/chat");
                        },
                        className: "w-full zPush-btn-primary",
                        children: "View Full Chat",
                      }),
                    ],
                  })
                : T.jsxs("div", {
                    className: "text-center space-y-3",
                    children: [
                      T.jsx("div", {
                        className: "text-muted-foreground",
                        children: "No conversation started yet",
                      }),
                      T.jsx(ho, {
                        onClick: y,
                        className: "zPush-btn-primary",
                        children: "Start New Conversation",
                      }),
                    ],
                  }),
              (v == null ? void 0 : v.lastActivity) &&
                T.jsxs("div", {
                  className: "text-xs text-muted-foreground text-center",
                  children: [
                    "Last activity: ",
                    x(v.lastActivity.toISOString()),
                  ],
                }),
            ],
          }),
        ],
      }),
    });
  },
  NB = () => {
    const n = P.useRef(null),
      e = P.useRef(),
      [t, r] = P.useState(null),
      {
        getModeFilteredTiles: i,
        gridWidth: s,
        gridHeight: o,
        initializeGrid: a,
        updateGridTile: l,
        messages: c,
        conversations: u,
      } = la(),
      f = i(),
      p = (S) => {
        if (!S.conversationId) return 0;
        const b = c.get(S.conversationId);
        return b ? b.length : 0;
      },
      [m, v] = P.useState({ width: 1200, height: 800 }),
      [y, x] = P.useState({ width: 12, height: 12 });
    P.useEffect(() => {
      const S = () => {
        const b = window.innerWidth,
          C = window.innerHeight;
        v({ width: b, height: C });
        const A = Math.max(8, Math.floor(b / s)),
          R = Math.max(8, Math.floor(C / o));
        x({ width: A, height: R });
      };
      return (
        S(),
        window.addEventListener("resize", S),
        () => window.removeEventListener("resize", S)
      );
    }, [s, o]),
      P.useEffect(() => {
        a(s, o);
      }, [a, s, o]),
      P.useEffect(() => {
        const S = n.current;
        if (!S) return;
        const b = S.getContext("2d");
        if (!b) return;
        const C = () => {
          b.clearRect(0, 0, S.width, S.height),
            (b.strokeStyle = "rgba(0, 0, 0, 0.1)"),
            (b.lineWidth = 1);
          for (let A = 0; A <= s; A++) {
            const R = A * y.width;
            b.beginPath(),
              b.moveTo(R, 0),
              b.lineTo(R, o * y.height),
              b.stroke();
          }
          for (let A = 0; A <= o; A++) {
            const R = A * y.height;
            b.beginPath(), b.moveTo(0, R), b.lineTo(s * y.width, R), b.stroke();
          }
          f.forEach((A) => {
            if (!A.conversationId) return;
            const R = A.x * y.width,
              O = A.y * y.height;
            let I = "";
            const N = p(A);
            if (
              (N === 0
                ? (I = "rgba(96, 165, 250, 0.5)")
                : N <= 2
                ? (I = "rgba(74, 222, 128, 0.6)")
                : N <= 5
                ? (I = "rgba(34, 197, 94, 0.75)")
                : N <= 10
                ? (I = "rgba(22, 163, 74, 0.85)")
                : (I = "rgba(21, 128, 61, 0.95)"),
              (b.fillStyle = I),
              b.fillRect(R, O, y.width, y.height),
              A.lastActivity && Date.now() - A.lastActivity.getTime() < 3e5)
            ) {
              const D = Date.now() - A.lastActivity.getTime(),
                j = Math.sin(Date.now() / 1e3) * 0.4 + 0.6,
                $ = Math.max(0, 1 - D / 3e5) * j;
              (b.fillStyle = `rgba(59, 130, 246, ${$ * 0.5})`),
                b.fillRect(R, O, y.width, y.height);
            }
            if (A.conversationId) {
              b.fillStyle = "rgba(255, 255, 255, 0.8)";
              const D = Math.max(2, y.width / 6),
                j = R + y.width - D - 1,
                $ = O + 1;
              b.fillRect(j, $, D, D);
            }
          }),
            (e.current = requestAnimationFrame(C));
        };
        return (
          C(),
          () => {
            e.current && cancelAnimationFrame(e.current);
          }
        );
      }, [f, y, m]);
    const g = async (S) => {
        const b = n.current;
        if (!b) return;
        const C = b.getBoundingClientRect(),
          A = Math.floor((S.clientX - C.left) / y.width),
          R = Math.floor((S.clientY - C.top) / y.height);
        if (!(A < 0 || A >= s || R < 0 || R >= o))
          try {
            await ol.clickTile(A, R),
              l(A, R, { hasClick: !0, lastActivity: new Date() }),
              r({ x: A, y: R });
          } catch (O) {
            es.error("Failed to register grid click"),
              console.error("Grid click error:", O);
          }
      },
      _ = (S) => {
        S.key === "Escape" && r(null);
      };
    return T.jsxs("div", {
      className: "w-full h-full",
      children: [
        T.jsx("canvas", {
          ref: n,
          width: m.width,
          height: m.height,
          className: "w-full h-full cursor-crosshair",
          onClick: g,
          onKeyDown: _,
          tabIndex: 0,
        }),
        t && T.jsx(tJ, { x: t.x, y: t.y, isOpen: !!t, onClose: () => r(null) }),
      ],
    });
  },
  Oa = P.forwardRef(({ className: n, ...e }, t) =>
    T.jsx("div", {
      ref: t,
      className: qt(
        "rounded-lg border bg-card text-card-foreground shadow-sm",
        n
      ),
      ...e,
    })
  );
Oa.displayName = "Card";
const Da = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx("div", {
    ref: t,
    className: qt("flex flex-col space-y-1.5 p-6", n),
    ...e,
  })
);
Da.displayName = "CardHeader";
const nc = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx("h3", {
    ref: t,
    className: qt("text-2xl font-semibold leading-none tracking-tight", n),
    ...e,
  })
);
nc.displayName = "CardTitle";
const gE = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx("p", {
    ref: t,
    className: qt("text-sm text-muted-foreground", n),
    ...e,
  })
);
gE.displayName = "CardDescription";
const ka = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx("div", { ref: t, className: qt("p-6 pt-0", n), ...e })
);
ka.displayName = "CardContent";
const nJ = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx("div", { ref: t, className: qt("flex items-center p-6 pt-0", n), ...e })
);
nJ.displayName = "CardFooter";
const rJ = ({
    conversation: n,
    messageCount: e = 0,
    lastMessage: t,
    onClick: r,
  }) => {
    const i = HU(),
      s = () => {
        r && r(), i("/chat");
      },
      o = (a) => new Date(a).toLocaleString();
    return T.jsxs(Oa, {
      className:
        "conversation-box bg-card/80 backdrop-blur-sm border-border hover:bg-card/90 transition-all cursor-pointer group",
      onClick: s,
      children: [
        T.jsx(Da, {
          className: "pb-2",
          children: T.jsxs("div", {
            className: "flex items-center justify-between",
            children: [
              T.jsxs("div", {
                className: "flex items-center gap-2",
                children: [
                  T.jsx(Sy, { className: "w-4 h-4 text-primary" }),
                  T.jsx("span", {
                    className: "text-sm font-mono text-foreground",
                    children: n.id.slice(-8),
                  }),
                ],
              }),
              T.jsxs("div", {
                className:
                  "flex items-center gap-1 text-xs text-muted-foreground",
                children: [
                  T.jsx(D8, { className: "w-3 h-3" }),
                  T.jsxs("span", {
                    children: ["(", n.grid_x, ", ", n.grid_y, ")"],
                  }),
                ],
              }),
            ],
          }),
        }),
        T.jsxs(ka, {
          className: "pt-0",
          children: [
            T.jsxs("div", {
              className: "space-y-2",
              children: [
                t &&
                  T.jsx("div", {
                    className: "text-xs text-muted-foreground line-clamp-2",
                    children: t,
                  }),
                T.jsxs("div", {
                  className:
                    "flex items-center justify-between text-xs text-muted-foreground",
                  children: [
                    T.jsxs("span", { children: [e, " messages"] }),
                    T.jsx("span", { children: o(n.created_at) }),
                  ],
                }),
              ],
            }),
            T.jsx(ho, {
              size: "sm",
              variant: "ghost",
              className:
                "w-full mt-2 h-6 text-xs opacity-0 group-hover:opacity-100 transition-opacity",
              children: "View Chat",
            }),
          ],
        }),
      ],
    });
  },
  LB = P.createContext({});
function iJ(n) {
  const e = P.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const GM = typeof window < "u",
  sJ = GM ? P.useLayoutEffect : P.useEffect,
  $M = P.createContext(null);
function XM(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function qM(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
const ta = (n, e, t) => (t > e ? e : t < n ? n : t);
let v0 = () => {};
const na = {},
  OB = (n) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);
function DB(n) {
  return typeof n == "object" && n !== null;
}
const kB = (n) => /^0[^.\s]+$/u.test(n);
function KM(n) {
  let e;
  return () => (e === void 0 && (e = n()), e);
}
const ss = (n) => n,
  oJ = (n, e) => (t) => e(n(t)),
  xm = (...n) => n.reduce(oJ),
  Fp = (n, e, t) => {
    const r = e - n;
    return r === 0 ? 1 : (t - n) / r;
  };
class YM {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return XM(this.subscriptions, e), () => qM(this.subscriptions, e);
  }
  notify(e, t, r) {
    const i = this.subscriptions.length;
    if (i)
      if (i === 1) this.subscriptions[0](e, t, r);
      else
        for (let s = 0; s < i; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const fo = (n) => n * 1e3,
  po = (n) => n / 1e3;
function UB(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const FB = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  aJ = 1e-7,
  lJ = 12;
function cJ(n, e, t, r, i) {
  let s,
    o,
    a = 0;
  do (o = e + (t - e) / 2), (s = FB(o, r, i) - n), s > 0 ? (t = o) : (e = o);
  while (Math.abs(s) > aJ && ++a < lJ);
  return o;
}
function _m(n, e, t, r) {
  if (n === e && t === r) return ss;
  const i = (s) => cJ(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : FB(i(s), e, r));
}
const BB = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  zB = (n) => (e) => 1 - n(1 - e),
  VB = _m(0.33, 1.53, 0.69, 0.99),
  JM = zB(VB),
  jB = BB(JM),
  HB = (n) =>
    (n *= 2) < 1 ? 0.5 * JM(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  ZM = (n) => 1 - Math.sin(Math.acos(n)),
  WB = zB(ZM),
  GB = BB(ZM),
  uJ = _m(0.42, 0, 1, 1),
  dJ = _m(0, 0, 0.58, 1),
  $B = _m(0.42, 0, 0.58, 1),
  hJ = (n) => Array.isArray(n) && typeof n[0] != "number",
  XB = (n) => Array.isArray(n) && typeof n[0] == "number",
  C2 = {
    linear: ss,
    easeIn: uJ,
    easeInOut: $B,
    easeOut: dJ,
    circIn: ZM,
    circInOut: GB,
    circOut: WB,
    backIn: JM,
    backInOut: jB,
    backOut: VB,
    anticipate: HB,
  },
  fJ = (n) => typeof n == "string",
  A2 = (n) => {
    if (XB(n)) {
      v0(n.length === 4);
      const [e, t, r, i] = n;
      return _m(e, t, r, i);
    } else if (fJ(n)) return v0(C2[n] !== void 0), C2[n];
    return n;
  },
  hv = [
    "setup",
    "read",
    "resolveKeyframes",
    "preUpdate",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  R2 = { value: null, addProjectionMetrics: null };
function pJ(n, e) {
  let t = new Set(),
    r = new Set(),
    i = !1,
    s = !1;
  const o = new WeakSet();
  let a = { delta: 0, timestamp: 0, isProcessing: !1 },
    l = 0;
  function c(f) {
    o.has(f) && (u.schedule(f), n()), l++, f(a);
  }
  const u = {
    schedule: (f, p = !1, m = !1) => {
      const y = m && i ? t : r;
      return p && o.add(f), y.has(f) || y.add(f), f;
    },
    cancel: (f) => {
      r.delete(f), o.delete(f);
    },
    process: (f) => {
      if (((a = f), i)) {
        s = !0;
        return;
      }
      (i = !0),
        ([t, r] = [r, t]),
        t.forEach(c),
        e && R2.value && R2.value.frameloop[e].push(l),
        (l = 0),
        t.clear(),
        (i = !1),
        s && ((s = !1), u.process(f));
    },
  };
  return u;
}
const mJ = 40;
function qB(n, e) {
  let t = !1,
    r = !0;
  const i = { delta: 0, timestamp: 0, isProcessing: !1 },
    s = () => (t = !0),
    o = hv.reduce((S, b) => ((S[b] = pJ(s, e ? b : void 0)), S), {}),
    {
      setup: a,
      read: l,
      resolveKeyframes: c,
      preUpdate: u,
      update: f,
      preRender: p,
      render: m,
      postRender: v,
    } = o,
    y = () => {
      const S = na.useManualTiming ? i.timestamp : performance.now();
      (t = !1),
        na.useManualTiming ||
          (i.delta = r ? 1e3 / 60 : Math.max(Math.min(S - i.timestamp, mJ), 1)),
        (i.timestamp = S),
        (i.isProcessing = !0),
        a.process(i),
        l.process(i),
        c.process(i),
        u.process(i),
        f.process(i),
        p.process(i),
        m.process(i),
        v.process(i),
        (i.isProcessing = !1),
        t && e && ((r = !1), n(y));
    },
    x = () => {
      (t = !0), (r = !0), i.isProcessing || n(y);
    };
  return {
    schedule: hv.reduce((S, b) => {
      const C = o[b];
      return (S[b] = (A, R = !1, O = !1) => (t || x(), C.schedule(A, R, O))), S;
    }, {}),
    cancel: (S) => {
      for (let b = 0; b < hv.length; b++) o[hv[b]].cancel(S);
    },
    state: i,
    steps: o,
  };
}
const {
  schedule: xn,
  cancel: dl,
  state: fr,
  steps: DS,
} = qB(typeof requestAnimationFrame < "u" ? requestAnimationFrame : ss, !0);
let My;
function gJ() {
  My = void 0;
}
const hi = {
    now: () => (
      My === void 0 &&
        hi.set(
          fr.isProcessing || na.useManualTiming
            ? fr.timestamp
            : performance.now()
        ),
      My
    ),
    set: (n) => {
      (My = n), queueMicrotask(gJ);
    },
  },
  KB = (n) => (e) => typeof e == "string" && e.startsWith(n),
  QM = KB("--"),
  vJ = KB("var(--"),
  eC = (n) => (vJ(n) ? yJ.test(n.split("/*")[0].trim()) : !1),
  yJ =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  Ch = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  Bp = { ...Ch, transform: (n) => ta(0, 1, n) },
  fv = { ...Ch, default: 1 },
  Jf = (n) => Math.round(n * 1e5) / 1e5,
  tC = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function xJ(n) {
  return n == null;
}
const _J =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  nC = (n, e) => (t) =>
    !!(
      (typeof t == "string" && _J.test(t) && t.startsWith(n)) ||
      (e && !xJ(t) && Object.prototype.hasOwnProperty.call(t, e))
    ),
  YB = (n, e, t) => (r) => {
    if (typeof r != "string") return r;
    const [i, s, o, a] = r.match(tC);
    return {
      [n]: parseFloat(i),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  wJ = (n) => ta(0, 255, n),
  kS = { ...Ch, transform: (n) => Math.round(wJ(n)) },
  pc = {
    test: nC("rgb", "red"),
    parse: YB("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: r = 1 }) =>
      "rgba(" +
      kS.transform(n) +
      ", " +
      kS.transform(e) +
      ", " +
      kS.transform(t) +
      ", " +
      Jf(Bp.transform(r)) +
      ")",
  };
function SJ(n) {
  let e = "",
    t = "",
    r = "",
    i = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (r = n.substring(5, 7)),
        (i = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (r = n.substring(3, 4)),
        (i = n.substring(4, 5)),
        (e += e),
        (t += t),
        (r += r),
        (i += i)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(r, 16),
      alpha: i ? parseInt(i, 16) / 255 : 1,
    }
  );
}
const vE = { test: nC("#"), parse: SJ, transform: pc.transform },
  wm = (n) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  Ia = wm("deg"),
  mo = wm("%"),
  Et = wm("px"),
  bJ = wm("vh"),
  EJ = wm("vw"),
  P2 = {
    ...mo,
    parse: (n) => mo.parse(n) / 100,
    transform: (n) => mo.transform(n * 100),
  },
  fd = {
    test: nC("hsl", "hue"),
    parse: YB("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: r = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      mo.transform(Jf(e)) +
      ", " +
      mo.transform(Jf(t)) +
      ", " +
      Jf(Bp.transform(r)) +
      ")",
  },
  Wn = {
    test: (n) => pc.test(n) || vE.test(n) || fd.test(n),
    parse: (n) =>
      pc.test(n) ? pc.parse(n) : fd.test(n) ? fd.parse(n) : vE.parse(n),
    transform: (n) =>
      typeof n == "string"
        ? n
        : n.hasOwnProperty("red")
        ? pc.transform(n)
        : fd.transform(n),
    getAnimatableNone: (n) => {
      const e = Wn.parse(n);
      return (e.alpha = 0), Wn.transform(e);
    },
  },
  TJ =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function MJ(n) {
  var e, t;
  return (
    isNaN(n) &&
    typeof n == "string" &&
    (((e = n.match(tC)) == null ? void 0 : e.length) || 0) +
      (((t = n.match(TJ)) == null ? void 0 : t.length) || 0) >
      0
  );
}
const JB = "number",
  ZB = "color",
  CJ = "var",
  AJ = "var(",
  I2 = "${}",
  RJ =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function zp(n) {
  const e = n.toString(),
    t = [],
    r = { color: [], number: [], var: [] },
    i = [];
  let s = 0;
  const a = e
    .replace(
      RJ,
      (l) => (
        Wn.test(l)
          ? (r.color.push(s), i.push(ZB), t.push(Wn.parse(l)))
          : l.startsWith(AJ)
          ? (r.var.push(s), i.push(CJ), t.push(l))
          : (r.number.push(s), i.push(JB), t.push(parseFloat(l))),
        ++s,
        I2
      )
    )
    .split(I2);
  return { values: t, split: a, indexes: r, types: i };
}
function QB(n) {
  return zp(n).values;
}
function ez(n) {
  const { split: e, types: t } = zp(n),
    r = e.length;
  return (i) => {
    let s = "";
    for (let o = 0; o < r; o++)
      if (((s += e[o]), i[o] !== void 0)) {
        const a = t[o];
        a === JB
          ? (s += Jf(i[o]))
          : a === ZB
          ? (s += Wn.transform(i[o]))
          : (s += i[o]);
      }
    return s;
  };
}
const PJ = (n) =>
  typeof n == "number" ? 0 : Wn.test(n) ? Wn.getAnimatableNone(n) : n;
function IJ(n) {
  const e = QB(n);
  return ez(n)(e.map(PJ));
}
const hl = {
  test: MJ,
  parse: QB,
  createTransformer: ez,
  getAnimatableNone: IJ,
};
function US(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function NJ({ hue: n, saturation: e, lightness: t, alpha: r }) {
  (n /= 360), (e /= 100), (t /= 100);
  let i = 0,
    s = 0,
    o = 0;
  if (!e) i = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - a;
    (i = US(l, a, n + 1 / 3)), (s = US(l, a, n)), (o = US(l, a, n - 1 / 3));
  }
  return {
    red: Math.round(i * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: r,
  };
}
function y0(n, e) {
  return (t) => (t > 0 ? e : n);
}
const bn = (n, e, t) => n + (e - n) * t,
  FS = (n, e, t) => {
    const r = n * n,
      i = t * (e * e - r) + r;
    return i < 0 ? 0 : Math.sqrt(i);
  },
  LJ = [vE, pc, fd],
  OJ = (n) => LJ.find((e) => e.test(n));
function N2(n) {
  const e = OJ(n);
  if (!e) return !1;
  let t = e.parse(n);
  return e === fd && (t = NJ(t)), t;
}
const L2 = (n, e) => {
    const t = N2(n),
      r = N2(e);
    if (!t || !r) return y0(n, e);
    const i = { ...t };
    return (s) => (
      (i.red = FS(t.red, r.red, s)),
      (i.green = FS(t.green, r.green, s)),
      (i.blue = FS(t.blue, r.blue, s)),
      (i.alpha = bn(t.alpha, r.alpha, s)),
      pc.transform(i)
    );
  },
  yE = new Set(["none", "hidden"]);
function DJ(n, e) {
  return yE.has(n) ? (t) => (t <= 0 ? n : e) : (t) => (t >= 1 ? e : n);
}
function kJ(n, e) {
  return (t) => bn(n, e, t);
}
function rC(n) {
  return typeof n == "number"
    ? kJ
    : typeof n == "string"
    ? eC(n)
      ? y0
      : Wn.test(n)
      ? L2
      : BJ
    : Array.isArray(n)
    ? tz
    : typeof n == "object"
    ? Wn.test(n)
      ? L2
      : UJ
    : y0;
}
function tz(n, e) {
  const t = [...n],
    r = t.length,
    i = n.map((s, o) => rC(s)(s, e[o]));
  return (s) => {
    for (let o = 0; o < r; o++) t[o] = i[o](s);
    return t;
  };
}
function UJ(n, e) {
  const t = { ...n, ...e },
    r = {};
  for (const i in t)
    n[i] !== void 0 && e[i] !== void 0 && (r[i] = rC(n[i])(n[i], e[i]));
  return (i) => {
    for (const s in r) t[s] = r[s](i);
    return t;
  };
}
function FJ(n, e) {
  const t = [],
    r = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < e.values.length; i++) {
    const s = e.types[i],
      o = n.indexes[s][r[s]],
      a = n.values[o] ?? 0;
    (t[i] = a), r[s]++;
  }
  return t;
}
const BJ = (n, e) => {
  const t = hl.createTransformer(e),
    r = zp(n),
    i = zp(e);
  return r.indexes.var.length === i.indexes.var.length &&
    r.indexes.color.length === i.indexes.color.length &&
    r.indexes.number.length >= i.indexes.number.length
    ? (yE.has(n) && !i.values.length) || (yE.has(e) && !r.values.length)
      ? DJ(n, e)
      : xm(tz(FJ(r, i), i.values), t)
    : y0(n, e);
};
function nz(n, e, t) {
  return typeof n == "number" && typeof e == "number" && typeof t == "number"
    ? bn(n, e, t)
    : rC(n)(n, e);
}
const zJ = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: (t = !0) => xn.update(e, t),
      stop: () => dl(e),
      now: () => (fr.isProcessing ? fr.timestamp : hi.now()),
    };
  },
  rz = (n, e, t = 10) => {
    let r = "";
    const i = Math.max(Math.round(e / t), 2);
    for (let s = 0; s < i; s++)
      r += Math.round(n(s / (i - 1)) * 1e4) / 1e4 + ", ";
    return `linear(${r.substring(0, r.length - 2)})`;
  },
  x0 = 2e4;
function iC(n) {
  let e = 0;
  const t = 50;
  let r = n.next(e);
  for (; !r.done && e < x0; ) (e += t), (r = n.next(e));
  return e >= x0 ? 1 / 0 : e;
}
function VJ(n, e = 100, t) {
  const r = t({ ...n, keyframes: [0, e] }),
    i = Math.min(iC(r), x0);
  return {
    type: "keyframes",
    ease: (s) => r.next(i * s).value / e,
    duration: po(i),
  };
}
const jJ = 5;
function iz(n, e, t) {
  const r = Math.max(e - jJ, 0);
  return UB(t - n(r), e - r);
}
const Pn = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: { granular: 0.01, default: 2 },
    restDelta: { granular: 0.005, default: 0.5 },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  BS = 0.001;
function HJ({
  duration: n = Pn.duration,
  bounce: e = Pn.bounce,
  velocity: t = Pn.velocity,
  mass: r = Pn.mass,
}) {
  let i,
    s,
    o = 1 - e;
  (o = ta(Pn.minDamping, Pn.maxDamping, o)),
    (n = ta(Pn.minDuration, Pn.maxDuration, po(n))),
    o < 1
      ? ((i = (c) => {
          const u = c * o,
            f = u * n,
            p = u - t,
            m = xE(c, o),
            v = Math.exp(-f);
          return BS - (p / m) * v;
        }),
        (s = (c) => {
          const f = c * o * n,
            p = f * t + t,
            m = Math.pow(o, 2) * Math.pow(c, 2) * n,
            v = Math.exp(-f),
            y = xE(Math.pow(c, 2), o);
          return ((-i(c) + BS > 0 ? -1 : 1) * ((p - m) * v)) / y;
        }))
      : ((i = (c) => {
          const u = Math.exp(-c * n),
            f = (c - t) * n + 1;
          return -BS + u * f;
        }),
        (s = (c) => {
          const u = Math.exp(-c * n),
            f = (t - c) * (n * n);
          return u * f;
        }));
  const a = 5 / n,
    l = GJ(i, s, a);
  if (((n = fo(n)), isNaN(l)))
    return { stiffness: Pn.stiffness, damping: Pn.damping, duration: n };
  {
    const c = Math.pow(l, 2) * r;
    return { stiffness: c, damping: o * 2 * Math.sqrt(r * c), duration: n };
  }
}
const WJ = 12;
function GJ(n, e, t) {
  let r = t;
  for (let i = 1; i < WJ; i++) r = r - n(r) / e(r);
  return r;
}
function xE(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const $J = ["duration", "bounce"],
  XJ = ["stiffness", "damping", "mass"];
function O2(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function qJ(n) {
  let e = {
    velocity: Pn.velocity,
    stiffness: Pn.stiffness,
    damping: Pn.damping,
    mass: Pn.mass,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!O2(n, XJ) && O2(n, $J))
    if (n.visualDuration) {
      const t = n.visualDuration,
        r = (2 * Math.PI) / (t * 1.2),
        i = r * r,
        s = 2 * ta(0.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(i);
      e = { ...e, mass: Pn.mass, stiffness: i, damping: s };
    } else {
      const t = HJ(n);
      (e = { ...e, ...t, mass: Pn.mass }), (e.isResolvedFromDuration = !0);
    }
  return e;
}
function _0(n = Pn.visualDuration, e = Pn.bounce) {
  const t =
    typeof n != "object"
      ? { visualDuration: n, keyframes: [0, 1], bounce: e }
      : n;
  let { restSpeed: r, restDelta: i } = t;
  const s = t.keyframes[0],
    o = t.keyframes[t.keyframes.length - 1],
    a = { done: !1, value: s },
    {
      stiffness: l,
      damping: c,
      mass: u,
      duration: f,
      velocity: p,
      isResolvedFromDuration: m,
    } = qJ({ ...t, velocity: -po(t.velocity || 0) }),
    v = p || 0,
    y = c / (2 * Math.sqrt(l * u)),
    x = o - s,
    g = po(Math.sqrt(l / u)),
    _ = Math.abs(x) < 5;
  r || (r = _ ? Pn.restSpeed.granular : Pn.restSpeed.default),
    i || (i = _ ? Pn.restDelta.granular : Pn.restDelta.default);
  let S;
  if (y < 1) {
    const C = xE(g, y);
    S = (A) => {
      const R = Math.exp(-y * g * A);
      return (
        o - R * (((v + y * g * x) / C) * Math.sin(C * A) + x * Math.cos(C * A))
      );
    };
  } else if (y === 1) S = (C) => o - Math.exp(-g * C) * (x + (v + g * x) * C);
  else {
    const C = g * Math.sqrt(y * y - 1);
    S = (A) => {
      const R = Math.exp(-y * g * A),
        O = Math.min(C * A, 300);
      return (
        o - (R * ((v + y * g * x) * Math.sinh(O) + C * x * Math.cosh(O))) / C
      );
    };
  }
  const b = {
    calculatedDuration: (m && f) || null,
    next: (C) => {
      const A = S(C);
      if (m) a.done = C >= f;
      else {
        let R = C === 0 ? v : 0;
        y < 1 && (R = C === 0 ? fo(v) : iz(S, C, A));
        const O = Math.abs(R) <= r,
          I = Math.abs(o - A) <= i;
        a.done = O && I;
      }
      return (a.value = a.done ? o : A), a;
    },
    toString: () => {
      const C = Math.min(iC(b), x0),
        A = rz((R) => b.next(C * R).value, C, 30);
      return C + "ms " + A;
    },
    toTransition: () => {},
  };
  return b;
}
_0.applyToOptions = (n) => {
  const e = VJ(n, 100, _0);
  return (
    (n.ease = e.ease), (n.duration = fo(e.duration)), (n.type = "keyframes"), n
  );
};
function _E({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: r = 325,
  bounceDamping: i = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const f = n[0],
    p = { done: !1, value: f },
    m = (O) => (a !== void 0 && O < a) || (l !== void 0 && O > l),
    v = (O) =>
      a === void 0
        ? l
        : l === void 0 || Math.abs(a - O) < Math.abs(l - O)
        ? a
        : l;
  let y = t * e;
  const x = f + y,
    g = o === void 0 ? x : o(x);
  g !== x && (y = g - f);
  const _ = (O) => -y * Math.exp(-O / r),
    S = (O) => g + _(O),
    b = (O) => {
      const I = _(O),
        N = S(O);
      (p.done = Math.abs(I) <= c), (p.value = p.done ? g : N);
    };
  let C, A;
  const R = (O) => {
    m(p.value) &&
      ((C = O),
      (A = _0({
        keyframes: [p.value, v(p.value)],
        velocity: iz(S, O, p.value),
        damping: i,
        stiffness: s,
        restDelta: c,
        restSpeed: u,
      })));
  };
  return (
    R(0),
    {
      calculatedDuration: null,
      next: (O) => {
        let I = !1;
        return (
          !A && C === void 0 && ((I = !0), b(O), R(O)),
          C !== void 0 && O >= C ? A.next(O - C) : (!I && b(O), p)
        );
      },
    }
  );
}
function KJ(n, e, t) {
  const r = [],
    i = t || na.mix || nz,
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = i(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || ss : e;
      a = xm(l, a);
    }
    r.push(a);
  }
  return r;
}
function YJ(n, e, { clamp: t = !0, ease: r, mixer: i } = {}) {
  const s = n.length;
  if ((v0(s === e.length), s === 1)) return () => e[0];
  if (s === 2 && e[0] === e[1]) return () => e[1];
  const o = n[0] === n[1];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const a = KJ(e, r, i),
    l = a.length,
    c = (u) => {
      if (o && u < n[0]) return e[0];
      let f = 0;
      if (l > 1) for (; f < n.length - 2 && !(u < n[f + 1]); f++);
      const p = Fp(n[f], n[f + 1], u);
      return a[f](p);
    };
  return t ? (u) => c(ta(n[0], n[s - 1], u)) : c;
}
function JJ(n, e) {
  const t = n[n.length - 1];
  for (let r = 1; r <= e; r++) {
    const i = Fp(0, e, r);
    n.push(bn(t, 1, i));
  }
}
function ZJ(n) {
  const e = [0];
  return JJ(e, n.length - 1), e;
}
function QJ(n, e) {
  return n.map((t) => t * e);
}
function eZ(n, e) {
  return n.map(() => e || $B).splice(0, n.length - 1);
}
function Zf({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: r = "easeInOut",
}) {
  const i = hJ(r) ? r.map(A2) : A2(r),
    s = { done: !1, value: e[0] },
    o = QJ(t && t.length === e.length ? t : ZJ(e), n),
    a = YJ(o, e, { ease: Array.isArray(i) ? i : eZ(e, i) });
  return {
    calculatedDuration: n,
    next: (l) => ((s.value = a(l)), (s.done = l >= n), s),
  };
}
const tZ = (n) => n !== null;
function sC(n, { repeat: e, repeatType: t = "loop" }, r, i = 1) {
  const s = n.filter(tZ),
    a = i < 0 || (e && t !== "loop" && e % 2 === 1) ? 0 : s.length - 1;
  return !a || r === void 0 ? s[a] : r;
}
const nZ = { decay: _E, inertia: _E, tween: Zf, keyframes: Zf, spring: _0 };
function sz(n) {
  typeof n.type == "string" && (n.type = nZ[n.type]);
}
class oC {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((e) => {
      this.resolve = e;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
}
const rZ = (n) => n / 100;
class aC extends oC {
  constructor(e) {
    super(),
      (this.state = "idle"),
      (this.startTime = null),
      (this.isStopped = !1),
      (this.currentTime = 0),
      (this.holdTime = null),
      (this.playbackSpeed = 1),
      (this.stop = () => {
        var r, i;
        const { motionValue: t } = this.options;
        t && t.updatedAt !== hi.now() && this.tick(hi.now()),
          (this.isStopped = !0),
          this.state !== "idle" &&
            (this.teardown(),
            (i = (r = this.options).onStop) == null || i.call(r));
      }),
      (this.options = e),
      this.initAnimation(),
      this.play(),
      e.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: e } = this;
    sz(e);
    const {
      type: t = Zf,
      repeat: r = 0,
      repeatDelay: i = 0,
      repeatType: s,
      velocity: o = 0,
    } = e;
    let { keyframes: a } = e;
    const l = t || Zf;
    l !== Zf &&
      typeof a[0] != "number" &&
      ((this.mixKeyframes = xm(rZ, nz(a[0], a[1]))), (a = [0, 100]));
    const c = l({ ...e, keyframes: a });
    s === "mirror" &&
      (this.mirroredGenerator = l({
        ...e,
        keyframes: [...a].reverse(),
        velocity: -o,
      })),
      c.calculatedDuration === null && (c.calculatedDuration = iC(c));
    const { calculatedDuration: u } = c;
    (this.calculatedDuration = u),
      (this.resolvedDuration = u + i),
      (this.totalDuration = this.resolvedDuration * (r + 1) - i),
      (this.generator = c);
  }
  updateTime(e) {
    const t = Math.round(e - this.startTime) * this.playbackSpeed;
    this.holdTime !== null
      ? (this.currentTime = this.holdTime)
      : (this.currentTime = t);
  }
  tick(e, t = !1) {
    const {
      generator: r,
      totalDuration: i,
      mixKeyframes: s,
      mirroredGenerator: o,
      resolvedDuration: a,
      calculatedDuration: l,
    } = this;
    if (this.startTime === null) return r.next(0);
    const {
      delay: c = 0,
      keyframes: u,
      repeat: f,
      repeatType: p,
      repeatDelay: m,
      type: v,
      onUpdate: y,
      finalKeyframe: x,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - i / this.speed, this.startTime)),
      t ? (this.currentTime = e) : this.updateTime(e);
    const g = this.currentTime - c * (this.playbackSpeed >= 0 ? 1 : -1),
      _ = this.playbackSpeed >= 0 ? g < 0 : g > i;
    (this.currentTime = Math.max(g, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = i);
    let S = this.currentTime,
      b = r;
    if (f) {
      const O = Math.min(this.currentTime, i) / a;
      let I = Math.floor(O),
        N = O % 1;
      !N && O >= 1 && (N = 1),
        N === 1 && I--,
        (I = Math.min(I, f + 1)),
        !!(I % 2) &&
          (p === "reverse"
            ? ((N = 1 - N), m && (N -= m / a))
            : p === "mirror" && (b = o)),
        (S = ta(0, 1, N) * a);
    }
    const C = _ ? { done: !1, value: u[0] } : b.next(S);
    s && (C.value = s(C.value));
    let { done: A } = C;
    !_ &&
      l !== null &&
      (A =
        this.playbackSpeed >= 0
          ? this.currentTime >= i
          : this.currentTime <= 0);
    const R =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && A));
    return (
      R && v !== _E && (C.value = sC(u, this.options, x, this.speed)),
      y && y(C.value),
      R && this.finish(),
      C
    );
  }
  then(e, t) {
    return this.finished.then(e, t);
  }
  get duration() {
    return po(this.calculatedDuration);
  }
  get time() {
    return po(this.currentTime);
  }
  set time(e) {
    var t;
    (e = fo(e)),
      (this.currentTime = e),
      this.startTime === null ||
      this.holdTime !== null ||
      this.playbackSpeed === 0
        ? (this.holdTime = e)
        : this.driver &&
          (this.startTime = this.driver.now() - e / this.playbackSpeed),
      (t = this.driver) == null || t.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    this.updateTime(hi.now());
    const t = this.playbackSpeed !== e;
    (this.playbackSpeed = e), t && (this.time = po(this.currentTime));
  }
  play() {
    var i, s;
    if (this.isStopped) return;
    const { driver: e = zJ, startTime: t } = this.options;
    this.driver || (this.driver = e((o) => this.tick(o))),
      (s = (i = this.options).onPlay) == null || s.call(i);
    const r = this.driver.now();
    this.state === "finished"
      ? (this.updateFinished(), (this.startTime = r))
      : this.holdTime !== null
      ? (this.startTime = r - this.holdTime)
      : this.startTime || (this.startTime = t ?? r),
      this.state === "finished" &&
        this.speed < 0 &&
        (this.startTime += this.calculatedDuration),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    (this.state = "paused"),
      this.updateTime(hi.now()),
      (this.holdTime = this.currentTime);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    var e, t;
    this.notifyFinished(),
      this.teardown(),
      (this.state = "finished"),
      (t = (e = this.options).onComplete) == null || t.call(e);
  }
  cancel() {
    var e, t;
    (this.holdTime = null),
      (this.startTime = 0),
      this.tick(0),
      this.teardown(),
      (t = (e = this.options).onCancel) == null || t.call(e);
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      (this.startTime = this.holdTime = null);
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0);
  }
  attachTimeline(e) {
    var t;
    return (
      this.options.allowFlatten &&
        ((this.options.type = "keyframes"),
        (this.options.ease = "linear"),
        this.initAnimation()),
      (t = this.driver) == null || t.stop(),
      e.observe(this)
    );
  }
}
function iZ(n) {
  for (let e = 1; e < n.length; e++) n[e] ?? (n[e] = n[e - 1]);
}
const mc = (n) => (n * 180) / Math.PI,
  wE = (n) => {
    const e = mc(Math.atan2(n[1], n[0]));
    return SE(e);
  },
  sZ = {
    x: 4,
    y: 5,
    translateX: 4,
    translateY: 5,
    scaleX: 0,
    scaleY: 3,
    scale: (n) => (Math.abs(n[0]) + Math.abs(n[3])) / 2,
    rotate: wE,
    rotateZ: wE,
    skewX: (n) => mc(Math.atan(n[1])),
    skewY: (n) => mc(Math.atan(n[2])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[2])) / 2,
  },
  SE = (n) => ((n = n % 360), n < 0 && (n += 360), n),
  D2 = wE,
  k2 = (n) => Math.sqrt(n[0] * n[0] + n[1] * n[1]),
  U2 = (n) => Math.sqrt(n[4] * n[4] + n[5] * n[5]),
  oZ = {
    x: 12,
    y: 13,
    z: 14,
    translateX: 12,
    translateY: 13,
    translateZ: 14,
    scaleX: k2,
    scaleY: U2,
    scale: (n) => (k2(n) + U2(n)) / 2,
    rotateX: (n) => SE(mc(Math.atan2(n[6], n[5]))),
    rotateY: (n) => SE(mc(Math.atan2(-n[2], n[0]))),
    rotateZ: D2,
    rotate: D2,
    skewX: (n) => mc(Math.atan(n[4])),
    skewY: (n) => mc(Math.atan(n[1])),
    skew: (n) => (Math.abs(n[1]) + Math.abs(n[4])) / 2,
  };
function bE(n) {
  return n.includes("scale") ? 1 : 0;
}
function EE(n, e) {
  if (!n || n === "none") return bE(e);
  const t = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let r, i;
  if (t) (r = oZ), (i = t);
  else {
    const a = n.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    (r = sZ), (i = a);
  }
  if (!i) return bE(e);
  const s = r[e],
    o = i[1].split(",").map(lZ);
  return typeof s == "function" ? s(o) : o[s];
}
const aZ = (n, e) => {
  const { transform: t = "none" } = getComputedStyle(n);
  return EE(t, e);
};
function lZ(n) {
  return parseFloat(n.trim());
}
const Ah = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  Rh = new Set(Ah),
  F2 = (n) => n === Ch || n === Et,
  cZ = new Set(["x", "y", "z"]),
  uZ = Ah.filter((n) => !cZ.has(n));
function dZ(n) {
  const e = [];
  return (
    uZ.forEach((t) => {
      const r = n.getValue(t);
      r !== void 0 &&
        (e.push([t, r.get()]), r.set(t.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const Cc = {
  width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
    n.max - n.min - parseFloat(e) - parseFloat(t),
  top: (n, { top: e }) => parseFloat(e),
  left: (n, { left: e }) => parseFloat(e),
  bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
  right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
  x: (n, { transform: e }) => EE(e, "x"),
  y: (n, { transform: e }) => EE(e, "y"),
};
Cc.translateX = Cc.x;
Cc.translateY = Cc.y;
const Ac = new Set();
let TE = !1,
  ME = !1,
  CE = !1;
function oz() {
  if (ME) {
    const n = Array.from(Ac).filter((r) => r.needsMeasurement),
      e = new Set(n.map((r) => r.element)),
      t = new Map();
    e.forEach((r) => {
      const i = dZ(r);
      i.length && (t.set(r, i), r.render());
    }),
      n.forEach((r) => r.measureInitialState()),
      e.forEach((r) => {
        r.render();
        const i = t.get(r);
        i &&
          i.forEach(([s, o]) => {
            var a;
            (a = r.getValue(s)) == null || a.set(o);
          });
      }),
      n.forEach((r) => r.measureEndState()),
      n.forEach((r) => {
        r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
      });
  }
  (ME = !1), (TE = !1), Ac.forEach((n) => n.complete(CE)), Ac.clear();
}
function az() {
  Ac.forEach((n) => {
    n.readKeyframes(), n.needsMeasurement && (ME = !0);
  });
}
function hZ() {
  (CE = !0), az(), oz(), (CE = !1);
}
class lC {
  constructor(e, t, r, i, s, o = !1) {
    (this.state = "pending"),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = t),
      (this.name = r),
      (this.motionValue = i),
      (this.element = s),
      (this.isAsync = o);
  }
  scheduleResolve() {
    (this.state = "scheduled"),
      this.isAsync
        ? (Ac.add(this),
          TE || ((TE = !0), xn.read(az), xn.resolveKeyframes(oz)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: t,
      element: r,
      motionValue: i,
    } = this;
    if (e[0] === null) {
      const s = i == null ? void 0 : i.get(),
        o = e[e.length - 1];
      if (s !== void 0) e[0] = s;
      else if (r && t) {
        const a = r.readValue(t, o);
        a != null && (e[0] = a);
      }
      e[0] === void 0 && (e[0] = o), i && s === void 0 && i.set(e[0]);
    }
    iZ(e);
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete(e = !1) {
    (this.state = "complete"),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e),
      Ac.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (Ac.delete(this), (this.state = "pending"));
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const fZ = (n) => n.startsWith("--");
function pZ(n, e, t) {
  fZ(e) ? n.style.setProperty(e, t) : (n.style[e] = t);
}
const mZ = KM(() => window.ScrollTimeline !== void 0),
  gZ = {};
function vZ(n, e) {
  const t = KM(n);
  return () => gZ[e] ?? t();
}
const lz = vZ(() => {
    try {
      document
        .createElement("div")
        .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  Lf = ([n, e, t, r]) => `cubic-bezier(${n}, ${e}, ${t}, ${r})`,
  B2 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: Lf([0, 0.65, 0.55, 1]),
    circOut: Lf([0.55, 0, 1, 0.45]),
    backIn: Lf([0.31, 0.01, 0.66, -0.59]),
    backOut: Lf([0.33, 1.53, 0.69, 0.99]),
  };
function cz(n, e) {
  if (n)
    return typeof n == "function"
      ? lz()
        ? rz(n, e)
        : "ease-out"
      : XB(n)
      ? Lf(n)
      : Array.isArray(n)
      ? n.map((t) => cz(t, e) || B2.easeOut)
      : B2[n];
}
function yZ(
  n,
  e,
  t,
  {
    delay: r = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a = "easeOut",
    times: l,
  } = {},
  c = void 0
) {
  const u = { [e]: t };
  l && (u.offset = l);
  const f = cz(a, i);
  Array.isArray(f) && (u.easing = f);
  const p = {
    delay: r,
    duration: i,
    easing: Array.isArray(f) ? "linear" : f,
    fill: "both",
    iterations: s + 1,
    direction: o === "reverse" ? "alternate" : "normal",
  };
  return c && (p.pseudoElement = c), n.animate(u, p);
}
function uz(n) {
  return typeof n == "function" && "applyToOptions" in n;
}
function xZ({ type: n, ...e }) {
  return uz(n) && lz()
    ? n.applyToOptions(e)
    : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e);
}
class _Z extends oC {
  constructor(e) {
    if ((super(), (this.finishedTime = null), (this.isStopped = !1), !e))
      return;
    const {
      element: t,
      name: r,
      keyframes: i,
      pseudoElement: s,
      allowFlatten: o = !1,
      finalKeyframe: a,
      onComplete: l,
    } = e;
    (this.isPseudoElement = !!s),
      (this.allowFlatten = o),
      (this.options = e),
      v0(typeof e.type != "string");
    const c = xZ(e);
    (this.animation = yZ(t, r, i, c, s)),
      c.autoplay === !1 && this.animation.pause(),
      (this.animation.onfinish = () => {
        if (((this.finishedTime = this.time), !s)) {
          const u = sC(i, this.options, a, this.speed);
          this.updateMotionValue ? this.updateMotionValue(u) : pZ(t, r, u),
            this.animation.cancel();
        }
        l == null || l(), this.notifyFinished();
      });
  }
  play() {
    this.isStopped ||
      (this.animation.play(),
      this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var e, t;
    (t = (e = this.animation).finish) == null || t.call(e);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {}
  }
  stop() {
    if (this.isStopped) return;
    this.isStopped = !0;
    const { state: e } = this;
    e === "idle" ||
      e === "finished" ||
      (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(),
      this.isPseudoElement || this.cancel());
  }
  commitStyles() {
    var e, t;
    this.isPseudoElement ||
      (t = (e = this.animation).commitStyles) == null ||
      t.call(e);
  }
  get duration() {
    var t, r;
    const e =
      ((r =
        (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) ==
      null
        ? void 0
        : r.call(t).duration) || 0;
    return po(Number(e));
  }
  get time() {
    return po(Number(this.animation.currentTime) || 0);
  }
  set time(e) {
    (this.finishedTime = null), (this.animation.currentTime = fo(e));
  }
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(e) {
    e < 0 && (this.finishedTime = null), (this.animation.playbackRate = e);
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(e) {
    this.animation.startTime = e;
  }
  attachTimeline({ timeline: e, observe: t }) {
    var r;
    return (
      this.allowFlatten &&
        ((r = this.animation.effect) == null ||
          r.updateTiming({ easing: "linear" })),
      (this.animation.onfinish = null),
      e && mZ() ? ((this.animation.timeline = e), ss) : t(this)
    );
  }
}
const dz = { anticipate: HB, backInOut: jB, circInOut: GB };
function wZ(n) {
  return n in dz;
}
function SZ(n) {
  typeof n.ease == "string" && wZ(n.ease) && (n.ease = dz[n.ease]);
}
const z2 = 10;
class bZ extends _Z {
  constructor(e) {
    SZ(e),
      sz(e),
      super(e),
      e.startTime && (this.startTime = e.startTime),
      (this.options = e);
  }
  updateMotionValue(e) {
    const {
      motionValue: t,
      onUpdate: r,
      onComplete: i,
      element: s,
      ...o
    } = this.options;
    if (!t) return;
    if (e !== void 0) {
      t.set(e);
      return;
    }
    const a = new aC({ ...o, autoplay: !1 }),
      l = fo(this.finishedTime ?? this.time);
    t.setWithVelocity(a.sample(l - z2).value, a.sample(l).value, z2), a.stop();
  }
}
const V2 = (n, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof n == "number" ||
        Array.isArray(n) ||
        (typeof n == "string" &&
          (hl.test(n) || n === "0") &&
          !n.startsWith("url("))
      );
function EZ(n) {
  const e = n[0];
  if (n.length === 1) return !0;
  for (let t = 0; t < n.length; t++) if (n[t] !== e) return !0;
}
function TZ(n, e, t, r) {
  const i = n[0];
  if (i === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const s = n[n.length - 1],
    o = V2(i, e),
    a = V2(s, e);
  return !o || !a ? !1 : EZ(n) || ((t === "spring" || uz(t)) && r);
}
function AE(n) {
  (n.duration = 0), n.type;
}
const MZ = new Set(["opacity", "clipPath", "filter", "transform"]),
  CZ = KM(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function AZ(n) {
  var u;
  const {
    motionValue: e,
    name: t,
    repeatDelay: r,
    repeatType: i,
    damping: s,
    type: o,
  } = n;
  if (
    !(
      ((u = e == null ? void 0 : e.owner) == null
        ? void 0
        : u.current) instanceof HTMLElement
    )
  )
    return !1;
  const { onUpdate: l, transformTemplate: c } = e.owner.getProps();
  return (
    CZ() &&
    t &&
    MZ.has(t) &&
    (t !== "transform" || !c) &&
    !l &&
    !r &&
    i !== "mirror" &&
    s !== 0 &&
    o !== "inertia"
  );
}
const RZ = 40;
class PZ extends oC {
  constructor({
    autoplay: e = !0,
    delay: t = 0,
    type: r = "keyframes",
    repeat: i = 0,
    repeatDelay: s = 0,
    repeatType: o = "loop",
    keyframes: a,
    name: l,
    motionValue: c,
    element: u,
    ...f
  }) {
    var v;
    super(),
      (this.stop = () => {
        var y, x;
        this._animation &&
          (this._animation.stop(),
          (y = this.stopTimeline) == null || y.call(this)),
          (x = this.keyframeResolver) == null || x.cancel();
      }),
      (this.createdAt = hi.now());
    const p = {
        autoplay: e,
        delay: t,
        type: r,
        repeat: i,
        repeatDelay: s,
        repeatType: o,
        name: l,
        motionValue: c,
        element: u,
        ...f,
      },
      m = (u == null ? void 0 : u.KeyframeResolver) || lC;
    (this.keyframeResolver = new m(
      a,
      (y, x, g) => this.onKeyframesResolved(y, x, p, !g),
      l,
      c,
      u
    )),
      (v = this.keyframeResolver) == null || v.scheduleResolve();
  }
  onKeyframesResolved(e, t, r, i) {
    this.keyframeResolver = void 0;
    const {
      name: s,
      type: o,
      velocity: a,
      delay: l,
      isHandoff: c,
      onUpdate: u,
    } = r;
    (this.resolvedAt = hi.now()),
      TZ(e, s, o, a) ||
        ((na.instantAnimations || !l) && (u == null || u(sC(e, r, t))),
        (e[0] = e[e.length - 1]),
        AE(r),
        (r.repeat = 0));
    const p = {
        startTime: i
          ? this.resolvedAt
            ? this.resolvedAt - this.createdAt > RZ
              ? this.resolvedAt
              : this.createdAt
            : this.createdAt
          : void 0,
        finalKeyframe: t,
        ...r,
        keyframes: e,
      },
      m =
        !c && AZ(p)
          ? new bZ({ ...p, element: p.motionValue.owner.current })
          : new aC(p);
    m.finished.then(() => this.notifyFinished()).catch(ss),
      this.pendingTimeline &&
        ((this.stopTimeline = m.attachTimeline(this.pendingTimeline)),
        (this.pendingTimeline = void 0)),
      (this._animation = m);
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(e, t) {
    return this.finished.finally(e).then(() => {});
  }
  get animation() {
    var e;
    return (
      this._animation ||
        ((e = this.keyframeResolver) == null || e.resume(), hZ()),
      this._animation
    );
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(e) {
    this.animation.time = e;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(e) {
    this.animation.speed = e;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(e) {
    return (
      this._animation
        ? (this.stopTimeline = this.animation.attachTimeline(e))
        : (this.pendingTimeline = e),
      () => this.stop()
    );
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var e;
    this._animation && this.animation.cancel(),
      (e = this.keyframeResolver) == null || e.cancel();
  }
}
const IZ = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function NZ(n) {
  const e = IZ.exec(n);
  if (!e) return [,];
  const [, t, r, i] = e;
  return [`--${t ?? r}`, i];
}
function hz(n, e, t = 1) {
  const [r, i] = NZ(n);
  if (!r) return;
  const s = window.getComputedStyle(e).getPropertyValue(r);
  if (s) {
    const o = s.trim();
    return OB(o) ? parseFloat(o) : o;
  }
  return eC(i) ? hz(i, e, t + 1) : i;
}
function cC(n, e) {
  return (n == null ? void 0 : n[e]) ?? (n == null ? void 0 : n.default) ?? n;
}
const fz = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    ...Ah,
  ]),
  LZ = { test: (n) => n === "auto", parse: (n) => n },
  pz = (n) => (e) => e.test(n),
  mz = [Ch, Et, mo, Ia, EJ, bJ, LZ],
  j2 = (n) => mz.find(pz(n));
function OZ(n) {
  return typeof n == "number"
    ? n === 0
    : n !== null
    ? n === "none" || n === "0" || kB(n)
    : !0;
}
const DZ = new Set(["brightness", "contrast", "saturate", "opacity"]);
function kZ(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [r] = t.match(tC) || [];
  if (!r) return n;
  const i = t.replace(r, "");
  let s = DZ.has(e) ? 1 : 0;
  return r !== t && (s *= 100), e + "(" + s + i + ")";
}
const UZ = /\b([a-z-]*)\(.*?\)/gu,
  RE = {
    ...hl,
    getAnimatableNone: (n) => {
      const e = n.match(UZ);
      return e ? e.map(kZ).join(" ") : n;
    },
  },
  H2 = { ...Ch, transform: Math.round },
  FZ = {
    rotate: Ia,
    rotateX: Ia,
    rotateY: Ia,
    rotateZ: Ia,
    scale: fv,
    scaleX: fv,
    scaleY: fv,
    scaleZ: fv,
    skew: Ia,
    skewX: Ia,
    skewY: Ia,
    distance: Et,
    translateX: Et,
    translateY: Et,
    translateZ: Et,
    x: Et,
    y: Et,
    z: Et,
    perspective: Et,
    transformPerspective: Et,
    opacity: Bp,
    originX: P2,
    originY: P2,
    originZ: Et,
  },
  uC = {
    borderWidth: Et,
    borderTopWidth: Et,
    borderRightWidth: Et,
    borderBottomWidth: Et,
    borderLeftWidth: Et,
    borderRadius: Et,
    radius: Et,
    borderTopLeftRadius: Et,
    borderTopRightRadius: Et,
    borderBottomRightRadius: Et,
    borderBottomLeftRadius: Et,
    width: Et,
    maxWidth: Et,
    height: Et,
    maxHeight: Et,
    top: Et,
    right: Et,
    bottom: Et,
    left: Et,
    padding: Et,
    paddingTop: Et,
    paddingRight: Et,
    paddingBottom: Et,
    paddingLeft: Et,
    margin: Et,
    marginTop: Et,
    marginRight: Et,
    marginBottom: Et,
    marginLeft: Et,
    backgroundPositionX: Et,
    backgroundPositionY: Et,
    ...FZ,
    zIndex: H2,
    fillOpacity: Bp,
    strokeOpacity: Bp,
    numOctaves: H2,
  },
  BZ = {
    ...uC,
    color: Wn,
    backgroundColor: Wn,
    outlineColor: Wn,
    fill: Wn,
    stroke: Wn,
    borderColor: Wn,
    borderTopColor: Wn,
    borderRightColor: Wn,
    borderBottomColor: Wn,
    borderLeftColor: Wn,
    filter: RE,
    WebkitFilter: RE,
  },
  gz = (n) => BZ[n];
function vz(n, e) {
  let t = gz(n);
  return (
    t !== RE && (t = hl), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
const zZ = new Set(["auto", "none", "0"]);
function VZ(n, e, t) {
  let r = 0,
    i;
  for (; r < n.length && !i; ) {
    const s = n[r];
    typeof s == "string" && !zZ.has(s) && zp(s).values.length && (i = n[r]),
      r++;
  }
  if (i && t) for (const s of e) n[s] = vz(t, i);
}
class jZ extends lC {
  constructor(e, t, r, i, s) {
    super(e, t, r, i, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: t, name: r } = this;
    if (!t || !t.current) return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == "string" && ((c = c.trim()), eC(c))) {
        const u = hz(c, t.current);
        u !== void 0 && (e[l] = u),
          l === e.length - 1 && (this.finalKeyframe = c);
      }
    }
    if ((this.resolveNoneKeyframes(), !fz.has(r) || e.length !== 2)) return;
    const [i, s] = e,
      o = j2(i),
      a = j2(s);
    if (o !== a)
      if (F2(o) && F2(a))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == "string" && (e[l] = parseFloat(c));
        }
      else Cc[r] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: t } = this,
      r = [];
    for (let i = 0; i < e.length; i++) (e[i] === null || OZ(e[i])) && r.push(i);
    r.length && VZ(e, r, t);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: t, name: r } = this;
    if (!e || !e.current) return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = Cc[r](
        e.measureViewportBox(),
        window.getComputedStyle(e.current)
      )),
      (t[0] = this.measuredOrigin);
    const i = t[t.length - 1];
    i !== void 0 && e.getValue(r, i).jump(i, !1);
  }
  measureEndState() {
    var a;
    const { element: e, name: t, unresolvedKeyframes: r } = this;
    if (!e || !e.current) return;
    const i = e.getValue(t);
    i && i.jump(this.measuredOrigin, !1);
    const s = r.length - 1,
      o = r[s];
    (r[s] = Cc[t](e.measureViewportBox(), window.getComputedStyle(e.current))),
      o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o),
      (a = this.removedTransforms) != null &&
        a.length &&
        this.removedTransforms.forEach(([l, c]) => {
          e.getValue(l).set(c);
        }),
      this.resolveNoneKeyframes();
  }
}
function HZ(n, e, t) {
  if (n instanceof EventTarget) return [n];
  if (typeof n == "string") {
    const i = document.querySelectorAll(n);
    return i ? Array.from(i) : [];
  }
  return Array.from(n);
}
const yz = (n, e) => (e && typeof n == "number" ? e.transform(n) : n);
function WZ(n) {
  return DB(n) && "offsetHeight" in n;
}
const W2 = 30,
  GZ = (n) => !isNaN(parseFloat(n));
class $Z {
  constructor(e, t = {}) {
    (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (r) => {
        var s;
        const i = hi.now();
        if (
          (this.updatedAt !== i && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(r),
          this.current !== this.prev &&
            ((s = this.events.change) == null || s.notify(this.current),
            this.dependents))
        )
          for (const o of this.dependents) o.dirty();
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = t.owner);
  }
  setCurrent(e) {
    (this.current = e),
      (this.updatedAt = hi.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = GZ(this.current));
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new YM());
    const r = this.events[e].add(t);
    return e === "change"
      ? () => {
          r(),
            xn.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : r;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e) {
    this.passiveEffect
      ? this.passiveEffect(e, this.updateAndNotify)
      : this.updateAndNotify(e);
  }
  setWithVelocity(e, t, r) {
    this.set(t),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - r);
  }
  jump(e, t = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      t && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var e;
    (e = this.events.change) == null || e.notify(this.current);
  }
  addDependent(e) {
    this.dependents || (this.dependents = new Set()), this.dependents.add(e);
  }
  removeDependent(e) {
    this.dependents && this.dependents.delete(e);
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = hi.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > W2
    )
      return 0;
    const t = Math.min(this.updatedAt - this.prevUpdatedAt, W2);
    return UB(parseFloat(this.current) - parseFloat(this.prevFrameValue), t);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    var e, t;
    (e = this.dependents) == null || e.clear(),
      (t = this.events.destroy) == null || t.notify(),
      this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function rh(n, e) {
  return new $Z(n, e);
}
const { schedule: dC, cancel: lhe } = qB(queueMicrotask, !1),
  _s = { x: !1, y: !1 };
function xz() {
  return _s.x || _s.y;
}
function XZ(n) {
  return n === "x" || n === "y"
    ? _s[n]
      ? null
      : ((_s[n] = !0),
        () => {
          _s[n] = !1;
        })
    : _s.x || _s.y
    ? null
    : ((_s.x = _s.y = !0),
      () => {
        _s.x = _s.y = !1;
      });
}
function _z(n, e) {
  const t = HZ(n),
    r = new AbortController(),
    i = { passive: !0, ...e, signal: r.signal };
  return [t, i, () => r.abort()];
}
function G2(n) {
  return !(n.pointerType === "touch" || xz());
}
function qZ(n, e, t = {}) {
  const [r, i, s] = _z(n, t),
    o = (a) => {
      if (!G2(a)) return;
      const { target: l } = a,
        c = e(l, a);
      if (typeof c != "function" || !l) return;
      const u = (f) => {
        G2(f) && (c(f), l.removeEventListener("pointerleave", u));
      };
      l.addEventListener("pointerleave", u, i);
    };
  return (
    r.forEach((a) => {
      a.addEventListener("pointerenter", o, i);
    }),
    s
  );
}
const wz = (n, e) => (e ? (n === e ? !0 : wz(n, e.parentElement)) : !1),
  hC = (n) =>
    n.pointerType === "mouse"
      ? typeof n.button != "number" || n.button <= 0
      : n.isPrimary !== !1,
  KZ = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function YZ(n) {
  return KZ.has(n.tagName) || n.tabIndex !== -1;
}
const Cy = new WeakSet();
function $2(n) {
  return (e) => {
    e.key === "Enter" && n(e);
  };
}
function zS(n, e) {
  n.dispatchEvent(
    new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 })
  );
}
const JZ = (n, e) => {
  const t = n.currentTarget;
  if (!t) return;
  const r = $2(() => {
    if (Cy.has(t)) return;
    zS(t, "down");
    const i = $2(() => {
        zS(t, "up");
      }),
      s = () => zS(t, "cancel");
    t.addEventListener("keyup", i, e), t.addEventListener("blur", s, e);
  });
  t.addEventListener("keydown", r, e),
    t.addEventListener("blur", () => t.removeEventListener("keydown", r), e);
};
function X2(n) {
  return hC(n) && !xz();
}
function ZZ(n, e, t = {}) {
  const [r, i, s] = _z(n, t),
    o = (a) => {
      const l = a.currentTarget;
      if (!X2(a)) return;
      Cy.add(l);
      const c = e(l, a),
        u = (m, v) => {
          window.removeEventListener("pointerup", f),
            window.removeEventListener("pointercancel", p),
            Cy.has(l) && Cy.delete(l),
            X2(m) && typeof c == "function" && c(m, { success: v });
        },
        f = (m) => {
          u(
            m,
            l === window ||
              l === document ||
              t.useGlobalTarget ||
              wz(l, m.target)
          );
        },
        p = (m) => {
          u(m, !1);
        };
      window.addEventListener("pointerup", f, i),
        window.addEventListener("pointercancel", p, i);
    };
  return (
    r.forEach((a) => {
      (t.useGlobalTarget ? window : a).addEventListener("pointerdown", o, i),
        WZ(a) &&
          (a.addEventListener("focus", (c) => JZ(c, i)),
          !YZ(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0));
    }),
    s
  );
}
function Sz(n) {
  return DB(n) && "ownerSVGElement" in n;
}
function QZ(n) {
  return Sz(n) && n.tagName === "svg";
}
const Lr = (n) => !!(n && n.getVelocity),
  eQ = [...mz, Wn, hl],
  tQ = (n) => eQ.find(pz(n)),
  bz = P.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  });
function nQ(n = !0) {
  const e = P.useContext($M);
  if (e === null) return [!0, null];
  const { isPresent: t, onExitComplete: r, register: i } = e,
    s = P.useId();
  P.useEffect(() => {
    if (n) return i(s);
  }, [n]);
  const o = P.useCallback(() => n && r && r(s), [s, r, n]);
  return !t && r ? [!1, o] : [!0];
}
const Ez = P.createContext({ strict: !1 }),
  q2 = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  ih = {};
for (const n in q2) ih[n] = { isEnabled: (e) => q2[n].some((t) => !!e[t]) };
function rQ(n) {
  for (const e in n) ih[e] = { ...ih[e], ...n[e] };
}
const iQ = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function w0(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    n.startsWith("onLayout") ||
    iQ.has(n)
  );
}
let Tz = (n) => !w0(n);
function sQ(n) {
  typeof n == "function" && (Tz = (e) => (e.startsWith("on") ? !w0(e) : n(e)));
}
try {
  sQ(require("@emotion/is-prop-valid").default);
} catch {}
function oQ(n, e, t) {
  const r = {};
  for (const i in n)
    (i === "values" && typeof n.values == "object") ||
      ((Tz(i) ||
        (t === !0 && w0(i)) ||
        (!e && !w0(i)) ||
        (n.draggable && i.startsWith("onDrag"))) &&
        (r[i] = n[i]));
  return r;
}
const Hx = P.createContext({});
function Wx(n) {
  return n !== null && typeof n == "object" && typeof n.start == "function";
}
function Vp(n) {
  return typeof n == "string" || Array.isArray(n);
}
const fC = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  pC = ["initial", ...fC];
function Gx(n) {
  return Wx(n.animate) || pC.some((e) => Vp(n[e]));
}
function Mz(n) {
  return !!(Gx(n) || n.variants);
}
function aQ(n, e) {
  if (Gx(n)) {
    const { initial: t, animate: r } = n;
    return {
      initial: t === !1 || Vp(t) ? t : void 0,
      animate: Vp(r) ? r : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function lQ(n) {
  const { initial: e, animate: t } = aQ(n, P.useContext(Hx));
  return P.useMemo(() => ({ initial: e, animate: t }), [K2(e), K2(t)]);
}
function K2(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const jp = {};
function cQ(n) {
  for (const e in n) (jp[e] = n[e]), QM(e) && (jp[e].isCSSVariable = !0);
}
function Cz(n, { layout: e, layoutId: t }) {
  return (
    Rh.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!jp[n] || n === "opacity"))
  );
}
const uQ = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  dQ = Ah.length;
function hQ(n, e, t) {
  let r = "",
    i = !0;
  for (let s = 0; s < dQ; s++) {
    const o = Ah[s],
      a = n[o];
    if (a === void 0) continue;
    let l = !0;
    if (
      (typeof a == "number"
        ? (l = a === (o.startsWith("scale") ? 1 : 0))
        : (l = parseFloat(a) === 0),
      !l || t)
    ) {
      const c = yz(a, uC[o]);
      if (!l) {
        i = !1;
        const u = uQ[o] || o;
        r += `${u}(${c}) `;
      }
      t && (e[o] = c);
    }
  }
  return (r = r.trim()), t ? (r = t(e, i ? "" : r)) : i && (r = "none"), r;
}
function mC(n, e, t) {
  const { style: r, vars: i, transformOrigin: s } = n;
  let o = !1,
    a = !1;
  for (const l in e) {
    const c = e[l];
    if (Rh.has(l)) {
      o = !0;
      continue;
    } else if (QM(l)) {
      i[l] = c;
      continue;
    } else {
      const u = yz(c, uC[l]);
      l.startsWith("origin") ? ((a = !0), (s[l] = u)) : (r[l] = u);
    }
  }
  if (
    (e.transform ||
      (o || t
        ? (r.transform = hQ(e, n.transform, t))
        : r.transform && (r.transform = "none")),
    a)
  ) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = s;
    r.transformOrigin = `${l} ${c} ${u}`;
  }
}
const gC = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function Az(n, e, t) {
  for (const r in e) !Lr(e[r]) && !Cz(r, t) && (n[r] = e[r]);
}
function fQ({ transformTemplate: n }, e) {
  return P.useMemo(() => {
    const t = gC();
    return mC(t, e, n), Object.assign({}, t.vars, t.style);
  }, [e]);
}
function pQ(n, e) {
  const t = n.style || {},
    r = {};
  return Az(r, t, n), Object.assign(r, fQ(n, e)), r;
}
function mQ(n, e) {
  const t = {},
    r = pQ(n, e);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((t.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (t.tabIndex = 0),
    (t.style = r),
    t
  );
}
const gQ = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  vQ = { offset: "strokeDashoffset", array: "strokeDasharray" };
function yQ(n, e, t = 1, r = 0, i = !0) {
  n.pathLength = 1;
  const s = i ? gQ : vQ;
  n[s.offset] = Et.transform(-r);
  const o = Et.transform(e),
    a = Et.transform(t);
  n[s.array] = `${o} ${a}`;
}
function Rz(
  n,
  {
    attrX: e,
    attrY: t,
    attrScale: r,
    pathLength: i,
    pathSpacing: s = 1,
    pathOffset: o = 0,
    ...a
  },
  l,
  c,
  u
) {
  if ((mC(n, a, c), l)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: f, style: p } = n;
  f.transform && ((p.transform = f.transform), delete f.transform),
    (p.transform || f.transformOrigin) &&
      ((p.transformOrigin = f.transformOrigin ?? "50% 50%"),
      delete f.transformOrigin),
    p.transform &&
      ((p.transformBox = (u == null ? void 0 : u.transformBox) ?? "fill-box"),
      delete f.transformBox),
    e !== void 0 && (f.x = e),
    t !== void 0 && (f.y = t),
    r !== void 0 && (f.scale = r),
    i !== void 0 && yQ(f, i, s, o, !1);
}
const Pz = () => ({ ...gC(), attrs: {} }),
  Iz = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function xQ(n, e, t, r) {
  const i = P.useMemo(() => {
    const s = Pz();
    return (
      Rz(s, e, Iz(r), n.transformTemplate, n.style),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    Az(s, n.style, n), (i.style = { ...s, ...i.style });
  }
  return i;
}
const _Q = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function vC(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(_Q.indexOf(n) > -1 || /[A-Z]/u.test(n));
}
function wQ(n, e, t, { latestValues: r }, i, s = !1) {
  const a = (vC(n) ? xQ : mQ)(e, r, i, n),
    l = oQ(e, typeof n == "string", s),
    c = n !== P.Fragment ? { ...l, ...a, ref: t } : {},
    { children: u } = e,
    f = P.useMemo(() => (Lr(u) ? u.get() : u), [u]);
  return P.createElement(n, { ...c, children: f });
}
function Y2(n) {
  const e = [{}, {}];
  return (
    n == null ||
      n.values.forEach((t, r) => {
        (e[0][r] = t.get()), (e[1][r] = t.getVelocity());
      }),
    e
  );
}
function yC(n, e, t, r) {
  if (typeof e == "function") {
    const [i, s] = Y2(r);
    e = e(t !== void 0 ? t : n.custom, i, s);
  }
  if (
    (typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function")
  ) {
    const [i, s] = Y2(r);
    e = e(t !== void 0 ? t : n.custom, i, s);
  }
  return e;
}
function Ay(n) {
  return Lr(n) ? n.get() : n;
}
function SQ({ scrapeMotionValuesFromProps: n, createRenderState: e }, t, r, i) {
  return { latestValues: bQ(t, r, i, n), renderState: e() };
}
function bQ(n, e, t, r) {
  const i = {},
    s = r(n, {});
  for (const p in s) i[p] = Ay(s[p]);
  let { initial: o, animate: a } = n;
  const l = Gx(n),
    c = Mz(n);
  e &&
    c &&
    !l &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let u = t ? t.initial === !1 : !1;
  u = u || o === !1;
  const f = u ? a : o;
  if (f && typeof f != "boolean" && !Wx(f)) {
    const p = Array.isArray(f) ? f : [f];
    for (let m = 0; m < p.length; m++) {
      const v = yC(n, p[m]);
      if (v) {
        const { transitionEnd: y, transition: x, ...g } = v;
        for (const _ in g) {
          let S = g[_];
          if (Array.isArray(S)) {
            const b = u ? S.length - 1 : 0;
            S = S[b];
          }
          S !== null && (i[_] = S);
        }
        for (const _ in y) i[_] = y[_];
      }
    }
  }
  return i;
}
const Nz = (n) => (e, t) => {
  const r = P.useContext(Hx),
    i = P.useContext($M),
    s = () => SQ(n, e, r, i);
  return t ? s() : iJ(s);
};
function xC(n, e, t) {
  var s;
  const { style: r } = n,
    i = {};
  for (const o in r)
    (Lr(r[o]) ||
      (e.style && Lr(e.style[o])) ||
      Cz(o, n) ||
      ((s = t == null ? void 0 : t.getValue(o)) == null
        ? void 0
        : s.liveStyle) !== void 0) &&
      (i[o] = r[o]);
  return i;
}
const EQ = Nz({ scrapeMotionValuesFromProps: xC, createRenderState: gC });
function Lz(n, e, t) {
  const r = xC(n, e, t);
  for (const i in n)
    if (Lr(n[i]) || Lr(e[i])) {
      const s =
        Ah.indexOf(i) !== -1
          ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
          : i;
      r[s] = n[i];
    }
  return r;
}
const TQ = Nz({ scrapeMotionValuesFromProps: Lz, createRenderState: Pz }),
  MQ = Symbol.for("motionComponentSymbol");
function pd(n) {
  return (
    n &&
    typeof n == "object" &&
    Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function CQ(n, e, t) {
  return P.useCallback(
    (r) => {
      r && n.onMount && n.onMount(r),
        e && (r ? e.mount(r) : e.unmount()),
        t && (typeof t == "function" ? t(r) : pd(t) && (t.current = r));
    },
    [e]
  );
}
const _C = (n) => n.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  AQ = "framerAppearId",
  Oz = "data-" + _C(AQ),
  Dz = P.createContext({});
function RQ(n, e, t, r, i) {
  var y, x;
  const { visualElement: s } = P.useContext(Hx),
    o = P.useContext(Ez),
    a = P.useContext($M),
    l = P.useContext(bz).reducedMotion,
    c = P.useRef(null);
  (r = r || o.renderer),
    !c.current &&
      r &&
      (c.current = r(n, {
        visualState: e,
        parent: s,
        props: t,
        presenceContext: a,
        blockInitialAnimation: a ? a.initial === !1 : !1,
        reducedMotionConfig: l,
      }));
  const u = c.current,
    f = P.useContext(Dz);
  u &&
    !u.projection &&
    i &&
    (u.type === "html" || u.type === "svg") &&
    PQ(c.current, t, i, f);
  const p = P.useRef(!1);
  P.useInsertionEffect(() => {
    u && p.current && u.update(t, a);
  });
  const m = t[Oz],
    v = P.useRef(
      !!m &&
        !((y = window.MotionHandoffIsComplete) != null && y.call(window, m)) &&
        ((x = window.MotionHasOptimisedAnimation) == null
          ? void 0
          : x.call(window, m))
    );
  return (
    sJ(() => {
      u &&
        ((p.current = !0),
        (window.MotionIsMounted = !0),
        u.updateFeatures(),
        u.scheduleRenderMicrotask(),
        v.current && u.animationState && u.animationState.animateChanges());
    }),
    P.useEffect(() => {
      u &&
        (!v.current && u.animationState && u.animationState.animateChanges(),
        v.current &&
          (queueMicrotask(() => {
            var g;
            (g = window.MotionHandoffMarkAsComplete) == null ||
              g.call(window, m);
          }),
          (v.current = !1)),
        (u.enteringChildren = void 0));
    }),
    u
  );
}
function PQ(n, e, t, r) {
  const {
    layoutId: i,
    layout: s,
    drag: o,
    dragConstraints: a,
    layoutScroll: l,
    layoutRoot: c,
    layoutCrossfade: u,
  } = e;
  (n.projection = new t(
    n.latestValues,
    e["data-framer-portal-id"] ? void 0 : kz(n.parent)
  )),
    n.projection.setOptions({
      layoutId: i,
      layout: s,
      alwaysMeasureLayout: !!o || (a && pd(a)),
      visualElement: n,
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: r,
      crossfade: u,
      layoutScroll: l,
      layoutRoot: c,
    });
}
function kz(n) {
  if (n) return n.options.allowProjection !== !1 ? n.projection : kz(n.parent);
}
function VS(n, { forwardMotionProps: e = !1 } = {}, t, r) {
  t && rQ(t);
  const i = vC(n) ? TQ : EQ;
  function s(a, l) {
    let c;
    const u = { ...P.useContext(bz), ...a, layoutId: IQ(a) },
      { isStatic: f } = u,
      p = lQ(a),
      m = i(a, f);
    if (!f && GM) {
      NQ();
      const v = LQ(u);
      (c = v.MeasureLayout),
        (p.visualElement = RQ(n, m, u, r, v.ProjectionNode));
    }
    return T.jsxs(Hx.Provider, {
      value: p,
      children: [
        c && p.visualElement
          ? T.jsx(c, { visualElement: p.visualElement, ...u })
          : null,
        wQ(n, a, CQ(m, p.visualElement, l), m, f, e),
      ],
    });
  }
  s.displayName = `motion.${
    typeof n == "string" ? n : `create(${n.displayName ?? n.name ?? ""})`
  }`;
  const o = P.forwardRef(s);
  return (o[MQ] = n), o;
}
function IQ({ layoutId: n }) {
  const e = P.useContext(LB).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function NQ(n, e) {
  P.useContext(Ez).strict;
}
function LQ(n) {
  const { drag: e, layout: t } = ih;
  if (!e && !t) return {};
  const r = { ...e, ...t };
  return {
    MeasureLayout:
      (e != null && e.isEnabled(n)) || (t != null && t.isEnabled(n))
        ? r.MeasureLayout
        : void 0,
    ProjectionNode: r.ProjectionNode,
  };
}
function OQ(n, e) {
  if (typeof Proxy > "u") return VS;
  const t = new Map(),
    r = (s, o) => VS(s, o, n, e),
    i = (s, o) => r(s, o);
  return new Proxy(i, {
    get: (s, o) =>
      o === "create"
        ? r
        : (t.has(o) || t.set(o, VS(o, void 0, n, e)), t.get(o)),
  });
}
function Uz({ top: n, left: e, right: t, bottom: r }) {
  return { x: { min: e, max: t }, y: { min: n, max: r } };
}
function DQ({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function kQ(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    r = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: r.y, right: r.x };
}
function jS(n) {
  return n === void 0 || n === 1;
}
function PE({ scale: n, scaleX: e, scaleY: t }) {
  return !jS(n) || !jS(e) || !jS(t);
}
function rc(n) {
  return (
    PE(n) ||
    Fz(n) ||
    n.z ||
    n.rotate ||
    n.rotateX ||
    n.rotateY ||
    n.skewX ||
    n.skewY
  );
}
function Fz(n) {
  return J2(n.x) || J2(n.y);
}
function J2(n) {
  return n && n !== "0%";
}
function S0(n, e, t) {
  const r = n - t,
    i = e * r;
  return t + i;
}
function Z2(n, e, t, r, i) {
  return i !== void 0 && (n = S0(n, i, r)), S0(n, t, r) + e;
}
function IE(n, e = 0, t = 1, r, i) {
  (n.min = Z2(n.min, e, t, r, i)), (n.max = Z2(n.max, e, t, r, i));
}
function Bz(n, { x: e, y: t }) {
  IE(n.x, e.translate, e.scale, e.originPoint),
    IE(n.y, t.translate, t.scale, t.originPoint);
}
const Q2 = 0.999999999999,
  eN = 1.0000000000001;
function UQ(n, e, t, r = !1) {
  const i = t.length;
  if (!i) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < i; a++) {
    (s = t[a]), (o = s.projectionDelta);
    const { visualElement: l } = s.options;
    (l && l.props.style && l.props.style.display === "contents") ||
      (r &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        gd(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), Bz(n, o)),
      r && rc(s.latestValues) && gd(n, s.latestValues));
  }
  e.x < eN && e.x > Q2 && (e.x = 1), e.y < eN && e.y > Q2 && (e.y = 1);
}
function md(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function tN(n, e, t, r, i = 0.5) {
  const s = bn(n.min, n.max, i);
  IE(n, e, t, s, r);
}
function gd(n, e) {
  tN(n.x, e.x, e.scaleX, e.scale, e.originX),
    tN(n.y, e.y, e.scaleY, e.scale, e.originY);
}
function zz(n, e) {
  return Uz(kQ(n.getBoundingClientRect(), e));
}
function FQ(n, e, t) {
  const r = zz(n, t),
    { scroll: i } = e;
  return i && (md(r.x, i.offset.x), md(r.y, i.offset.y)), r;
}
const nN = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  vd = () => ({ x: nN(), y: nN() }),
  rN = () => ({ min: 0, max: 0 }),
  Fn = () => ({ x: rN(), y: rN() }),
  NE = { current: null },
  Vz = { current: !1 };
function BQ() {
  if (((Vz.current = !0), !!GM))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (NE.current = n.matches);
      n.addEventListener("change", e), e();
    } else NE.current = !1;
}
const zQ = new WeakMap();
function VQ(n, e, t) {
  for (const r in e) {
    const i = e[r],
      s = t[r];
    if (Lr(i)) n.addValue(r, i);
    else if (Lr(s)) n.addValue(r, rh(i, { owner: n }));
    else if (s !== i)
      if (n.hasValue(r)) {
        const o = n.getValue(r);
        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);
      } else {
        const o = n.getStaticValue(r);
        n.addValue(r, rh(o !== void 0 ? o : i, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const iN = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
class jQ {
  scrapeMotionValuesFromProps(e, t, r) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: r,
      reducedMotionConfig: i,
      blockInitialAnimation: s,
      visualState: o,
    },
    a = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = lC),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const p = hi.now();
        this.renderScheduledAt < p &&
          ((this.renderScheduledAt = p), xn.render(this.render, !1, !0));
      });
    const { latestValues: l, renderState: c } = o;
    (this.latestValues = l),
      (this.baseTarget = { ...l }),
      (this.initialValues = t.initial ? { ...l } : {}),
      (this.renderState = c),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = r),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = i),
      (this.options = a),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = Gx(t)),
      (this.isVariantNode = Mz(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: u, ...f } = this.scrapeMotionValuesFromProps(
      t,
      {},
      this
    );
    for (const p in f) {
      const m = f[p];
      l[p] !== void 0 && Lr(m) && m.set(l[p]);
    }
  }
  mount(e) {
    var t;
    (this.current = e),
      zQ.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((r, i) => this.bindToMotionValue(i, r)),
      Vz.current || BQ(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : NE.current),
      (t = this.parent) == null || t.addChild(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    var e;
    this.projection && this.projection.unmount(),
      dl(this.notifyUpdate),
      dl(this.render),
      this.valueSubscriptions.forEach((t) => t()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      (e = this.parent) == null || e.removeChild(this);
    for (const t in this.events) this.events[t].clear();
    for (const t in this.features) {
      const r = this.features[t];
      r && (r.unmount(), (r.isMounted = !1));
    }
    this.current = null;
  }
  addChild(e) {
    this.children.add(e),
      this.enteringChildren ?? (this.enteringChildren = new Set()),
      this.enteringChildren.add(e);
  }
  removeChild(e) {
    this.children.delete(e),
      this.enteringChildren && this.enteringChildren.delete(e);
  }
  bindToMotionValue(e, t) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const r = Rh.has(e);
    r && this.onBindTransform && this.onBindTransform();
    const i = t.on("change", (o) => {
      (this.latestValues[e] = o),
        this.props.onUpdate && xn.preRender(this.notifyUpdate),
        r && this.projection && (this.projection.isTransformDirty = !0),
        this.scheduleRender();
    });
    let s;
    window.MotionCheckAppearSync &&
      (s = window.MotionCheckAppearSync(this, e, t)),
      this.valueSubscriptions.set(e, () => {
        i(), s && s(), t.owner && t.stop();
      });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in ih) {
      const t = ih[e];
      if (!t) continue;
      const { isEnabled: r, Feature: i } = t;
      if (
        (!this.features[e] &&
          i &&
          r(this.props) &&
          (this.features[e] = new i(this)),
        this.features[e])
      ) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Fn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let r = 0; r < iN.length; r++) {
      const i = iN[r];
      this.propEventSubscriptions[i] &&
        (this.propEventSubscriptions[i](),
        delete this.propEventSubscriptions[i]);
      const s = "on" + i,
        o = e[s];
      o && (this.propEventSubscriptions[i] = this.on(i, o));
    }
    (this.prevMotionValues = VQ(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    const r = this.values.get(e);
    t !== r &&
      (r && this.removeValue(e),
      this.bindToMotionValue(e, t),
      this.values.set(e, t),
      (this.latestValues[e] = t.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let r = this.values.get(e);
    return (
      r === void 0 &&
        t !== void 0 &&
        ((r = rh(t === null ? void 0 : t, { owner: this })),
        this.addValue(e, r)),
      r
    );
  }
  readValue(e, t) {
    let r =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : this.getBaseTargetFromProps(this.props, e) ??
          this.readValueFromInstance(this.current, e, this.options);
    return (
      r != null &&
        (typeof r == "string" && (OB(r) || kB(r))
          ? (r = parseFloat(r))
          : !tQ(r) && hl.test(t) && (r = vz(e, t)),
        this.setBaseTarget(e, Lr(r) ? r.get() : r)),
      Lr(r) ? r.get() : r
    );
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var s;
    const { initial: t } = this.props;
    let r;
    if (typeof t == "string" || typeof t == "object") {
      const o = yC(
        this.props,
        t,
        (s = this.presenceContext) == null ? void 0 : s.custom
      );
      o && (r = o[e]);
    }
    if (t && r !== void 0) return r;
    const i = this.getBaseTargetFromProps(this.props, e);
    return i !== void 0 && !Lr(i)
      ? i
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new YM()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
  scheduleRenderMicrotask() {
    dC.render(this.render);
  }
}
class jz extends jQ {
  constructor() {
    super(...arguments), (this.KeyframeResolver = jZ);
  }
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: r }) {
    delete t[e], delete r[e];
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Lr(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
}
function Hz(n, { style: e, vars: t }, r, i) {
  const s = n.style;
  let o;
  for (o in e) s[o] = e[o];
  i == null || i.applyProjectionStyles(s, r);
  for (o in t) s.setProperty(o, t[o]);
}
function HQ(n) {
  return window.getComputedStyle(n);
}
class WQ extends jz {
  constructor() {
    super(...arguments), (this.type = "html"), (this.renderInstance = Hz);
  }
  readValueFromInstance(e, t) {
    var r;
    if (Rh.has(t))
      return (r = this.projection) != null && r.isProjecting ? bE(t) : aZ(e, t);
    {
      const i = HQ(e),
        s = (QM(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return zz(e, t);
  }
  build(e, t, r) {
    mC(e, t, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t, r) {
    return xC(e, t, r);
  }
}
const Wz = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function GQ(n, e, t, r) {
  Hz(n, e, void 0, r);
  for (const i in e.attrs) n.setAttribute(Wz.has(i) ? i : _C(i), e.attrs[i]);
}
class $Q extends jz {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Fn);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (Rh.has(t)) {
      const r = gz(t);
      return (r && r.default) || 0;
    }
    return (t = Wz.has(t) ? t : _C(t)), e.getAttribute(t);
  }
  scrapeMotionValuesFromProps(e, t, r) {
    return Lz(e, t, r);
  }
  build(e, t, r) {
    Rz(e, t, this.isSVGTag, r.transformTemplate, r.style);
  }
  renderInstance(e, t, r, i) {
    GQ(e, t, r, i);
  }
  mount(e) {
    (this.isSVGTag = Iz(e.tagName)), super.mount(e);
  }
}
const XQ = (n, e) =>
  vC(n) ? new $Q(e) : new WQ(e, { allowProjection: n !== P.Fragment });
function Od(n, e, t) {
  const r = n.getProps();
  return yC(r, e, t !== void 0 ? t : r.custom, n);
}
const LE = (n) => Array.isArray(n);
function qQ(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, rh(t));
}
function KQ(n) {
  return LE(n) ? n[n.length - 1] || 0 : n;
}
function YQ(n, e) {
  const t = Od(n, e);
  let { transitionEnd: r = {}, transition: i = {}, ...s } = t || {};
  s = { ...s, ...r };
  for (const o in s) {
    const a = KQ(s[o]);
    qQ(n, o, a);
  }
}
function JQ(n) {
  return !!(Lr(n) && n.add);
}
function OE(n, e) {
  const t = n.getValue("willChange");
  if (JQ(t)) return t.add(e);
  if (!t && na.WillChange) {
    const r = new na.WillChange("auto");
    n.addValue("willChange", r), r.add(e);
  }
}
function Gz(n) {
  return n.props[Oz];
}
const ZQ = (n) => n !== null;
function QQ(n, { repeat: e, repeatType: t = "loop" }, r) {
  const i = n.filter(ZQ),
    s = e && t !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
  return !s || r === void 0 ? i[s] : r;
}
const eee = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  tee = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  nee = { type: "keyframes", duration: 0.8 },
  ree = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  iee = (n, { keyframes: e }) =>
    e.length > 2
      ? nee
      : Rh.has(n)
      ? n.startsWith("scale")
        ? tee(e[1])
        : eee
      : ree;
function see({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: r,
  staggerDirection: i,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length;
}
const wC =
  (n, e, t, r = {}, i, s) =>
  (o) => {
    const a = cC(r, n) || {},
      l = a.delay || r.delay || 0;
    let { elapsed: c = 0 } = r;
    c = c - fo(l);
    const u = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...a,
      delay: -c,
      onUpdate: (p) => {
        e.set(p), a.onUpdate && a.onUpdate(p);
      },
      onComplete: () => {
        o(), a.onComplete && a.onComplete();
      },
      name: n,
      motionValue: e,
      element: s ? void 0 : i,
    };
    see(a) || Object.assign(u, iee(n, u)),
      u.duration && (u.duration = fo(u.duration)),
      u.repeatDelay && (u.repeatDelay = fo(u.repeatDelay)),
      u.from !== void 0 && (u.keyframes[0] = u.from);
    let f = !1;
    if (
      ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
        (AE(u), u.delay === 0 && (f = !0)),
      (na.instantAnimations || na.skipAnimations) &&
        ((f = !0), AE(u), (u.delay = 0)),
      (u.allowFlatten = !a.type && !a.ease),
      f && !s && e.get() !== void 0)
    ) {
      const p = QQ(u.keyframes, a);
      if (p !== void 0) {
        xn.update(() => {
          u.onUpdate(p), u.onComplete();
        });
        return;
      }
    }
    return a.isSync ? new aC(u) : new PZ(u);
  };
function oee({ protectedKeys: n, needsAnimating: e }, t) {
  const r = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), r;
}
function $z(n, e, { delay: t = 0, transitionOverride: r, type: i } = {}) {
  let { transition: s = n.getDefaultTransition(), transitionEnd: o, ...a } = e;
  r && (s = r);
  const l = [],
    c = i && n.animationState && n.animationState.getState()[i];
  for (const u in a) {
    const f = n.getValue(u, n.latestValues[u] ?? null),
      p = a[u];
    if (p === void 0 || (c && oee(c, u))) continue;
    const m = { delay: t, ...cC(s || {}, u) },
      v = f.get();
    if (
      v !== void 0 &&
      !f.isAnimating &&
      !Array.isArray(p) &&
      p === v &&
      !m.velocity
    )
      continue;
    let y = !1;
    if (window.MotionHandoffAnimation) {
      const g = Gz(n);
      if (g) {
        const _ = window.MotionHandoffAnimation(g, u, xn);
        _ !== null && ((m.startTime = _), (y = !0));
      }
    }
    OE(n, u),
      f.start(
        wC(u, f, p, n.shouldReduceMotion && fz.has(u) ? { type: !1 } : m, n, y)
      );
    const x = f.animation;
    x && l.push(x);
  }
  return (
    o &&
      Promise.all(l).then(() => {
        xn.update(() => {
          o && YQ(n, o);
        });
      }),
    l
  );
}
function Xz(n, e, t, r = 0, i = 1) {
  const s = Array.from(n)
      .sort((c, u) => c.sortNodePosition(u))
      .indexOf(e),
    o = n.size,
    a = (o - 1) * r;
  return typeof t == "function" ? t(s, o) : i === 1 ? s * r : a - s * r;
}
function DE(n, e, t = {}) {
  var l;
  const r = Od(
    n,
    e,
    t.type === "exit"
      ? (l = n.presenceContext) == null
        ? void 0
        : l.custom
      : void 0
  );
  let { transition: i = n.getDefaultTransition() || {} } = r || {};
  t.transitionOverride && (i = t.transitionOverride);
  const s = r ? () => Promise.all($z(n, r, t)) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (c = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: f,
              staggerDirection: p,
            } = i;
            return aee(n, e, c, u, f, p, t);
          }
        : () => Promise.resolve(),
    { when: a } = i;
  if (a) {
    const [c, u] = a === "beforeChildren" ? [s, o] : [o, s];
    return c().then(() => u());
  } else return Promise.all([s(), o(t.delay)]);
}
function aee(n, e, t = 0, r = 0, i = 0, s = 1, o) {
  const a = [];
  for (const l of n.variantChildren)
    l.notify("AnimationStart", e),
      a.push(
        DE(l, e, {
          ...o,
          delay:
            t +
            (typeof r == "function" ? 0 : r) +
            Xz(n.variantChildren, l, r, i, s),
        }).then(() => l.notify("AnimationComplete", e))
      );
  return Promise.all(a);
}
function lee(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let r;
  if (Array.isArray(e)) {
    const i = e.map((s) => DE(n, s, t));
    r = Promise.all(i);
  } else if (typeof e == "string") r = DE(n, e, t);
  else {
    const i = typeof e == "function" ? Od(n, e, t.custom) : e;
    r = Promise.all($z(n, i, t));
  }
  return r.then(() => {
    n.notify("AnimationComplete", e);
  });
}
function qz(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let r = 0; r < t; r++) if (e[r] !== n[r]) return !1;
  return !0;
}
const cee = pC.length;
function Kz(n) {
  if (!n) return;
  if (!n.isControllingVariants) {
    const t = n.parent ? Kz(n.parent) || {} : {};
    return n.props.initial !== void 0 && (t.initial = n.props.initial), t;
  }
  const e = {};
  for (let t = 0; t < cee; t++) {
    const r = pC[t],
      i = n.props[r];
    (Vp(i) || i === !1) && (e[r] = i);
  }
  return e;
}
const uee = [...fC].reverse(),
  dee = fC.length;
function hee(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: r }) => lee(n, t, r)));
}
function fee(n) {
  let e = hee(n),
    t = sN(),
    r = !0;
  const i = (l) => (c, u) => {
    var p;
    const f = Od(
      n,
      u,
      l === "exit"
        ? (p = n.presenceContext) == null
          ? void 0
          : p.custom
        : void 0
    );
    if (f) {
      const { transition: m, transitionEnd: v, ...y } = f;
      c = { ...c, ...y, ...v };
    }
    return c;
  };
  function s(l) {
    e = l(n);
  }
  function o(l) {
    const { props: c } = n,
      u = Kz(n.parent) || {},
      f = [],
      p = new Set();
    let m = {},
      v = 1 / 0;
    for (let x = 0; x < dee; x++) {
      const g = uee[x],
        _ = t[g],
        S = c[g] !== void 0 ? c[g] : u[g],
        b = Vp(S),
        C = g === l ? _.isActive : null;
      C === !1 && (v = x);
      let A = S === u[g] && S !== c[g] && b;
      if (
        (A && r && n.manuallyAnimateOnMount && (A = !1),
        (_.protectedKeys = { ...m }),
        (!_.isActive && C === null) ||
          (!S && !_.prevProp) ||
          Wx(S) ||
          typeof S == "boolean")
      )
        continue;
      const R = pee(_.prevProp, S);
      let O = R || (g === l && _.isActive && !A && b) || (x > v && b),
        I = !1;
      const N = Array.isArray(S) ? S : [S];
      let D = N.reduce(i(g), {});
      C === !1 && (D = {});
      const { prevResolvedValues: j = {} } = _,
        $ = { ...j, ...D },
        G = (Y) => {
          (O = !0),
            p.has(Y) && ((I = !0), p.delete(Y)),
            (_.needsAnimating[Y] = !0);
          const U = n.getValue(Y);
          U && (U.liveStyle = !1);
        };
      for (const Y in $) {
        const U = D[Y],
          H = j[Y];
        if (m.hasOwnProperty(Y)) continue;
        let X = !1;
        LE(U) && LE(H) ? (X = !qz(U, H)) : (X = U !== H),
          X
            ? U != null
              ? G(Y)
              : p.add(Y)
            : U !== void 0 && p.has(Y)
            ? G(Y)
            : (_.protectedKeys[Y] = !0);
      }
      (_.prevProp = S),
        (_.prevResolvedValues = D),
        _.isActive && (m = { ...m, ...D }),
        r && n.blockInitialAnimation && (O = !1);
      const Z = A && R;
      O &&
        (!Z || I) &&
        f.push(
          ...N.map((Y) => {
            const U = { type: g };
            if (
              typeof Y == "string" &&
              r &&
              !Z &&
              n.manuallyAnimateOnMount &&
              n.parent
            ) {
              const { parent: H } = n,
                X = Od(H, Y);
              if (H.enteringChildren && X) {
                const { delayChildren: ie } = X.transition || {};
                U.delay = Xz(H.enteringChildren, n, ie);
              }
            }
            return { animation: Y, options: U };
          })
        );
    }
    if (p.size) {
      const x = {};
      if (typeof c.initial != "boolean") {
        const g = Od(n, Array.isArray(c.initial) ? c.initial[0] : c.initial);
        g && g.transition && (x.transition = g.transition);
      }
      p.forEach((g) => {
        const _ = n.getBaseTarget(g),
          S = n.getValue(g);
        S && (S.liveStyle = !0), (x[g] = _ ?? null);
      }),
        f.push({ animation: x });
    }
    let y = !!f.length;
    return (
      r &&
        (c.initial === !1 || c.initial === c.animate) &&
        !n.manuallyAnimateOnMount &&
        (y = !1),
      (r = !1),
      y ? e(f) : Promise.resolve()
    );
  }
  function a(l, c) {
    var f;
    if (t[l].isActive === c) return Promise.resolve();
    (f = n.variantChildren) == null ||
      f.forEach((p) => {
        var m;
        return (m = p.animationState) == null ? void 0 : m.setActive(l, c);
      }),
      (t[l].isActive = c);
    const u = o(l);
    for (const p in t) t[p].protectedKeys = {};
    return u;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
    reset: () => {
      (t = sN()), (r = !0);
    },
  };
}
function pee(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !qz(e, n) : !1;
}
function Fl(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function sN() {
  return {
    animate: Fl(!0),
    whileInView: Fl(),
    whileHover: Fl(),
    whileTap: Fl(),
    whileDrag: Fl(),
    whileFocus: Fl(),
    exit: Fl(),
  };
}
class _l {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
class mee extends _l {
  constructor(e) {
    super(e), e.animationState || (e.animationState = fee(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    Wx(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(),
      (e = this.unmountControls) == null || e.call(this);
  }
}
let gee = 0;
class vee extends _l {
  constructor() {
    super(...arguments), (this.id = gee++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: t } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const i = this.node.animationState.setActive("exit", !e);
    t &&
      !e &&
      i.then(() => {
        t(this.id);
      });
  }
  mount() {
    const { register: e, onExitComplete: t } = this.node.presenceContext || {};
    t && t(this.id), e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const yee = { animation: { Feature: mee }, exit: { Feature: vee } };
function Hp(n, e, t, r = { passive: !0 }) {
  return n.addEventListener(e, t, r), () => n.removeEventListener(e, t);
}
function Sm(n) {
  return { point: { x: n.pageX, y: n.pageY } };
}
const xee = (n) => (e) => hC(e) && n(e, Sm(e));
function Qf(n, e, t, r) {
  return Hp(n, e, xee(t), r);
}
const Yz = 1e-4,
  _ee = 1 - Yz,
  wee = 1 + Yz,
  Jz = 0.01,
  See = 0 - Jz,
  bee = 0 + Jz;
function Kr(n) {
  return n.max - n.min;
}
function Eee(n, e, t) {
  return Math.abs(n - e) <= t;
}
function oN(n, e, t, r = 0.5) {
  (n.origin = r),
    (n.originPoint = bn(e.min, e.max, n.origin)),
    (n.scale = Kr(t) / Kr(e)),
    (n.translate = bn(t.min, t.max, n.origin) - n.originPoint),
    ((n.scale >= _ee && n.scale <= wee) || isNaN(n.scale)) && (n.scale = 1),
    ((n.translate >= See && n.translate <= bee) || isNaN(n.translate)) &&
      (n.translate = 0);
}
function ep(n, e, t, r) {
  oN(n.x, e.x, t.x, r ? r.originX : void 0),
    oN(n.y, e.y, t.y, r ? r.originY : void 0);
}
function aN(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + Kr(e));
}
function Tee(n, e, t) {
  aN(n.x, e.x, t.x), aN(n.y, e.y, t.y);
}
function lN(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + Kr(e));
}
function tp(n, e, t) {
  lN(n.x, e.x, t.x), lN(n.y, e.y, t.y);
}
function Yi(n) {
  return [n("x"), n("y")];
}
const Zz = ({ current: n }) => (n ? n.ownerDocument.defaultView : null),
  cN = (n, e) => Math.abs(n - e);
function Mee(n, e) {
  const t = cN(n.x, e.x),
    r = cN(n.y, e.y);
  return Math.sqrt(t ** 2 + r ** 2);
}
class Qz {
  constructor(
    e,
    t,
    {
      transformPagePoint: r,
      contextWindow: i = window,
      dragSnapToOrigin: s = !1,
      distanceThreshold: o = 3,
    } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const p = WS(this.lastMoveEventInfo, this.history),
          m = this.startEvent !== null,
          v = Mee(p.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
        if (!m && !v) return;
        const { point: y } = p,
          { timestamp: x } = fr;
        this.history.push({ ...y, timestamp: x });
        const { onStart: g, onMove: _ } = this.handlers;
        m ||
          (g && g(this.lastMoveEvent, p),
          (this.startEvent = this.lastMoveEvent)),
          _ && _(this.lastMoveEvent, p);
      }),
      (this.handlePointerMove = (p, m) => {
        (this.lastMoveEvent = p),
          (this.lastMoveEventInfo = HS(m, this.transformPagePoint)),
          xn.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (p, m) => {
        this.end();
        const { onEnd: v, onSessionEnd: y, resumeAnimation: x } = this.handlers;
        if (
          (this.dragSnapToOrigin && x && x(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const g = WS(
          p.type === "pointercancel"
            ? this.lastMoveEventInfo
            : HS(m, this.transformPagePoint),
          this.history
        );
        this.startEvent && v && v(p, g), y && y(p, g);
      }),
      !hC(e))
    )
      return;
    (this.dragSnapToOrigin = s),
      (this.handlers = t),
      (this.transformPagePoint = r),
      (this.distanceThreshold = o),
      (this.contextWindow = i || window);
    const a = Sm(e),
      l = HS(a, this.transformPagePoint),
      { point: c } = l,
      { timestamp: u } = fr;
    this.history = [{ ...c, timestamp: u }];
    const { onSessionStart: f } = t;
    f && f(e, WS(l, this.history)),
      (this.removeListeners = xm(
        Qf(this.contextWindow, "pointermove", this.handlePointerMove),
        Qf(this.contextWindow, "pointerup", this.handlePointerUp),
        Qf(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), dl(this.updatePoint);
  }
}
function HS(n, e) {
  return e ? { point: e(n.point) } : n;
}
function uN(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function WS({ point: n }, e) {
  return {
    point: n,
    delta: uN(n, e4(e)),
    offset: uN(n, Cee(e)),
    velocity: Aee(e, 0.1),
  };
}
function Cee(n) {
  return n[0];
}
function e4(n) {
  return n[n.length - 1];
}
function Aee(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    r = null;
  const i = e4(n);
  for (; t >= 0 && ((r = n[t]), !(i.timestamp - r.timestamp > fo(e))); ) t--;
  if (!r) return { x: 0, y: 0 };
  const s = po(i.timestamp - r.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (i.x - r.x) / s, y: (i.y - r.y) / s };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function Ree(n, { min: e, max: t }, r) {
  return (
    e !== void 0 && n < e
      ? (n = r ? bn(e, n, r.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = r ? bn(t, n, r.max) : Math.min(n, t)),
    n
  );
}
function dN(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function Pee(n, { top: e, left: t, bottom: r, right: i }) {
  return { x: dN(n.x, t, i), y: dN(n.y, e, r) };
}
function hN(n, e) {
  let t = e.min - n.min,
    r = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, r] = [r, t]), { min: t, max: r };
}
function Iee(n, e) {
  return { x: hN(n.x, e.x), y: hN(n.y, e.y) };
}
function Nee(n, e) {
  let t = 0.5;
  const r = Kr(n),
    i = Kr(e);
  return (
    i > r
      ? (t = Fp(e.min, e.max - r, n.min))
      : r > i && (t = Fp(n.min, n.max - i, e.min)),
    ta(0, 1, t)
  );
}
function Lee(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const kE = 0.35;
function Oee(n = kE) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = kE),
    { x: fN(n, "left", "right"), y: fN(n, "top", "bottom") }
  );
}
function fN(n, e, t) {
  return { min: pN(n, e), max: pN(n, t) };
}
function pN(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const Dee = new WeakMap();
class kee {
  constructor(e) {
    (this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Fn()),
      (this.latestPointerEvent = null),
      (this.latestPanInfo = null),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1, distanceThreshold: r } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const s = (f) => {
        const { dragSnapToOrigin: p } = this.getProps();
        p ? this.pauseAnimation() : this.stopAnimation(),
          t && this.snapToCursor(Sm(f).point);
      },
      o = (f, p) => {
        const { drag: m, dragPropagation: v, onDragStart: y } = this.getProps();
        if (
          m &&
          !v &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = XZ(m)),
          !this.openDragLock)
        )
          return;
        (this.latestPointerEvent = f),
          (this.latestPanInfo = p),
          (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Yi((g) => {
            let _ = this.getAxisMotionValue(g).get() || 0;
            if (mo.test(_)) {
              const { projection: S } = this.visualElement;
              if (S && S.layout) {
                const b = S.layout.layoutBox[g];
                b && (_ = Kr(b) * (parseFloat(_) / 100));
              }
            }
            this.originPoint[g] = _;
          }),
          y && xn.postRender(() => y(f, p)),
          OE(this.visualElement, "transform");
        const { animationState: x } = this.visualElement;
        x && x.setActive("whileDrag", !0);
      },
      a = (f, p) => {
        (this.latestPointerEvent = f), (this.latestPanInfo = p);
        const {
          dragPropagation: m,
          dragDirectionLock: v,
          onDirectionLock: y,
          onDrag: x,
        } = this.getProps();
        if (!m && !this.openDragLock) return;
        const { offset: g } = p;
        if (v && this.currentDirection === null) {
          (this.currentDirection = Uee(g)),
            this.currentDirection !== null && y && y(this.currentDirection);
          return;
        }
        this.updateAxis("x", p.point, g),
          this.updateAxis("y", p.point, g),
          this.visualElement.render(),
          x && x(f, p);
      },
      l = (f, p) => {
        (this.latestPointerEvent = f),
          (this.latestPanInfo = p),
          this.stop(f, p),
          (this.latestPointerEvent = null),
          (this.latestPanInfo = null);
      },
      c = () =>
        Yi((f) => {
          var p;
          return (
            this.getAnimationState(f) === "paused" &&
            ((p = this.getAxisMotionValue(f).animation) == null
              ? void 0
              : p.play())
          );
        }),
      { dragSnapToOrigin: u } = this.getProps();
    this.panSession = new Qz(
      e,
      {
        onSessionStart: s,
        onStart: o,
        onMove: a,
        onSessionEnd: l,
        resumeAnimation: c,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: u,
        distanceThreshold: r,
        contextWindow: Zz(this.visualElement),
      }
    );
  }
  stop(e, t) {
    const r = e || this.latestPointerEvent,
      i = t || this.latestPanInfo,
      s = this.isDragging;
    if ((this.cancel(), !s || !i || !r)) return;
    const { velocity: o } = i;
    this.startAnimation(o);
    const { onDragEnd: a } = this.getProps();
    a && xn.postRender(() => a(r, i));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: r } = this.getProps();
    !r &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, r) {
    const { drag: i } = this.getProps();
    if (!r || !pv(e, i, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + r[e];
    this.constraints &&
      this.constraints[e] &&
      (o = Ree(o, this.constraints[e], this.elastic[e])),
      s.set(o);
  }
  resolveConstraints() {
    var s;
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (s = this.visualElement.projection) == null
          ? void 0
          : s.layout,
      i = this.constraints;
    e && pd(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && r
      ? (this.constraints = Pee(r.layoutBox, e))
      : (this.constraints = !1),
      (this.elastic = Oee(t)),
      i !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Yi((o) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(o) &&
            (this.constraints[o] = Lee(r.layoutBox[o], this.constraints[o]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !pd(e)) return !1;
    const r = e.current,
      { projection: i } = this.visualElement;
    if (!i || !i.layout) return !1;
    const s = FQ(r, i.root, this.visualElement.getTransformPagePoint());
    let o = Iee(i.layout.layoutBox, s);
    if (t) {
      const a = t(DQ(o));
      (this.hasMutatedConstraints = !!a), a && (o = Uz(a));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: r,
        dragElastic: i,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      c = Yi((u) => {
        if (!pv(u, t, this.currentDirection)) return;
        let f = (l && l[u]) || {};
        o && (f = { min: 0, max: 0 });
        const p = i ? 200 : 1e6,
          m = i ? 40 : 1e7,
          v = {
            type: "inertia",
            velocity: r ? e[u] : 0,
            bounceStiffness: p,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...f,
          };
        return this.startAxisValueAnimation(u, v);
      });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(e, t) {
    const r = this.getAxisMotionValue(e);
    return (
      OE(this.visualElement, e), r.start(wC(e, r, 0, t, this.visualElement, !1))
    );
  }
  stopAnimation() {
    Yi((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Yi((e) => {
      var t;
      return (t = this.getAxisMotionValue(e).animation) == null
        ? void 0
        : t.pause();
    });
  }
  getAnimationState(e) {
    var t;
    return (t = this.getAxisMotionValue(e).animation) == null
      ? void 0
      : t.state;
  }
  getAxisMotionValue(e) {
    const t = `_drag${e.toUpperCase()}`,
      r = this.visualElement.getProps(),
      i = r[t];
    return (
      i ||
      this.visualElement.getValue(e, (r.initial ? r.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    Yi((t) => {
      const { drag: r } = this.getProps();
      if (!pv(t, r, this.currentDirection)) return;
      const { projection: i } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (i && i.layout) {
        const { min: o, max: a } = i.layout.layoutBox[t];
        s.set(e[t] - bn(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: r } = this.visualElement;
    if (!pd(t) || !r || !this.constraints) return;
    this.stopAnimation();
    const i = { x: 0, y: 0 };
    Yi((o) => {
      const a = this.getAxisMotionValue(o);
      if (a && this.constraints !== !1) {
        const l = a.get();
        i[o] = Nee({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      r.root && r.root.updateScroll(),
      r.updateLayout(),
      this.resolveConstraints(),
      Yi((o) => {
        if (!pv(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: l, max: c } = this.constraints[o];
        a.set(bn(l, c, i[o]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    Dee.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Qf(e, "pointerdown", (l) => {
        const { drag: c, dragListener: u = !0 } = this.getProps();
        c && u && this.start(l);
      }),
      r = () => {
        const { dragConstraints: l } = this.getProps();
        pd(l) && l.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: i } = this.visualElement,
      s = i.addEventListener("measure", r);
    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()),
      xn.read(r);
    const o = Hp(window, "resize", () => this.scalePositionWithinConstraints()),
      a = i.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: c }) => {
          this.isDragging &&
            c &&
            (Yi((u) => {
              const f = this.getAxisMotionValue(u);
              f &&
                ((this.originPoint[u] += l[u].translate),
                f.set(f.get() + l[u].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      o(), t(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: r = !1,
        dragPropagation: i = !1,
        dragConstraints: s = !1,
        dragElastic: o = kE,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: r,
      dragPropagation: i,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function pv(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function Uee(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class Fee extends _l {
  constructor(e) {
    super(e),
      (this.removeGroupControls = ss),
      (this.removeListeners = ss),
      (this.controls = new kee(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || ss);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const mN = (n) => (e, t) => {
  n && xn.postRender(() => n(e, t));
};
class Bee extends _l {
  constructor() {
    super(...arguments), (this.removePointerDownListener = ss);
  }
  onPointerDown(e) {
    this.session = new Qz(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: Zz(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: r,
      onPanEnd: i,
    } = this.node.getProps();
    return {
      onSessionStart: mN(e),
      onStart: mN(t),
      onMove: r,
      onEnd: (s, o) => {
        delete this.session, i && xn.postRender(() => i(s, o));
      },
    };
  }
  mount() {
    this.removePointerDownListener = Qf(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Ry = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
function gN(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const ff = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (Et.test(n)) n = parseFloat(n);
        else return n;
      const t = gN(n, e.target.x),
        r = gN(n, e.target.y);
      return `${t}% ${r}%`;
    },
  },
  zee = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const r = n,
        i = hl.parse(n);
      if (i.length > 5) return r;
      const s = hl.createTransformer(n),
        o = typeof i[0] != "number" ? 1 : 0,
        a = t.x.scale * e.x,
        l = t.y.scale * e.y;
      (i[0 + o] /= a), (i[1 + o] /= l);
      const c = bn(a, l, 0.5);
      return (
        typeof i[2 + o] == "number" && (i[2 + o] /= c),
        typeof i[3 + o] == "number" && (i[3 + o] /= c),
        s(i)
      );
    },
  };
let GS = !1;
class Vee extends P.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: r,
        layoutId: i,
      } = this.props,
      { projection: s } = e;
    cQ(jee),
      s &&
        (t.group && t.group.add(s),
        r && r.register && i && r.register(s),
        GS && s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Ry.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: r,
        drag: i,
        isPresent: s,
      } = this.props,
      { projection: o } = r;
    return (
      o &&
        ((o.isPresent = s),
        (GS = !0),
        i || e.layoutDependency !== t || t === void 0 || e.isPresent !== s
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              xn.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      dC.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: r,
      } = this.props,
      { projection: i } = e;
    (GS = !0),
      i &&
        (i.scheduleCheckAfterUnmount(),
        t && t.group && t.group.remove(i),
        r && r.deregister && r.deregister(i));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function t4(n) {
  const [e, t] = nQ(),
    r = P.useContext(LB);
  return T.jsx(Vee, {
    ...n,
    layoutGroup: r,
    switchLayoutGroup: P.useContext(Dz),
    isPresent: e,
    safeToRemove: t,
  });
}
const jee = {
  borderRadius: {
    ...ff,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: ff,
  borderTopRightRadius: ff,
  borderBottomLeftRadius: ff,
  borderBottomRightRadius: ff,
  boxShadow: zee,
};
function Hee(n, e, t) {
  const r = Lr(n) ? n : rh(n);
  return r.start(wC("", r, e, t)), r.animation;
}
const Wee = (n, e) => n.depth - e.depth;
class Gee {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    XM(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    qM(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(Wee),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function $ee(n, e) {
  const t = hi.now(),
    r = ({ timestamp: i }) => {
      const s = i - t;
      s >= e && (dl(r), n(s - e));
    };
  return xn.setup(r, !0), () => dl(r);
}
const n4 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  Xee = n4.length,
  vN = (n) => (typeof n == "string" ? parseFloat(n) : n),
  yN = (n) => typeof n == "number" || Et.test(n);
function qee(n, e, t, r, i, s) {
  i
    ? ((n.opacity = bn(0, t.opacity ?? 1, Kee(r))),
      (n.opacityExit = bn(e.opacity ?? 1, 0, Yee(r))))
    : s && (n.opacity = bn(e.opacity ?? 1, t.opacity ?? 1, r));
  for (let o = 0; o < Xee; o++) {
    const a = `border${n4[o]}Radius`;
    let l = xN(e, a),
      c = xN(t, a);
    if (l === void 0 && c === void 0) continue;
    l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || yN(l) === yN(c)
        ? ((n[a] = Math.max(bn(vN(l), vN(c), r), 0)),
          (mo.test(c) || mo.test(l)) && (n[a] += "%"))
        : (n[a] = c);
  }
  (e.rotate || t.rotate) && (n.rotate = bn(e.rotate || 0, t.rotate || 0, r));
}
function xN(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const Kee = r4(0, 0.5, WB),
  Yee = r4(0.5, 0.95, ss);
function r4(n, e, t) {
  return (r) => (r < n ? 0 : r > e ? 1 : t(Fp(n, e, r)));
}
function _N(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function qi(n, e) {
  _N(n.x, e.x), _N(n.y, e.y);
}
function wN(n, e) {
  (n.translate = e.translate),
    (n.scale = e.scale),
    (n.originPoint = e.originPoint),
    (n.origin = e.origin);
}
function SN(n, e, t, r, i) {
  return (
    (n -= e), (n = S0(n, 1 / t, r)), i !== void 0 && (n = S0(n, 1 / i, r)), n
  );
}
function Jee(n, e = 0, t = 1, r = 0.5, i, s = n, o = n) {
  if (
    (mo.test(e) &&
      ((e = parseFloat(e)), (e = bn(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = bn(s.min, s.max, r);
  n === s && (a -= e),
    (n.min = SN(n.min, e, t, a, i)),
    (n.max = SN(n.max, e, t, a, i));
}
function bN(n, e, [t, r, i], s, o) {
  Jee(n, e[t], e[r], e[i], e.scale, s, o);
}
const Zee = ["x", "scaleX", "originX"],
  Qee = ["y", "scaleY", "originY"];
function EN(n, e, t, r) {
  bN(n.x, e, Zee, t ? t.x : void 0, r ? r.x : void 0),
    bN(n.y, e, Qee, t ? t.y : void 0, r ? r.y : void 0);
}
function TN(n) {
  return n.translate === 0 && n.scale === 1;
}
function i4(n) {
  return TN(n.x) && TN(n.y);
}
function MN(n, e) {
  return n.min === e.min && n.max === e.max;
}
function ete(n, e) {
  return MN(n.x, e.x) && MN(n.y, e.y);
}
function CN(n, e) {
  return (
    Math.round(n.min) === Math.round(e.min) &&
    Math.round(n.max) === Math.round(e.max)
  );
}
function s4(n, e) {
  return CN(n.x, e.x) && CN(n.y, e.y);
}
function AN(n) {
  return Kr(n.x) / Kr(n.y);
}
function RN(n, e) {
  return (
    n.translate === e.translate &&
    n.scale === e.scale &&
    n.originPoint === e.originPoint
  );
}
class tte {
  constructor() {
    this.members = [];
  }
  add(e) {
    XM(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (qM(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((i) => e === i);
    if (t === 0) return !1;
    let r;
    for (let i = t; i >= 0; i--) {
      const s = this.members[i];
      if (s.isPresent !== !1) {
        r = s;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(e, t) {
    const r = this.lead;
    if (e !== r && ((this.prevLead = r), (this.lead = e), e.show(), r)) {
      r.instance && r.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = r),
        t && (e.resumeFrom.preserveOpacity = !0),
        r.snapshot &&
          ((e.snapshot = r.snapshot),
          (e.snapshot.latestValues = r.animationValues || r.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: i } = e.options;
      i === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: r } = e;
      t.onExitComplete && t.onExitComplete(),
        r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function nte(n, e, t) {
  let r = "";
  const i = n.x.translate / e.x,
    s = n.y.translate / e.y,
    o = (t == null ? void 0 : t.z) || 0;
  if (
    ((i || s || o) && (r = `translate3d(${i}px, ${s}px, ${o}px) `),
    (e.x !== 1 || e.y !== 1) && (r += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const {
      transformPerspective: c,
      rotate: u,
      rotateX: f,
      rotateY: p,
      skewX: m,
      skewY: v,
    } = t;
    c && (r = `perspective(${c}px) ${r}`),
      u && (r += `rotate(${u}deg) `),
      f && (r += `rotateX(${f}deg) `),
      p && (r += `rotateY(${p}deg) `),
      m && (r += `skewX(${m}deg) `),
      v && (r += `skewY(${v}deg) `);
  }
  const a = n.x.scale * e.x,
    l = n.y.scale * e.y;
  return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none";
}
const $S = ["", "X", "Y", "Z"],
  rte = 1e3;
let ite = 0;
function XS(n, e, t, r) {
  const { latestValues: i } = e;
  i[n] && ((t[n] = i[n]), e.setStaticValue(n, 0), r && (r[n] = 0));
}
function o4(n) {
  if (((n.hasCheckedOptimisedAppear = !0), n.root === n)) return;
  const { visualElement: e } = n.options;
  if (!e) return;
  const t = Gz(e);
  if (window.MotionHasOptimisedAnimation(t, "transform")) {
    const { layout: i, layoutId: s } = n.options;
    window.MotionCancelOptimisedAnimation(t, "transform", xn, !(i || s));
  }
  const { parent: r } = n;
  r && !r.hasCheckedOptimisedAppear && o4(r);
}
function a4({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: r,
  resetTransform: i,
}) {
  return class {
    constructor(o = {}, a = e == null ? void 0 : e()) {
      (this.id = ite++),
        (this.animationId = 0),
        (this.animationCommitId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            this.nodes.forEach(ate),
            this.nodes.forEach(dte),
            this.nodes.forEach(hte),
            this.nodes.forEach(lte);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = o),
        (this.root = a ? a.root || a : this),
        (this.path = a ? [...a.path, a] : []),
        (this.parent = a),
        (this.depth = a ? a.depth + 1 : 0);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Gee());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new YM()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    mount(o) {
      if (this.instance) return;
      (this.isSVG = Sz(o) && !QZ(o)), (this.instance = o);
      const { layoutId: a, layout: l, visualElement: c } = this.options;
      if (
        (c && !c.current && c.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0),
        n)
      ) {
        let u,
          f = 0;
        const p = () => (this.root.updateBlockedByResize = !1);
        xn.read(() => {
          f = window.innerWidth;
        }),
          n(o, () => {
            const m = window.innerWidth;
            m !== f &&
              ((f = m),
              (this.root.updateBlockedByResize = !0),
              u && u(),
              (u = $ee(p, 250)),
              Ry.hasAnimatedSinceResize &&
                ((Ry.hasAnimatedSinceResize = !1), this.nodes.forEach(NN)));
          });
      }
      a && this.root.registerSharedNode(a, this),
        this.options.animate !== !1 &&
          c &&
          (a || l) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: u,
              hasLayoutChanged: f,
              hasRelativeLayoutChanged: p,
              layout: m,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const v =
                  this.options.transition || c.getDefaultTransition() || vte,
                { onLayoutAnimationStart: y, onLayoutAnimationComplete: x } =
                  c.getProps(),
                g = !this.targetLayout || !s4(this.targetLayout, m),
                _ = !f && p;
              if (
                this.options.layoutRoot ||
                this.resumeFrom ||
                _ ||
                (f && (g || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0));
                const S = { ...cC(v, "layout"), onPlay: y, onComplete: x };
                (c.shouldReduceMotion || this.options.layoutRoot) &&
                  ((S.delay = 0), (S.type = !1)),
                  this.startAnimation(S),
                  this.setAnimationOrigin(u, _);
              } else
                f || NN(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = m;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        this.eventHandlers.clear(),
        dl(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(fte),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          o4(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        (f.shouldResetTransform = !0),
          f.updateScroll("snapshot"),
          f.options.layoutRoot && f.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const c = this.getTransformTemplate();
      (this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(PN);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(IN);
        return;
      }
      (this.animationCommitId = this.animationId),
        this.isUpdating
          ? ((this.isUpdating = !1),
            this.nodes.forEach(ute),
            this.nodes.forEach(ste),
            this.nodes.forEach(ote))
          : this.nodes.forEach(IN),
        this.clearAllSnapshots();
      const a = hi.now();
      (fr.delta = ta(0, 1e3 / 60, a - fr.timestamp)),
        (fr.timestamp = a),
        (fr.isProcessing = !0),
        DS.update.process(fr),
        DS.preRender.process(fr),
        DS.render.process(fr),
        (fr.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), dC.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(cte), this.sharedNodes.forEach(pte);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        xn.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      xn.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot ||
        !this.instance ||
        ((this.snapshot = this.measure()),
        this.snapshot &&
          !Kr(this.snapshot.measuredBox.x) &&
          !Kr(this.snapshot.measuredBox.y) &&
          (this.snapshot = void 0));
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const o = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = Fn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === o &&
          (a = !1),
        a && this.instance)
      ) {
        const l = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: o,
          isRoot: l,
          offset: t(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!i) return;
      const o =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        a = this.projectionDelta && !i4(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        u = c !== this.prevTransformTemplateValue;
      o &&
        this.instance &&
        (a || rc(this.latestValues) || u) &&
        (i(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        o && (l = this.removeTransform(l)),
        yte(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var c;
      const { visualElement: o } = this.options;
      if (!o) return Fn();
      const a = o.measureViewportBox();
      if (
        !(
          ((c = this.scroll) == null ? void 0 : c.wasRoot) ||
          this.path.some(xte)
        )
      ) {
        const { scroll: u } = this.root;
        u && (md(a.x, u.offset.x), md(a.y, u.offset.y));
      }
      return a;
    }
    removeElementScroll(o) {
      var l;
      const a = Fn();
      if ((qi(a, o), (l = this.scroll) != null && l.wasRoot)) return a;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c],
          { scroll: f, options: p } = u;
        u !== this.root &&
          f &&
          p.layoutScroll &&
          (f.wasRoot && qi(a, o), md(a.x, f.offset.x), md(a.y, f.offset.y));
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const l = Fn();
      qi(l, o);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !a &&
          u.options.layoutScroll &&
          u.scroll &&
          u !== u.root &&
          gd(l, { x: -u.scroll.offset.x, y: -u.scroll.offset.y }),
          rc(u.latestValues) && gd(l, u.latestValues);
      }
      return rc(this.latestValues) && gd(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = Fn();
      qi(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !rc(c.latestValues)) continue;
        PE(c.latestValues) && c.updateSnapshot();
        const u = Fn(),
          f = c.measurePageBox();
        qi(u, f),
          EN(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return rc(this.latestValues) && EN(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      (this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== fr.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(o = !1) {
      var p;
      const a = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== a;
      if (
        !(
          o ||
          (l && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          ((p = this.parent) != null && p.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: u, layoutId: f } = this.options;
      if (!(!this.layout || !(u || f))) {
        if (
          ((this.resolvedRelativeTargetAt = fr.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const m = this.getClosestProjectingParent();
          m && m.layout && this.animationProgress !== 1
            ? ((this.relativeParent = m),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Fn()),
              (this.relativeTargetOrigin = Fn()),
              tp(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                m.layout.layoutBox
              ),
              qi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (
          !(!this.relativeTarget && !this.targetDelta) &&
          (this.target ||
            ((this.target = Fn()), (this.targetWithTransforms = Fn())),
          this.relativeTarget &&
          this.relativeTargetOrigin &&
          this.relativeParent &&
          this.relativeParent.target
            ? (this.forceRelativeParentToResolveTarget(),
              Tee(this.target, this.relativeTarget, this.relativeParent.target))
            : this.targetDelta
            ? (this.resumingFrom
                ? (this.target = this.applyTransform(this.layout.layoutBox))
                : qi(this.target, this.layout.layoutBox),
              Bz(this.target, this.targetDelta))
            : qi(this.target, this.layout.layoutBox),
          this.attemptToResolveRelativeTarget)
        ) {
          this.attemptToResolveRelativeTarget = !1;
          const m = this.getClosestProjectingParent();
          m &&
          !!m.resumingFrom == !!this.resumingFrom &&
          !m.options.layoutScroll &&
          m.target &&
          this.animationProgress !== 1
            ? ((this.relativeParent = m),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Fn()),
              (this.relativeTargetOrigin = Fn()),
              tp(this.relativeTargetOrigin, this.target, m.target),
              qi(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          PE(this.parent.latestValues) ||
          Fz(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var v;
      const o = this.getLead(),
        a = !!this.resumingFrom || this !== o;
      let l = !0;
      if (
        ((this.isProjectionDirty ||
          ((v = this.parent) != null && v.isProjectionDirty)) &&
          (l = !1),
        a &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (l = !1),
        this.resolvedRelativeTargetAt === fr.timestamp && (l = !1),
        l)
      )
        return;
      const { layout: c, layoutId: u } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(c || u))
      )
        return;
      qi(this.layoutCorrected, this.layout.layoutBox);
      const f = this.treeScale.x,
        p = this.treeScale.y;
      UQ(this.layoutCorrected, this.treeScale, this.path, a),
        o.layout &&
          !o.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((o.target = o.layout.layoutBox), (o.targetWithTransforms = Fn()));
      const { target: m } = o;
      if (!m) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (wN(this.prevProjectionDelta.x, this.projectionDelta.x),
          wN(this.prevProjectionDelta.y, this.projectionDelta.y)),
        ep(this.projectionDelta, this.layoutCorrected, m, this.latestValues),
        (this.treeScale.x !== f ||
          this.treeScale.y !== p ||
          !RN(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !RN(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", m));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      var a;
      if (((a = this.options.visualElement) == null || a.scheduleRender(), o)) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = vd()),
        (this.projectionDelta = vd()),
        (this.projectionDeltaWithTransform = vd());
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        u = { ...this.latestValues },
        f = vd();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const p = Fn(),
        m = l ? l.source : void 0,
        v = this.layout ? this.layout.source : void 0,
        y = m !== v,
        x = this.getStack(),
        g = !x || x.members.length <= 1,
        _ = !!(
          y &&
          !g &&
          this.options.crossfade === !0 &&
          !this.path.some(gte)
        );
      this.animationProgress = 0;
      let S;
      (this.mixTargetDelta = (b) => {
        const C = b / 1e3;
        LN(f.x, o.x, C),
          LN(f.y, o.y, C),
          this.setTargetDelta(f),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (tp(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            mte(this.relativeTarget, this.relativeTargetOrigin, p, C),
            S && ete(this.relativeTarget, S) && (this.isProjectionDirty = !1),
            S || (S = Fn()),
            qi(S, this.relativeTarget)),
          y &&
            ((this.animationValues = u), qee(u, c, this.latestValues, C, _, g)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = C);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      var a, l, c;
      this.notifyListeners("animationStart"),
        (a = this.currentAnimation) == null || a.stop(),
        (c = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) ==
          null || c.stop(),
        this.pendingAnimation &&
          (dl(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = xn.update(() => {
          (Ry.hasAnimatedSinceResize = !0),
            this.motionValue || (this.motionValue = rh(0)),
            (this.currentAnimation = Hee(this.motionValue, [0, 1e3], {
              ...o,
              velocity: 0,
              isSync: !0,
              onUpdate: (u) => {
                this.mixTargetDelta(u), o.onUpdate && o.onUpdate(u);
              },
              onStop: () => {},
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(rte),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: c,
        latestValues: u,
      } = o;
      if (!(!a || !l || !c)) {
        if (
          this !== o &&
          this.layout &&
          c &&
          l4(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || Fn();
          const f = Kr(this.layout.layoutBox.x);
          (l.x.min = o.target.x.min), (l.x.max = l.x.min + f);
          const p = Kr(this.layout.layoutBox.y);
          (l.y.min = o.target.y.min), (l.y.max = l.y.min + p);
        }
        qi(a, l),
          gd(a, u),
          ep(this.projectionDeltaWithTransform, this.layoutCorrected, a, u);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new tte()),
        this.sharedNodes.get(o).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity
            ? c.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var a;
      const { layoutId: o } = this.options;
      return o
        ? ((a = this.getStack()) == null ? void 0 : a.lead) || this
        : this;
    }
    getPrevLead() {
      var a;
      const { layoutId: o } = this.options;
      return o ? ((a = this.getStack()) == null ? void 0 : a.prevLead) : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: l } = o;
      if (
        ((l.z ||
          l.rotate ||
          l.rotateX ||
          l.rotateY ||
          l.rotateZ ||
          l.skewX ||
          l.skewY) &&
          (a = !0),
        !a)
      )
        return;
      const c = {};
      l.z && XS("z", o, c, this.animationValues);
      for (let u = 0; u < $S.length; u++)
        XS(`rotate${$S[u]}`, o, c, this.animationValues),
          XS(`skew${$S[u]}`, o, c, this.animationValues);
      o.render();
      for (const u in c)
        o.setStaticValue(u, c[u]),
          this.animationValues && (this.animationValues[u] = c[u]);
      o.scheduleRender();
    }
    applyProjectionStyles(o, a) {
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) {
        o.visibility = "hidden";
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        (this.needsReset = !1),
          (o.visibility = ""),
          (o.opacity = ""),
          (o.pointerEvents = Ay(a == null ? void 0 : a.pointerEvents) || ""),
          (o.transform = l ? l(this.latestValues, "") : "none");
        return;
      }
      const c = this.getLead();
      if (!this.projectionDelta || !this.layout || !c.target) {
        this.options.layoutId &&
          ((o.opacity =
            this.latestValues.opacity !== void 0
              ? this.latestValues.opacity
              : 1),
          (o.pointerEvents = Ay(a == null ? void 0 : a.pointerEvents) || "")),
          this.hasProjected &&
            !rc(this.latestValues) &&
            ((o.transform = l ? l({}, "") : "none"), (this.hasProjected = !1));
        return;
      }
      o.visibility = "";
      const u = c.animationValues || c.latestValues;
      this.applyTransformsToTarget();
      let f = nte(this.projectionDeltaWithTransform, this.treeScale, u);
      l && (f = l(u, f)), (o.transform = f);
      const { x: p, y: m } = this.projectionDelta;
      (o.transformOrigin = `${p.origin * 100}% ${m.origin * 100}% 0`),
        c.animationValues
          ? (o.opacity =
              c === this
                ? u.opacity ?? this.latestValues.opacity ?? 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : u.opacityExit)
          : (o.opacity =
              c === this
                ? u.opacity !== void 0
                  ? u.opacity
                  : ""
                : u.opacityExit !== void 0
                ? u.opacityExit
                : 0);
      for (const v in jp) {
        if (u[v] === void 0) continue;
        const { correct: y, applyTo: x, isCSSVariable: g } = jp[v],
          _ = f === "none" ? u[v] : y(u[v], c);
        if (x) {
          const S = x.length;
          for (let b = 0; b < S; b++) o[x[b]] = _;
        } else
          g ? (this.options.visualElement.renderState.vars[v] = _) : (o[v] = _);
      }
      this.options.layoutId &&
        (o.pointerEvents =
          c === this ? Ay(a == null ? void 0 : a.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) == null ? void 0 : a.stop();
      }),
        this.root.nodes.forEach(PN),
        this.root.sharedNodes.clear();
    }
  };
}
function ste(n) {
  n.updateLayout();
}
function ote(n) {
  var t;
  const e = ((t = n.resumeFrom) == null ? void 0 : t.snapshot) || n.snapshot;
  if (n.isLead() && n.layout && e && n.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: i } = n.layout,
      { animationType: s } = n.options,
      o = e.source !== n.layout.source;
    s === "size"
      ? Yi((f) => {
          const p = o ? e.measuredBox[f] : e.layoutBox[f],
            m = Kr(p);
          (p.min = r[f].min), (p.max = p.min + m);
        })
      : l4(s, e.layoutBox, r) &&
        Yi((f) => {
          const p = o ? e.measuredBox[f] : e.layoutBox[f],
            m = Kr(r[f]);
          (p.max = p.min + m),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[f].max = n.relativeTarget[f].min + m));
        });
    const a = vd();
    ep(a, r, e.layoutBox);
    const l = vd();
    o ? ep(l, n.applyTransform(i, !0), e.measuredBox) : ep(l, r, e.layoutBox);
    const c = !i4(a);
    let u = !1;
    if (!n.resumeFrom) {
      const f = n.getClosestProjectingParent();
      if (f && !f.resumeFrom) {
        const { snapshot: p, layout: m } = f;
        if (p && m) {
          const v = Fn();
          tp(v, e.layoutBox, p.layoutBox);
          const y = Fn();
          tp(y, r, m.layoutBox),
            s4(v, y) || (u = !0),
            f.options.layoutRoot &&
              ((n.relativeTarget = y),
              (n.relativeTargetOrigin = v),
              (n.relativeParent = f));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: r,
      snapshot: e,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeLayoutChanged: u,
    });
  } else if (n.isLead()) {
    const { onExitComplete: r } = n.options;
    r && r();
  }
  n.options.transition = void 0;
}
function ate(n) {
  n.parent &&
    (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
    n.isSharedProjectionDirty ||
      (n.isSharedProjectionDirty = !!(
        n.isProjectionDirty ||
        n.parent.isProjectionDirty ||
        n.parent.isSharedProjectionDirty
      )),
    n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function lte(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function cte(n) {
  n.clearSnapshot();
}
function PN(n) {
  n.clearMeasurements();
}
function IN(n) {
  n.isLayoutDirty = !1;
}
function ute(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function NN(n) {
  n.finishAnimation(),
    (n.targetDelta = n.relativeTarget = n.target = void 0),
    (n.isProjectionDirty = !0);
}
function dte(n) {
  n.resolveTargetDelta();
}
function hte(n) {
  n.calcProjection();
}
function fte(n) {
  n.resetSkewAndRotation();
}
function pte(n) {
  n.removeLeadSnapshot();
}
function LN(n, e, t) {
  (n.translate = bn(e.translate, 0, t)),
    (n.scale = bn(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function ON(n, e, t, r) {
  (n.min = bn(e.min, t.min, r)), (n.max = bn(e.max, t.max, r));
}
function mte(n, e, t, r) {
  ON(n.x, e.x, t.x, r), ON(n.y, e.y, t.y, r);
}
function gte(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const vte = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  DN = (n) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(n),
  kN = DN("applewebkit/") && !DN("chrome/") ? Math.round : ss;
function UN(n) {
  (n.min = kN(n.min)), (n.max = kN(n.max));
}
function yte(n) {
  UN(n.x), UN(n.y);
}
function l4(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !Eee(AN(e), AN(t), 0.2))
  );
}
function xte(n) {
  var e;
  return n !== n.root && ((e = n.scroll) == null ? void 0 : e.wasRoot);
}
const _te = a4({
    attachResizeListener: (n, e) => Hp(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  qS = { current: void 0 },
  c4 = a4({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!qS.current) {
        const n = new _te({});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (qS.current = n);
      }
      return qS.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  wte = {
    pan: { Feature: Bee },
    drag: { Feature: Fee, ProjectionNode: c4, MeasureLayout: t4 },
  };
function FN(n, e, t) {
  const { props: r } = n;
  n.animationState &&
    r.whileHover &&
    n.animationState.setActive("whileHover", t === "Start");
  const i = "onHover" + t,
    s = r[i];
  s && xn.postRender(() => s(e, Sm(e)));
}
class Ste extends _l {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = qZ(
        e,
        (t, r) => (FN(this.node, r, "Start"), (i) => FN(this.node, i, "End"))
      ));
  }
  unmount() {}
}
class bte extends _l {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = xm(
      Hp(this.node.current, "focus", () => this.onFocus()),
      Hp(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
function BN(n, e, t) {
  const { props: r } = n;
  if (n.current instanceof HTMLButtonElement && n.current.disabled) return;
  n.animationState &&
    r.whileTap &&
    n.animationState.setActive("whileTap", t === "Start");
  const i = "onTap" + (t === "End" ? "" : t),
    s = r[i];
  s && xn.postRender(() => s(e, Sm(e)));
}
class Ete extends _l {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = ZZ(
        e,
        (t, r) => (
          BN(this.node, r, "Start"),
          (i, { success: s }) => BN(this.node, i, s ? "End" : "Cancel")
        ),
        { useGlobalTarget: this.node.props.globalTapTarget }
      ));
  }
  unmount() {}
}
const UE = new WeakMap(),
  KS = new WeakMap(),
  Tte = (n) => {
    const e = UE.get(n.target);
    e && e(n);
  },
  Mte = (n) => {
    n.forEach(Tte);
  };
function Cte({ root: n, ...e }) {
  const t = n || document;
  KS.has(t) || KS.set(t, {});
  const r = KS.get(t),
    i = JSON.stringify(e);
  return (
    r[i] || (r[i] = new IntersectionObserver(Mte, { root: n, ...e })), r[i]
  );
}
function Ate(n, e, t) {
  const r = Cte(e);
  return (
    UE.set(n, t),
    r.observe(n),
    () => {
      UE.delete(n), r.unobserve(n);
    }
  );
}
const Rte = { some: 0, all: 1 };
class Pte extends _l {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: r, amount: i = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: r,
        threshold: typeof i == "number" ? i : Rte[i],
      },
      a = (l) => {
        const { isIntersecting: c } = l;
        if (
          this.isInView === c ||
          ((this.isInView = c), s && !c && this.hasEnteredView)
        )
          return;
        c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", c);
        const { onViewportEnter: u, onViewportLeave: f } = this.node.getProps(),
          p = c ? u : f;
        p && p(l);
      };
    return Ate(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(Ite(e, t)) && this.startObserver();
  }
  unmount() {}
}
function Ite({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const Nte = {
    inView: { Feature: Pte },
    tap: { Feature: Ete },
    focus: { Feature: bte },
    hover: { Feature: Ste },
  },
  Lte = { layout: { ProjectionNode: c4, MeasureLayout: t4 } },
  Ote = { ...yee, ...Nte, ...wte, ...Lte },
  Dte = OQ(Ote, XQ),
  kte = ({
    children: n,
    className: e,
    background: t,
    beams: r,
    width: i = 858,
    height: s = 434,
    baseColor: o = "var(--slate-800)",
    accentColor: a = "var(--slate-600)",
    gradientColors: l,
  }) =>
    T.jsxs("div", {
      className: qt(
        "w-full h-screen relative flex items-center justify-center antialiased overflow-hidden",
        e
      ),
      children: [
        t,
        T.jsx("div", { className: "relative z-10", children: n }),
        T.jsx("div", {
          className: "absolute inset-0 flex items-center justify-center",
          children: T.jsx(Ute, {
            beams: r,
            width: i,
            height: s,
            baseColor: o,
            accentColor: a,
            gradientColors: l,
          }),
        }),
      ],
    }),
  Ute = ({
    beams: n,
    width: e,
    height: t,
    baseColor: r,
    accentColor: i,
    gradientColors: s,
  }) =>
    T.jsxs("svg", {
      width: e,
      height: t,
      viewBox: `0 0 ${e} ${t}`,
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      className: "flex flex-shrink-0",
      children: [
        n.map((o, a) => {
          var l;
          return T.jsxs(
            Le.Fragment,
            {
              children: [
                T.jsx("path", { d: o.path, stroke: r, strokeWidth: "1" }),
                T.jsx("path", {
                  d: o.path,
                  stroke: `url(#grad${a})`,
                  strokeWidth: "2",
                  strokeLinecap: "round",
                }),
                (l = o.connectionPoints) == null
                  ? void 0
                  : l.map((c, u) =>
                      T.jsx(
                        "circle",
                        { cx: c.cx, cy: c.cy, r: c.r, fill: r, stroke: i },
                        `${a}-${u}`
                      )
                    ),
              ],
            },
            a
          );
        }),
        T.jsx("defs", {
          children: n.map((o, a) =>
            T.jsx(
              Dte.linearGradient,
              {
                id: `grad${a}`,
                gradientUnits: "userSpaceOnUse",
                initial: o.gradientConfig.initial,
                animate: o.gradientConfig.animate,
                transition: o.gradientConfig.transition,
                children: T.jsx(Fte, { colors: s }),
              },
              a
            )
          ),
        }),
      ],
    }),
  Fte = ({
    colors: n = { start: "#18CCFC", middle: "#6344F5", end: "#AE48FF" },
  }) =>
    T.jsxs(T.Fragment, {
      children: [
        T.jsx("stop", { offset: "0%", stopColor: n.start, stopOpacity: "0" }),
        T.jsx("stop", { offset: "20%", stopColor: n.start, stopOpacity: "1" }),
        T.jsx("stop", { offset: "50%", stopColor: n.middle, stopOpacity: "1" }),
        T.jsx("stop", { offset: "100%", stopColor: n.end, stopOpacity: "0" }),
      ],
    });
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const $x = "179",
  Bte = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  zte = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  u4 = 0,
  FE = 1,
  d4 = 2,
  Vte = 3,
  h4 = 0,
  Xx = 1,
  np = 2,
  Ts = 3,
  ra = 0,
  Jr = 1,
  io = 2,
  Xo = 0,
  Rc = 1,
  BE = 2,
  zE = 3,
  VE = 4,
  SC = 5,
  Va = 100,
  f4 = 101,
  p4 = 102,
  m4 = 103,
  g4 = 104,
  v4 = 200,
  bC = 201,
  y4 = 202,
  x4 = 203,
  Wp = 204,
  b0 = 205,
  _4 = 206,
  w4 = 207,
  S4 = 208,
  b4 = 209,
  E4 = 210,
  T4 = 211,
  M4 = 212,
  C4 = 213,
  A4 = 214,
  E0 = 0,
  T0 = 1,
  M0 = 2,
  zc = 3,
  C0 = 4,
  A0 = 5,
  R0 = 6,
  P0 = 7,
  bm = 0,
  R4 = 1,
  P4 = 2,
  go = 0,
  I4 = 1,
  N4 = 2,
  L4 = 3,
  EC = 4,
  O4 = 5,
  D4 = 6,
  k4 = 7,
  jE = "attached",
  U4 = "detached",
  qx = 300,
  ia = 301,
  fl = 302,
  Gp = 303,
  $p = 304,
  Ph = 306,
  Xp = 1e3,
  rs = 1001,
  qp = 1002,
  mr = 1003,
  TC = 1004,
  jte = 1004,
  yd = 1005,
  Hte = 1005,
  Zn = 1006,
  rp = 1007,
  Wte = 1007,
  oo = 1008,
  Gte = 1008,
  ls = 1009,
  MC = 1010,
  CC = 1011,
  sh = 1012,
  Kx = 1013,
  sa = 1014,
  fi = 1015,
  Ih = 1016,
  Yx = 1017,
  Jx = 1018,
  oh = 1020,
  AC = 35902,
  RC = 1021,
  PC = 1022,
  Or = 1023,
  ah = 1026,
  lh = 1027,
  Zx = 1028,
  Em = 1029,
  IC = 1030,
  Qx = 1031,
  $te = 1032,
  e_ = 1033,
  ip = 33776,
  sp = 33777,
  op = 33778,
  ap = 33779,
  I0 = 35840,
  N0 = 35841,
  L0 = 35842,
  O0 = 35843,
  D0 = 36196,
  k0 = 37492,
  U0 = 37496,
  F0 = 37808,
  B0 = 37809,
  z0 = 37810,
  V0 = 37811,
  j0 = 37812,
  H0 = 37813,
  W0 = 37814,
  G0 = 37815,
  $0 = 37816,
  X0 = 37817,
  q0 = 37818,
  K0 = 37819,
  Y0 = 37820,
  J0 = 37821,
  lp = 36492,
  Z0 = 36494,
  Q0 = 36495,
  NC = 36283,
  ex = 36284,
  tx = 36285,
  nx = 36286,
  F4 = 2200,
  B4 = 2201,
  z4 = 2202,
  Kp = 2300,
  rx = 2301,
  Py = 2302,
  gc = 2400,
  vc = 2401,
  Yp = 2402,
  t_ = 2500,
  LC = 2501,
  Xte = 0,
  qte = 1,
  Kte = 2,
  V4 = 3200,
  j4 = 3201,
  Yte = 3202,
  Jte = 3203,
  wl = 0,
  H4 = 1,
  jo = "",
  li = "srgb",
  Vc = "srgb-linear",
  Jp = "linear",
  nn = "srgb",
  Zte = 0,
  ic = 7680,
  Qte = 7681,
  ene = 7682,
  tne = 7683,
  nne = 34055,
  rne = 34056,
  ine = 5386,
  sne = 512,
  one = 513,
  ane = 514,
  lne = 515,
  cne = 516,
  une = 517,
  dne = 518,
  HE = 519,
  W4 = 512,
  G4 = 513,
  $4 = 514,
  OC = 515,
  X4 = 516,
  q4 = 517,
  K4 = 518,
  Y4 = 519,
  Zp = 35044,
  hne = 35048,
  fne = 35040,
  pne = 35045,
  mne = 35049,
  gne = 35041,
  vne = 35046,
  yne = 35050,
  xne = 35042,
  _ne = "100",
  ix = "300 es",
  Pi = 2e3,
  ch = 2001,
  wne = { COMPUTE: "compute", RENDER: "render" },
  Sne = { PERSPECTIVE: "perspective", LINEAR: "linear", FLAT: "flat" },
  bne = {
    NORMAL: "normal",
    CENTROID: "centroid",
    SAMPLE: "sample",
    FIRST: "first",
    EITHER: "either",
  };
class wo {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const r = this._listeners;
    r[e] === void 0 && (r[e] = []), r[e].indexOf(t) === -1 && r[e].push(t);
  }
  hasEventListener(e, t) {
    const r = this._listeners;
    return r === void 0 ? !1 : r[e] !== void 0 && r[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const r = this._listeners;
    if (r === void 0) return;
    const i = r[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const r = t[e.type];
    if (r !== void 0) {
      e.target = this;
      const i = r.slice(0);
      for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const Ar = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let zN = 1234567;
const Pc = Math.PI / 180,
  uh = 180 / Math.PI;
function Li() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    r = (Math.random() * 4294967295) | 0;
  return (
    Ar[n & 255] +
    Ar[(n >> 8) & 255] +
    Ar[(n >> 16) & 255] +
    Ar[(n >> 24) & 255] +
    "-" +
    Ar[e & 255] +
    Ar[(e >> 8) & 255] +
    "-" +
    Ar[((e >> 16) & 15) | 64] +
    Ar[(e >> 24) & 255] +
    "-" +
    Ar[(t & 63) | 128] +
    Ar[(t >> 8) & 255] +
    "-" +
    Ar[(t >> 16) & 255] +
    Ar[(t >> 24) & 255] +
    Ar[r & 255] +
    Ar[(r >> 8) & 255] +
    Ar[(r >> 16) & 255] +
    Ar[(r >> 24) & 255]
  ).toLowerCase();
}
function St(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function DC(n, e) {
  return ((n % e) + e) % e;
}
function Ene(n, e, t, r, i) {
  return r + ((n - e) * (i - r)) / (t - e);
}
function Tne(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function cp(n, e, t) {
  return (1 - t) * n + t * e;
}
function Mne(n, e, t, r) {
  return cp(n, e, 1 - Math.exp(-t * r));
}
function Cne(n, e = 1) {
  return e - Math.abs(DC(n, e * 2) - e);
}
function Ane(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function Rne(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function Pne(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function Ine(n, e) {
  return n + Math.random() * (e - n);
}
function Nne(n) {
  return n * (0.5 - Math.random());
}
function Lne(n) {
  n !== void 0 && (zN = n);
  let e = (zN += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function One(n) {
  return n * Pc;
}
function Dne(n) {
  return n * uh;
}
function kne(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function Une(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function Fne(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function Bne(n, e, t, r, i) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + r) / 2),
    u = o((e + r) / 2),
    f = s((e - r) / 2),
    p = o((e - r) / 2),
    m = s((r - e) / 2),
    v = o((r - e) / 2);
  switch (i) {
    case "XYX":
      n.set(a * u, l * f, l * p, a * c);
      break;
    case "YZY":
      n.set(l * p, a * u, l * f, a * c);
      break;
    case "ZXZ":
      n.set(l * f, l * p, a * u, a * c);
      break;
    case "XZX":
      n.set(a * u, l * v, l * m, a * c);
      break;
    case "YXY":
      n.set(l * m, a * u, l * v, a * c);
      break;
    case "ZYZ":
      n.set(l * v, l * m, a * u, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function qr(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return n / 4294967295;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int32Array:
      return Math.max(n / 2147483647, -1);
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Dt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint32Array:
      return Math.round(n * 4294967295);
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int32Array:
      return Math.round(n * 2147483647);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const zne = {
  DEG2RAD: Pc,
  RAD2DEG: uh,
  generateUUID: Li,
  clamp: St,
  euclideanModulo: DC,
  mapLinear: Ene,
  inverseLerp: Tne,
  lerp: cp,
  damp: Mne,
  pingpong: Cne,
  smoothstep: Ane,
  smootherstep: Rne,
  randInt: Pne,
  randFloat: Ine,
  randFloatSpread: Nne,
  seededRandom: Lne,
  degToRad: One,
  radToDeg: Dne,
  isPowerOfTwo: kne,
  ceilPowerOfTwo: Une,
  floorPowerOfTwo: Fne,
  setQuaternionFromProperEuler: Bne,
  normalize: Dt,
  denormalize: qr,
};
class xe {
  constructor(e = 0, t = 0) {
    (xe.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * r + i[6]),
      (this.y = i[1] * t + i[4] * r + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = St(this.x, e.x, t.x)), (this.y = St(this.y, e.y, t.y)), this
    );
  }
  clampScalar(e, t) {
    return (this.x = St(this.x, e, t)), (this.y = St(this.y, e, t)), this;
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(St(r, e, t));
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(St(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y;
    return t * t + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * r - o * i + e.x), (this.y = s * i + o * r + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class vi {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i);
  }
  static slerpFlat(e, t, r, i, s, o, a) {
    let l = r[i + 0],
      c = r[i + 1],
      u = r[i + 2],
      f = r[i + 3];
    const p = s[o + 0],
      m = s[o + 1],
      v = s[o + 2],
      y = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = v), (e[t + 3] = y);
      return;
    }
    if (f !== y || l !== p || c !== m || u !== v) {
      let x = 1 - a;
      const g = l * p + c * m + u * v + f * y,
        _ = g >= 0 ? 1 : -1,
        S = 1 - g * g;
      if (S > Number.EPSILON) {
        const C = Math.sqrt(S),
          A = Math.atan2(C, g * _);
        (x = Math.sin(x * A) / C), (a = Math.sin(a * A) / C);
      }
      const b = a * _;
      if (
        ((l = l * x + p * b),
        (c = c * x + m * b),
        (u = u * x + v * b),
        (f = f * x + y * b),
        x === 1 - a)
      ) {
        const C = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
        (l *= C), (c *= C), (u *= C), (f *= C);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = f);
  }
  static multiplyQuaternionsFlat(e, t, r, i, s, o) {
    const a = r[i],
      l = r[i + 1],
      c = r[i + 2],
      u = r[i + 3],
      f = s[o],
      p = s[o + 1],
      m = s[o + 2],
      v = s[o + 3];
    return (
      (e[t] = a * v + u * f + l * m - c * p),
      (e[t + 1] = l * v + u * p + c * f - a * m),
      (e[t + 2] = c * v + u * m + a * p - l * f),
      (e[t + 3] = u * v - a * f - l * p - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, r, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t = !0) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(r / 2),
      u = a(i / 2),
      f = a(s / 2),
      p = l(r / 2),
      m = l(i / 2),
      v = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * u * f + c * m * v),
          (this._y = c * m * f - p * u * v),
          (this._z = c * u * v + p * m * f),
          (this._w = c * u * f - p * m * v);
        break;
      case "YXZ":
        (this._x = p * u * f + c * m * v),
          (this._y = c * m * f - p * u * v),
          (this._z = c * u * v - p * m * f),
          (this._w = c * u * f + p * m * v);
        break;
      case "ZXY":
        (this._x = p * u * f - c * m * v),
          (this._y = c * m * f + p * u * v),
          (this._z = c * u * v + p * m * f),
          (this._w = c * u * f - p * m * v);
        break;
      case "ZYX":
        (this._x = p * u * f - c * m * v),
          (this._y = c * m * f + p * u * v),
          (this._z = c * u * v - p * m * f),
          (this._w = c * u * f + p * m * v);
        break;
      case "YZX":
        (this._x = p * u * f + c * m * v),
          (this._y = c * m * f + p * u * v),
          (this._z = c * u * v - p * m * f),
          (this._w = c * u * f - p * m * v);
        break;
      case "XZY":
        (this._x = p * u * f - c * m * v),
          (this._y = c * m * f - p * u * v),
          (this._z = c * u * v + p * m * f),
          (this._w = c * u * f + p * m * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const r = t / 2,
      i = Math.sin(r);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(r)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      r = t[0],
      i = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      f = t[10],
      p = r + a + f;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (u - l) * m),
        (this._y = (s - c) * m),
        (this._z = (o - i) * m);
    } else if (r > a && r > f) {
      const m = 2 * Math.sqrt(1 + r - a - f);
      (this._w = (u - l) / m),
        (this._x = 0.25 * m),
        (this._y = (i + o) / m),
        (this._z = (s + c) / m);
    } else if (a > f) {
      const m = 2 * Math.sqrt(1 + a - r - f);
      (this._w = (s - c) / m),
        (this._x = (i + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + u) / m);
    } else {
      const m = 2 * Math.sqrt(1 + f - r - a);
      (this._w = (o - i) / m),
        (this._x = (s + c) / m),
        (this._y = (l + u) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let r = e.dot(t) + 1;
    return (
      r < 1e-8
        ? ((r = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = r))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = r)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = r)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(St(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const r = this.angleTo(e);
    if (r === 0) return this;
    const i = Math.min(1, t / r);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const r = e._x,
      i = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = r * u + o * a + i * c - s * l),
      (this._y = i * u + o * l + s * a - r * c),
      (this._z = s * u + o * c + r * l - i * a),
      (this._w = o * u - r * a - i * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const r = this._x,
      i = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + r * e._x + i * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = r), (this._y = i), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * r + t * this._x),
        (this._y = m * i + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, a),
      f = Math.sin((1 - t) * u) / c,
      p = Math.sin(t * u) / c;
    return (
      (this._w = o * f + this._w * p),
      (this._x = r * f + this._x * p),
      (this._y = i * f + this._y * p),
      (this._z = s * f + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, r) {
    return this.copy(e).slerp(t, r);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      t = 2 * Math.PI * Math.random(),
      r = Math.random(),
      i = Math.sqrt(1 - r),
      s = Math.sqrt(r);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      s * Math.sin(t),
      s * Math.cos(t)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class z {
  constructor(e = 0, t = 0, r = 0) {
    (z.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
  }
  set(e, t, r) {
    return (
      r === void 0 && (r = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(VN.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(VN.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * r + s[6] * i),
      (this.y = s[1] * t + s[4] * r + s[7] * i),
      (this.z = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * r + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * r + s[8] * i + s[12]) * o),
      (this.y = (s[1] * t + s[5] * r + s[9] * i + s[13]) * o),
      (this.z = (s[2] * t + s[6] * r + s[10] * i + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = 2 * (o * i - a * r),
      u = 2 * (a * t - s * i),
      f = 2 * (s * r - o * t);
    return (
      (this.x = t + l * c + o * f - a * u),
      (this.y = r + l * u + a * c - s * f),
      (this.z = i + l * f + s * u - o * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * r + s[8] * i),
      (this.y = s[1] * t + s[5] * r + s[9] * i),
      (this.z = s[2] * t + s[6] * r + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = St(this.x, e.x, t.x)),
      (this.y = St(this.y, e.y, t.y)),
      (this.z = St(this.z, e.z, t.z)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = St(this.x, e, t)),
      (this.y = St(this.y, e, t)),
      (this.z = St(this.z, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(St(r, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = i * l - s * a),
      (this.y = s * o - r * l),
      (this.z = r * a - i * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const r = e.dot(this) / t;
    return this.copy(e).multiplyScalar(r);
  }
  projectOnPlane(e) {
    return YS.copy(this).projectOnVector(e), this.sub(YS);
  }
  reflect(e) {
    return this.sub(YS.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const r = this.dot(e) / t;
    return Math.acos(St(r, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      r = this.y - e.y,
      i = this.z - e.z;
    return t * t + r * r + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, r) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(r)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(r)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, r) {
    return (
      (this.x = e * Math.sin(t)), (this.y = r), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      r = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = r), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      t = Math.random() * 2 - 1,
      r = Math.sqrt(1 - t * t);
    return (
      (this.x = r * Math.cos(e)), (this.y = t), (this.z = r * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const YS = new z(),
  VN = new vi();
class Nt {
  constructor(e, t, r, i, s, o, a, l, c) {
    (Nt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, c);
  }
  set(e, t, r, i, s, o, a, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = a),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = r),
      (u[7] = o),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      r.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[3],
      l = r[6],
      c = r[1],
      u = r[4],
      f = r[7],
      p = r[2],
      m = r[5],
      v = r[8],
      y = i[0],
      x = i[3],
      g = i[6],
      _ = i[1],
      S = i[4],
      b = i[7],
      C = i[2],
      A = i[5],
      R = i[8];
    return (
      (s[0] = o * y + a * _ + l * C),
      (s[3] = o * x + a * S + l * A),
      (s[6] = o * g + a * b + l * R),
      (s[1] = c * y + u * _ + f * C),
      (s[4] = c * x + u * S + f * A),
      (s[7] = c * g + u * b + f * R),
      (s[2] = p * y + m * _ + v * C),
      (s[5] = p * x + m * S + v * A),
      (s[8] = p * g + m * b + v * R),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * o * u - t * a * c - r * s * u + r * a * l + i * s * c - i * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = u * o - a * c,
      p = a * l - u * s,
      m = c * s - o * l,
      v = t * f + r * p + i * m;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const y = 1 / v;
    return (
      (e[0] = f * y),
      (e[1] = (i * c - u * r) * y),
      (e[2] = (a * r - i * o) * y),
      (e[3] = p * y),
      (e[4] = (u * t - i * l) * y),
      (e[5] = (i * s - a * t) * y),
      (e[6] = m * y),
      (e[7] = (r * l - c * t) * y),
      (e[8] = (o * t - r * s) * y),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, r, i, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        r * l,
        r * c,
        -r * (l * o + c * a) + o + e,
        -i * c,
        i * l,
        -i * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(JS.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(JS.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(JS.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const JS = new Nt();
function J4(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const Vne = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function xd(n, e) {
  return new Vne[n](e);
}
function Qp(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function Z4() {
  const n = Qp("canvas");
  return (n.style.display = "block"), n;
}
const jN = {};
function Dd(n) {
  n in jN || ((jN[n] = !0), console.warn(n));
}
function jne(n, e, t) {
  return new Promise(function (r, i) {
    function s() {
      switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case n.WAIT_FAILED:
          i();
          break;
        case n.TIMEOUT_EXPIRED:
          setTimeout(s, t);
          break;
        default:
          r();
      }
    }
    setTimeout(s, t);
  });
}
const HN = new Nt().set(
    0.4123908,
    0.3575843,
    0.1804808,
    0.212639,
    0.7151687,
    0.0721923,
    0.0193308,
    0.1191948,
    0.9505322
  ),
  WN = new Nt().set(
    3.2409699,
    -1.5373832,
    -0.4986108,
    -0.9692436,
    1.8759675,
    0.0415551,
    0.0556301,
    -0.203977,
    1.0569715
  );
function Hne() {
  const n = {
      enabled: !0,
      workingColorSpace: Vc,
      spaces: {},
      convert: function (i, s, o) {
        return (
          this.enabled === !1 ||
            s === o ||
            !s ||
            !o ||
            (this.spaces[s].transfer === nn &&
              ((i.r = qo(i.r)), (i.g = qo(i.g)), (i.b = qo(i.b))),
            this.spaces[s].primaries !== this.spaces[o].primaries &&
              (i.applyMatrix3(this.spaces[s].toXYZ),
              i.applyMatrix3(this.spaces[o].fromXYZ)),
            this.spaces[o].transfer === nn &&
              ((i.r = kd(i.r)), (i.g = kd(i.g)), (i.b = kd(i.b)))),
          i
        );
      },
      workingToColorSpace: function (i, s) {
        return this.convert(i, this.workingColorSpace, s);
      },
      colorSpaceToWorking: function (i, s) {
        return this.convert(i, s, this.workingColorSpace);
      },
      getPrimaries: function (i) {
        return this.spaces[i].primaries;
      },
      getTransfer: function (i) {
        return i === jo ? Jp : this.spaces[i].transfer;
      },
      getLuminanceCoefficients: function (i, s = this.workingColorSpace) {
        return i.fromArray(this.spaces[s].luminanceCoefficients);
      },
      define: function (i) {
        Object.assign(this.spaces, i);
      },
      _getMatrix: function (i, s, o) {
        return i.copy(this.spaces[s].toXYZ).multiply(this.spaces[o].fromXYZ);
      },
      _getDrawingBufferColorSpace: function (i) {
        return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function (i = this.workingColorSpace) {
        return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
      },
      fromWorkingColorSpace: function (i, s) {
        return (
          Dd(
            "THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."
          ),
          n.workingToColorSpace(i, s)
        );
      },
      toWorkingColorSpace: function (i, s) {
        return (
          Dd(
            "THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."
          ),
          n.colorSpaceToWorking(i, s)
        );
      },
    },
    e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
    t = [0.2126, 0.7152, 0.0722],
    r = [0.3127, 0.329];
  return (
    n.define({
      [Vc]: {
        primaries: e,
        whitePoint: r,
        transfer: Jp,
        toXYZ: HN,
        fromXYZ: WN,
        luminanceCoefficients: t,
        workingColorSpaceConfig: { unpackColorSpace: li },
        outputColorSpaceConfig: { drawingBufferColorSpace: li },
      },
      [li]: {
        primaries: e,
        whitePoint: r,
        transfer: nn,
        toXYZ: HN,
        fromXYZ: WN,
        luminanceCoefficients: t,
        outputColorSpaceConfig: { drawingBufferColorSpace: li },
      },
    }),
    n
  );
}
const Ht = Hne();
function qo(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function kd(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
let Mu;
class Q4 {
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let r;
    if (e instanceof HTMLCanvasElement) r = e;
    else {
      Mu === void 0 && (Mu = Qp("canvas")),
        (Mu.width = e.width),
        (Mu.height = e.height);
      const i = Mu.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (r = Mu);
    }
    return r.toDataURL(t);
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Qp("canvas");
      (t.width = e.width), (t.height = e.height);
      const r = t.getContext("2d");
      r.drawImage(e, 0, 0, e.width, e.height);
      const i = r.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let o = 0; o < s.length; o++) s[o] = qo(s[o] / 255) * 255;
      return r.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let r = 0; r < t.length; r++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[r] = Math.floor(qo(t[r] / 255) * 255))
          : (t[r] = qo(t[r]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let Wne = 0;
class Ya {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", { value: Wne++ }),
      (this.uuid = Li()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  getSize(e) {
    const t = this.data;
    return (
      t instanceof HTMLVideoElement
        ? e.set(t.videoWidth, t.videoHeight, 0)
        : t instanceof VideoFrame
        ? e.set(t.displayHeight, t.displayWidth, 0)
        : t !== null
        ? e.set(t.width, t.height, t.depth || 0)
        : e.set(0, 0, 0),
      e
    );
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const r = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let o = 0, a = i.length; o < a; o++)
          i[o].isDataTexture ? s.push(ZS(i[o].image)) : s.push(ZS(i[o]));
      } else s = ZS(i);
      r.url = s;
    }
    return t || (e.images[this.uuid] = r), r;
  }
}
function ZS(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? Q4.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Gne = 0;
const QS = new z();
class Nn extends wo {
  constructor(
    e = Nn.DEFAULT_IMAGE,
    t = Nn.DEFAULT_MAPPING,
    r = rs,
    i = rs,
    s = Zn,
    o = oo,
    a = Or,
    l = ls,
    c = Nn.DEFAULT_ANISOTROPY,
    u = jo
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: Gne++ }),
      (this.uuid = Li()),
      (this.name = ""),
      (this.source = new Ya(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = r),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new xe(0, 0)),
      (this.repeat = new xe(1, 1)),
      (this.center = new xe(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Nt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.updateRanges = []),
      (this.version = 0),
      (this.onUpdate = null),
      (this.renderTarget = null),
      (this.isRenderTargetTexture = !1),
      (this.isArrayTexture = !!(e && e.depth && e.depth > 1)),
      (this.pmremVersion = 0);
  }
  get width() {
    return this.source.getSize(QS).x;
  }
  get height() {
    return this.source.getSize(QS).y;
  }
  get depth() {
    return this.source.getSize(QS).z;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.renderTarget = e.renderTarget),
      (this.isRenderTargetTexture = e.isRenderTargetTexture),
      (this.isArrayTexture = e.isArrayTexture),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  setValues(e) {
    for (const t in e) {
      const r = e[t];
      if (r === void 0) {
        console.warn(
          `THREE.Texture.setValues(): parameter '${t}' has value of undefined.`
        );
        continue;
      }
      const i = this[t];
      if (i === void 0) {
        console.warn(
          `THREE.Texture.setValues(): property '${t}' does not exist.`
        );
        continue;
      }
      (i && r && i.isVector2 && r.isVector2) ||
      (i && r && i.isVector3 && r.isVector3) ||
      (i && r && i.isMatrix3 && r.isMatrix3)
        ? i.copy(r)
        : (this[t] = r);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const r = {
      metadata: { version: 4.7, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      t || (e.textures[this.uuid] = r),
      r
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== qx) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Xp:
          e.x = e.x - Math.floor(e.x);
          break;
        case rs:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case qp:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Xp:
          e.y = e.y - Math.floor(e.y);
          break;
        case rs:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case qp:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Nn.DEFAULT_IMAGE = null;
Nn.DEFAULT_MAPPING = qx;
Nn.DEFAULT_ANISOTROPY = 1;
class Gt {
  constructor(e = 0, t = 0, r = 0, i = 1) {
    (Gt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = r),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, r, i) {
    return (this.x = e), (this.y = t), (this.z = r), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      r = this.y,
      i = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * r + o[8] * i + o[12] * s),
      (this.y = o[1] * t + o[5] * r + o[9] * i + o[13] * s),
      (this.z = o[2] * t + o[6] * r + o[10] * i + o[14] * s),
      (this.w = o[3] * t + o[7] * r + o[11] * i + o[15] * s),
      this
    );
  }
  divide(e) {
    return (
      (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), (this.w /= e.w), this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, r, i, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      f = l[8],
      p = l[1],
      m = l[5],
      v = l[9],
      y = l[2],
      x = l[6],
      g = l[10];
    if (
      Math.abs(u - p) < 0.01 &&
      Math.abs(f - y) < 0.01 &&
      Math.abs(v - x) < 0.01
    ) {
      if (
        Math.abs(u + p) < 0.1 &&
        Math.abs(f + y) < 0.1 &&
        Math.abs(v + x) < 0.1 &&
        Math.abs(c + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (c + 1) / 2,
        b = (m + 1) / 2,
        C = (g + 1) / 2,
        A = (u + p) / 4,
        R = (f + y) / 4,
        O = (v + x) / 4;
      return (
        S > b && S > C
          ? S < 0.01
            ? ((r = 0), (i = 0.707106781), (s = 0.707106781))
            : ((r = Math.sqrt(S)), (i = A / r), (s = R / r))
          : b > C
          ? b < 0.01
            ? ((r = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(b)), (r = A / i), (s = O / i))
          : C < 0.01
          ? ((r = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(C)), (r = R / s), (i = O / s)),
        this.set(r, i, s, t),
        this
      );
    }
    let _ = Math.sqrt(
      (x - v) * (x - v) + (f - y) * (f - y) + (p - u) * (p - u)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (x - v) / _),
      (this.y = (f - y) / _),
      (this.z = (p - u) / _),
      (this.w = Math.acos((c + m + g - 1) / 2)),
      this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (
      (this.x = t[12]),
      (this.y = t[13]),
      (this.z = t[14]),
      (this.w = t[15]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = St(this.x, e.x, t.x)),
      (this.y = St(this.y, e.y, t.y)),
      (this.z = St(this.z, e.z, t.z)),
      (this.w = St(this.w, e.w, t.w)),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = St(this.x, e, t)),
      (this.y = St(this.y, e, t)),
      (this.z = St(this.z, e, t)),
      (this.w = St(this.w, e, t)),
      this
    );
  }
  clampLength(e, t) {
    const r = this.length();
    return this.divideScalar(r || 1).multiplyScalar(St(r, e, t));
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, r) {
    return (
      (this.x = e.x + (t.x - e.x) * r),
      (this.y = e.y + (t.y - e.y) * r),
      (this.z = e.z + (t.z - e.z) * r),
      (this.w = e.w + (t.w - e.w) * r),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class kC extends wo {
  constructor(e = 1, t = 1, r = {}) {
    super(),
      (r = Object.assign(
        {
          generateMipmaps: !1,
          internalFormat: null,
          minFilter: Zn,
          depthBuffer: !0,
          stencilBuffer: !1,
          resolveDepthBuffer: !0,
          resolveStencilBuffer: !0,
          depthTexture: null,
          samples: 0,
          count: 1,
          depth: 1,
          multiview: !1,
        },
        r
      )),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = r.depth),
      (this.scissor = new Gt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Gt(0, 0, e, t));
    const i = { width: e, height: t, depth: r.depth },
      s = new Nn(i);
    this.textures = [];
    const o = r.count;
    for (let a = 0; a < o; a++)
      (this.textures[a] = s.clone()),
        (this.textures[a].isRenderTargetTexture = !0),
        (this.textures[a].renderTarget = this);
    this._setTextureOptions(r),
      (this.depthBuffer = r.depthBuffer),
      (this.stencilBuffer = r.stencilBuffer),
      (this.resolveDepthBuffer = r.resolveDepthBuffer),
      (this.resolveStencilBuffer = r.resolveStencilBuffer),
      (this._depthTexture = null),
      (this.depthTexture = r.depthTexture),
      (this.samples = r.samples),
      (this.multiview = r.multiview);
  }
  _setTextureOptions(e = {}) {
    const t = {
      minFilter: Zn,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null,
    };
    e.mapping !== void 0 && (t.mapping = e.mapping),
      e.wrapS !== void 0 && (t.wrapS = e.wrapS),
      e.wrapT !== void 0 && (t.wrapT = e.wrapT),
      e.wrapR !== void 0 && (t.wrapR = e.wrapR),
      e.magFilter !== void 0 && (t.magFilter = e.magFilter),
      e.minFilter !== void 0 && (t.minFilter = e.minFilter),
      e.format !== void 0 && (t.format = e.format),
      e.type !== void 0 && (t.type = e.type),
      e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy),
      e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace),
      e.flipY !== void 0 && (t.flipY = e.flipY),
      e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps),
      e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
    for (let r = 0; r < this.textures.length; r++)
      this.textures[r].setValues(t);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null),
      e !== null && (e.renderTarget = this),
      (this._depthTexture = e);
  }
  get depthTexture() {
    return this._depthTexture;
  }
  setSize(e, t, r = 1) {
    if (this.width !== e || this.height !== t || this.depth !== r) {
      (this.width = e), (this.height = t), (this.depth = r);
      for (let i = 0, s = this.textures.length; i < s; i++)
        (this.textures[i].image.width = e),
          (this.textures[i].image.height = t),
          (this.textures[i].image.depth = r),
          (this.textures[i].isArrayTexture = this.textures[i].image.depth > 1);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let t = 0, r = e.textures.length; t < r; t++) {
      (this.textures[t] = e.textures[t].clone()),
        (this.textures[t].isRenderTargetTexture = !0),
        (this.textures[t].renderTarget = this);
      const i = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new Ya(i);
    }
    return (
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      (this.resolveDepthBuffer = e.resolveDepthBuffer),
      (this.resolveStencilBuffer = e.resolveStencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class xo extends kC {
  constructor(e = 1, t = 1, r = {}) {
    super(e, t, r), (this.isWebGLRenderTarget = !0);
  }
}
class n_ extends Nn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = mr),
      (this.minFilter = mr),
      (this.wrapR = rs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class $ne extends xo {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = r),
      (this.texture = new n_(null, e, t, r)),
      this._setTextureOptions(i),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class r_ extends Nn {
  constructor(e = null, t = 1, r = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: r, depth: i }),
      (this.magFilter = mr),
      (this.minFilter = mr),
      (this.wrapR = rs),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Xne extends xo {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = r),
      (this.texture = new r_(null, e, t, r)),
      this._setTextureOptions(i),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class Dr {
  constructor(
    e = new z(1 / 0, 1 / 0, 1 / 0),
    t = new z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t += 3)
      this.expandByPoint(ms.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, r = e.count; t < r; t++)
      this.expandByPoint(ms.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = ms.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const r = e.geometry;
    if (r !== void 0) {
      const s = r.getAttribute("position");
      if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let o = 0, a = s.count; o < a; o++)
          e.isMesh === !0
            ? e.getVertexPosition(o, ms)
            : ms.fromBufferAttribute(s, o),
            ms.applyMatrix4(e.matrixWorld),
            this.expandByPoint(ms);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            mv.copy(e.boundingBox))
          : (r.boundingBox === null && r.computeBoundingBox(),
            mv.copy(r.boundingBox)),
          mv.applyMatrix4(e.matrixWorld),
          this.union(mv);
    }
    const i = e.children;
    for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], t);
    return this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y &&
      e.z >= this.min.z &&
      e.z <= this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y &&
      e.max.z >= this.min.z &&
      e.min.z <= this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, ms),
      ms.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, r;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
      t <= -e.constant && r >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(pf),
      gv.subVectors(this.max, pf),
      Cu.subVectors(e.a, pf),
      Au.subVectors(e.b, pf),
      Ru.subVectors(e.c, pf),
      Sa.subVectors(Au, Cu),
      ba.subVectors(Ru, Au),
      Bl.subVectors(Cu, Ru);
    let t = [
      0,
      -Sa.z,
      Sa.y,
      0,
      -ba.z,
      ba.y,
      0,
      -Bl.z,
      Bl.y,
      Sa.z,
      0,
      -Sa.x,
      ba.z,
      0,
      -ba.x,
      Bl.z,
      0,
      -Bl.x,
      -Sa.y,
      Sa.x,
      0,
      -ba.y,
      ba.x,
      0,
      -Bl.y,
      Bl.x,
      0,
    ];
    return !e1(t, Cu, Au, Ru, gv) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !e1(t, Cu, Au, Ru, gv))
      ? !1
      : (vv.crossVectors(Sa, ba),
        (t = [vv.x, vv.y, vv.z]),
        e1(t, Cu, Au, Ru, gv));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ms).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(ms).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Io[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Io[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Io[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Io[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Io[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Io[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Io[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Io[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Io),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  toJSON() {
    return { min: this.min.toArray(), max: this.max.toArray() };
  }
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const Io = [
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
  ],
  ms = new z(),
  mv = new Dr(),
  Cu = new z(),
  Au = new z(),
  Ru = new z(),
  Sa = new z(),
  ba = new z(),
  Bl = new z(),
  pf = new z(),
  gv = new z(),
  vv = new z(),
  zl = new z();
function e1(n, e, t, r, i) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    zl.fromArray(n, s);
    const a =
        i.x * Math.abs(zl.x) + i.y * Math.abs(zl.y) + i.z * Math.abs(zl.z),
      l = e.dot(zl),
      c = t.dot(zl),
      u = r.dot(zl);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1;
  }
  return !0;
}
const qne = new Dr(),
  mf = new z(),
  t1 = new z();
class gr {
  constructor(e = new z(), t = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const r = this.center;
    t !== void 0 ? r.copy(t) : qne.setFromPoints(e).getCenter(r);
    let i = 0;
    for (let s = 0, o = e.length; s < o; s++)
      i = Math.max(i, r.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const r = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      r > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    mf.subVectors(e, this.center);
    const t = mf.lengthSq();
    if (t > this.radius * this.radius) {
      const r = Math.sqrt(t),
        i = (r - this.radius) * 0.5;
      this.center.addScaledVector(mf, i / r), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (t1.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(mf.copy(e.center).add(t1)),
            this.expandByPoint(mf.copy(e.center).sub(t1))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    return { radius: this.radius, center: this.center.toArray() };
  }
  fromJSON(e) {
    return (this.radius = e.radius), this.center.fromArray(e.center), this;
  }
}
const No = new z(),
  n1 = new z(),
  yv = new z(),
  Ea = new z(),
  r1 = new z(),
  xv = new z(),
  i1 = new z();
class Nh {
  constructor(e = new z(), t = new z(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, No)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const r = t.dot(this.direction);
    return r < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, r);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = No.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (No.copy(this.origin).addScaledVector(this.direction, t),
        No.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, r, i) {
    n1.copy(e).add(t).multiplyScalar(0.5),
      yv.copy(t).sub(e).normalize(),
      Ea.copy(this.origin).sub(n1);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(yv),
      a = Ea.dot(this.direction),
      l = -Ea.dot(yv),
      c = Ea.lengthSq(),
      u = Math.abs(1 - o * o);
    let f, p, m, v;
    if (u > 0)
      if (((f = o * l - a), (p = o * a - l), (v = s * u), f >= 0))
        if (p >= -v)
          if (p <= v) {
            const y = 1 / u;
            (f *= y),
              (p *= y),
              (m = f * (f + o * p + 2 * a) + p * (o * f + p + 2 * l) + c);
          } else
            (p = s),
              (f = Math.max(0, -(o * p + a))),
              (m = -f * f + p * (p + 2 * l) + c);
        else
          (p = -s),
            (f = Math.max(0, -(o * p + a))),
            (m = -f * f + p * (p + 2 * l) + c);
      else
        p <= -v
          ? ((f = Math.max(0, -(-o * s + a))),
            (p = f > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -f * f + p * (p + 2 * l) + c))
          : p <= v
          ? ((f = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (m = p * (p + 2 * l) + c))
          : ((f = Math.max(0, -(o * s + a))),
            (p = f > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -f * f + p * (p + 2 * l) + c));
    else
      (p = o > 0 ? -s : s),
        (f = Math.max(0, -(o * p + a))),
        (m = -f * f + p * (p + 2 * l) + c);
    return (
      r && r.copy(this.origin).addScaledVector(this.direction, f),
      i && i.copy(n1).addScaledVector(yv, p),
      m
    );
  }
  intersectSphere(e, t) {
    No.subVectors(e.center, this.origin);
    const r = No.dot(this.direction),
      i = No.dot(No) - r * r,
      s = e.radius * e.radius;
    if (i > s) return null;
    const o = Math.sqrt(s - i),
      a = r - o,
      l = r + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return e.radius < 0
      ? !1
      : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const r = -(this.origin.dot(e.normal) + e.constant) / t;
    return r >= 0 ? r : null;
  }
  intersectPlane(e, t) {
    const r = this.distanceToPlane(e);
    return r === null ? null : this.at(r, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let r, i, s, o, a, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      f = 1 / this.direction.z,
      p = this.origin;
    return (
      c >= 0
        ? ((r = (e.min.x - p.x) * c), (i = (e.max.x - p.x) * c))
        : ((r = (e.max.x - p.x) * c), (i = (e.min.x - p.x) * c)),
      u >= 0
        ? ((s = (e.min.y - p.y) * u), (o = (e.max.y - p.y) * u))
        : ((s = (e.max.y - p.y) * u), (o = (e.min.y - p.y) * u)),
      r > o ||
      s > i ||
      ((s > r || isNaN(r)) && (r = s),
      (o < i || isNaN(i)) && (i = o),
      f >= 0
        ? ((a = (e.min.z - p.z) * f), (l = (e.max.z - p.z) * f))
        : ((a = (e.max.z - p.z) * f), (l = (e.min.z - p.z) * f)),
      r > l || a > i) ||
      ((a > r || r !== r) && (r = a), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(r >= 0 ? r : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, No) !== null;
  }
  intersectTriangle(e, t, r, i, s) {
    r1.subVectors(t, e), xv.subVectors(r, e), i1.crossVectors(r1, xv);
    let o = this.direction.dot(i1),
      a;
    if (o > 0) {
      if (i) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    Ea.subVectors(this.origin, e);
    const l = a * this.direction.dot(xv.crossVectors(Ea, xv));
    if (l < 0) return null;
    const c = a * this.direction.dot(r1.cross(Ea));
    if (c < 0 || l + c > o) return null;
    const u = -a * Ea.dot(i1);
    return u < 0 ? null : this.at(u / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Tt {
  constructor(e, t, r, i, s, o, a, l, c, u, f, p, m, v, y, x) {
    (Tt.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i, s, o, a, l, c, u, f, p, m, v, y, x);
  }
  set(e, t, r, i, s, o, a, l, c, u, f, p, m, v, y, x) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = r),
      (g[12] = i),
      (g[1] = s),
      (g[5] = o),
      (g[9] = a),
      (g[13] = l),
      (g[2] = c),
      (g[6] = u),
      (g[10] = f),
      (g[14] = p),
      (g[3] = m),
      (g[7] = v),
      (g[11] = y),
      (g[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Tt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      r = e.elements;
    return (
      (t[0] = r[0]),
      (t[1] = r[1]),
      (t[2] = r[2]),
      (t[3] = r[3]),
      (t[4] = r[4]),
      (t[5] = r[5]),
      (t[6] = r[6]),
      (t[7] = r[7]),
      (t[8] = r[8]),
      (t[9] = r[9]),
      (t[10] = r[10]),
      (t[11] = r[11]),
      (t[12] = r[12]),
      (t[13] = r[13]),
      (t[14] = r[14]),
      (t[15] = r[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      r = e.elements;
    return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, r) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      r.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, r) {
    return (
      this.set(
        e.x,
        t.x,
        r.x,
        0,
        e.y,
        t.y,
        r.y,
        0,
        e.z,
        t.z,
        r.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      r = e.elements,
      i = 1 / Pu.setFromMatrixColumn(e, 0).length(),
      s = 1 / Pu.setFromMatrixColumn(e, 1).length(),
      o = 1 / Pu.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = r[0] * i),
      (t[1] = r[1] * i),
      (t[2] = r[2] * i),
      (t[3] = 0),
      (t[4] = r[4] * s),
      (t[5] = r[5] * s),
      (t[6] = r[6] * s),
      (t[7] = 0),
      (t[8] = r[8] * o),
      (t[9] = r[9] * o),
      (t[10] = r[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z,
      o = Math.cos(r),
      a = Math.sin(r),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(s),
      f = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * u,
        m = o * f,
        v = a * u,
        y = a * f;
      (t[0] = l * u),
        (t[4] = -l * f),
        (t[8] = c),
        (t[1] = m + v * c),
        (t[5] = p - y * c),
        (t[9] = -a * l),
        (t[2] = y - p * c),
        (t[6] = v + m * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * u,
        m = l * f,
        v = c * u,
        y = c * f;
      (t[0] = p + y * a),
        (t[4] = v * a - m),
        (t[8] = o * c),
        (t[1] = o * f),
        (t[5] = o * u),
        (t[9] = -a),
        (t[2] = m * a - v),
        (t[6] = y + p * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * u,
        m = l * f,
        v = c * u,
        y = c * f;
      (t[0] = p - y * a),
        (t[4] = -o * f),
        (t[8] = v + m * a),
        (t[1] = m + v * a),
        (t[5] = o * u),
        (t[9] = y - p * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * u,
        m = o * f,
        v = a * u,
        y = a * f;
      (t[0] = l * u),
        (t[4] = v * c - m),
        (t[8] = p * c + y),
        (t[1] = l * f),
        (t[5] = y * c + p),
        (t[9] = m * c - v),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        m = o * c,
        v = a * l,
        y = a * c;
      (t[0] = l * u),
        (t[4] = y - p * f),
        (t[8] = v * f + m),
        (t[1] = f),
        (t[5] = o * u),
        (t[9] = -a * u),
        (t[2] = -c * u),
        (t[6] = m * f + v),
        (t[10] = p - y * f);
    } else if (e.order === "XZY") {
      const p = o * l,
        m = o * c,
        v = a * l,
        y = a * c;
      (t[0] = l * u),
        (t[4] = -f),
        (t[8] = c * u),
        (t[1] = p * f + y),
        (t[5] = o * u),
        (t[9] = m * f - v),
        (t[2] = v * f - m),
        (t[6] = a * u),
        (t[10] = y * f + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Kne, e, Yne);
  }
  lookAt(e, t, r) {
    const i = this.elements;
    return (
      bi.subVectors(e, t),
      bi.lengthSq() === 0 && (bi.z = 1),
      bi.normalize(),
      Ta.crossVectors(r, bi),
      Ta.lengthSq() === 0 &&
        (Math.abs(r.z) === 1 ? (bi.x += 1e-4) : (bi.z += 1e-4),
        bi.normalize(),
        Ta.crossVectors(r, bi)),
      Ta.normalize(),
      _v.crossVectors(bi, Ta),
      (i[0] = Ta.x),
      (i[4] = _v.x),
      (i[8] = bi.x),
      (i[1] = Ta.y),
      (i[5] = _v.y),
      (i[9] = bi.y),
      (i[2] = Ta.z),
      (i[6] = _v.z),
      (i[10] = bi.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const r = e.elements,
      i = t.elements,
      s = this.elements,
      o = r[0],
      a = r[4],
      l = r[8],
      c = r[12],
      u = r[1],
      f = r[5],
      p = r[9],
      m = r[13],
      v = r[2],
      y = r[6],
      x = r[10],
      g = r[14],
      _ = r[3],
      S = r[7],
      b = r[11],
      C = r[15],
      A = i[0],
      R = i[4],
      O = i[8],
      I = i[12],
      N = i[1],
      D = i[5],
      j = i[9],
      $ = i[13],
      G = i[2],
      Z = i[6],
      q = i[10],
      Y = i[14],
      U = i[3],
      H = i[7],
      X = i[11],
      ie = i[15];
    return (
      (s[0] = o * A + a * N + l * G + c * U),
      (s[4] = o * R + a * D + l * Z + c * H),
      (s[8] = o * O + a * j + l * q + c * X),
      (s[12] = o * I + a * $ + l * Y + c * ie),
      (s[1] = u * A + f * N + p * G + m * U),
      (s[5] = u * R + f * D + p * Z + m * H),
      (s[9] = u * O + f * j + p * q + m * X),
      (s[13] = u * I + f * $ + p * Y + m * ie),
      (s[2] = v * A + y * N + x * G + g * U),
      (s[6] = v * R + y * D + x * Z + g * H),
      (s[10] = v * O + y * j + x * q + g * X),
      (s[14] = v * I + y * $ + x * Y + g * ie),
      (s[3] = _ * A + S * N + b * G + C * U),
      (s[7] = _ * R + S * D + b * Z + C * H),
      (s[11] = _ * O + S * j + b * q + C * X),
      (s[15] = _ * I + S * $ + b * Y + C * ie),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      r = e[4],
      i = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      f = e[6],
      p = e[10],
      m = e[14],
      v = e[3],
      y = e[7],
      x = e[11],
      g = e[15];
    return (
      v *
        (+s * l * f -
          i * c * f -
          s * a * p +
          r * c * p +
          i * a * m -
          r * l * m) +
      y *
        (+t * l * m -
          t * c * p +
          s * o * p -
          i * o * m +
          i * c * u -
          s * l * u) +
      x *
        (+t * c * f -
          t * a * m -
          s * o * f +
          r * o * m +
          s * a * u -
          r * c * u) +
      g *
        (-i * a * u - t * l * f + t * a * p + i * o * f - r * o * p + r * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, r) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = r)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      r = e[1],
      i = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      f = e[9],
      p = e[10],
      m = e[11],
      v = e[12],
      y = e[13],
      x = e[14],
      g = e[15],
      _ = f * x * c - y * p * c + y * l * m - a * x * m - f * l * g + a * p * g,
      S = v * p * c - u * x * c - v * l * m + o * x * m + u * l * g - o * p * g,
      b = u * y * c - v * f * c + v * a * m - o * y * m - u * a * g + o * f * g,
      C = v * f * l - u * y * l - v * a * p + o * y * p + u * a * x - o * f * x,
      A = t * _ + r * S + i * b + s * C;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const R = 1 / A;
    return (
      (e[0] = _ * R),
      (e[1] =
        (y * p * s -
          f * x * s -
          y * i * m +
          r * x * m +
          f * i * g -
          r * p * g) *
        R),
      (e[2] =
        (a * x * s -
          y * l * s +
          y * i * c -
          r * x * c -
          a * i * g +
          r * l * g) *
        R),
      (e[3] =
        (f * l * s -
          a * p * s -
          f * i * c +
          r * p * c +
          a * i * m -
          r * l * m) *
        R),
      (e[4] = S * R),
      (e[5] =
        (u * x * s -
          v * p * s +
          v * i * m -
          t * x * m -
          u * i * g +
          t * p * g) *
        R),
      (e[6] =
        (v * l * s -
          o * x * s -
          v * i * c +
          t * x * c +
          o * i * g -
          t * l * g) *
        R),
      (e[7] =
        (o * p * s -
          u * l * s +
          u * i * c -
          t * p * c -
          o * i * m +
          t * l * m) *
        R),
      (e[8] = b * R),
      (e[9] =
        (v * f * s -
          u * y * s -
          v * r * m +
          t * y * m +
          u * r * g -
          t * f * g) *
        R),
      (e[10] =
        (o * y * s -
          v * a * s +
          v * r * c -
          t * y * c -
          o * r * g +
          t * a * g) *
        R),
      (e[11] =
        (u * a * s -
          o * f * s -
          u * r * c +
          t * f * c +
          o * r * m -
          t * a * m) *
        R),
      (e[12] = C * R),
      (e[13] =
        (u * y * i -
          v * f * i +
          v * r * p -
          t * y * p -
          u * r * x +
          t * f * x) *
        R),
      (e[14] =
        (v * a * i -
          o * y * i -
          v * r * l +
          t * y * l +
          o * r * x -
          t * a * x) *
        R),
      (e[15] =
        (o * f * i -
          u * a * i +
          u * r * l -
          t * f * l -
          o * r * p +
          t * a * p) *
        R),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      r = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= r),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= r),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= r),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= r),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, r, i));
  }
  makeTranslation(e, t, r) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      r = Math.sin(e);
    return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const r = Math.cos(t),
      i = Math.sin(t),
      s = 1 - r,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      u = s * a;
    return (
      this.set(
        c * o + r,
        c * a - i * l,
        c * l + i * a,
        0,
        c * a + i * l,
        u * a + r,
        u * l - i * o,
        0,
        c * l - i * a,
        u * l + i * o,
        s * l * l + r,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, r) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, r, i, s, o) {
    return this.set(1, r, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, r) {
    const i = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      u = o + o,
      f = a + a,
      p = s * c,
      m = s * u,
      v = s * f,
      y = o * u,
      x = o * f,
      g = a * f,
      _ = l * c,
      S = l * u,
      b = l * f,
      C = r.x,
      A = r.y,
      R = r.z;
    return (
      (i[0] = (1 - (y + g)) * C),
      (i[1] = (m + b) * C),
      (i[2] = (v - S) * C),
      (i[3] = 0),
      (i[4] = (m - b) * A),
      (i[5] = (1 - (p + g)) * A),
      (i[6] = (x + _) * A),
      (i[7] = 0),
      (i[8] = (v + S) * R),
      (i[9] = (x - _) * R),
      (i[10] = (1 - (p + y)) * R),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, r) {
    const i = this.elements;
    let s = Pu.set(i[0], i[1], i[2]).length();
    const o = Pu.set(i[4], i[5], i[6]).length(),
      a = Pu.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      gs.copy(this);
    const c = 1 / s,
      u = 1 / o,
      f = 1 / a;
    return (
      (gs.elements[0] *= c),
      (gs.elements[1] *= c),
      (gs.elements[2] *= c),
      (gs.elements[4] *= u),
      (gs.elements[5] *= u),
      (gs.elements[6] *= u),
      (gs.elements[8] *= f),
      (gs.elements[9] *= f),
      (gs.elements[10] *= f),
      t.setFromRotationMatrix(gs),
      (r.x = s),
      (r.y = o),
      (r.z = a),
      this
    );
  }
  makePerspective(e, t, r, i, s, o, a = Pi, l = !1) {
    const c = this.elements,
      u = (2 * s) / (t - e),
      f = (2 * s) / (r - i),
      p = (t + e) / (t - e),
      m = (r + i) / (r - i);
    let v, y;
    if (l) (v = s / (o - s)), (y = (o * s) / (o - s));
    else if (a === Pi) (v = -(o + s) / (o - s)), (y = (-2 * o * s) / (o - s));
    else if (a === ch) (v = -o / (o - s)), (y = (-o * s) / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = p),
      (c[12] = 0),
      (c[1] = 0),
      (c[5] = f),
      (c[9] = m),
      (c[13] = 0),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = v),
      (c[14] = y),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = -1),
      (c[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, r, i, s, o, a = Pi, l = !1) {
    const c = this.elements,
      u = 2 / (t - e),
      f = 2 / (r - i),
      p = -(t + e) / (t - e),
      m = -(r + i) / (r - i);
    let v, y;
    if (l) (v = 1 / (o - s)), (y = o / (o - s));
    else if (a === Pi) (v = -2 / (o - s)), (y = -(o + s) / (o - s));
    else if (a === ch) (v = -1 / (o - s)), (y = -s / (o - s));
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
      );
    return (
      (c[0] = u),
      (c[4] = 0),
      (c[8] = 0),
      (c[12] = p),
      (c[1] = 0),
      (c[5] = f),
      (c[9] = 0),
      (c[13] = m),
      (c[2] = 0),
      (c[6] = 0),
      (c[10] = v),
      (c[14] = y),
      (c[3] = 0),
      (c[7] = 0),
      (c[11] = 0),
      (c[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      r = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== r[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.elements;
    return (
      (e[t] = r[0]),
      (e[t + 1] = r[1]),
      (e[t + 2] = r[2]),
      (e[t + 3] = r[3]),
      (e[t + 4] = r[4]),
      (e[t + 5] = r[5]),
      (e[t + 6] = r[6]),
      (e[t + 7] = r[7]),
      (e[t + 8] = r[8]),
      (e[t + 9] = r[9]),
      (e[t + 10] = r[10]),
      (e[t + 11] = r[11]),
      (e[t + 12] = r[12]),
      (e[t + 13] = r[13]),
      (e[t + 14] = r[14]),
      (e[t + 15] = r[15]),
      e
    );
  }
}
const Pu = new z(),
  gs = new Tt(),
  Kne = new z(0, 0, 0),
  Yne = new z(1, 1, 1),
  Ta = new z(),
  _v = new z(),
  bi = new z(),
  GN = new Tt(),
  $N = new vi();
class Di {
  constructor(e = 0, t = 0, r = 0, i = Di.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, r, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = r),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, r = !0) {
    const i = e.elements,
      s = i[0],
      o = i[4],
      a = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      f = i[2],
      p = i[6],
      m = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(St(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-u, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-St(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-f, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(St(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-f, m)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-St(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(St(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-f, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-St(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-u, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), r === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, r) {
    return (
      GN.makeRotationFromQuaternion(e), this.setFromRotationMatrix(GN, t, r)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return $N.setFromEuler(this), this.setFromQuaternion($N, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Di.DEFAULT_ORDER = "XYZ";
class Ic {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let Jne = 0;
const XN = new z(),
  Iu = new vi(),
  Lo = new Tt(),
  wv = new z(),
  gf = new z(),
  Zne = new z(),
  Qne = new vi(),
  qN = new z(1, 0, 0),
  KN = new z(0, 1, 0),
  YN = new z(0, 0, 1),
  JN = { type: "added" },
  ere = { type: "removed" },
  Nu = { type: "childadded", child: null },
  s1 = { type: "childremoved", child: null };
class Xt extends wo {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: Jne++ }),
      (this.uuid = Li()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Xt.DEFAULT_UP.clone());
    const e = new z(),
      t = new Di(),
      r = new vi(),
      i = new z(1, 1, 1);
    function s() {
      r.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(r, void 0, !1);
    }
    t._onChange(s),
      r._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: r },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new Tt() },
        normalMatrix: { value: new Nt() },
      }),
      (this.matrix = new Tt()),
      (this.matrixWorld = new Tt()),
      (this.matrixAutoUpdate = Xt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = Xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new Ic()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.customDepthMaterial = void 0),
      (this.customDistanceMaterial = void 0),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Iu.setFromAxisAngle(e, t), this.quaternion.multiply(Iu), this;
  }
  rotateOnWorldAxis(e, t) {
    return Iu.setFromAxisAngle(e, t), this.quaternion.premultiply(Iu), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(qN, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(KN, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(YN, e);
  }
  translateOnAxis(e, t) {
    return (
      XN.copy(e).applyQuaternion(this.quaternion),
      this.position.add(XN.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(qN, e);
  }
  translateY(e) {
    return this.translateOnAxis(KN, e);
  }
  translateZ(e) {
    return this.translateOnAxis(YN, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Lo.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, r) {
    e.isVector3 ? wv.copy(e) : wv.set(e, t, r);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      gf.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Lo.lookAt(gf, wv, this.up)
        : Lo.lookAt(wv, gf, this.up),
      this.quaternion.setFromRotationMatrix(Lo),
      i &&
        (Lo.extractRotation(i.matrixWorld),
        Iu.setFromRotationMatrix(Lo),
        this.quaternion.premultiply(Iu.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(JN),
            (Nu.child = e),
            this.dispatchEvent(Nu),
            (Nu.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++) this.remove(arguments[r]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null),
        this.children.splice(t, 1),
        e.dispatchEvent(ere),
        (s1.child = e),
        this.dispatchEvent(s1),
        (s1.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Lo.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Lo.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Lo),
      e.removeFromParent(),
      (e.parent = this),
      this.children.push(e),
      e.updateWorldMatrix(!1, !0),
      e.dispatchEvent(JN),
      (Nu.child = e),
      this.dispatchEvent(Nu),
      (Nu.child = null),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let r = 0, i = this.children.length; r < i; r++) {
      const o = this.children[r].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, r = []) {
    this[e] === t && r.push(this);
    const i = this.children;
    for (let s = 0, o = i.length; s < o; s++)
      i[s].getObjectsByProperty(e, t, r);
    return r;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gf, e, Zne), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(gf, Qne, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.matrixWorldAutoUpdate === !0 &&
          (this.parent === null
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              )),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let r = 0, i = t.length; r < i; r++) t[r].updateMatrixWorld(e);
  }
  updateWorldMatrix(e, t) {
    const r = this.parent;
    if (
      (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldAutoUpdate === !0 &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            )),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, o = i.length; s < o; s++) i[s].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      r = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (r.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((i.type = "BatchedMesh"),
        (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (i.sortObjects = this.sortObjects),
        (i.drawRanges = this._drawRanges),
        (i.reservedRanges = this._reservedRanges),
        (i.geometryInfo = this._geometryInfo.map((a) => ({
          ...a,
          boundingBox: a.boundingBox ? a.boundingBox.toJSON() : void 0,
          boundingSphere: a.boundingSphere ? a.boundingSphere.toJSON() : void 0,
        }))),
        (i.instanceInfo = this._instanceInfo.map((a) => ({ ...a }))),
        (i.availableInstanceIds = this._availableInstanceIds.slice()),
        (i.availableGeometryIds = this._availableGeometryIds.slice()),
        (i.nextIndexStart = this._nextIndexStart),
        (i.nextVertexStart = this._nextVertexStart),
        (i.geometryCount = this._geometryCount),
        (i.maxInstanceCount = this._maxInstanceCount),
        (i.maxVertexCount = this._maxVertexCount),
        (i.maxIndexCount = this._maxIndexCount),
        (i.geometryInitialized = this._geometryInitialized),
        (i.matricesTexture = this._matricesTexture.toJSON(e)),
        (i.indirectTexture = this._indirectTexture.toJSON(e)),
        this._colorsTexture !== null &&
          (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (i.boundingSphere = this.boundingSphere.toJSON()),
        this.boundingBox !== null &&
          (i.boundingBox = this.boundingBox.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const f = l[c];
            s(e.shapes, f);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        i.material = a;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let a = 0; a < this.children.length; a++)
        i.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        u = o(e.images),
        f = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        v = o(e.nodes);
      a.length > 0 && (r.geometries = a),
        l.length > 0 && (r.materials = l),
        c.length > 0 && (r.textures = c),
        u.length > 0 && (r.images = u),
        f.length > 0 && (r.shapes = f),
        p.length > 0 && (r.skeletons = p),
        m.length > 0 && (r.animations = m),
        v.length > 0 && (r.nodes = v);
    }
    return (r.object = i), r;
    function o(a) {
      const l = [];
      for (const c in a) {
        const u = a[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let r = 0; r < e.children.length; r++) {
        const i = e.children[r];
        this.add(i.clone());
      }
    return this;
  }
}
Xt.DEFAULT_UP = new z(0, 1, 0);
Xt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const vs = new z(),
  Oo = new z(),
  o1 = new z(),
  Do = new z(),
  Lu = new z(),
  Ou = new z(),
  ZN = new z(),
  a1 = new z(),
  l1 = new z(),
  c1 = new z(),
  u1 = new Gt(),
  d1 = new Gt(),
  h1 = new Gt();
class ui {
  constructor(e = new z(), t = new z(), r = new z()) {
    (this.a = e), (this.b = t), (this.c = r);
  }
  static getNormal(e, t, r, i) {
    i.subVectors(r, t), vs.subVectors(e, t), i.cross(vs);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, r, i, s) {
    vs.subVectors(i, t), Oo.subVectors(r, t), o1.subVectors(e, t);
    const o = vs.dot(vs),
      a = vs.dot(Oo),
      l = vs.dot(o1),
      c = Oo.dot(Oo),
      u = Oo.dot(o1),
      f = o * c - a * a;
    if (f === 0) return s.set(0, 0, 0), null;
    const p = 1 / f,
      m = (c * l - a * u) * p,
      v = (o * u - a * l) * p;
    return s.set(1 - m - v, v, m);
  }
  static containsPoint(e, t, r, i) {
    return this.getBarycoord(e, t, r, i, Do) === null
      ? !1
      : Do.x >= 0 && Do.y >= 0 && Do.x + Do.y <= 1;
  }
  static getInterpolation(e, t, r, i, s, o, a, l) {
    return this.getBarycoord(e, t, r, i, Do) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, Do.x),
        l.addScaledVector(o, Do.y),
        l.addScaledVector(a, Do.z),
        l);
  }
  static getInterpolatedAttribute(e, t, r, i, s, o) {
    return (
      u1.setScalar(0),
      d1.setScalar(0),
      h1.setScalar(0),
      u1.fromBufferAttribute(e, t),
      d1.fromBufferAttribute(e, r),
      h1.fromBufferAttribute(e, i),
      o.setScalar(0),
      o.addScaledVector(u1, s.x),
      o.addScaledVector(d1, s.y),
      o.addScaledVector(h1, s.z),
      o
    );
  }
  static isFrontFacing(e, t, r, i) {
    return vs.subVectors(r, t), Oo.subVectors(e, t), vs.cross(Oo).dot(i) < 0;
  }
  set(e, t, r) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
  }
  setFromPointsAndIndices(e, t, r, i) {
    return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, r, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, r),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      vs.subVectors(this.c, this.b),
      Oo.subVectors(this.a, this.b),
      vs.cross(Oo).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ui.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return ui.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, r, i, s) {
    return ui.getInterpolation(e, this.a, this.b, this.c, t, r, i, s);
  }
  containsPoint(e) {
    return ui.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ui.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const r = this.a,
      i = this.b,
      s = this.c;
    let o, a;
    Lu.subVectors(i, r), Ou.subVectors(s, r), a1.subVectors(e, r);
    const l = Lu.dot(a1),
      c = Ou.dot(a1);
    if (l <= 0 && c <= 0) return t.copy(r);
    l1.subVectors(e, i);
    const u = Lu.dot(l1),
      f = Ou.dot(l1);
    if (u >= 0 && f <= u) return t.copy(i);
    const p = l * f - u * c;
    if (p <= 0 && l >= 0 && u <= 0)
      return (o = l / (l - u)), t.copy(r).addScaledVector(Lu, o);
    c1.subVectors(e, s);
    const m = Lu.dot(c1),
      v = Ou.dot(c1);
    if (v >= 0 && m <= v) return t.copy(s);
    const y = m * c - l * v;
    if (y <= 0 && c >= 0 && v <= 0)
      return (a = c / (c - v)), t.copy(r).addScaledVector(Ou, a);
    const x = u * v - m * f;
    if (x <= 0 && f - u >= 0 && m - v >= 0)
      return (
        ZN.subVectors(s, i),
        (a = (f - u) / (f - u + (m - v))),
        t.copy(i).addScaledVector(ZN, a)
      );
    const g = 1 / (x + y + p);
    return (
      (o = y * g),
      (a = p * g),
      t.copy(r).addScaledVector(Lu, o).addScaledVector(Ou, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const eV = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Ma = { h: 0, s: 0, l: 0 },
  Sv = { h: 0, s: 0, l: 0 };
function f1(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Je {
  constructor(e, t, r) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, r)
    );
  }
  set(e, t, r) {
    if (t === void 0 && r === void 0) {
      const i = e;
      i && i.isColor
        ? this.copy(i)
        : typeof i == "number"
        ? this.setHex(i)
        : typeof i == "string" && this.setStyle(i);
    } else this.setRGB(e, t, r);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = li) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Ht.colorSpaceToWorking(this, t),
      this
    );
  }
  setRGB(e, t, r, i = Ht.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = r),
      Ht.colorSpaceToWorking(this, i),
      this
    );
  }
  setHSL(e, t, r, i = Ht.workingColorSpace) {
    if (((e = DC(e, 1)), (t = St(t, 0, 1)), (r = St(r, 0, 1)), t === 0))
      this.r = this.g = this.b = r;
    else {
      const s = r <= 0.5 ? r * (1 + t) : r + t - r * t,
        o = 2 * r - s;
      (this.r = f1(o, s, e + 1 / 3)),
        (this.g = f1(o, s, e)),
        (this.b = f1(o, s, e - 1 / 3));
    }
    return Ht.colorSpaceToWorking(this, i), this;
  }
  setStyle(e, t = li) {
    function r(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = i[1],
        a = i[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              r(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = li) {
    const r = eV[e.toLowerCase()];
    return (
      r !== void 0
        ? this.setHex(r, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = qo(e.r)), (this.g = qo(e.g)), (this.b = qo(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = kd(e.r)), (this.g = kd(e.g)), (this.b = kd(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = li) {
    return (
      Ht.workingToColorSpace(Rr.copy(this), e),
      Math.round(St(Rr.r * 255, 0, 255)) * 65536 +
        Math.round(St(Rr.g * 255, 0, 255)) * 256 +
        Math.round(St(Rr.b * 255, 0, 255))
    );
  }
  getHexString(e = li) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ht.workingColorSpace) {
    Ht.workingToColorSpace(Rr.copy(this), t);
    const r = Rr.r,
      i = Rr.g,
      s = Rr.b,
      o = Math.max(r, i, s),
      a = Math.min(r, i, s);
    let l, c;
    const u = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const f = o - a;
      switch (((c = u <= 0.5 ? f / (o + a) : f / (2 - o - a)), o)) {
        case r:
          l = (i - s) / f + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - r) / f + 2;
          break;
        case s:
          l = (r - i) / f + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = Ht.workingColorSpace) {
    return (
      Ht.workingToColorSpace(Rr.copy(this), t),
      (e.r = Rr.r),
      (e.g = Rr.g),
      (e.b = Rr.b),
      e
    );
  }
  getStyle(e = li) {
    Ht.workingToColorSpace(Rr.copy(this), e);
    const t = Rr.r,
      r = Rr.g,
      i = Rr.b;
    return e !== li
      ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, r) {
    return this.getHSL(Ma), this.setHSL(Ma.h + e, Ma.s + t, Ma.l + r);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, r) {
    return (
      (this.r = e.r + (t.r - e.r) * r),
      (this.g = e.g + (t.g - e.g) * r),
      (this.b = e.b + (t.b - e.b) * r),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Ma), e.getHSL(Sv);
    const r = cp(Ma.h, Sv.h, t),
      i = cp(Ma.s, Sv.s, t),
      s = cp(Ma.l, Sv.l, t);
    return this.setHSL(r, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      r = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * r + s[6] * i),
      (this.g = s[1] * t + s[4] * r + s[7] * i),
      (this.b = s[2] * t + s[5] * r + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Rr = new Je();
Je.NAMES = eV;
let tre = 0;
class Ur extends wo {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: tre++ }),
      (this.uuid = Li()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Rc),
      (this.side = ra),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Wp),
      (this.blendDst = b0),
      (this.blendEquation = Va),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new Je(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = zc),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = HE),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ic),
      (this.stencilZFail = ic),
      (this.stencilZPass = ic),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.allowOverride = !0),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const r = e[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(r)
          : i && i.isVector3 && r && r.isVector3
          ? i.copy(r)
          : (this[t] = r);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const r = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.color && this.color.isColor && (r.color = this.color.getHex()),
      this.roughness !== void 0 && (r.roughness = this.roughness),
      this.metalness !== void 0 && (r.metalness = this.metalness),
      this.sheen !== void 0 && (r.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (r.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (r.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (r.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (r.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (r.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (r.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (r.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (r.shininess = this.shininess),
      this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.dispersion !== void 0 && (r.dispersion = this.dispersion),
      this.iridescence !== void 0 && (r.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (r.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (r.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (r.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (r.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (r.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((r.lightMap = this.lightMap.toJSON(e).uuid),
        (r.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((r.aoMap = this.aoMap.toJSON(e).uuid),
        (r.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
        (r.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((r.normalMap = this.normalMap.toJSON(e).uuid),
        (r.normalMapType = this.normalMapType),
        (r.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
        (r.displacementScale = this.displacementScale),
        (r.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (r.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((r.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (r.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (r.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (r.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (r.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (r.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (r.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (r.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (r.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (r.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (r.size = this.size),
      this.shadowSide !== null && (r.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (r.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Rc && (r.blending = this.blending),
      this.side !== ra && (r.side = this.side),
      this.vertexColors === !0 && (r.vertexColors = !0),
      this.opacity < 1 && (r.opacity = this.opacity),
      this.transparent === !0 && (r.transparent = !0),
      this.blendSrc !== Wp && (r.blendSrc = this.blendSrc),
      this.blendDst !== b0 && (r.blendDst = this.blendDst),
      this.blendEquation !== Va && (r.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (r.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (r.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
      this.depthFunc !== zc && (r.depthFunc = this.depthFunc),
      this.depthTest === !1 && (r.depthTest = this.depthTest),
      this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (r.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== HE && (r.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (r.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ic && (r.stencilFail = this.stencilFail),
      this.stencilZFail !== ic && (r.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ic && (r.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (r.rotation = this.rotation),
      this.polygonOffset === !0 && (r.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (r.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (r.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (r.linewidth = this.linewidth),
      this.dashSize !== void 0 && (r.dashSize = this.dashSize),
      this.gapSize !== void 0 && (r.gapSize = this.gapSize),
      this.scale !== void 0 && (r.scale = this.scale),
      this.dithering === !0 && (r.dithering = !0),
      this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (r.alphaHash = !0),
      this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (r.forceSinglePass = !0),
      this.wireframe === !0 && (r.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (r.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (r.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (r.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (r.flatShading = !0),
      this.visible === !1 && (r.visible = !1),
      this.toneMapped === !1 && (r.toneMapped = !1),
      this.fog === !1 && (r.fog = !1),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData);
    function i(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = i(e.textures),
        o = i(e.images);
      s.length > 0 && (r.textures = s), o.length > 0 && (r.images = o);
    }
    return r;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let r = null;
    if (t !== null) {
      const i = t.length;
      r = new Array(i);
      for (let s = 0; s !== i; ++s) r[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = r),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class Sl extends Ur {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Di()),
      (this.combine = bm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ho = nre();
function nre() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    r = new Uint32Array(512),
    i = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((r[l] = 0), (r[l | 256] = 32768), (i[l] = 24), (i[l | 256] = 24))
      : c < -14
      ? ((r[l] = 1024 >> (-c - 14)),
        (r[l | 256] = (1024 >> (-c - 14)) | 32768),
        (i[l] = -c - 1),
        (i[l | 256] = -c - 1))
      : c <= 15
      ? ((r[l] = (c + 15) << 10),
        (r[l | 256] = ((c + 15) << 10) | 32768),
        (i[l] = 13),
        (i[l | 256] = 13))
      : c < 128
      ? ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 24), (i[l | 256] = 24))
      : ((r[l] = 31744), (r[l | 256] = 64512), (i[l] = 13), (i[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      u = 0;
    for (; !(c & 8388608); ) (c <<= 1), (u -= 8388608);
    (c &= -8388609), (u += 947912704), (s[l] = c | u);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: r,
    shiftTable: i,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function oi(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = St(n, -65504, 65504)),
    (Ho.floatView[0] = n);
  const e = Ho.uint32View[0],
    t = (e >> 23) & 511;
  return Ho.baseTable[t] + ((e & 8388607) >> Ho.shiftTable[t]);
}
function Of(n) {
  const e = n >> 10;
  return (
    (Ho.uint32View[0] =
      Ho.mantissaTable[Ho.offsetTable[e] + (n & 1023)] + Ho.exponentTable[e]),
    Ho.floatView[0]
  );
}
class rre {
  static toHalfFloat(e) {
    return oi(e);
  }
  static fromHalfFloat(e) {
    return Of(e);
  }
}
const jn = new z(),
  bv = new xe();
let ire = 0;
class sn {
  constructor(e, t, r = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      Object.defineProperty(this, "id", { value: ire++ }),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = r),
      (this.usage = Zp),
      (this.updateRanges = []),
      (this.gpuType = fi),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.itemSize), (r *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, r = this.count; t < r; t++)
        bv.fromBufferAttribute(this, t),
          bv.applyMatrix3(e),
          this.setXY(t, bv.x, bv.y);
    else if (this.itemSize === 3)
      for (let t = 0, r = this.count; t < r; t++)
        jn.fromBufferAttribute(this, t),
          jn.applyMatrix3(e),
          this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.count; t < r; t++)
      jn.fromBufferAttribute(this, t),
        jn.applyMatrix4(e),
        this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      jn.fromBufferAttribute(this, t),
        jn.applyNormalMatrix(e),
        this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      jn.fromBufferAttribute(this, t),
        jn.transformDirection(e),
        this.setXYZ(t, jn.x, jn.y, jn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.itemSize + t];
    return this.normalized && (r = qr(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = Dt(r, this.array)),
      (this.array[e * this.itemSize + t] = r),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Dt(t, this.array)), (r = Dt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array)),
        (s = Dt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = r),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Zp && (e.usage = this.usage),
      e
    );
  }
}
class sre extends sn {
  constructor(e, t, r) {
    super(new Int8Array(e), t, r);
  }
}
class ore extends sn {
  constructor(e, t, r) {
    super(new Uint8Array(e), t, r);
  }
}
class are extends sn {
  constructor(e, t, r) {
    super(new Uint8ClampedArray(e), t, r);
  }
}
class lre extends sn {
  constructor(e, t, r) {
    super(new Int16Array(e), t, r);
  }
}
class UC extends sn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r);
  }
}
class cre extends sn {
  constructor(e, t, r) {
    super(new Int32Array(e), t, r);
  }
}
class FC extends sn {
  constructor(e, t, r) {
    super(new Uint32Array(e), t, r);
  }
}
class ure extends sn {
  constructor(e, t, r) {
    super(new Uint16Array(e), t, r), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Of(this.array[e * this.itemSize]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize] = oi(t)),
      this
    );
  }
  getY(e) {
    let t = Of(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 1] = oi(t)),
      this
    );
  }
  getZ(e) {
    let t = Of(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 2] = oi(t)),
      this
    );
  }
  getW(e) {
    let t = Of(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.array[e * this.itemSize + 3] = oi(t)),
      this
    );
  }
  setXY(e, t, r) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Dt(t, this.array)), (r = Dt(r, this.array))),
      (this.array[e + 0] = oi(t)),
      (this.array[e + 1] = oi(r)),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array))),
      (this.array[e + 0] = oi(t)),
      (this.array[e + 1] = oi(r)),
      (this.array[e + 2] = oi(i)),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array)),
        (s = Dt(s, this.array))),
      (this.array[e + 0] = oi(t)),
      (this.array[e + 1] = oi(r)),
      (this.array[e + 2] = oi(i)),
      (this.array[e + 3] = oi(s)),
      this
    );
  }
}
class st extends sn {
  constructor(e, t, r) {
    super(new Float32Array(e), t, r);
  }
}
let dre = 0;
const Ki = new Tt(),
  p1 = new Xt(),
  Du = new z(),
  Ei = new Dr(),
  vf = new Dr(),
  sr = new z();
class kt extends wo {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: dre++ }),
      (this.uuid = Li()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.indirect = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (J4(e) ? FC : UC)(e, 1))
        : (this.index = e),
      this
    );
  }
  setIndirect(e) {
    return (this.indirect = e), this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, r = 0) {
    this.groups.push({ start: e, count: t, materialIndex: r });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const r = this.attributes.normal;
    if (r !== void 0) {
      const s = new Nt().getNormalMatrix(e);
      r.applyNormalMatrix(s), (r.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ki.makeRotationFromQuaternion(e), this.applyMatrix4(Ki), this;
  }
  rotateX(e) {
    return Ki.makeRotationX(e), this.applyMatrix4(Ki), this;
  }
  rotateY(e) {
    return Ki.makeRotationY(e), this.applyMatrix4(Ki), this;
  }
  rotateZ(e) {
    return Ki.makeRotationZ(e), this.applyMatrix4(Ki), this;
  }
  translate(e, t, r) {
    return Ki.makeTranslation(e, t, r), this.applyMatrix4(Ki), this;
  }
  scale(e, t, r) {
    return Ki.makeScale(e, t, r), this.applyMatrix4(Ki), this;
  }
  lookAt(e) {
    return p1.lookAt(e), p1.updateMatrix(), this.applyMatrix4(p1.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Du).negate(),
      this.translate(Du.x, Du.y, Du.z),
      this
    );
  }
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const r = [];
      for (let i = 0, s = e.length; i < s; i++) {
        const o = e[i];
        r.push(o.x, o.y, o.z || 0);
      }
      this.setAttribute("position", new st(r, 3));
    } else {
      const r = Math.min(e.length, t.count);
      for (let i = 0; i < r; i++) {
        const s = e[i];
        t.setXYZ(i, s.x, s.y, s.z || 0);
      }
      e.length > t.count &&
        console.warn(
          "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
        ),
        (t.needsUpdate = !0);
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Dr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new z(-1 / 0, -1 / 0, -1 / 0),
          new z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let r = 0, i = t.length; r < i; r++) {
          const s = t[r];
          Ei.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (sr.addVectors(this.boundingBox.min, Ei.min),
                this.boundingBox.expandByPoint(sr),
                sr.addVectors(this.boundingBox.max, Ei.max),
                this.boundingBox.expandByPoint(sr))
              : (this.boundingBox.expandByPoint(Ei.min),
                this.boundingBox.expandByPoint(Ei.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new gr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new z(), 1 / 0);
      return;
    }
    if (e) {
      const r = this.boundingSphere.center;
      if ((Ei.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          vf.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (sr.addVectors(Ei.min, vf.min),
                Ei.expandByPoint(sr),
                sr.addVectors(Ei.max, vf.max),
                Ei.expandByPoint(sr))
              : (Ei.expandByPoint(vf.min), Ei.expandByPoint(vf.max));
        }
      Ei.getCenter(r);
      let i = 0;
      for (let s = 0, o = e.count; s < o; s++)
        sr.fromBufferAttribute(e, s),
          (i = Math.max(i, r.distanceToSquared(sr)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = a.count; c < u; c++)
            sr.fromBufferAttribute(a, c),
              l && (Du.fromBufferAttribute(e, c), sr.add(Du)),
              (i = Math.max(i, r.distanceToSquared(sr)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const r = t.position,
      i = t.normal,
      s = t.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new sn(new Float32Array(4 * r.count), 4));
    const o = this.getAttribute("tangent"),
      a = [],
      l = [];
    for (let O = 0; O < r.count; O++) (a[O] = new z()), (l[O] = new z());
    const c = new z(),
      u = new z(),
      f = new z(),
      p = new xe(),
      m = new xe(),
      v = new xe(),
      y = new z(),
      x = new z();
    function g(O, I, N) {
      c.fromBufferAttribute(r, O),
        u.fromBufferAttribute(r, I),
        f.fromBufferAttribute(r, N),
        p.fromBufferAttribute(s, O),
        m.fromBufferAttribute(s, I),
        v.fromBufferAttribute(s, N),
        u.sub(c),
        f.sub(c),
        m.sub(p),
        v.sub(p);
      const D = 1 / (m.x * v.y - v.x * m.y);
      isFinite(D) &&
        (y
          .copy(u)
          .multiplyScalar(v.y)
          .addScaledVector(f, -m.y)
          .multiplyScalar(D),
        x
          .copy(f)
          .multiplyScalar(m.x)
          .addScaledVector(u, -v.x)
          .multiplyScalar(D),
        a[O].add(y),
        a[I].add(y),
        a[N].add(y),
        l[O].add(x),
        l[I].add(x),
        l[N].add(x));
    }
    let _ = this.groups;
    _.length === 0 && (_ = [{ start: 0, count: e.count }]);
    for (let O = 0, I = _.length; O < I; ++O) {
      const N = _[O],
        D = N.start,
        j = N.count;
      for (let $ = D, G = D + j; $ < G; $ += 3)
        g(e.getX($ + 0), e.getX($ + 1), e.getX($ + 2));
    }
    const S = new z(),
      b = new z(),
      C = new z(),
      A = new z();
    function R(O) {
      C.fromBufferAttribute(i, O), A.copy(C);
      const I = a[O];
      S.copy(I),
        S.sub(C.multiplyScalar(C.dot(I))).normalize(),
        b.crossVectors(A, I);
      const D = b.dot(l[O]) < 0 ? -1 : 1;
      o.setXYZW(O, S.x, S.y, S.z, D);
    }
    for (let O = 0, I = _.length; O < I; ++O) {
      const N = _[O],
        D = N.start,
        j = N.count;
      for (let $ = D, G = D + j; $ < G; $ += 3)
        R(e.getX($ + 0)), R(e.getX($ + 1)), R(e.getX($ + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let r = this.getAttribute("normal");
      if (r === void 0)
        (r = new sn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", r);
      else for (let p = 0, m = r.count; p < m; p++) r.setXYZ(p, 0, 0, 0);
      const i = new z(),
        s = new z(),
        o = new z(),
        a = new z(),
        l = new z(),
        c = new z(),
        u = new z(),
        f = new z();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const v = e.getX(p + 0),
            y = e.getX(p + 1),
            x = e.getX(p + 2);
          i.fromBufferAttribute(t, v),
            s.fromBufferAttribute(t, y),
            o.fromBufferAttribute(t, x),
            u.subVectors(o, s),
            f.subVectors(i, s),
            u.cross(f),
            a.fromBufferAttribute(r, v),
            l.fromBufferAttribute(r, y),
            c.fromBufferAttribute(r, x),
            a.add(u),
            l.add(u),
            c.add(u),
            r.setXYZ(v, a.x, a.y, a.z),
            r.setXYZ(y, l.x, l.y, l.z),
            r.setXYZ(x, c.x, c.y, c.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          i.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            u.subVectors(o, s),
            f.subVectors(i, s),
            u.cross(f),
            r.setXYZ(p + 0, u.x, u.y, u.z),
            r.setXYZ(p + 1, u.x, u.y, u.z),
            r.setXYZ(p + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (r.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, r = e.count; t < r; t++)
      sr.fromBufferAttribute(e, t),
        sr.normalize(),
        e.setXYZ(t, sr.x, sr.y, sr.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        u = a.itemSize,
        f = a.normalized,
        p = new c.constructor(l.length * u);
      let m = 0,
        v = 0;
      for (let y = 0, x = l.length; y < x; y++) {
        a.isInterleavedBufferAttribute
          ? (m = l[y] * a.data.stride + a.offset)
          : (m = l[y] * u);
        for (let g = 0; g < u; g++) p[v++] = c[m++];
      }
      return new sn(p, u, f);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new kt(),
      r = this.index.array,
      i = this.attributes;
    for (const a in i) {
      const l = i[a],
        c = e(l, r);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let u = 0, f = c.length; u < f; u++) {
        const p = c[u],
          m = e(p, r);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const r = this.attributes;
    for (const l in r) {
      const c = r[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let f = 0, p = c.length; f < p; f++) {
        const m = c[f];
        u.push(m.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = a.toJSON()), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const r = e.index;
    r !== null && this.setIndex(r.clone());
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        f = s[c];
      for (let p = 0, m = f.length; p < m; p++) u.push(f[p].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, u = o.length; c < u; c++) {
      const f = o[c];
      this.addGroup(f.start, f.count, f.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const QN = new Tt(),
  Vl = new Nh(),
  Ev = new gr(),
  eL = new z(),
  Tv = new z(),
  Mv = new z(),
  Cv = new z(),
  m1 = new z(),
  Av = new z(),
  tL = new z(),
  Rv = new z();
class $n extends Xt {
  constructor(e = new kt(), t = new Sl()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      (this.count = 1),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const r = this.geometry,
      i = r.attributes.position,
      s = r.morphAttributes.position,
      o = r.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Av.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = a[l],
          f = s[l];
        u !== 0 &&
          (m1.fromBufferAttribute(f, e),
          o ? Av.addScaledVector(m1, u) : Av.addScaledVector(m1.sub(t), u));
      }
      t.add(Av);
    }
    return t;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (r.boundingSphere === null && r.computeBoundingSphere(),
      Ev.copy(r.boundingSphere),
      Ev.applyMatrix4(s),
      Vl.copy(e.ray).recast(e.near),
      !(
        Ev.containsPoint(Vl.origin) === !1 &&
        (Vl.intersectSphere(Ev, eL) === null ||
          Vl.origin.distanceToSquared(eL) > (e.far - e.near) ** 2)
      ) &&
        (QN.copy(s).invert(),
        Vl.copy(e.ray).applyMatrix4(QN),
        !(r.boundingBox !== null && Vl.intersectsBox(r.boundingBox) === !1) &&
          this._computeIntersections(e, t, Vl)));
  }
  _computeIntersections(e, t, r) {
    let i;
    const s = this.geometry,
      o = this.material,
      a = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      f = s.attributes.normal,
      p = s.groups,
      m = s.drawRange;
    if (a !== null)
      if (Array.isArray(o))
        for (let v = 0, y = p.length; v < y; v++) {
          const x = p[v],
            g = o[x.materialIndex],
            _ = Math.max(x.start, m.start),
            S = Math.min(
              a.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let b = _, C = S; b < C; b += 3) {
            const A = a.getX(b),
              R = a.getX(b + 1),
              O = a.getX(b + 2);
            (i = Pv(this, g, e, r, c, u, f, A, R, O)),
              i &&
                ((i.faceIndex = Math.floor(b / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          y = Math.min(a.count, m.start + m.count);
        for (let x = v, g = y; x < g; x += 3) {
          const _ = a.getX(x),
            S = a.getX(x + 1),
            b = a.getX(x + 2);
          (i = Pv(this, o, e, r, c, u, f, _, S, b)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(o))
        for (let v = 0, y = p.length; v < y; v++) {
          const x = p[v],
            g = o[x.materialIndex],
            _ = Math.max(x.start, m.start),
            S = Math.min(
              l.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let b = _, C = S; b < C; b += 3) {
            const A = b,
              R = b + 1,
              O = b + 2;
            (i = Pv(this, g, e, r, c, u, f, A, R, O)),
              i &&
                ((i.faceIndex = Math.floor(b / 3)),
                (i.face.materialIndex = x.materialIndex),
                t.push(i));
          }
        }
      else {
        const v = Math.max(0, m.start),
          y = Math.min(l.count, m.start + m.count);
        for (let x = v, g = y; x < g; x += 3) {
          const _ = x,
            S = x + 1,
            b = x + 2;
          (i = Pv(this, o, e, r, c, u, f, _, S, b)),
            i && ((i.faceIndex = Math.floor(x / 3)), t.push(i));
        }
      }
  }
}
function hre(n, e, t, r, i, s, o, a) {
  let l;
  if (
    (e.side === Jr
      ? (l = r.intersectTriangle(o, s, i, !0, a))
      : (l = r.intersectTriangle(i, s, o, e.side === ra, a)),
    l === null)
  )
    return null;
  Rv.copy(a), Rv.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(Rv);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Rv.clone(), object: n };
}
function Pv(n, e, t, r, i, s, o, a, l, c) {
  n.getVertexPosition(a, Tv),
    n.getVertexPosition(l, Mv),
    n.getVertexPosition(c, Cv);
  const u = hre(n, e, t, r, Tv, Mv, Cv, tL);
  if (u) {
    const f = new z();
    ui.getBarycoord(tL, Tv, Mv, Cv, f),
      i && (u.uv = ui.getInterpolatedAttribute(i, a, l, c, f, new xe())),
      s && (u.uv1 = ui.getInterpolatedAttribute(s, a, l, c, f, new xe())),
      o &&
        ((u.normal = ui.getInterpolatedAttribute(o, a, l, c, f, new z())),
        u.normal.dot(r.direction) > 0 && u.normal.multiplyScalar(-1));
    const p = { a, b: l, c, normal: new z(), materialIndex: 0 };
    ui.getNormal(Tv, Mv, Cv, p.normal), (u.face = p), (u.barycoord = f);
  }
  return u;
}
class Qc extends kt {
  constructor(e = 1, t = 1, r = 1, i = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: r,
        widthSegments: i,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      c = [],
      u = [],
      f = [];
    let p = 0,
      m = 0;
    v("z", "y", "x", -1, -1, r, t, e, o, s, 0),
      v("z", "y", "x", 1, -1, r, t, -e, o, s, 1),
      v("x", "z", "y", 1, 1, e, r, t, i, o, 2),
      v("x", "z", "y", 1, -1, e, r, -t, i, o, 3),
      v("x", "y", "z", 1, -1, e, t, r, i, s, 4),
      v("x", "y", "z", -1, -1, e, t, -r, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new st(c, 3)),
      this.setAttribute("normal", new st(u, 3)),
      this.setAttribute("uv", new st(f, 2));
    function v(y, x, g, _, S, b, C, A, R, O, I) {
      const N = b / R,
        D = C / O,
        j = b / 2,
        $ = C / 2,
        G = A / 2,
        Z = R + 1,
        q = O + 1;
      let Y = 0,
        U = 0;
      const H = new z();
      for (let X = 0; X < q; X++) {
        const ie = X * D - $;
        for (let de = 0; de < Z; de++) {
          const Ee = de * N - j;
          (H[y] = Ee * _),
            (H[x] = ie * S),
            (H[g] = G),
            c.push(H.x, H.y, H.z),
            (H[y] = 0),
            (H[x] = 0),
            (H[g] = A > 0 ? 1 : -1),
            u.push(H.x, H.y, H.z),
            f.push(de / R),
            f.push(1 - X / O),
            (Y += 1);
        }
      }
      for (let X = 0; X < O; X++)
        for (let ie = 0; ie < R; ie++) {
          const de = p + ie + Z * X,
            Ee = p + ie + Z * (X + 1),
            Ie = p + (ie + 1) + Z * (X + 1),
            se = p + (ie + 1) + Z * X;
          l.push(de, Ee, se), l.push(Ee, Ie, se), (U += 6);
        }
      a.addGroup(m, U, I), (m += U), (p += Y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Qc(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function dh(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const r in n[t]) {
      const i = n[t][r];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][r] = null))
          : (e[t][r] = i.clone())
        : Array.isArray(i)
        ? (e[t][r] = i.slice())
        : (e[t][r] = i);
    }
  }
  return e;
}
function Hr(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = dh(n[t]);
    for (const i in r) e[i] = r[i];
  }
  return e;
}
function fre(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function tV(n) {
  const e = n.getRenderTarget();
  return e === null
    ? n.outputColorSpace
    : e.isXRRenderTarget === !0
    ? e.texture.colorSpace
    : Ht.workingColorSpace;
}
const nV = { clone: dh, merge: Hr };
var pre = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  mre = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
let cs = class extends Ur {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = pre),
      (this.fragmentShader = mre),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = dh(e.uniforms)),
      (this.uniformsGroups = fre(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const o = this.uniforms[i].value;
      o && o.isTexture
        ? (t.uniforms[i] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[i] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[i] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[i] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[i] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: o.toArray() })
        : (t.uniforms[i] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const r = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (r[i] = !0);
    return Object.keys(r).length > 0 && (t.extensions = r), t;
  }
};
class Tm extends Xt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Tt()),
      (this.projectionMatrix = new Tt()),
      (this.projectionMatrixInverse = new Tt()),
      (this.coordinateSystem = Pi),
      (this._reversedDepth = !1);
  }
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ca = new z(),
  nL = new xe(),
  rL = new xe();
class lr extends Tm {
  constructor(e = 50, t = 1, r = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = r),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = uh * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Pc * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return uh * 2 * Math.atan(Math.tan(Pc * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, r) {
    Ca.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      t.set(Ca.x, Ca.y).multiplyScalar(-e / Ca.z),
      Ca.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      r.set(Ca.x, Ca.y).multiplyScalar(-e / Ca.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, nL, rL), t.subVectors(rL, nL);
  }
  setViewOffset(e, t, r, i, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Pc * 0.5 * this.fov)) / this.zoom,
      r = 2 * t,
      i = this.aspect * r,
      s = -0.5 * i;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (s += (o.offsetX * i) / l),
        (t -= (o.offsetY * r) / c),
        (i *= o.width / l),
        (r *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + i,
        t,
        t - r,
        e,
        this.far,
        this.coordinateSystem,
        this.reversedDepth
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const ku = -90,
  Uu = 1;
class rV extends Xt {
  constructor(e, t, r) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = r),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const i = new lr(ku, Uu, e, t);
    (i.layers = this.layers), this.add(i);
    const s = new lr(ku, Uu, e, t);
    (s.layers = this.layers), this.add(s);
    const o = new lr(ku, Uu, e, t);
    (o.layers = this.layers), this.add(o);
    const a = new lr(ku, Uu, e, t);
    (a.layers = this.layers), this.add(a);
    const l = new lr(ku, Uu, e, t);
    (l.layers = this.layers), this.add(l);
    const c = new lr(ku, Uu, e, t);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [r, i, s, o, a, l] = t;
    for (const c of t) this.remove(c);
    if (e === Pi)
      r.up.set(0, 1, 0),
        r.lookAt(1, 0, 0),
        i.up.set(0, 1, 0),
        i.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, 1),
        o.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === ch)
      r.up.set(0, -1, 0),
        r.lookAt(-1, 0, 0),
        i.up.set(0, -1, 0),
        i.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        o.up.set(0, 0, -1),
        o.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of t) this.add(c), c.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: r, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, o, a, l, c, u] = this.children,
      f = e.getRenderTarget(),
      p = e.getActiveCubeFace(),
      m = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const y = r.texture.generateMipmaps;
    (r.texture.generateMipmaps = !1),
      e.setRenderTarget(r, 0, i),
      e.render(t, s),
      e.setRenderTarget(r, 1, i),
      e.render(t, o),
      e.setRenderTarget(r, 2, i),
      e.render(t, a),
      e.setRenderTarget(r, 3, i),
      e.render(t, l),
      e.setRenderTarget(r, 4, i),
      e.render(t, c),
      (r.texture.generateMipmaps = y),
      e.setRenderTarget(r, 5, i),
      e.render(t, u),
      e.setRenderTarget(f, p, m),
      (e.xr.enabled = v),
      (r.texture.needsPMREMUpdate = !0);
  }
}
class Mm extends Nn {
  constructor(e = [], t = ia, r, i, s, o, a, l, c, u) {
    super(e, t, r, i, s, o, a, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class iV extends xo {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const r = { width: e, height: e, depth: 1 },
      i = [r, r, r, r, r, r];
    (this.texture = new Mm(i)),
      this._setTextureOptions(t),
      (this.texture.isRenderTargetTexture = !0);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const r = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new Qc(5, 5, 5),
      s = new cs({
        name: "CubemapFromEquirect",
        uniforms: dh(r.uniforms),
        vertexShader: r.vertexShader,
        fragmentShader: r.fragmentShader,
        side: Jr,
        blending: Xo,
      });
    s.uniforms.tEquirect.value = t;
    const o = new $n(i, s),
      a = t.minFilter;
    return (
      t.minFilter === oo && (t.minFilter = Zn),
      new rV(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t = !0, r = !0, i = !0) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, r, i);
    e.setRenderTarget(s);
  }
}
class _d extends Xt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const gre = { type: "move" };
class Iy {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new _d()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new _d()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new _d()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new z())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, r) {
    let i = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const y of e.hand.values()) {
          const x = t.getJointPose(y, r),
            g = this._getHandJoint(c, y);
          x !== null &&
            (g.matrix.fromArray(x.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.matrixWorldNeedsUpdate = !0),
            (g.jointRadius = x.radius)),
            (g.visible = x !== null);
        }
        const u = c.joints["index-finger-tip"],
          f = c.joints["thumb-tip"],
          p = u.position.distanceTo(f.position),
          m = 0.02,
          v = 0.005;
        c.inputState.pinching && p > m + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            p <= m - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, r)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((i = t.getPose(e.targetRaySpace, r)),
        i === null && s !== null && (i = s),
        i !== null &&
          (a.matrix.fromArray(i.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(i.linearVelocity))
            : (a.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(i.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(gre)));
    }
    return (
      a !== null && (a.visible = i !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const r = new _d();
      (r.matrixAutoUpdate = !1),
        (r.visible = !1),
        (e.joints[t.jointName] = r),
        e.add(r);
    }
    return e.joints[t.jointName];
  }
}
class i_ {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Je(e)),
      (this.density = t);
  }
  clone() {
    return new i_(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class s_ {
  constructor(e, t = 1, r = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Je(e)),
      (this.near = t),
      (this.far = r);
  }
  clone() {
    return new s_(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class BC extends Xt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new Di()),
      (this.environmentIntensity = 1),
      (this.environmentRotation = new Di()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      (this.environmentIntensity = e.environmentIntensity),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      (t.object.backgroundRotation = this.backgroundRotation.toArray()),
      this.environmentIntensity !== 1 &&
        (t.object.environmentIntensity = this.environmentIntensity),
      (t.object.environmentRotation = this.environmentRotation.toArray()),
      t
    );
  }
}
class o_ {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Zp),
      (this.updateRanges = []),
      (this.version = 0),
      (this.uuid = Li());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, r) {
    (e *= this.stride), (r *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[r + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Li()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      r = new this.constructor(t, this.stride);
    return r.setUsage(this.usage), r;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Li()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Vr = new z();
class jc {
  constructor(e, t, r, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = r),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, r = this.data.count; t < r; t++)
      Vr.fromBufferAttribute(this, t),
        Vr.applyMatrix4(e),
        this.setXYZ(t, Vr.x, Vr.y, Vr.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Vr.fromBufferAttribute(this, t),
        Vr.applyNormalMatrix(e),
        this.setXYZ(t, Vr.x, Vr.y, Vr.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, r = this.count; t < r; t++)
      Vr.fromBufferAttribute(this, t),
        Vr.transformDirection(e),
        this.setXYZ(t, Vr.x, Vr.y, Vr.z);
    return this;
  }
  getComponent(e, t) {
    let r = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (r = qr(r, this.array)), r;
  }
  setComponent(e, t, r) {
    return (
      this.normalized && (r = Dt(r, this.array)),
      (this.data.array[e * this.data.stride + this.offset + t] = r),
      this
    );
  }
  setX(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = qr(t, this.array)), t;
  }
  setXY(e, t, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Dt(t, this.array)), (r = Dt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      this
    );
  }
  setXYZ(e, t, r, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, r, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Dt(t, this.array)),
        (r = Dt(r, this.array)),
        (i = Dt(i, this.array)),
        (s = Dt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = r),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new sn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new jc(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let r = 0; r < this.count; r++) {
        const i = r * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class zC extends Ur {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Fu;
const yf = new z(),
  Bu = new z(),
  zu = new z(),
  Vu = new xe(),
  xf = new xe(),
  sV = new Tt(),
  Iv = new z(),
  _f = new z(),
  Nv = new z(),
  iL = new xe(),
  g1 = new xe(),
  sL = new xe();
class oV extends Xt {
  constructor(e = new zC()) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Fu === void 0)
    ) {
      Fu = new kt();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        r = new o_(t, 5);
      Fu.setIndex([0, 1, 2, 0, 2, 3]),
        Fu.setAttribute("position", new jc(r, 3, 0, !1)),
        Fu.setAttribute("uv", new jc(r, 2, 3, !1));
    }
    (this.geometry = Fu),
      (this.material = e),
      (this.center = new xe(0.5, 0.5)),
      (this.count = 1);
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Bu.setFromMatrixScale(this.matrixWorld),
      sV.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      zu.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Bu.multiplyScalar(-zu.z);
    const r = this.material.rotation;
    let i, s;
    r !== 0 && ((s = Math.cos(r)), (i = Math.sin(r)));
    const o = this.center;
    Lv(Iv.set(-0.5, -0.5, 0), zu, o, Bu, i, s),
      Lv(_f.set(0.5, -0.5, 0), zu, o, Bu, i, s),
      Lv(Nv.set(0.5, 0.5, 0), zu, o, Bu, i, s),
      iL.set(0, 0),
      g1.set(1, 0),
      sL.set(1, 1);
    let a = e.ray.intersectTriangle(Iv, _f, Nv, !1, yf);
    if (
      a === null &&
      (Lv(_f.set(-0.5, 0.5, 0), zu, o, Bu, i, s),
      g1.set(0, 1),
      (a = e.ray.intersectTriangle(Iv, Nv, _f, !1, yf)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(yf);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: yf.clone(),
        uv: ui.getInterpolation(yf, Iv, _f, Nv, iL, g1, sL, new xe()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Lv(n, e, t, r, i, s) {
  Vu.subVectors(n, t).addScalar(0.5).multiply(r),
    i !== void 0
      ? ((xf.x = s * Vu.x - i * Vu.y), (xf.y = i * Vu.x + s * Vu.y))
      : xf.copy(Vu),
    n.copy(e),
    (n.x += xf.x),
    (n.y += xf.y),
    n.applyMatrix4(sV);
}
const Ov = new z(),
  oL = new z();
class aV extends Xt {
  constructor() {
    super(),
      (this.isLOD = !0),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = t[r];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, r = 0) {
    t = Math.abs(t);
    const i = this.levels;
    let s;
    for (s = 0; s < i.length && !(t < i[s].distance); s++);
    return (
      i.splice(s, 0, { distance: t, hysteresis: r, object: e }),
      this.add(e),
      this
    );
  }
  removeLevel(e) {
    const t = this.levels;
    for (let r = 0; r < t.length; r++)
      if (t[r].distance === e) {
        const i = t.splice(r, 1);
        return this.remove(i[0].object), !0;
      }
    return !1;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let r, i;
      for (r = 1, i = t.length; r < i; r++) {
        let s = t[r].distance;
        if ((t[r].object.visible && (s -= s * t[r].hysteresis), e < s)) break;
      }
      return t[r - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Ov.setFromMatrixPosition(this.matrixWorld);
      const i = e.ray.origin.distanceTo(Ov);
      this.getObjectForDistance(i).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Ov.setFromMatrixPosition(e.matrixWorld),
        oL.setFromMatrixPosition(this.matrixWorld);
      const r = Ov.distanceTo(oL) / e.zoom;
      t[0].object.visible = !0;
      let i, s;
      for (i = 1, s = t.length; i < s; i++) {
        let o = t[i].distance;
        if ((t[i].object.visible && (o -= o * t[i].hysteresis), r >= o))
          (t[i - 1].object.visible = !1), (t[i].object.visible = !0);
        else break;
      }
      for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const r = this.levels;
    for (let i = 0, s = r.length; i < s; i++) {
      const o = r[i];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const aL = new z(),
  lL = new Gt(),
  cL = new Gt(),
  vre = new z(),
  uL = new Tt(),
  Dv = new z(),
  v1 = new gr(),
  dL = new Tt(),
  y1 = new Nh();
class lV extends $n {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = jE),
      (this.bindMatrix = new Tt()),
      (this.bindMatrixInverse = new Tt()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Dr()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Dv), this.boundingBox.expandByPoint(Dv);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new gr()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let r = 0; r < t.count; r++)
      this.getVertexPosition(r, Dv), this.boundingSphere.expandByPoint(Dv);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const r = this.material,
      i = this.matrixWorld;
    r !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      v1.copy(this.boundingSphere),
      v1.applyMatrix4(i),
      e.ray.intersectsSphere(v1) !== !1 &&
        (dL.copy(i).invert(),
        y1.copy(e.ray).applyMatrix4(dL),
        !(
          this.boundingBox !== null && y1.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, t, y1)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Gt(),
      t = this.geometry.attributes.skinWeight;
    for (let r = 0, i = t.count; r < i; r++) {
      e.fromBufferAttribute(t, r);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(r, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === jE
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === U4
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const r = this.skeleton,
      i = this.geometry;
    lL.fromBufferAttribute(i.attributes.skinIndex, e),
      cL.fromBufferAttribute(i.attributes.skinWeight, e),
      aL.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = cL.getComponent(s);
      if (o !== 0) {
        const a = lL.getComponent(s);
        uL.multiplyMatrices(r.bones[a].matrixWorld, r.boneInverses[a]),
          t.addScaledVector(vre.copy(aL).applyMatrix4(uL), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class VC extends Xt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class vo extends Nn {
  constructor(e = null, t = 1, r = 1, i, s, o, a, l, c = mr, u = mr, f, p) {
    super(null, o, a, l, c, u, i, s, f, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: r }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const hL = new Tt(),
  yre = new Tt();
class a_ {
  constructor(e = [], t = []) {
    (this.uuid = Li()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let r = 0, i = this.bones.length; r < i; r++)
        this.boneInverses.push(new Tt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = new Tt();
      this.bones[e] && r.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(r);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r && r.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const r = this.bones[e];
      r &&
        (r.parent && r.parent.isBone
          ? (r.matrix.copy(r.parent.matrixWorld).invert(),
            r.matrix.multiply(r.matrixWorld))
          : r.matrix.copy(r.matrixWorld),
        r.matrix.decompose(r.position, r.quaternion, r.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      r = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : yre;
      hL.multiplyMatrices(a, t[s]), hL.toArray(r, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new a_(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const r = new vo(t, e, e, Or, fi);
    return (
      (r.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = r),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, r = this.bones.length; t < r; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let r = 0, i = e.bones.length; r < i; r++) {
      const s = e.bones[r];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new VC())),
        this.bones.push(o),
        this.boneInverses.push(new Tt().fromArray(e.boneInverses[r]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      r = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const o = t[i];
      e.bones.push(o.uuid);
      const a = r[i];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class hh extends sn {
  constructor(e, t, r, i = 1) {
    super(e, t, r),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ju = new Tt(),
  fL = new Tt(),
  kv = [],
  pL = new Dr(),
  xre = new Tt(),
  wf = new $n(),
  Sf = new gr();
class cV extends $n {
  constructor(e, t, r) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new hh(new Float32Array(r * 16), 16)),
      (this.instanceColor = null),
      (this.morphTexture = null),
      (this.count = r),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < r; i++) this.setMatrixAt(i, xre);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Dr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, ju),
        pL.copy(e.boundingBox).applyMatrix4(ju),
        this.boundingBox.union(pL);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new gr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let r = 0; r < t; r++)
      this.getMatrixAt(r, ju),
        Sf.copy(e.boundingSphere).applyMatrix4(ju),
        this.boundingSphere.union(Sf);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  getMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = this.morphTexture.source.data.data,
      s = r.length + 1,
      o = e * s + 1;
    for (let a = 0; a < r.length; a++) r[a] = i[o + a];
  }
  raycast(e, t) {
    const r = this.matrixWorld,
      i = this.count;
    if (
      ((wf.geometry = this.geometry),
      (wf.material = this.material),
      wf.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Sf.copy(this.boundingSphere),
        Sf.applyMatrix4(r),
        e.ray.intersectsSphere(Sf) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, ju),
          fL.multiplyMatrices(r, ju),
          (wf.matrixWorld = fL),
          wf.raycast(e, kv);
        for (let o = 0, a = kv.length; o < a; o++) {
          const l = kv[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        kv.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new hh(
        new Float32Array(this.instanceMatrix.count * 3).fill(1),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  setMorphAt(e, t) {
    const r = t.morphTargetInfluences,
      i = r.length + 1;
    this.morphTexture === null &&
      (this.morphTexture = new vo(
        new Float32Array(i * this.count),
        i,
        this.count,
        Zx,
        fi
      ));
    const s = this.morphTexture.source.data.data;
    let o = 0;
    for (let c = 0; c < r.length; c++) o += r[c];
    const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
      l = i * e;
    (s[l] = a), s.set(r, l + 1);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" }),
      this.morphTexture !== null &&
        (this.morphTexture.dispose(), (this.morphTexture = null));
  }
}
const x1 = new z(),
  _re = new z(),
  wre = new Nt();
class Ua {
  constructor(e = new z(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, r, i) {
    return this.normal.set(e, t, r), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, r) {
    const i = x1.subVectors(r, t).cross(_re.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const r = e.delta(x1),
      i = this.normal.dot(r);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(r, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      r = this.distanceToPoint(e.end);
    return (t < 0 && r > 0) || (r < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const r = t || wre.getNormalMatrix(e),
      i = this.coplanarPoint(x1).applyMatrix4(e),
      s = this.normal.applyMatrix3(r).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const jl = new gr(),
  Sre = new xe(0.5, 0.5),
  Uv = new z();
class Lh {
  constructor(
    e = new Ua(),
    t = new Ua(),
    r = new Ua(),
    i = new Ua(),
    s = new Ua(),
    o = new Ua()
  ) {
    this.planes = [e, t, r, i, s, o];
  }
  set(e, t, r, i, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(r),
      a[3].copy(i),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
    return this;
  }
  setFromProjectionMatrix(e, t = Pi, r = !1) {
    const i = this.planes,
      s = e.elements,
      o = s[0],
      a = s[1],
      l = s[2],
      c = s[3],
      u = s[4],
      f = s[5],
      p = s[6],
      m = s[7],
      v = s[8],
      y = s[9],
      x = s[10],
      g = s[11],
      _ = s[12],
      S = s[13],
      b = s[14],
      C = s[15];
    if (
      (i[0].setComponents(c - o, m - u, g - v, C - _).normalize(),
      i[1].setComponents(c + o, m + u, g + v, C + _).normalize(),
      i[2].setComponents(c + a, m + f, g + y, C + S).normalize(),
      i[3].setComponents(c - a, m - f, g - y, C - S).normalize(),
      r)
    )
      i[4].setComponents(l, p, x, b).normalize(),
        i[5].setComponents(c - l, m - p, g - x, C - b).normalize();
    else if (
      (i[4].setComponents(c - l, m - p, g - x, C - b).normalize(), t === Pi)
    )
      i[5].setComponents(c + l, m + p, g + x, C + b).normalize();
    else if (t === ch) i[5].setComponents(l, p, x, b).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          t
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        jl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        jl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(jl);
  }
  intersectsSprite(e) {
    jl.center.set(0, 0, 0);
    const t = Sre.distanceTo(e.center);
    return (
      (jl.radius = 0.7071067811865476 + t),
      jl.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(jl)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      r = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(r) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) {
      const i = t[r];
      if (
        ((Uv.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Uv.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Uv.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Uv) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Js = new Tt(),
  Zs = new Lh();
class l_ {
  constructor() {
    this.coordinateSystem = Pi;
  }
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const i = t.cameras[r];
      if (
        (Js.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        Zs.setFromProjectionMatrix(Js, i.coordinateSystem, i.reversedDepth),
        Zs.intersectsObject(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const i = t.cameras[r];
      if (
        (Js.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        Zs.setFromProjectionMatrix(Js, i.coordinateSystem, i.reversedDepth),
        Zs.intersectsSprite(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const i = t.cameras[r];
      if (
        (Js.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        Zs.setFromProjectionMatrix(Js, i.coordinateSystem, i.reversedDepth),
        Zs.intersectsSphere(e))
      )
        return !0;
    }
    return !1;
  }
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const i = t.cameras[r];
      if (
        (Js.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        Zs.setFromProjectionMatrix(Js, i.coordinateSystem, i.reversedDepth),
        Zs.intersectsBox(e))
      )
        return !0;
    }
    return !1;
  }
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0) return !1;
    for (let r = 0; r < t.cameras.length; r++) {
      const i = t.cameras[r];
      if (
        (Js.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
        Zs.setFromProjectionMatrix(Js, i.coordinateSystem, i.reversedDepth),
        Zs.containsPoint(e))
      )
        return !0;
    }
    return !1;
  }
  clone() {
    return new l_();
  }
}
function _1(n, e) {
  return n - e;
}
function bre(n, e) {
  return n.z - e.z;
}
function Ere(n, e) {
  return e.z - n.z;
}
class Tre {
  constructor() {
    (this.index = 0), (this.pool = []), (this.list = []);
  }
  push(e, t, r, i) {
    const s = this.pool,
      o = this.list;
    this.index >= s.length &&
      s.push({ start: -1, count: -1, z: -1, index: -1 });
    const a = s[this.index];
    o.push(a),
      this.index++,
      (a.start = e),
      (a.count = t),
      (a.z = r),
      (a.index = i);
  }
  reset() {
    (this.list.length = 0), (this.index = 0);
  }
}
const si = new Tt(),
  Mre = new Je(1, 1, 1),
  mL = new Lh(),
  Cre = new l_(),
  Fv = new Dr(),
  Hl = new gr(),
  bf = new z(),
  gL = new z(),
  Are = new z(),
  w1 = new Tre(),
  Pr = new $n(),
  Bv = [];
function Rre(n, e, t = 0) {
  const r = e.itemSize;
  if (
    n.isInterleavedBufferAttribute ||
    n.array.constructor !== e.array.constructor
  ) {
    const i = n.count;
    for (let s = 0; s < i; s++)
      for (let o = 0; o < r; o++)
        e.setComponent(s + t, o, n.getComponent(s, o));
  } else e.array.set(n.array, t * r);
  e.needsUpdate = !0;
}
function Wl(n, e) {
  if (n.constructor !== e.constructor) {
    const t = Math.min(n.length, e.length);
    for (let r = 0; r < t; r++) e[r] = n[r];
  } else {
    const t = Math.min(n.length, e.length);
    e.set(new n.constructor(n.buffer, 0, t));
  }
}
class uV extends $n {
  constructor(e, t, r = t * 2, i) {
    super(new kt(), i),
      (this.isBatchedMesh = !0),
      (this.perObjectFrustumCulled = !0),
      (this.sortObjects = !0),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.customSort = null),
      (this._instanceInfo = []),
      (this._geometryInfo = []),
      (this._availableInstanceIds = []),
      (this._availableGeometryIds = []),
      (this._nextIndexStart = 0),
      (this._nextVertexStart = 0),
      (this._geometryCount = 0),
      (this._visibilityChanged = !0),
      (this._geometryInitialized = !1),
      (this._maxInstanceCount = e),
      (this._maxVertexCount = t),
      (this._maxIndexCount = r),
      (this._multiDrawCounts = new Int32Array(e)),
      (this._multiDrawStarts = new Int32Array(e)),
      (this._multiDrawCount = 0),
      (this._multiDrawInstances = null),
      (this._matricesTexture = null),
      (this._indirectTexture = null),
      (this._colorsTexture = null),
      this._initMatricesTexture(),
      this._initIndirectTexture();
  }
  get maxInstanceCount() {
    return this._maxInstanceCount;
  }
  get instanceCount() {
    return this._instanceInfo.length - this._availableInstanceIds.length;
  }
  get unusedVertexCount() {
    return this._maxVertexCount - this._nextVertexStart;
  }
  get unusedIndexCount() {
    return this._maxIndexCount - this._nextIndexStart;
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxInstanceCount * 4);
    (e = Math.ceil(e / 4) * 4), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4),
      r = new vo(t, e, e, Or, fi);
    this._matricesTexture = r;
  }
  _initIndirectTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Uint32Array(e * e),
      r = new vo(t, e, e, Em, sa);
    this._indirectTexture = r;
  }
  _initColorsTexture() {
    let e = Math.sqrt(this._maxInstanceCount);
    e = Math.ceil(e);
    const t = new Float32Array(e * e * 4).fill(1),
      r = new vo(t, e, e, Or, fi);
    (r.colorSpace = Ht.workingColorSpace), (this._colorsTexture = r);
  }
  _initializeGeometry(e) {
    const t = this.geometry,
      r = this._maxVertexCount,
      i = this._maxIndexCount;
    if (this._geometryInitialized === !1) {
      for (const s in e.attributes) {
        const o = e.getAttribute(s),
          { array: a, itemSize: l, normalized: c } = o,
          u = new a.constructor(r * l),
          f = new sn(u, l, c);
        t.setAttribute(s, f);
      }
      if (e.getIndex() !== null) {
        const s = r > 65535 ? new Uint32Array(i) : new Uint16Array(i);
        t.setIndex(new sn(s, 1));
      }
      this._geometryInitialized = !0;
    }
  }
  _validateGeometry(e) {
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex())
      throw new Error(
        'THREE.BatchedMesh: All geometries must consistently have "index".'
      );
    for (const r in t.attributes) {
      if (!e.hasAttribute(r))
        throw new Error(
          `THREE.BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`
        );
      const i = e.getAttribute(r),
        s = t.getAttribute(r);
      if (i.itemSize !== s.itemSize || i.normalized !== s.normalized)
        throw new Error(
          "THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value."
        );
    }
  }
  validateInstanceId(e) {
    const t = this._instanceInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`
      );
  }
  validateGeometryId(e) {
    const t = this._geometryInfo;
    if (e < 0 || e >= t.length || t[e].active === !1)
      throw new Error(
        `THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`
      );
  }
  setCustomSort(e) {
    return (this.customSort = e), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Dr());
    const e = this.boundingBox,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const s = t[r].geometryIndex;
      this.getMatrixAt(r, si),
        this.getBoundingBoxAt(s, Fv).applyMatrix4(si),
        e.union(Fv);
    }
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new gr());
    const e = this.boundingSphere,
      t = this._instanceInfo;
    e.makeEmpty();
    for (let r = 0, i = t.length; r < i; r++) {
      if (t[r].active === !1) continue;
      const s = t[r].geometryIndex;
      this.getMatrixAt(r, si),
        this.getBoundingSphereAt(s, Hl).applyMatrix4(si),
        e.union(Hl);
    }
  }
  addInstance(e) {
    if (
      this._instanceInfo.length >= this.maxInstanceCount &&
      this._availableInstanceIds.length === 0
    )
      throw new Error("THREE.BatchedMesh: Maximum item count reached.");
    const r = { visible: !0, active: !0, geometryIndex: e };
    let i = null;
    this._availableInstanceIds.length > 0
      ? (this._availableInstanceIds.sort(_1),
        (i = this._availableInstanceIds.shift()),
        (this._instanceInfo[i] = r))
      : ((i = this._instanceInfo.length), this._instanceInfo.push(r));
    const s = this._matricesTexture;
    si.identity().toArray(s.image.data, i * 16), (s.needsUpdate = !0);
    const o = this._colorsTexture;
    return (
      o && (Mre.toArray(o.image.data, i * 4), (o.needsUpdate = !0)),
      (this._visibilityChanged = !0),
      i
    );
  }
  addGeometry(e, t = -1, r = -1) {
    this._initializeGeometry(e), this._validateGeometry(e);
    const i = {
        vertexStart: -1,
        vertexCount: -1,
        reservedVertexCount: -1,
        indexStart: -1,
        indexCount: -1,
        reservedIndexCount: -1,
        start: -1,
        count: -1,
        boundingBox: null,
        boundingSphere: null,
        active: !0,
      },
      s = this._geometryInfo;
    (i.vertexStart = this._nextVertexStart),
      (i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t);
    const o = e.getIndex();
    if (
      (o !== null &&
        ((i.indexStart = this._nextIndexStart),
        (i.reservedIndexCount = r === -1 ? o.count : r)),
      (i.indexStart !== -1 &&
        i.indexStart + i.reservedIndexCount > this._maxIndexCount) ||
        i.vertexStart + i.reservedVertexCount > this._maxVertexCount)
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size."
      );
    let l;
    return (
      this._availableGeometryIds.length > 0
        ? (this._availableGeometryIds.sort(_1),
          (l = this._availableGeometryIds.shift()),
          (s[l] = i))
        : ((l = this._geometryCount), this._geometryCount++, s.push(i)),
      this.setGeometryAt(l, e),
      (this._nextIndexStart = i.indexStart + i.reservedIndexCount),
      (this._nextVertexStart = i.vertexStart + i.reservedVertexCount),
      l
    );
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount)
      throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const r = this.geometry,
      i = r.getIndex() !== null,
      s = r.getIndex(),
      o = t.getIndex(),
      a = this._geometryInfo[e];
    if (
      (i && o.count > a.reservedIndexCount) ||
      t.attributes.position.count > a.reservedVertexCount
    )
      throw new Error(
        "THREE.BatchedMesh: Reserved space not large enough for provided geometry."
      );
    const l = a.vertexStart,
      c = a.reservedVertexCount;
    a.vertexCount = t.getAttribute("position").count;
    for (const u in r.attributes) {
      const f = t.getAttribute(u),
        p = r.getAttribute(u);
      Rre(f, p, l);
      const m = f.itemSize;
      for (let v = f.count, y = c; v < y; v++) {
        const x = l + v;
        for (let g = 0; g < m; g++) p.setComponent(x, g, 0);
      }
      (p.needsUpdate = !0), p.addUpdateRange(l * m, c * m);
    }
    if (i) {
      const u = a.indexStart,
        f = a.reservedIndexCount;
      a.indexCount = t.getIndex().count;
      for (let p = 0; p < o.count; p++) s.setX(u + p, l + o.getX(p));
      for (let p = o.count, m = f; p < m; p++) s.setX(u + p, l);
      (s.needsUpdate = !0), s.addUpdateRange(u, a.reservedIndexCount);
    }
    return (
      (a.start = i ? a.indexStart : a.vertexStart),
      (a.count = i ? a.indexCount : a.vertexCount),
      (a.boundingBox = null),
      t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()),
      (a.boundingSphere = null),
      t.boundingSphere !== null &&
        (a.boundingSphere = t.boundingSphere.clone()),
      (this._visibilityChanged = !0),
      e
    );
  }
  deleteGeometry(e) {
    const t = this._geometryInfo;
    if (e >= t.length || t[e].active === !1) return this;
    const r = this._instanceInfo;
    for (let i = 0, s = r.length; i < s; i++)
      r[i].active && r[i].geometryIndex === e && this.deleteInstance(i);
    return (
      (t[e].active = !1),
      this._availableGeometryIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  deleteInstance(e) {
    return (
      this.validateInstanceId(e),
      (this._instanceInfo[e].active = !1),
      this._availableInstanceIds.push(e),
      (this._visibilityChanged = !0),
      this
    );
  }
  optimize() {
    let e = 0,
      t = 0;
    const r = this._geometryInfo,
      i = r
        .map((o, a) => a)
        .sort((o, a) => r[o].vertexStart - r[a].vertexStart),
      s = this.geometry;
    for (let o = 0, a = r.length; o < a; o++) {
      const l = i[o],
        c = r[l];
      if (c.active !== !1) {
        if (s.index !== null) {
          if (c.indexStart !== t) {
            const { indexStart: u, vertexStart: f, reservedIndexCount: p } = c,
              m = s.index,
              v = m.array,
              y = e - f;
            for (let x = u; x < u + p; x++) v[x] = v[x] + y;
            m.array.copyWithin(t, u, u + p),
              m.addUpdateRange(t, p),
              (c.indexStart = t);
          }
          t += c.reservedIndexCount;
        }
        if (c.vertexStart !== e) {
          const { vertexStart: u, reservedVertexCount: f } = c,
            p = s.attributes;
          for (const m in p) {
            const v = p[m],
              { array: y, itemSize: x } = v;
            y.copyWithin(e * x, u * x, (u + f) * x),
              v.addUpdateRange(e * x, f * x);
          }
          c.vertexStart = e;
        }
        (e += c.reservedVertexCount),
          (c.start = s.index ? c.indexStart : c.vertexStart),
          (this._nextIndexStart = s.index
            ? c.indexStart + c.reservedIndexCount
            : 0),
          (this._nextVertexStart = c.vertexStart + c.reservedVertexCount);
      }
    }
    return this;
  }
  getBoundingBoxAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingBox === null) {
      const s = new Dr(),
        o = r.index,
        a = r.attributes.position;
      for (let l = i.start, c = i.start + i.count; l < c; l++) {
        let u = l;
        o && (u = o.getX(u)), s.expandByPoint(bf.fromBufferAttribute(a, u));
      }
      i.boundingBox = s;
    }
    return t.copy(i.boundingBox), t;
  }
  getBoundingSphereAt(e, t) {
    if (e >= this._geometryCount) return null;
    const r = this.geometry,
      i = this._geometryInfo[e];
    if (i.boundingSphere === null) {
      const s = new gr();
      this.getBoundingBoxAt(e, Fv), Fv.getCenter(s.center);
      const o = r.index,
        a = r.attributes.position;
      let l = 0;
      for (let c = i.start, u = i.start + i.count; c < u; c++) {
        let f = c;
        o && (f = o.getX(f)),
          bf.fromBufferAttribute(a, f),
          (l = Math.max(l, s.center.distanceToSquared(bf)));
      }
      (s.radius = Math.sqrt(l)), (i.boundingSphere = s);
    }
    return t.copy(i.boundingSphere), t;
  }
  setMatrixAt(e, t) {
    this.validateInstanceId(e);
    const r = this._matricesTexture,
      i = this._matricesTexture.image.data;
    return t.toArray(i, e * 16), (r.needsUpdate = !0), this;
  }
  getMatrixAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._matricesTexture.image.data, e * 16)
    );
  }
  setColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._colorsTexture === null && this._initColorsTexture(),
      t.toArray(this._colorsTexture.image.data, e * 4),
      (this._colorsTexture.needsUpdate = !0),
      this
    );
  }
  getColorAt(e, t) {
    return (
      this.validateInstanceId(e),
      t.fromArray(this._colorsTexture.image.data, e * 4)
    );
  }
  setVisibleAt(e, t) {
    return (
      this.validateInstanceId(e),
      this._instanceInfo[e].visible === t
        ? this
        : ((this._instanceInfo[e].visible = t),
          (this._visibilityChanged = !0),
          this)
    );
  }
  getVisibleAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].visible;
  }
  setGeometryIdAt(e, t) {
    return (
      this.validateInstanceId(e),
      this.validateGeometryId(t),
      (this._instanceInfo[e].geometryIndex = t),
      this
    );
  }
  getGeometryIdAt(e) {
    return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex;
  }
  getGeometryRangeAt(e, t = {}) {
    this.validateGeometryId(e);
    const r = this._geometryInfo[e];
    return (
      (t.vertexStart = r.vertexStart),
      (t.vertexCount = r.vertexCount),
      (t.reservedVertexCount = r.reservedVertexCount),
      (t.indexStart = r.indexStart),
      (t.indexCount = r.indexCount),
      (t.reservedIndexCount = r.reservedIndexCount),
      (t.start = r.start),
      (t.count = r.count),
      t
    );
  }
  setInstanceCount(e) {
    const t = this._availableInstanceIds,
      r = this._instanceInfo;
    for (t.sort(_1); t[t.length - 1] === r.length - 1; ) r.pop(), t.pop();
    if (e < r.length)
      throw new Error(
        `BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`
      );
    const i = new Int32Array(e),
      s = new Int32Array(e);
    Wl(this._multiDrawCounts, i),
      Wl(this._multiDrawStarts, s),
      (this._multiDrawCounts = i),
      (this._multiDrawStarts = s),
      (this._maxInstanceCount = e);
    const o = this._indirectTexture,
      a = this._matricesTexture,
      l = this._colorsTexture;
    o.dispose(),
      this._initIndirectTexture(),
      Wl(o.image.data, this._indirectTexture.image.data),
      a.dispose(),
      this._initMatricesTexture(),
      Wl(a.image.data, this._matricesTexture.image.data),
      l &&
        (l.dispose(),
        this._initColorsTexture(),
        Wl(l.image.data, this._colorsTexture.image.data));
  }
  setGeometrySize(e, t) {
    const r = [...this._geometryInfo].filter((a) => a.active);
    if (Math.max(...r.map((a) => a.vertexStart + a.reservedVertexCount)) > e)
      throw new Error(
        `BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`
      );
    if (
      this.geometry.index &&
      Math.max(...r.map((l) => l.indexStart + l.reservedIndexCount)) > t
    )
      throw new Error(
        `BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`
      );
    const s = this.geometry;
    s.dispose(),
      (this._maxVertexCount = e),
      (this._maxIndexCount = t),
      this._geometryInitialized &&
        ((this._geometryInitialized = !1),
        (this.geometry = new kt()),
        this._initializeGeometry(s));
    const o = this.geometry;
    s.index && Wl(s.index.array, o.index.array);
    for (const a in s.attributes)
      Wl(s.attributes[a].array, o.attributes[a].array);
  }
  raycast(e, t) {
    const r = this._instanceInfo,
      i = this._geometryInfo,
      s = this.matrixWorld,
      o = this.geometry;
    (Pr.material = this.material),
      (Pr.geometry.index = o.index),
      (Pr.geometry.attributes = o.attributes),
      Pr.geometry.boundingBox === null && (Pr.geometry.boundingBox = new Dr()),
      Pr.geometry.boundingSphere === null &&
        (Pr.geometry.boundingSphere = new gr());
    for (let a = 0, l = r.length; a < l; a++) {
      if (!r[a].visible || !r[a].active) continue;
      const c = r[a].geometryIndex,
        u = i[c];
      Pr.geometry.setDrawRange(u.start, u.count),
        this.getMatrixAt(a, Pr.matrixWorld).premultiply(s),
        this.getBoundingBoxAt(c, Pr.geometry.boundingBox),
        this.getBoundingSphereAt(c, Pr.geometry.boundingSphere),
        Pr.raycast(e, Bv);
      for (let f = 0, p = Bv.length; f < p; f++) {
        const m = Bv[f];
        (m.object = this), (m.batchId = a), t.push(m);
      }
      Bv.length = 0;
    }
    (Pr.material = null),
      (Pr.geometry.index = null),
      (Pr.geometry.attributes = {}),
      Pr.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.geometry = e.geometry.clone()),
      (this.perObjectFrustumCulled = e.perObjectFrustumCulled),
      (this.sortObjects = e.sortObjects),
      (this.boundingBox =
        e.boundingBox !== null ? e.boundingBox.clone() : null),
      (this.boundingSphere =
        e.boundingSphere !== null ? e.boundingSphere.clone() : null),
      (this._geometryInfo = e._geometryInfo.map((t) => ({
        ...t,
        boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
        boundingSphere:
          t.boundingSphere !== null ? t.boundingSphere.clone() : null,
      }))),
      (this._instanceInfo = e._instanceInfo.map((t) => ({ ...t }))),
      (this._availableInstanceIds = e._availableInstanceIds.slice()),
      (this._availableGeometryIds = e._availableGeometryIds.slice()),
      (this._nextIndexStart = e._nextIndexStart),
      (this._nextVertexStart = e._nextVertexStart),
      (this._geometryCount = e._geometryCount),
      (this._maxInstanceCount = e._maxInstanceCount),
      (this._maxVertexCount = e._maxVertexCount),
      (this._maxIndexCount = e._maxIndexCount),
      (this._geometryInitialized = e._geometryInitialized),
      (this._multiDrawCounts = e._multiDrawCounts.slice()),
      (this._multiDrawStarts = e._multiDrawStarts.slice()),
      (this._indirectTexture = e._indirectTexture.clone()),
      (this._indirectTexture.image.data =
        this._indirectTexture.image.data.slice()),
      (this._matricesTexture = e._matricesTexture.clone()),
      (this._matricesTexture.image.data =
        this._matricesTexture.image.data.slice()),
      this._colorsTexture !== null &&
        ((this._colorsTexture = e._colorsTexture.clone()),
        (this._colorsTexture.image.data =
          this._colorsTexture.image.data.slice())),
      this
    );
  }
  dispose() {
    this.geometry.dispose(),
      this._matricesTexture.dispose(),
      (this._matricesTexture = null),
      this._indirectTexture.dispose(),
      (this._indirectTexture = null),
      this._colorsTexture !== null &&
        (this._colorsTexture.dispose(), (this._colorsTexture = null));
  }
  onBeforeRender(e, t, r, i, s) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    )
      return;
    const o = i.getIndex(),
      a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
      l = this._instanceInfo,
      c = this._multiDrawStarts,
      u = this._multiDrawCounts,
      f = this._geometryInfo,
      p = this.perObjectFrustumCulled,
      m = this._indirectTexture,
      v = m.image.data,
      y = r.isArrayCamera ? Cre : mL;
    p &&
      !r.isArrayCamera &&
      (si
        .multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse)
        .multiply(this.matrixWorld),
      mL.setFromProjectionMatrix(si, r.coordinateSystem, r.reversedDepth));
    let x = 0;
    if (this.sortObjects) {
      si.copy(this.matrixWorld).invert(),
        bf.setFromMatrixPosition(r.matrixWorld).applyMatrix4(si),
        gL
          .set(0, 0, -1)
          .transformDirection(r.matrixWorld)
          .transformDirection(si);
      for (let S = 0, b = l.length; S < b; S++)
        if (l[S].visible && l[S].active) {
          const C = l[S].geometryIndex;
          this.getMatrixAt(S, si),
            this.getBoundingSphereAt(C, Hl).applyMatrix4(si);
          let A = !1;
          if ((p && (A = !y.intersectsSphere(Hl, r)), !A)) {
            const R = f[C],
              O = Are.subVectors(Hl.center, bf).dot(gL);
            w1.push(R.start, R.count, O, S);
          }
        }
      const g = w1.list,
        _ = this.customSort;
      _ === null ? g.sort(s.transparent ? Ere : bre) : _.call(this, g, r);
      for (let S = 0, b = g.length; S < b; S++) {
        const C = g[S];
        (c[x] = C.start * a), (u[x] = C.count), (v[x] = C.index), x++;
      }
      w1.reset();
    } else
      for (let g = 0, _ = l.length; g < _; g++)
        if (l[g].visible && l[g].active) {
          const S = l[g].geometryIndex;
          let b = !1;
          if (
            (p &&
              (this.getMatrixAt(g, si),
              this.getBoundingSphereAt(S, Hl).applyMatrix4(si),
              (b = !y.intersectsSphere(Hl, r))),
            !b)
          ) {
            const C = f[S];
            (c[x] = C.start * a), (u[x] = C.count), (v[x] = g), x++;
          }
        }
    (m.needsUpdate = !0),
      (this._multiDrawCount = x),
      (this._visibilityChanged = !1);
  }
  onBeforeShadow(e, t, r, i, s, o) {
    this.onBeforeRender(e, null, i, s, o);
  }
}
class ei extends Ur {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const sx = new z(),
  ox = new z(),
  vL = new Tt(),
  Ef = new Nh(),
  zv = new gr(),
  S1 = new z(),
  yL = new z();
class pl extends Xt {
  constructor(e = new kt(), t = new ei()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [0];
      for (let i = 1, s = t.count; i < s; i++)
        sx.fromBufferAttribute(t, i - 1),
          ox.fromBufferAttribute(t, i),
          (r[i] = r[i - 1]),
          (r[i] += sx.distanceTo(ox));
      e.setAttribute("lineDistance", new st(r, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      zv.copy(r.boundingSphere),
      zv.applyMatrix4(i),
      (zv.radius += s),
      e.ray.intersectsSphere(zv) === !1)
    )
      return;
    vL.copy(i).invert(), Ef.copy(e.ray).applyMatrix4(vL);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = this.isLineSegments ? 2 : 1,
      u = r.index,
      p = r.attributes.position;
    if (u !== null) {
      const m = Math.max(0, o.start),
        v = Math.min(u.count, o.start + o.count);
      for (let y = m, x = v - 1; y < x; y += c) {
        const g = u.getX(y),
          _ = u.getX(y + 1),
          S = Vv(this, e, Ef, l, g, _, y);
        S && t.push(S);
      }
      if (this.isLineLoop) {
        const y = u.getX(v - 1),
          x = u.getX(m),
          g = Vv(this, e, Ef, l, y, x, v - 1);
        g && t.push(g);
      }
    } else {
      const m = Math.max(0, o.start),
        v = Math.min(p.count, o.start + o.count);
      for (let y = m, x = v - 1; y < x; y += c) {
        const g = Vv(this, e, Ef, l, y, y + 1, y);
        g && t.push(g);
      }
      if (this.isLineLoop) {
        const y = Vv(this, e, Ef, l, v - 1, m, v - 1);
        y && t.push(y);
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function Vv(n, e, t, r, i, s, o) {
  const a = n.geometry.attributes.position;
  if (
    (sx.fromBufferAttribute(a, i),
    ox.fromBufferAttribute(a, s),
    t.distanceSqToSegment(sx, ox, S1, yL) > r)
  )
    return;
  S1.applyMatrix4(n.matrixWorld);
  const c = e.ray.origin.distanceTo(S1);
  if (!(c < e.near || c > e.far))
    return {
      distance: c,
      point: yL.clone().applyMatrix4(n.matrixWorld),
      index: o,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n,
    };
}
const xL = new z(),
  _L = new z();
class So extends pl {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        r = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        xL.fromBufferAttribute(t, i),
          _L.fromBufferAttribute(t, i + 1),
          (r[i] = i === 0 ? 0 : r[i - 1]),
          (r[i + 1] = r[i] + xL.distanceTo(_L));
      e.setAttribute("lineDistance", new st(r, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class dV extends pl {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class jC extends Ur {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const wL = new Tt(),
  WE = new Nh(),
  jv = new gr(),
  Hv = new z();
class hV extends Xt {
  constructor(e = new kt(), t = new jC()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      (this.morphTargetDictionary = void 0),
      (this.morphTargetInfluences = void 0),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const r = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      o = r.drawRange;
    if (
      (r.boundingSphere === null && r.computeBoundingSphere(),
      jv.copy(r.boundingSphere),
      jv.applyMatrix4(i),
      (jv.radius += s),
      e.ray.intersectsSphere(jv) === !1)
    )
      return;
    wL.copy(i).invert(), WE.copy(e.ray).applyMatrix4(wL);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = r.index,
      f = r.attributes.position;
    if (c !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(c.count, o.start + o.count);
      for (let v = p, y = m; v < y; v++) {
        const x = c.getX(v);
        Hv.fromBufferAttribute(f, x), SL(Hv, x, l, i, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(f.count, o.start + o.count);
      for (let v = p, y = m; v < y; v++)
        Hv.fromBufferAttribute(f, v), SL(Hv, v, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      r = Object.keys(t);
    if (r.length > 0) {
      const i = t[r[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = i.length; s < o; s++) {
          const a = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
function SL(n, e, t, r, i, s, o) {
  const a = WE.distanceSqToPoint(n);
  if (a < t) {
    const l = new z();
    WE.closestPointToPoint(n, l), l.applyMatrix4(r);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: o,
    });
  }
}
class fV extends Nn {
  constructor(e, t, r, i, s = Zn, o = Zn, a, l, c) {
    super(e, t, r, i, s, o, a, l, c),
      (this.isVideoTexture = !0),
      (this.generateMipmaps = !1),
      (this._requestVideoFrameCallbackId = 0);
    const u = this;
    function f() {
      (u.needsUpdate = !0),
        (u._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f));
    }
    "requestVideoFrameCallback" in e &&
      (this._requestVideoFrameCallbackId = e.requestVideoFrameCallback(f));
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
  dispose() {
    this._requestVideoFrameCallbackId !== 0 &&
      this.source.data.cancelVideoFrameCallback(
        this._requestVideoFrameCallbackId
      ),
      super.dispose();
  }
}
class Pre extends fV {
  constructor(e, t, r, i, s, o, a, l) {
    super({}, e, t, r, i, s, o, a, l), (this.isVideoFrameTexture = !0);
  }
  update() {}
  clone() {
    return new this.constructor().copy(this);
  }
  setFrame(e) {
    (this.image = e), (this.needsUpdate = !0);
  }
}
class Ire extends Nn {
  constructor(e, t) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = mr),
      (this.minFilter = mr),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class c_ extends Nn {
  constructor(e, t, r, i, s, o, a, l, c, u, f, p) {
    super(null, o, a, l, c, u, i, s, f, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: r }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class Nre extends c_ {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = i),
      (this.wrapR = rs),
      (this.layerUpdates = new Set());
  }
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
class Lre extends c_ {
  constructor(e, t, r) {
    super(void 0, e[0].width, e[0].height, t, r, ia),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class Ore extends Nn {
  constructor(e, t, r, i, s, o, a, l, c) {
    super(e, t, r, i, s, o, a, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class HC extends Nn {
  constructor(e, t, r = sa, i, s, o, a = mr, l = mr, c, u = ah, f = 1) {
    if (u !== ah && u !== lh)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    const p = { width: e, height: t, depth: f };
    super(p, i, s, o, a, l, u, r, c),
      (this.isDepthTexture = !0),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.source = new Ya(Object.assign({}, e.image))),
      (this.compareFunction = e.compareFunction),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class u_ extends kt {
  constructor(e = 1, t = 1, r = 4, i = 8, s = 1) {
    super(),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: r,
        radialSegments: i,
        heightSegments: s,
      }),
      (t = Math.max(0, t)),
      (r = Math.max(1, Math.floor(r))),
      (i = Math.max(3, Math.floor(i))),
      (s = Math.max(1, Math.floor(s)));
    const o = [],
      a = [],
      l = [],
      c = [],
      u = t / 2,
      f = (Math.PI / 2) * e,
      p = t,
      m = 2 * f + p,
      v = r * 2 + s,
      y = i + 1,
      x = new z(),
      g = new z();
    for (let _ = 0; _ <= v; _++) {
      let S = 0,
        b = 0,
        C = 0,
        A = 0;
      if (_ <= r) {
        const I = _ / r,
          N = (I * Math.PI) / 2;
        (b = -u - e * Math.cos(N)),
          (C = e * Math.sin(N)),
          (A = -e * Math.cos(N)),
          (S = I * f);
      } else if (_ <= r + s) {
        const I = (_ - r) / s;
        (b = -u + I * t), (C = e), (A = 0), (S = f + I * p);
      } else {
        const I = (_ - r - s) / r,
          N = (I * Math.PI) / 2;
        (b = u + e * Math.sin(N)),
          (C = e * Math.cos(N)),
          (A = e * Math.sin(N)),
          (S = f + p + I * f);
      }
      const R = Math.max(0, Math.min(1, S / m));
      let O = 0;
      _ === 0 ? (O = 0.5 / i) : _ === v && (O = -0.5 / i);
      for (let I = 0; I <= i; I++) {
        const N = I / i,
          D = N * Math.PI * 2,
          j = Math.sin(D),
          $ = Math.cos(D);
        (g.x = -C * $),
          (g.y = b),
          (g.z = C * j),
          a.push(g.x, g.y, g.z),
          x.set(-C * $, A, C * j),
          x.normalize(),
          l.push(x.x, x.y, x.z),
          c.push(N + O, R);
      }
      if (_ > 0) {
        const I = (_ - 1) * y;
        for (let N = 0; N < i; N++) {
          const D = I + N,
            j = I + N + 1,
            $ = _ * y + N,
            G = _ * y + N + 1;
          o.push(D, j, $), o.push(j, G, $);
        }
      }
    }
    this.setIndex(o),
      this.setAttribute("position", new st(a, 3)),
      this.setAttribute("normal", new st(l, 3)),
      this.setAttribute("uv", new st(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new u_(
      e.radius,
      e.height,
      e.capSegments,
      e.radialSegments,
      e.heightSegments
    );
  }
}
class d_ extends kt {
  constructor(e = 1, t = 32, r = 0, i = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: r,
        thetaLength: i,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = new z(),
      u = new xe();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let f = 0, p = 3; f <= t; f++, p += 3) {
      const m = r + (f / t) * i;
      (c.x = e * Math.cos(m)),
        (c.y = e * Math.sin(m)),
        o.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (u.x = (o[p] / e + 1) / 2),
        (u.y = (o[p + 1] / e + 1) / 2),
        l.push(u.x, u.y);
    }
    for (let f = 1; f <= t; f++) s.push(f, f + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new st(o, 3)),
      this.setAttribute("normal", new st(a, 3)),
      this.setAttribute("uv", new st(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new d_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class Cm extends kt {
  constructor(
    e = 1,
    t = 1,
    r = 1,
    i = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: r,
        radialSegments: i,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const c = this;
    (i = Math.floor(i)), (s = Math.floor(s));
    const u = [],
      f = [],
      p = [],
      m = [];
    let v = 0;
    const y = [],
      x = r / 2;
    let g = 0;
    _(),
      o === !1 && (e > 0 && S(!0), t > 0 && S(!1)),
      this.setIndex(u),
      this.setAttribute("position", new st(f, 3)),
      this.setAttribute("normal", new st(p, 3)),
      this.setAttribute("uv", new st(m, 2));
    function _() {
      const b = new z(),
        C = new z();
      let A = 0;
      const R = (t - e) / r;
      for (let O = 0; O <= s; O++) {
        const I = [],
          N = O / s,
          D = N * (t - e) + e;
        for (let j = 0; j <= i; j++) {
          const $ = j / i,
            G = $ * l + a,
            Z = Math.sin(G),
            q = Math.cos(G);
          (C.x = D * Z),
            (C.y = -N * r + x),
            (C.z = D * q),
            f.push(C.x, C.y, C.z),
            b.set(Z, R, q).normalize(),
            p.push(b.x, b.y, b.z),
            m.push($, 1 - N),
            I.push(v++);
        }
        y.push(I);
      }
      for (let O = 0; O < i; O++)
        for (let I = 0; I < s; I++) {
          const N = y[I][O],
            D = y[I + 1][O],
            j = y[I + 1][O + 1],
            $ = y[I][O + 1];
          (e > 0 || I !== 0) && (u.push(N, D, $), (A += 3)),
            (t > 0 || I !== s - 1) && (u.push(D, j, $), (A += 3));
        }
      c.addGroup(g, A, 0), (g += A);
    }
    function S(b) {
      const C = v,
        A = new xe(),
        R = new z();
      let O = 0;
      const I = b === !0 ? e : t,
        N = b === !0 ? 1 : -1;
      for (let j = 1; j <= i; j++)
        f.push(0, x * N, 0), p.push(0, N, 0), m.push(0.5, 0.5), v++;
      const D = v;
      for (let j = 0; j <= i; j++) {
        const G = (j / i) * l + a,
          Z = Math.cos(G),
          q = Math.sin(G);
        (R.x = I * q),
          (R.y = x * N),
          (R.z = I * Z),
          f.push(R.x, R.y, R.z),
          p.push(0, N, 0),
          (A.x = Z * 0.5 + 0.5),
          (A.y = q * 0.5 * N + 0.5),
          m.push(A.x, A.y),
          v++;
      }
      for (let j = 0; j < i; j++) {
        const $ = C + j,
          G = D + j;
        b === !0 ? u.push(G, G + 1, $) : u.push(G + 1, G, $), (O += 3);
      }
      c.addGroup(g, O, b === !0 ? 1 : 2), (g += O);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Cm(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Am extends Cm {
  constructor(e = 1, t = 1, r = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, r, i, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Am(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class bl extends kt {
  constructor(e = [], t = [], r = 1, i = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: r, detail: i });
    const s = [],
      o = [];
    a(i),
      c(r),
      u(),
      this.setAttribute("position", new st(s, 3)),
      this.setAttribute("normal", new st(s.slice(), 3)),
      this.setAttribute("uv", new st(o, 2)),
      i === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(_) {
      const S = new z(),
        b = new z(),
        C = new z();
      for (let A = 0; A < t.length; A += 3)
        m(t[A + 0], S), m(t[A + 1], b), m(t[A + 2], C), l(S, b, C, _);
    }
    function l(_, S, b, C) {
      const A = C + 1,
        R = [];
      for (let O = 0; O <= A; O++) {
        R[O] = [];
        const I = _.clone().lerp(b, O / A),
          N = S.clone().lerp(b, O / A),
          D = A - O;
        for (let j = 0; j <= D; j++)
          j === 0 && O === A
            ? (R[O][j] = I)
            : (R[O][j] = I.clone().lerp(N, j / D));
      }
      for (let O = 0; O < A; O++)
        for (let I = 0; I < 2 * (A - O) - 1; I++) {
          const N = Math.floor(I / 2);
          I % 2 === 0
            ? (p(R[O][N + 1]), p(R[O + 1][N]), p(R[O][N]))
            : (p(R[O][N + 1]), p(R[O + 1][N + 1]), p(R[O + 1][N]));
        }
    }
    function c(_) {
      const S = new z();
      for (let b = 0; b < s.length; b += 3)
        (S.x = s[b + 0]),
          (S.y = s[b + 1]),
          (S.z = s[b + 2]),
          S.normalize().multiplyScalar(_),
          (s[b + 0] = S.x),
          (s[b + 1] = S.y),
          (s[b + 2] = S.z);
    }
    function u() {
      const _ = new z();
      for (let S = 0; S < s.length; S += 3) {
        (_.x = s[S + 0]), (_.y = s[S + 1]), (_.z = s[S + 2]);
        const b = x(_) / 2 / Math.PI + 0.5,
          C = g(_) / Math.PI + 0.5;
        o.push(b, 1 - C);
      }
      v(), f();
    }
    function f() {
      for (let _ = 0; _ < o.length; _ += 6) {
        const S = o[_ + 0],
          b = o[_ + 2],
          C = o[_ + 4],
          A = Math.max(S, b, C),
          R = Math.min(S, b, C);
        A > 0.9 &&
          R < 0.1 &&
          (S < 0.2 && (o[_ + 0] += 1),
          b < 0.2 && (o[_ + 2] += 1),
          C < 0.2 && (o[_ + 4] += 1));
      }
    }
    function p(_) {
      s.push(_.x, _.y, _.z);
    }
    function m(_, S) {
      const b = _ * 3;
      (S.x = e[b + 0]), (S.y = e[b + 1]), (S.z = e[b + 2]);
    }
    function v() {
      const _ = new z(),
        S = new z(),
        b = new z(),
        C = new z(),
        A = new xe(),
        R = new xe(),
        O = new xe();
      for (let I = 0, N = 0; I < s.length; I += 9, N += 6) {
        _.set(s[I + 0], s[I + 1], s[I + 2]),
          S.set(s[I + 3], s[I + 4], s[I + 5]),
          b.set(s[I + 6], s[I + 7], s[I + 8]),
          A.set(o[N + 0], o[N + 1]),
          R.set(o[N + 2], o[N + 3]),
          O.set(o[N + 4], o[N + 5]),
          C.copy(_).add(S).add(b).divideScalar(3);
        const D = x(C);
        y(A, N + 0, _, D), y(R, N + 2, S, D), y(O, N + 4, b, D);
      }
    }
    function y(_, S, b, C) {
      C < 0 && _.x === 1 && (o[S] = _.x - 1),
        b.x === 0 && b.z === 0 && (o[S] = C / 2 / Math.PI + 0.5);
    }
    function x(_) {
      return Math.atan2(_.z, -_.x);
    }
    function g(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new bl(e.vertices, e.indices, e.radius, e.details);
  }
}
class h_ extends bl {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = 1 / r,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        -i,
        -r,
        0,
        -i,
        r,
        0,
        i,
        -r,
        0,
        i,
        r,
        0,
        -r,
        0,
        -i,
        r,
        0,
        -i,
        -r,
        0,
        i,
        r,
        0,
        i,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new h_(e.radius, e.detail);
  }
}
const Wv = new z(),
  Gv = new z(),
  b1 = new z(),
  $v = new ui();
class pV extends kt {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const i = Math.pow(10, 4),
        s = Math.cos(Pc * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        c = [0, 0, 0],
        u = ["a", "b", "c"],
        f = new Array(3),
        p = {},
        m = [];
      for (let v = 0; v < l; v += 3) {
        o
          ? ((c[0] = o.getX(v)), (c[1] = o.getX(v + 1)), (c[2] = o.getX(v + 2)))
          : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
        const { a: y, b: x, c: g } = $v;
        if (
          (y.fromBufferAttribute(a, c[0]),
          x.fromBufferAttribute(a, c[1]),
          g.fromBufferAttribute(a, c[2]),
          $v.getNormal(b1),
          (f[0] = `${Math.round(y.x * i)},${Math.round(y.y * i)},${Math.round(
            y.z * i
          )}`),
          (f[1] = `${Math.round(x.x * i)},${Math.round(x.y * i)},${Math.round(
            x.z * i
          )}`),
          (f[2] = `${Math.round(g.x * i)},${Math.round(g.y * i)},${Math.round(
            g.z * i
          )}`),
          !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
        )
          for (let _ = 0; _ < 3; _++) {
            const S = (_ + 1) % 3,
              b = f[_],
              C = f[S],
              A = $v[u[_]],
              R = $v[u[S]],
              O = `${b}_${C}`,
              I = `${C}_${b}`;
            I in p && p[I]
              ? (b1.dot(p[I].normal) <= s &&
                  (m.push(A.x, A.y, A.z), m.push(R.x, R.y, R.z)),
                (p[I] = null))
              : O in p ||
                (p[O] = { index0: c[_], index1: c[S], normal: b1.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: y, index1: x } = p[v];
          Wv.fromBufferAttribute(a, y),
            Gv.fromBufferAttribute(a, x),
            m.push(Wv.x, Wv.y, Wv.z),
            m.push(Gv.x, Gv.y, Gv.z);
        }
      this.setAttribute("position", new st(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class zs {
  constructor() {
    (this.type = "Curve"),
      (this.arcLengthDivisions = 200),
      (this.needsUpdate = !1),
      (this.cacheArcLengths = null);
  }
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
  }
  getPointAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getPoint(r, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPointAt(r / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let r,
      i = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (r = this.getPoint(o / e)), (s += r.distanceTo(i)), t.push(s), (i = r);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t = null) {
    const r = this.getLengths();
    let i = 0;
    const s = r.length;
    let o;
    t ? (o = t) : (o = e * r[s - 1]);
    let a = 0,
      l = s - 1,
      c;
    for (; a <= l; )
      if (((i = Math.floor(a + (l - a) / 2)), (c = r[i] - o), c < 0)) a = i + 1;
      else if (c > 0) l = i - 1;
      else {
        l = i;
        break;
      }
    if (((i = l), r[i] === o)) return i / (s - 1);
    const u = r[i],
      p = r[i + 1] - u,
      m = (o - u) / p;
    return (i + m) / (s - 1);
  }
  getTangent(e, t) {
    let i = e - 1e-4,
      s = e + 1e-4;
    i < 0 && (i = 0), s > 1 && (s = 1);
    const o = this.getPoint(i),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new xe() : new z());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const r = this.getUtoTmapping(e);
    return this.getTangent(r, t);
  }
  computeFrenetFrames(e, t = !1) {
    const r = new z(),
      i = [],
      s = [],
      o = [],
      a = new z(),
      l = new Tt();
    for (let m = 0; m <= e; m++) {
      const v = m / e;
      i[m] = this.getTangentAt(v, new z());
    }
    (s[0] = new z()), (o[0] = new z());
    let c = Number.MAX_VALUE;
    const u = Math.abs(i[0].x),
      f = Math.abs(i[0].y),
      p = Math.abs(i[0].z);
    u <= c && ((c = u), r.set(1, 0, 0)),
      f <= c && ((c = f), r.set(0, 1, 0)),
      p <= c && r.set(0, 0, 1),
      a.crossVectors(i[0], r).normalize(),
      s[0].crossVectors(i[0], a),
      o[0].crossVectors(i[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(i[m - 1], i[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const v = Math.acos(St(i[m - 1].dot(i[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, v));
      }
      o[m].crossVectors(i[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(St(s[0].dot(s[e]), -1, 1));
      (m /= e), i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let v = 1; v <= e; v++)
        s[v].applyMatrix4(l.makeRotationAxis(i[v], m * v)),
          o[v].crossVectors(i[v], s[v]);
    }
    return { tangents: i, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.7, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class f_ extends zs {
  constructor(
    e = 0,
    t = 0,
    r = 1,
    i = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = r),
      (this.yRadius = i),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t = new xe()) {
    const r = t,
      i = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += i;
    for (; s > i; ) s -= i;
    s < Number.EPSILON && (o ? (s = 0) : (s = i)),
      this.aClockwise === !0 && !o && (s === i ? (s = -i) : (s = s - i));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const u = Math.cos(this.aRotation),
        f = Math.sin(this.aRotation),
        p = l - this.aX,
        m = c - this.aY;
      (l = p * u - m * f + this.aX), (c = p * f + m * u + this.aY);
    }
    return r.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class mV extends f_ {
  constructor(e, t, r, i, s, o) {
    super(e, t, r, r, i, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function WC() {
  let n = 0,
    e = 0,
    t = 0,
    r = 0;
  function i(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (r = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, c) {
      i(o, a, c * (a - s), c * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, c, u, f) {
      let p = (o - s) / c - (a - s) / (c + u) + (a - o) / u,
        m = (a - o) / u - (l - o) / (u + f) + (l - a) / f;
      (p *= u), (m *= u), i(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + r * a;
    },
  };
}
const Xv = new z(),
  E1 = new WC(),
  T1 = new WC(),
  M1 = new WC();
class gV extends zs {
  constructor(e = [], t = !1, r = "centripetal", i = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = r),
      (this.tension = i);
  }
  getPoint(e, t = new z()) {
    const r = t,
      i = this.points,
      s = i.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let c, u;
    this.closed || a > 0
      ? (c = i[(a - 1) % s])
      : (Xv.subVectors(i[0], i[1]).add(i[0]), (c = Xv));
    const f = i[a % s],
      p = i[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (u = i[(a + 2) % s])
        : (Xv.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), (u = Xv)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(c.distanceToSquared(f), m),
        y = Math.pow(f.distanceToSquared(p), m),
        x = Math.pow(p.distanceToSquared(u), m);
      y < 1e-4 && (y = 1),
        v < 1e-4 && (v = y),
        x < 1e-4 && (x = y),
        E1.initNonuniformCatmullRom(c.x, f.x, p.x, u.x, v, y, x),
        T1.initNonuniformCatmullRom(c.y, f.y, p.y, u.y, v, y, x),
        M1.initNonuniformCatmullRom(c.z, f.z, p.z, u.z, v, y, x);
    } else
      this.curveType === "catmullrom" &&
        (E1.initCatmullRom(c.x, f.x, p.x, u.x, this.tension),
        T1.initCatmullRom(c.y, f.y, p.y, u.y, this.tension),
        M1.initCatmullRom(c.z, f.z, p.z, u.z, this.tension));
    return r.set(E1.calc(l), T1.calc(l), M1.calc(l)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new z().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function bL(n, e, t, r, i) {
  const s = (r - e) * 0.5,
    o = (i - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * r + s + o) * l + (-3 * t + 3 * r - 2 * s - o) * a + s * n + t
  );
}
function Dre(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function kre(n, e) {
  return 2 * (1 - n) * n * e;
}
function Ure(n, e) {
  return n * n * e;
}
function up(n, e, t, r) {
  return Dre(n, e) + kre(n, t) + Ure(n, r);
}
function Fre(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function Bre(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function zre(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function Vre(n, e) {
  return n * n * n * e;
}
function dp(n, e, t, r, i) {
  return Fre(n, e) + Bre(n, t) + zre(n, r) + Vre(n, i);
}
class GC extends zs {
  constructor(e = new xe(), t = new xe(), r = new xe(), i = new xe()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new xe()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return r.set(dp(e, i.x, s.x, o.x, a.x), dp(e, i.y, s.y, o.y, a.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class vV extends zs {
  constructor(e = new z(), t = new z(), r = new z(), i = new z()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r),
      (this.v3 = i);
  }
  getPoint(e, t = new z()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      r.set(
        dp(e, i.x, s.x, o.x, a.x),
        dp(e, i.y, s.y, o.y, a.y),
        dp(e, i.z, s.z, o.z, a.z)
      ),
      r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class $C extends zs {
  constructor(e = new xe(), t = new xe()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new xe()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new xe()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class yV extends zs {
  constructor(e = new z(), t = new z()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new z()) {
    const r = t;
    return (
      e === 1
        ? r.copy(this.v2)
        : (r.copy(this.v2).sub(this.v1), r.multiplyScalar(e).add(this.v1)),
      r
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new z()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class XC extends zs {
  constructor(e = new xe(), t = new xe(), r = new xe()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new xe()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return r.set(up(e, i.x, s.x, o.x), up(e, i.y, s.y, o.y)), r;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class qC extends zs {
  constructor(e = new z(), t = new z(), r = new z()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = r);
  }
  getPoint(e, t = new z()) {
    const r = t,
      i = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      r.set(up(e, i.x, s.x, o.x), up(e, i.y, s.y, o.y), up(e, i.z, s.z, o.z)), r
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class KC extends zs {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new xe()) {
    const r = t,
      i = this.points,
      s = (i.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = i[o === 0 ? o : o - 1],
      c = i[o],
      u = i[o > i.length - 2 ? i.length - 1 : o + 1],
      f = i[o > i.length - 3 ? i.length - 1 : o + 2];
    return r.set(bL(a, l.x, c.x, u.x, f.x), bL(a, l.y, c.y, u.y, f.y)), r;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, r = this.points.length; t < r; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, r = e.points.length; t < r; t++) {
      const i = e.points[t];
      this.points.push(new xe().fromArray(i));
    }
    return this;
  }
}
var ax = Object.freeze({
  __proto__: null,
  ArcCurve: mV,
  CatmullRomCurve3: gV,
  CubicBezierCurve: GC,
  CubicBezierCurve3: vV,
  EllipseCurve: f_,
  LineCurve: $C,
  LineCurve3: yV,
  QuadraticBezierCurve: XC,
  QuadraticBezierCurve3: qC,
  SplineCurve: KC,
});
class xV extends zs {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const r = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
      this.curves.push(new ax[r](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const r = e * this.getLength(),
      i = this.getCurveLengths();
    let s = 0;
    for (; s < i.length; ) {
      if (i[s] >= r) {
        const o = i[s] - r,
          a = this.curves[s],
          l = a.getLength(),
          c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let r = 0, i = this.curves.length; r < i; r++)
      (t += this.curves[r].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let r = 0; r <= e; r++) t.push(this.getPoint(r / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let r;
    for (let i = 0, s = this.curves; i < s.length; i++) {
      const o = s[i],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const u = l[c];
        (r && r.equals(u)) || (t.push(u), (r = u));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(i.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, r = this.curves.length; t < r; t++) {
      const i = this.curves[t];
      e.curves.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, r = e.curves.length; t < r; t++) {
      const i = e.curves[t];
      this.curves.push(new ax[i.type]().fromJSON(i));
    }
    return this;
  }
}
class lx extends xV {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new xe()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, r = e.length; t < r; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const r = new $C(this.currentPoint.clone(), new xe(e, t));
    return this.curves.push(r), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    const s = new XC(this.currentPoint.clone(), new xe(e, t), new xe(r, i));
    return this.curves.push(s), this.currentPoint.set(r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    const a = new GC(
      this.currentPoint.clone(),
      new xe(e, t),
      new xe(r, i),
      new xe(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      r = new KC(t);
    return this.curves.push(r), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, r, i, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, r, i, s, o), this;
  }
  absarc(e, t, r, i, s, o) {
    return this.absellipse(e, t, r, r, i, s, o), this;
  }
  ellipse(e, t, r, i, s, o, a, l) {
    const c = this.currentPoint.x,
      u = this.currentPoint.y;
    return this.absellipse(e + c, t + u, r, i, s, o, a, l), this;
  }
  absellipse(e, t, r, i, s, o, a, l) {
    const c = new f_(e, t, r, i, s, o, a, l);
    if (this.curves.length > 0) {
      const f = c.getPoint(0);
      f.equals(this.currentPoint) || this.lineTo(f.x, f.y);
    }
    this.curves.push(c);
    const u = c.getPoint(1);
    return this.currentPoint.copy(u), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Nc extends lx {
  constructor(e) {
    super(e), (this.uuid = Li()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let r = 0, i = this.holes.length; r < i; r++)
      t[r] = this.holes[r].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(i.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, r = this.holes.length; t < r; t++) {
      const i = this.holes[t];
      e.holes.push(i.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, r = e.holes.length; t < r; t++) {
      const i = e.holes[t];
      this.holes.push(new lx().fromJSON(i));
    }
    return this;
  }
}
function jre(n, e, t = 2) {
  const r = e && e.length,
    i = r ? e[0] * t : n.length;
  let s = _V(n, 0, i, t, !0);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let a, l, c;
  if ((r && (s = Xre(n, e, s, t)), n.length > 80 * t)) {
    (a = 1 / 0), (l = 1 / 0);
    let u = -1 / 0,
      f = -1 / 0;
    for (let p = t; p < i; p += t) {
      const m = n[p],
        v = n[p + 1];
      m < a && (a = m), v < l && (l = v), m > u && (u = m), v > f && (f = v);
    }
    (c = Math.max(u - a, f - l)), (c = c !== 0 ? 32767 / c : 0);
  }
  return em(s, o, t, a, l, c, 0), o;
}
function _V(n, e, t, r, i) {
  let s;
  if (i === iie(n, e, t, r) > 0)
    for (let o = e; o < t; o += r) s = EL((o / r) | 0, n[o], n[o + 1], s);
  else
    for (let o = t - r; o >= e; o -= r) s = EL((o / r) | 0, n[o], n[o + 1], s);
  return s && fh(s, s.next) && (nm(s), (s = s.next)), s;
}
function Hc(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    r;
  do
    if (
      ((r = !1), !t.steiner && (fh(t, t.next) || En(t.prev, t, t.next) === 0))
    ) {
      if ((nm(t), (t = e = t.prev), t === t.next)) break;
      r = !0;
    } else t = t.next;
  while (r || t !== e);
  return e;
}
function em(n, e, t, r, i, s, o) {
  if (!n) return;
  !o && s && Zre(n, r, i, s);
  let a = n;
  for (; n.prev !== n.next; ) {
    const l = n.prev,
      c = n.next;
    if (s ? Wre(n, r, i, s) : Hre(n)) {
      e.push(l.i, n.i, c.i), nm(n), (n = c.next), (a = c.next);
      continue;
    }
    if (((n = c), n === a)) {
      o
        ? o === 1
          ? ((n = Gre(Hc(n), e)), em(n, e, t, r, i, s, 2))
          : o === 2 && $re(n, e, t, r, i, s)
        : em(Hc(n), e, t, r, i, s, 1);
      break;
    }
  }
}
function Hre(n) {
  const e = n.prev,
    t = n,
    r = n.next;
  if (En(e, t, r) >= 0) return !1;
  const i = e.x,
    s = t.x,
    o = r.x,
    a = e.y,
    l = t.y,
    c = r.y,
    u = Math.min(i, s, o),
    f = Math.min(a, l, c),
    p = Math.max(i, s, o),
    m = Math.max(a, l, c);
  let v = r.next;
  for (; v !== e; ) {
    if (
      v.x >= u &&
      v.x <= p &&
      v.y >= f &&
      v.y <= m &&
      Df(i, a, s, l, o, c, v.x, v.y) &&
      En(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function Wre(n, e, t, r) {
  const i = n.prev,
    s = n,
    o = n.next;
  if (En(i, s, o) >= 0) return !1;
  const a = i.x,
    l = s.x,
    c = o.x,
    u = i.y,
    f = s.y,
    p = o.y,
    m = Math.min(a, l, c),
    v = Math.min(u, f, p),
    y = Math.max(a, l, c),
    x = Math.max(u, f, p),
    g = GE(m, v, e, t, r),
    _ = GE(y, x, e, t, r);
  let S = n.prevZ,
    b = n.nextZ;
  for (; S && S.z >= g && b && b.z <= _; ) {
    if (
      (S.x >= m &&
        S.x <= y &&
        S.y >= v &&
        S.y <= x &&
        S !== i &&
        S !== o &&
        Df(a, u, l, f, c, p, S.x, S.y) &&
        En(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      b.x >= m &&
        b.x <= y &&
        b.y >= v &&
        b.y <= x &&
        b !== i &&
        b !== o &&
        Df(a, u, l, f, c, p, b.x, b.y) &&
        En(b.prev, b, b.next) >= 0)
    )
      return !1;
    b = b.nextZ;
  }
  for (; S && S.z >= g; ) {
    if (
      S.x >= m &&
      S.x <= y &&
      S.y >= v &&
      S.y <= x &&
      S !== i &&
      S !== o &&
      Df(a, u, l, f, c, p, S.x, S.y) &&
      En(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; b && b.z <= _; ) {
    if (
      b.x >= m &&
      b.x <= y &&
      b.y >= v &&
      b.y <= x &&
      b !== i &&
      b !== o &&
      Df(a, u, l, f, c, p, b.x, b.y) &&
      En(b.prev, b, b.next) >= 0
    )
      return !1;
    b = b.nextZ;
  }
  return !0;
}
function Gre(n, e) {
  let t = n;
  do {
    const r = t.prev,
      i = t.next.next;
    !fh(r, i) &&
      SV(r, t, t.next, i) &&
      tm(r, i) &&
      tm(i, r) &&
      (e.push(r.i, t.i, i.i), nm(t), nm(t.next), (t = n = i)),
      (t = t.next);
  } while (t !== n);
  return Hc(t);
}
function $re(n, e, t, r, i, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && tie(o, a)) {
        let l = bV(o, a);
        (o = Hc(o, o.next)),
          (l = Hc(l, l.next)),
          em(o, e, t, r, i, s, 0),
          em(l, e, t, r, i, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function Xre(n, e, t, r) {
  const i = [];
  for (let s = 0, o = e.length; s < o; s++) {
    const a = e[s] * r,
      l = s < o - 1 ? e[s + 1] * r : n.length,
      c = _V(n, a, l, r, !1);
    c === c.next && (c.steiner = !0), i.push(eie(c));
  }
  i.sort(qre);
  for (let s = 0; s < i.length; s++) t = Kre(i[s], t);
  return t;
}
function qre(n, e) {
  let t = n.x - e.x;
  if (t === 0 && ((t = n.y - e.y), t === 0)) {
    const r = (n.next.y - n.y) / (n.next.x - n.x),
      i = (e.next.y - e.y) / (e.next.x - e.x);
    t = r - i;
  }
  return t;
}
function Kre(n, e) {
  const t = Yre(n, e);
  if (!t) return e;
  const r = bV(t, n);
  return Hc(r, r.next), Hc(t, t.next);
}
function Yre(n, e) {
  let t = e;
  const r = n.x,
    i = n.y;
  let s = -1 / 0,
    o;
  if (fh(n, t)) return t;
  do {
    if (fh(n, t.next)) return t.next;
    if (i <= t.y && i >= t.next.y && t.next.y !== t.y) {
      const f = t.x + ((i - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        f <= r &&
        f > s &&
        ((s = f), (o = t.x < t.next.x ? t : t.next), f === r)
      )
        return o;
    }
    t = t.next;
  } while (t !== e);
  if (!o) return null;
  const a = o,
    l = o.x,
    c = o.y;
  let u = 1 / 0;
  t = o;
  do {
    if (
      r >= t.x &&
      t.x >= l &&
      r !== t.x &&
      wV(i < c ? r : s, i, l, c, i < c ? s : r, i, t.x, t.y)
    ) {
      const f = Math.abs(i - t.y) / (r - t.x);
      tm(t, n) &&
        (f < u || (f === u && (t.x > o.x || (t.x === o.x && Jre(o, t))))) &&
        ((o = t), (u = f));
    }
    t = t.next;
  } while (t !== a);
  return o;
}
function Jre(n, e) {
  return En(n.prev, n, e.prev) < 0 && En(e.next, n, n.next) < 0;
}
function Zre(n, e, t, r) {
  let i = n;
  do
    i.z === 0 && (i.z = GE(i.x, i.y, e, t, r)),
      (i.prevZ = i.prev),
      (i.nextZ = i.next),
      (i = i.next);
  while (i !== n);
  (i.prevZ.nextZ = null), (i.prevZ = null), Qre(i);
}
function Qre(n) {
  let e,
    t = 1;
  do {
    let r = n,
      i;
    n = null;
    let s = null;
    for (e = 0; r; ) {
      e++;
      let o = r,
        a = 0;
      for (let c = 0; c < t && (a++, (o = o.nextZ), !!o); c++);
      let l = t;
      for (; a > 0 || (l > 0 && o); )
        a !== 0 && (l === 0 || !o || r.z <= o.z)
          ? ((i = r), (r = r.nextZ), a--)
          : ((i = o), (o = o.nextZ), l--),
          s ? (s.nextZ = i) : (n = i),
          (i.prevZ = s),
          (s = i);
      r = o;
    }
    (s.nextZ = null), (t *= 2);
  } while (e > 1);
  return n;
}
function GE(n, e, t, r, i) {
  return (
    (n = ((n - t) * i) | 0),
    (e = ((e - r) * i) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function eie(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function wV(n, e, t, r, i, s, o, a) {
  return (
    (i - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (r - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (i - o) * (r - a)
  );
}
function Df(n, e, t, r, i, s, o, a) {
  return !(n === o && e === a) && wV(n, e, t, r, i, s, o, a);
}
function tie(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !nie(n, e) &&
    ((tm(n, e) &&
      tm(e, n) &&
      rie(n, e) &&
      (En(n.prev, n, e.prev) || En(n, e.prev, e))) ||
      (fh(n, e) && En(n.prev, n, n.next) > 0 && En(e.prev, e, e.next) > 0))
  );
}
function En(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function fh(n, e) {
  return n.x === e.x && n.y === e.y;
}
function SV(n, e, t, r) {
  const i = Kv(En(n, e, t)),
    s = Kv(En(n, e, r)),
    o = Kv(En(t, r, n)),
    a = Kv(En(t, r, e));
  return !!(
    (i !== s && o !== a) ||
    (i === 0 && qv(n, t, e)) ||
    (s === 0 && qv(n, r, e)) ||
    (o === 0 && qv(t, n, r)) ||
    (a === 0 && qv(t, e, r))
  );
}
function qv(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function Kv(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function nie(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      SV(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function tm(n, e) {
  return En(n.prev, n, n.next) < 0
    ? En(n, e, n.next) >= 0 && En(n, n.prev, e) >= 0
    : En(n, e, n.prev) < 0 || En(n, n.next, e) < 0;
}
function rie(n, e) {
  let t = n,
    r = !1;
  const i = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      i < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (r = !r),
      (t = t.next);
  while (t !== n);
  return r;
}
function bV(n, e) {
  const t = $E(n.i, n.x, n.y),
    r = $E(e.i, e.x, e.y),
    i = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = i),
    (i.prev = t),
    (r.next = t),
    (t.prev = r),
    (s.next = r),
    (r.prev = s),
    r
  );
}
function EL(n, e, t, r) {
  const i = $E(n, e, t);
  return (
    r
      ? ((i.next = r.next), (i.prev = r), (r.next.prev = i), (r.next = i))
      : ((i.prev = i), (i.next = i)),
    i
  );
}
function nm(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function $E(n, e, t) {
  return {
    i: n,
    x: e,
    y: t,
    prev: null,
    next: null,
    z: 0,
    prevZ: null,
    nextZ: null,
    steiner: !1,
  };
}
function iie(n, e, t, r) {
  let i = 0;
  for (let s = e, o = t - r; s < t; s += r)
    (i += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return i;
}
class sie {
  static triangulate(e, t, r = 2) {
    return jre(e, t, r);
  }
}
class Ns {
  static area(e) {
    const t = e.length;
    let r = 0;
    for (let i = t - 1, s = 0; s < t; i = s++)
      r += e[i].x * e[s].y - e[s].x * e[i].y;
    return r * 0.5;
  }
  static isClockWise(e) {
    return Ns.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const r = [],
      i = [],
      s = [];
    TL(e), ML(r, e);
    let o = e.length;
    t.forEach(TL);
    for (let l = 0; l < t.length; l++)
      i.push(o), (o += t[l].length), ML(r, t[l]);
    const a = sie.triangulate(r, i);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function TL(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function ML(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class p_ extends kt {
  constructor(
    e = new Nc([
      new xe(0.5, 0.5),
      new xe(-0.5, 0.5),
      new xe(-0.5, -0.5),
      new xe(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const r = this,
      i = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new st(i, 3)),
      this.setAttribute("uv", new st(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        u = t.steps !== void 0 ? t.steps : 1,
        f = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        v = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath,
        _ = t.UVGenerator !== void 0 ? t.UVGenerator : oie;
      let S,
        b = !1,
        C,
        A,
        R,
        O;
      g &&
        ((S = g.getSpacedPoints(u)),
        (b = !0),
        (p = !1),
        (C = g.computeFrenetFrames(u, !1)),
        (A = new z()),
        (R = new z()),
        (O = new z())),
        p || ((x = 0), (m = 0), (v = 0), (y = 0));
      const I = a.extractPoints(c);
      let N = I.shape;
      const D = I.holes;
      if (!Ns.isClockWise(N)) {
        N = N.reverse();
        for (let ge = 0, pe = D.length; ge < pe; ge++) {
          const Se = D[ge];
          Ns.isClockWise(Se) && (D[ge] = Se.reverse());
        }
      }
      function $(ge) {
        const Se = 10000000000000001e-36;
        let me = ge[0];
        for (let Oe = 1; Oe <= ge.length; Oe++) {
          const Te = Oe % ge.length,
            De = ge[Te],
            _t = De.x - me.x,
            wt = De.y - me.y,
            B = _t * _t + wt * wt,
            k = Math.max(
              Math.abs(De.x),
              Math.abs(De.y),
              Math.abs(me.x),
              Math.abs(me.y)
            ),
            ne = Se * k * k;
          if (B <= ne) {
            ge.splice(Te, 1), Oe--;
            continue;
          }
          me = De;
        }
      }
      $(N), D.forEach($);
      const G = D.length,
        Z = N;
      for (let ge = 0; ge < G; ge++) {
        const pe = D[ge];
        N = N.concat(pe);
      }
      function q(ge, pe, Se) {
        return (
          pe || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          ge.clone().addScaledVector(pe, Se)
        );
      }
      const Y = N.length;
      function U(ge, pe, Se) {
        let me, Oe, Te;
        const De = ge.x - pe.x,
          _t = ge.y - pe.y,
          wt = Se.x - ge.x,
          B = Se.y - ge.y,
          k = De * De + _t * _t,
          ne = De * B - _t * wt;
        if (Math.abs(ne) > Number.EPSILON) {
          const ae = Math.sqrt(k),
            we = Math.sqrt(wt * wt + B * B),
            he = pe.x - _t / ae,
            ot = pe.y + De / ae,
            Ne = Se.x - B / we,
            it = Se.y + wt / we,
            tt = ((Ne - he) * B - (it - ot) * wt) / (De * B - _t * wt);
          (me = he + De * tt - ge.x), (Oe = ot + _t * tt - ge.y);
          const Ce = me * me + Oe * Oe;
          if (Ce <= 2) return new xe(me, Oe);
          Te = Math.sqrt(Ce / 2);
        } else {
          let ae = !1;
          De > Number.EPSILON
            ? wt > Number.EPSILON && (ae = !0)
            : De < -Number.EPSILON
            ? wt < -Number.EPSILON && (ae = !0)
            : Math.sign(_t) === Math.sign(B) && (ae = !0),
            ae
              ? ((me = -_t), (Oe = De), (Te = Math.sqrt(k)))
              : ((me = De), (Oe = _t), (Te = Math.sqrt(k / 2)));
        }
        return new xe(me / Te, Oe / Te);
      }
      const H = [];
      for (
        let ge = 0, pe = Z.length, Se = pe - 1, me = ge + 1;
        ge < pe;
        ge++, Se++, me++
      )
        Se === pe && (Se = 0),
          me === pe && (me = 0),
          (H[ge] = U(Z[ge], Z[Se], Z[me]));
      const X = [];
      let ie,
        de = H.concat();
      for (let ge = 0, pe = G; ge < pe; ge++) {
        const Se = D[ge];
        ie = [];
        for (
          let me = 0, Oe = Se.length, Te = Oe - 1, De = me + 1;
          me < Oe;
          me++, Te++, De++
        )
          Te === Oe && (Te = 0),
            De === Oe && (De = 0),
            (ie[me] = U(Se[me], Se[Te], Se[De]));
        X.push(ie), (de = de.concat(ie));
      }
      let Ee;
      if (x === 0) Ee = Ns.triangulateShape(Z, D);
      else {
        const ge = [],
          pe = [];
        for (let Se = 0; Se < x; Se++) {
          const me = Se / x,
            Oe = m * Math.cos((me * Math.PI) / 2),
            Te = v * Math.sin((me * Math.PI) / 2) + y;
          for (let De = 0, _t = Z.length; De < _t; De++) {
            const wt = q(Z[De], H[De], Te);
            Ue(wt.x, wt.y, -Oe), me === 0 && ge.push(wt);
          }
          for (let De = 0, _t = G; De < _t; De++) {
            const wt = D[De];
            ie = X[De];
            const B = [];
            for (let k = 0, ne = wt.length; k < ne; k++) {
              const ae = q(wt[k], ie[k], Te);
              Ue(ae.x, ae.y, -Oe), me === 0 && B.push(ae);
            }
            me === 0 && pe.push(B);
          }
        }
        Ee = Ns.triangulateShape(ge, pe);
      }
      const Ie = Ee.length,
        se = v + y;
      for (let ge = 0; ge < Y; ge++) {
        const pe = p ? q(N[ge], de[ge], se) : N[ge];
        b
          ? (R.copy(C.normals[0]).multiplyScalar(pe.x),
            A.copy(C.binormals[0]).multiplyScalar(pe.y),
            O.copy(S[0]).add(R).add(A),
            Ue(O.x, O.y, O.z))
          : Ue(pe.x, pe.y, 0);
      }
      for (let ge = 1; ge <= u; ge++)
        for (let pe = 0; pe < Y; pe++) {
          const Se = p ? q(N[pe], de[pe], se) : N[pe];
          b
            ? (R.copy(C.normals[ge]).multiplyScalar(Se.x),
              A.copy(C.binormals[ge]).multiplyScalar(Se.y),
              O.copy(S[ge]).add(R).add(A),
              Ue(O.x, O.y, O.z))
            : Ue(Se.x, Se.y, (f / u) * ge);
        }
      for (let ge = x - 1; ge >= 0; ge--) {
        const pe = ge / x,
          Se = m * Math.cos((pe * Math.PI) / 2),
          me = v * Math.sin((pe * Math.PI) / 2) + y;
        for (let Oe = 0, Te = Z.length; Oe < Te; Oe++) {
          const De = q(Z[Oe], H[Oe], me);
          Ue(De.x, De.y, f + Se);
        }
        for (let Oe = 0, Te = D.length; Oe < Te; Oe++) {
          const De = D[Oe];
          ie = X[Oe];
          for (let _t = 0, wt = De.length; _t < wt; _t++) {
            const B = q(De[_t], ie[_t], me);
            b
              ? Ue(B.x, B.y + S[u - 1].y, S[u - 1].x + Se)
              : Ue(B.x, B.y, f + Se);
          }
        }
      }
      _e(), re();
      function _e() {
        const ge = i.length / 3;
        if (p) {
          let pe = 0,
            Se = Y * pe;
          for (let me = 0; me < Ie; me++) {
            const Oe = Ee[me];
            Fe(Oe[2] + Se, Oe[1] + Se, Oe[0] + Se);
          }
          (pe = u + x * 2), (Se = Y * pe);
          for (let me = 0; me < Ie; me++) {
            const Oe = Ee[me];
            Fe(Oe[0] + Se, Oe[1] + Se, Oe[2] + Se);
          }
        } else {
          for (let pe = 0; pe < Ie; pe++) {
            const Se = Ee[pe];
            Fe(Se[2], Se[1], Se[0]);
          }
          for (let pe = 0; pe < Ie; pe++) {
            const Se = Ee[pe];
            Fe(Se[0] + Y * u, Se[1] + Y * u, Se[2] + Y * u);
          }
        }
        r.addGroup(ge, i.length / 3 - ge, 0);
      }
      function re() {
        const ge = i.length / 3;
        let pe = 0;
        Be(Z, pe), (pe += Z.length);
        for (let Se = 0, me = D.length; Se < me; Se++) {
          const Oe = D[Se];
          Be(Oe, pe), (pe += Oe.length);
        }
        r.addGroup(ge, i.length / 3 - ge, 1);
      }
      function Be(ge, pe) {
        let Se = ge.length;
        for (; --Se >= 0; ) {
          const me = Se;
          let Oe = Se - 1;
          Oe < 0 && (Oe = ge.length - 1);
          for (let Te = 0, De = u + x * 2; Te < De; Te++) {
            const _t = Y * Te,
              wt = Y * (Te + 1),
              B = pe + me + _t,
              k = pe + Oe + _t,
              ne = pe + Oe + wt,
              ae = pe + me + wt;
            Ke(B, k, ne, ae);
          }
        }
      }
      function Ue(ge, pe, Se) {
        l.push(ge), l.push(pe), l.push(Se);
      }
      function Fe(ge, pe, Se) {
        Ve(ge), Ve(pe), Ve(Se);
        const me = i.length / 3,
          Oe = _.generateTopUV(r, i, me - 3, me - 2, me - 1);
        W(Oe[0]), W(Oe[1]), W(Oe[2]);
      }
      function Ke(ge, pe, Se, me) {
        Ve(ge), Ve(pe), Ve(me), Ve(pe), Ve(Se), Ve(me);
        const Oe = i.length / 3,
          Te = _.generateSideWallUV(r, i, Oe - 6, Oe - 3, Oe - 2, Oe - 1);
        W(Te[0]), W(Te[1]), W(Te[3]), W(Te[1]), W(Te[2]), W(Te[3]);
      }
      function Ve(ge) {
        i.push(l[ge * 3 + 0]), i.push(l[ge * 3 + 1]), i.push(l[ge * 3 + 2]);
      }
      function W(ge) {
        s.push(ge.x), s.push(ge.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      r = this.parameters.options;
    return aie(t, r, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      r.push(a);
    }
    const i = e.options.extrudePath;
    return (
      i !== void 0 && (e.options.extrudePath = new ax[i.type]().fromJSON(i)),
      new p_(r, e.options)
    );
  }
}
const oie = {
  generateTopUV: function (n, e, t, r, i) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[r * 3],
      l = e[r * 3 + 1],
      c = e[i * 3],
      u = e[i * 3 + 1];
    return [new xe(s, o), new xe(a, l), new xe(c, u)];
  },
  generateSideWallUV: function (n, e, t, r, i, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[r * 3],
      u = e[r * 3 + 1],
      f = e[r * 3 + 2],
      p = e[i * 3],
      m = e[i * 3 + 1],
      v = e[i * 3 + 2],
      y = e[s * 3],
      x = e[s * 3 + 1],
      g = e[s * 3 + 2];
    return Math.abs(a - u) < Math.abs(o - c)
      ? [new xe(o, 1 - l), new xe(c, 1 - f), new xe(p, 1 - v), new xe(y, 1 - g)]
      : [
          new xe(a, 1 - l),
          new xe(u, 1 - f),
          new xe(m, 1 - v),
          new xe(x, 1 - g),
        ];
  },
};
function aie(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let r = 0, i = n.length; r < i; r++) {
      const s = n[r];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class m_ extends bl {
  constructor(e = 1, t = 0) {
    const r = (1 + Math.sqrt(5)) / 2,
      i = [
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        0,
        0,
        -1,
        r,
        0,
        1,
        r,
        0,
        -1,
        -r,
        0,
        1,
        -r,
        r,
        0,
        -1,
        r,
        0,
        1,
        -r,
        0,
        -1,
        -r,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(i, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new m_(e.radius, e.detail);
  }
}
class g_ extends kt {
  constructor(
    e = [new xe(0, -0.5), new xe(0.5, 0), new xe(0, 0.5)],
    t = 12,
    r = 0,
    i = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: r, phiLength: i }),
      (t = Math.floor(t)),
      (i = St(i, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = [],
      u = 1 / t,
      f = new z(),
      p = new xe(),
      m = new z(),
      v = new z(),
      y = new z();
    let x = 0,
      g = 0;
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            y.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(y.x, y.y, y.z);
          break;
        default:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            v.copy(m),
            (m.x += y.x),
            (m.y += y.y),
            (m.z += y.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            y.copy(v);
      }
    for (let _ = 0; _ <= t; _++) {
      const S = r + _ * u * i,
        b = Math.sin(S),
        C = Math.cos(S);
      for (let A = 0; A <= e.length - 1; A++) {
        (f.x = e[A].x * b),
          (f.y = e[A].y),
          (f.z = e[A].x * C),
          o.push(f.x, f.y, f.z),
          (p.x = _ / t),
          (p.y = A / (e.length - 1)),
          a.push(p.x, p.y);
        const R = l[3 * A + 0] * b,
          O = l[3 * A + 1],
          I = l[3 * A + 0] * C;
        c.push(R, O, I);
      }
    }
    for (let _ = 0; _ < t; _++)
      for (let S = 0; S < e.length - 1; S++) {
        const b = S + _ * e.length,
          C = b,
          A = b + e.length,
          R = b + e.length + 1,
          O = b + 1;
        s.push(C, A, O), s.push(R, O, A);
      }
    this.setIndex(s),
      this.setAttribute("position", new st(o, 3)),
      this.setAttribute("uv", new st(a, 2)),
      this.setAttribute("normal", new st(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new g_(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Rm extends bl {
  constructor(e = 1, t = 0) {
    const r = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      i = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(r, i, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Rm(e.radius, e.detail);
  }
}
class Oh extends kt {
  constructor(e = 1, t = 1, r = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: r,
        heightSegments: i,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(r),
      l = Math.floor(i),
      c = a + 1,
      u = l + 1,
      f = e / a,
      p = t / l,
      m = [],
      v = [],
      y = [],
      x = [];
    for (let g = 0; g < u; g++) {
      const _ = g * p - o;
      for (let S = 0; S < c; S++) {
        const b = S * f - s;
        v.push(b, -_, 0), y.push(0, 0, 1), x.push(S / a), x.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let _ = 0; _ < a; _++) {
        const S = _ + c * g,
          b = _ + c * (g + 1),
          C = _ + 1 + c * (g + 1),
          A = _ + 1 + c * g;
        m.push(S, b, A), m.push(b, C, A);
      }
    this.setIndex(m),
      this.setAttribute("position", new st(v, 3)),
      this.setAttribute("normal", new st(y, 3)),
      this.setAttribute("uv", new st(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Oh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
class v_ extends kt {
  constructor(e = 0.5, t = 1, r = 32, i = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: r,
        phiSegments: i,
        thetaStart: s,
        thetaLength: o,
      }),
      (r = Math.max(3, r)),
      (i = Math.max(1, i));
    const a = [],
      l = [],
      c = [],
      u = [];
    let f = e;
    const p = (t - e) / i,
      m = new z(),
      v = new xe();
    for (let y = 0; y <= i; y++) {
      for (let x = 0; x <= r; x++) {
        const g = s + (x / r) * o;
        (m.x = f * Math.cos(g)),
          (m.y = f * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          c.push(0, 0, 1),
          (v.x = (m.x / t + 1) / 2),
          (v.y = (m.y / t + 1) / 2),
          u.push(v.x, v.y);
      }
      f += p;
    }
    for (let y = 0; y < i; y++) {
      const x = y * (r + 1);
      for (let g = 0; g < r; g++) {
        const _ = g + x,
          S = _,
          b = _ + r + 1,
          C = _ + r + 2,
          A = _ + 1;
        a.push(S, b, A), a.push(b, C, A);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new st(l, 3)),
      this.setAttribute("normal", new st(c, 3)),
      this.setAttribute("uv", new st(u, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new v_(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class y_ extends kt {
  constructor(
    e = new Nc([new xe(0, 0.5), new xe(-0.5, -0.5), new xe(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const r = [],
      i = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let u = 0; u < e.length; u++)
        c(e[u]), this.addGroup(a, l, u), (a += l), (l = 0);
    this.setIndex(r),
      this.setAttribute("position", new st(i, 3)),
      this.setAttribute("normal", new st(s, 3)),
      this.setAttribute("uv", new st(o, 2));
    function c(u) {
      const f = i.length / 3,
        p = u.extractPoints(t);
      let m = p.shape;
      const v = p.holes;
      Ns.isClockWise(m) === !1 && (m = m.reverse());
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        Ns.isClockWise(_) === !0 && (v[x] = _.reverse());
      }
      const y = Ns.triangulateShape(m, v);
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        m = m.concat(_);
      }
      for (let x = 0, g = m.length; x < g; x++) {
        const _ = m[x];
        i.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y);
      }
      for (let x = 0, g = y.length; x < g; x++) {
        const _ = y[x],
          S = _[0] + f,
          b = _[1] + f,
          C = _[2] + f;
        r.push(S, b, C), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return lie(t, e);
  }
  static fromJSON(e, t) {
    const r = [];
    for (let i = 0, s = e.shapes.length; i < s; i++) {
      const o = t[e.shapes[i]];
      r.push(o);
    }
    return new y_(r, e.curveSegments);
  }
}
function lie(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, r = n.length; t < r; t++) {
      const i = n[t];
      e.shapes.push(i.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class Pm extends kt {
  constructor(
    e = 1,
    t = 32,
    r = 16,
    i = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: r,
        phiStart: i,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (r = Math.max(2, Math.floor(r)));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const u = [],
      f = new z(),
      p = new z(),
      m = [],
      v = [],
      y = [],
      x = [];
    for (let g = 0; g <= r; g++) {
      const _ = [],
        S = g / r;
      let b = 0;
      g === 0 && o === 0
        ? (b = 0.5 / t)
        : g === r && l === Math.PI && (b = -0.5 / t);
      for (let C = 0; C <= t; C++) {
        const A = C / t;
        (f.x = -e * Math.cos(i + A * s) * Math.sin(o + S * a)),
          (f.y = e * Math.cos(o + S * a)),
          (f.z = e * Math.sin(i + A * s) * Math.sin(o + S * a)),
          v.push(f.x, f.y, f.z),
          p.copy(f).normalize(),
          y.push(p.x, p.y, p.z),
          x.push(A + b, 1 - S),
          _.push(c++);
      }
      u.push(_);
    }
    for (let g = 0; g < r; g++)
      for (let _ = 0; _ < t; _++) {
        const S = u[g][_ + 1],
          b = u[g][_],
          C = u[g + 1][_],
          A = u[g + 1][_ + 1];
        (g !== 0 || o > 0) && m.push(S, b, A),
          (g !== r - 1 || l < Math.PI) && m.push(b, C, A);
      }
    this.setIndex(m),
      this.setAttribute("position", new st(v, 3)),
      this.setAttribute("normal", new st(y, 3)),
      this.setAttribute("uv", new st(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Pm(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class x_ extends bl {
  constructor(e = 1, t = 0) {
    const r = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(r, i, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new x_(e.radius, e.detail);
  }
}
class __ extends kt {
  constructor(e = 1, t = 0.4, r = 12, i = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: r,
        tubularSegments: i,
        arc: s,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const o = [],
      a = [],
      l = [],
      c = [],
      u = new z(),
      f = new z(),
      p = new z();
    for (let m = 0; m <= r; m++)
      for (let v = 0; v <= i; v++) {
        const y = (v / i) * s,
          x = (m / r) * Math.PI * 2;
        (f.x = (e + t * Math.cos(x)) * Math.cos(y)),
          (f.y = (e + t * Math.cos(x)) * Math.sin(y)),
          (f.z = t * Math.sin(x)),
          a.push(f.x, f.y, f.z),
          (u.x = e * Math.cos(y)),
          (u.y = e * Math.sin(y)),
          p.subVectors(f, u).normalize(),
          l.push(p.x, p.y, p.z),
          c.push(v / i),
          c.push(m / r);
      }
    for (let m = 1; m <= r; m++)
      for (let v = 1; v <= i; v++) {
        const y = (i + 1) * m + v - 1,
          x = (i + 1) * (m - 1) + v - 1,
          g = (i + 1) * (m - 1) + v,
          _ = (i + 1) * m + v;
        o.push(y, x, _), o.push(x, g, _);
      }
    this.setIndex(o),
      this.setAttribute("position", new st(a, 3)),
      this.setAttribute("normal", new st(l, 3)),
      this.setAttribute("uv", new st(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new __(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class w_ extends kt {
  constructor(e = 1, t = 0.4, r = 64, i = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: r,
        radialSegments: i,
        p: s,
        q: o,
      }),
      (r = Math.floor(r)),
      (i = Math.floor(i));
    const a = [],
      l = [],
      c = [],
      u = [],
      f = new z(),
      p = new z(),
      m = new z(),
      v = new z(),
      y = new z(),
      x = new z(),
      g = new z();
    for (let S = 0; S <= r; ++S) {
      const b = (S / r) * s * Math.PI * 2;
      _(b, s, o, e, m),
        _(b + 0.01, s, o, e, v),
        x.subVectors(v, m),
        g.addVectors(v, m),
        y.crossVectors(x, g),
        g.crossVectors(y, x),
        y.normalize(),
        g.normalize();
      for (let C = 0; C <= i; ++C) {
        const A = (C / i) * Math.PI * 2,
          R = -t * Math.cos(A),
          O = t * Math.sin(A);
        (f.x = m.x + (R * g.x + O * y.x)),
          (f.y = m.y + (R * g.y + O * y.y)),
          (f.z = m.z + (R * g.z + O * y.z)),
          l.push(f.x, f.y, f.z),
          p.subVectors(f, m).normalize(),
          c.push(p.x, p.y, p.z),
          u.push(S / r),
          u.push(C / i);
      }
    }
    for (let S = 1; S <= r; S++)
      for (let b = 1; b <= i; b++) {
        const C = (i + 1) * (S - 1) + (b - 1),
          A = (i + 1) * S + (b - 1),
          R = (i + 1) * S + b,
          O = (i + 1) * (S - 1) + b;
        a.push(C, A, O), a.push(A, R, O);
      }
    this.setIndex(a),
      this.setAttribute("position", new st(l, 3)),
      this.setAttribute("normal", new st(c, 3)),
      this.setAttribute("uv", new st(u, 2));
    function _(S, b, C, A, R) {
      const O = Math.cos(S),
        I = Math.sin(S),
        N = (C / b) * S,
        D = Math.cos(N);
      (R.x = A * (2 + D) * 0.5 * O),
        (R.y = A * (2 + D) * I * 0.5),
        (R.z = A * Math.sin(N) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new w_(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class S_ extends kt {
  constructor(
    e = new qC(new z(-1, -1, 0), new z(-1, 1, 0), new z(1, 1, 0)),
    t = 64,
    r = 1,
    i = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: r,
        radialSegments: i,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new z(),
      l = new z(),
      c = new xe();
    let u = new z();
    const f = [],
      p = [],
      m = [],
      v = [];
    y(),
      this.setIndex(v),
      this.setAttribute("position", new st(f, 3)),
      this.setAttribute("normal", new st(p, 3)),
      this.setAttribute("uv", new st(m, 2));
    function y() {
      for (let S = 0; S < t; S++) x(S);
      x(s === !1 ? t : 0), _(), g();
    }
    function x(S) {
      u = e.getPointAt(S / t, u);
      const b = o.normals[S],
        C = o.binormals[S];
      for (let A = 0; A <= i; A++) {
        const R = (A / i) * Math.PI * 2,
          O = Math.sin(R),
          I = -Math.cos(R);
        (l.x = I * b.x + O * C.x),
          (l.y = I * b.y + O * C.y),
          (l.z = I * b.z + O * C.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = u.x + r * l.x),
          (a.y = u.y + r * l.y),
          (a.z = u.z + r * l.z),
          f.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let S = 1; S <= t; S++)
        for (let b = 1; b <= i; b++) {
          const C = (i + 1) * (S - 1) + (b - 1),
            A = (i + 1) * S + (b - 1),
            R = (i + 1) * S + b,
            O = (i + 1) * (S - 1) + b;
          v.push(C, A, O), v.push(A, R, O);
        }
    }
    function _() {
      for (let S = 0; S <= t; S++)
        for (let b = 0; b <= i; b++)
          (c.x = S / t), (c.y = b / i), m.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new S_(
      new ax[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class EV extends kt {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        r = new Set(),
        i = new z(),
        s = new z();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, u = l.length; c < u; ++c) {
          const f = l[c],
            p = f.start,
            m = f.count;
          for (let v = p, y = p + m; v < y; v += 3)
            for (let x = 0; x < 3; x++) {
              const g = a.getX(v + x),
                _ = a.getX(v + ((x + 1) % 3));
              i.fromBufferAttribute(o, g),
                s.fromBufferAttribute(o, _),
                CL(i, s, r) === !0 &&
                  (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const u = 3 * a + c,
              f = 3 * a + ((c + 1) % 3);
            i.fromBufferAttribute(o, u),
              s.fromBufferAttribute(o, f),
              CL(i, s, r) === !0 &&
                (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new st(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function CL(n, e, t) {
  const r = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    i = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(r) === !0 || t.has(i) === !0 ? !1 : (t.add(r), t.add(i), !0);
}
var AL = Object.freeze({
  __proto__: null,
  BoxGeometry: Qc,
  CapsuleGeometry: u_,
  CircleGeometry: d_,
  ConeGeometry: Am,
  CylinderGeometry: Cm,
  DodecahedronGeometry: h_,
  EdgesGeometry: pV,
  ExtrudeGeometry: p_,
  IcosahedronGeometry: m_,
  LatheGeometry: g_,
  OctahedronGeometry: Rm,
  PlaneGeometry: Oh,
  PolyhedronGeometry: bl,
  RingGeometry: v_,
  ShapeGeometry: y_,
  SphereGeometry: Pm,
  TetrahedronGeometry: x_,
  TorusGeometry: __,
  TorusKnotGeometry: w_,
  TubeGeometry: S_,
  WireframeGeometry: EV,
});
class TV extends Ur {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Je(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class MV extends cs {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class YC extends Ur {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.type = "MeshStandardMaterial"),
      (this.defines = { STANDARD: "" }),
      (this.color = new Je(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Di()),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class CV extends YC {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new xe(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return St((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Je(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Je(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Je(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._dispersion = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, (this._dispersion = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.dispersion = e.dispersion),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class AV extends Ur {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Je(16777215)),
      (this.specular = new Je(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Di()),
      (this.combine = bm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class RV extends Ur {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class PV extends Ur {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class IV extends Ur {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Je(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Je(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new Di()),
      (this.combine = bm),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class JC extends Ur {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = V4),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class ZC extends Ur {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
class NV extends Ur {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Je(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = wl),
      (this.normalScale = new xe(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class LV extends ei {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function yc(n, e) {
  return !n || n.constructor === e
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function OV(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function DV(n) {
  function e(i, s) {
    return n[i] - n[s];
  }
  const t = n.length,
    r = new Array(t);
  for (let i = 0; i !== t; ++i) r[i] = i;
  return r.sort(e), r;
}
function XE(n, e, t) {
  const r = n.length,
    i = new n.constructor(r);
  for (let s = 0, o = 0; o !== r; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) i[o++] = n[a + l];
  }
  return i;
}
function QC(n, e, t, r) {
  let i = 1,
    s = n[0];
  for (; s !== void 0 && s[r] === void 0; ) s = n[i++];
  if (s === void 0) return;
  let o = s[r];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), t.push(...o)),
          (s = n[i++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[r]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[i++]);
      while (s !== void 0);
    else
      do (o = s[r]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[i++]);
      while (s !== void 0);
}
function cie(n, e, t, r, i = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l],
      u = c.getValueSize(),
      f = [],
      p = [];
    for (let m = 0; m < c.times.length; ++m) {
      const v = c.times[m] * i;
      if (!(v < t || v >= r)) {
        f.push(c.times[m]);
        for (let y = 0; y < u; ++y) p.push(c.values[m * u + y]);
      }
    }
    f.length !== 0 &&
      ((c.times = yc(f, c.times.constructor)),
      (c.values = yc(p, c.values.constructor)),
      o.push(c));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function uie(n, e = 0, t = n, r = 30) {
  r <= 0 && (r = 30);
  const i = t.tracks.length,
    s = e / r;
  for (let o = 0; o < i; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = n.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let u = 0;
    const f = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (u = f / 3);
    let p = 0;
    const m = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const v = a.times.length - 1;
    let y;
    if (s <= a.times[0]) {
      const g = u,
        _ = f - u;
      y = a.values.slice(g, _);
    } else if (s >= a.times[v]) {
      const g = v * f + u,
        _ = g + f - u;
      y = a.values.slice(g, _);
    } else {
      const g = a.createInterpolant(),
        _ = u,
        S = f - u;
      g.evaluate(s), (y = g.resultBuffer.slice(_, S));
    }
    l === "quaternion" &&
      new vi().fromArray(y).normalize().conjugate().toArray(y);
    const x = c.times.length;
    for (let g = 0; g < x; ++g) {
      const _ = g * m + p;
      if (l === "quaternion")
        vi.multiplyQuaternionsFlat(c.values, _, y, 0, c.values, _);
      else {
        const S = m - p * 2;
        for (let b = 0; b < S; ++b) c.values[_ + b] -= y[b];
      }
    }
  }
  return (n.blendMode = LC), n;
}
class die {
  static convertArray(e, t) {
    return yc(e, t);
  }
  static isTypedArray(e) {
    return OV(e);
  }
  static getKeyframeOrder(e) {
    return DV(e);
  }
  static sortedArray(e, t, r) {
    return XE(e, t, r);
  }
  static flattenJSON(e, t, r, i) {
    QC(e, t, r, i);
  }
  static subclip(e, t, r, i, s = 30) {
    return cie(e, t, r, i, s);
  }
  static makeClipAdditive(e, t = 0, r = e, i = 30) {
    return uie(e, t, r, i);
  }
}
class Im {
  constructor(e, t, r, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(r)),
      (this.sampleValues = t),
      (this.valueSize = r),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let r = this._cachedIndex,
      i = t[r],
      s = t[r - 1];
    e: {
      t: {
        let o;
        n: {
          r: if (!(e < i)) {
            for (let a = r + 2; ; ) {
              if (i === void 0) {
                if (e < s) break r;
                return (
                  (r = t.length),
                  (this._cachedIndex = r),
                  this.copySampleValue_(r - 1)
                );
              }
              if (r === a) break;
              if (((s = i), (i = t[++r]), e < i)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((r = 2), (s = a));
            for (let l = r - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (r === l) break;
              if (((i = s), (s = t[--r - 1]), e >= s)) break t;
            }
            (o = r), (r = 0);
            break n;
          }
          break e;
        }
        for (; r < o; ) {
          const a = (r + o) >>> 1;
          e < t[a] ? (o = a) : (r = a + 1);
        }
        if (((i = t[r]), (s = t[r - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (r = t.length),
            (this._cachedIndex = r),
            this.copySampleValue_(r - 1)
          );
      }
      (this._cachedIndex = r), this.intervalChanged_(r, s, i);
    }
    return this.interpolate_(r, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      r = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let o = 0; o !== i; ++o) t[o] = r[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class kV extends Im {
  constructor(e, t, r, i) {
    super(e, t, r, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: gc, endingEnd: gc });
  }
  intervalChanged_(e, t, r) {
    const i = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = i[s],
      l = i[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case vc:
          (s = e), (a = 2 * t - r);
          break;
        case Yp:
          (s = i.length - 2), (a = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (a = r);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case vc:
          (o = e), (l = 2 * r - t);
          break;
        case Yp:
          (o = 1), (l = r + i[1] - i[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (r - t) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - r)),
      (this._offsetPrev = s * u),
      (this._offsetNext = o * u);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = this._offsetPrev,
      f = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      v = (r - t) / (i - t),
      y = v * v,
      x = y * v,
      g = -p * x + 2 * p * y - p * v,
      _ = (1 + p) * x + (-1.5 - 2 * p) * y + (-0.5 + p) * v + 1,
      S = (-1 - m) * x + (1.5 + m) * y + 0.5 * v,
      b = m * x - m * y;
    for (let C = 0; C !== a; ++C)
      s[C] = g * o[u + C] + _ * o[c + C] + S * o[l + C] + b * o[f + C];
    return s;
  }
}
class eA extends Im {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      u = (r - t) / (i - t),
      f = 1 - u;
    for (let p = 0; p !== a; ++p) s[p] = o[c + p] * f + o[l + p] * u;
    return s;
  }
}
class UV extends Im {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class us {
  constructor(e, t, r, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = yc(t, this.TimeBufferType)),
      (this.values = yc(r, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let r;
    if (t.toJSON !== this.toJSON) r = t.toJSON(e);
    else {
      r = {
        name: e.name,
        times: yc(e.times, Array),
        values: yc(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (r.interpolation = i);
    }
    return (r.type = e.ValueTypeName), r;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new UV(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new eA(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new kV(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Kp:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case rx:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Py:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const r =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(r);
      return console.warn("THREE.KeyframeTrack:", r), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Kp;
      case this.InterpolantFactoryMethodLinear:
        return rx;
      case this.InterpolantFactoryMethodSmooth:
        return Py;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let r = 0, i = t.length; r !== i; ++r) t[r] *= e;
    }
    return this;
  }
  trim(e, t) {
    const r = this.times,
      i = r.length;
    let s = 0,
      o = i - 1;
    for (; s !== i && r[s] < e; ) ++s;
    for (; o !== -1 && r[o] > t; ) --o;
    if ((++o, s !== 0 || o !== i)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = r.slice(s, o)),
        (this.values = this.values.slice(s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const r = this.times,
      i = this.values,
      s = r.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = r[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (i !== void 0 && OV(i))
      for (let a = 0, l = i.length; a !== l; ++a) {
        const c = i[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.getValueSize(),
      i = this.getInterpolation() === Py,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        u = e[a + 1];
      if (c !== u && (a !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const f = a * r,
            p = f - r,
            m = f + r;
          for (let v = 0; v !== r; ++v) {
            const y = t[f + v];
            if (y !== t[p + v] || y !== t[m + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const f = a * r,
            p = o * r;
          for (let m = 0; m !== r; ++m) t[p + m] = t[f + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * r, l = o * r, c = 0; c !== r; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * r)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = this.times.slice(),
      t = this.values.slice(),
      r = this.constructor,
      i = new r(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
us.prototype.ValueTypeName = "";
us.prototype.TimeBufferType = Float32Array;
us.prototype.ValueBufferType = Float32Array;
us.prototype.DefaultInterpolation = rx;
class eu extends us {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
eu.prototype.ValueTypeName = "bool";
eu.prototype.ValueBufferType = Array;
eu.prototype.DefaultInterpolation = Kp;
eu.prototype.InterpolantFactoryMethodLinear = void 0;
eu.prototype.InterpolantFactoryMethodSmooth = void 0;
class tA extends us {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
}
tA.prototype.ValueTypeName = "color";
class rm extends us {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
}
rm.prototype.ValueTypeName = "number";
class FV extends Im {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  interpolate_(e, t, r, i) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (r - t) / (i - t);
    let c = e * a;
    for (let u = c + a; c !== u; c += 4) vi.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class Nm extends us {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
  InterpolantFactoryMethodLinear(e) {
    return new FV(this.times, this.values, this.getValueSize(), e);
  }
}
Nm.prototype.ValueTypeName = "quaternion";
Nm.prototype.InterpolantFactoryMethodSmooth = void 0;
class tu extends us {
  constructor(e, t, r) {
    super(e, t, r);
  }
}
tu.prototype.ValueTypeName = "string";
tu.prototype.ValueBufferType = Array;
tu.prototype.DefaultInterpolation = Kp;
tu.prototype.InterpolantFactoryMethodLinear = void 0;
tu.prototype.InterpolantFactoryMethodSmooth = void 0;
class im extends us {
  constructor(e, t, r, i) {
    super(e, t, r, i);
  }
}
im.prototype.ValueTypeName = "vector";
class sm {
  constructor(e = "", t = -1, r = [], i = t_) {
    (this.name = e),
      (this.tracks = r),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = Li()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      r = e.tracks,
      i = 1 / (e.fps || 1);
    for (let o = 0, a = r.length; o !== a; ++o) t.push(fie(r[o]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      r = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = r.length; s !== o; ++s) t.push(us.toJSON(r[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, r, i) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
      const u = DV(l);
      (l = XE(l, 1, u)),
        (c = XE(c, 1, u)),
        !i && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new rm(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / r)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let r = e;
    if (!Array.isArray(e)) {
      const i = e;
      r = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < r.length; i++) if (r[i].name === t) return r[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, r) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const f = u[1];
        let p = i[f];
        p || (i[f] = p = []), p.push(c);
      }
    }
    const o = [];
    for (const a in i)
      o.push(this.CreateFromMorphTargetSequence(a, i[a], t, r));
    return o;
  }
  static parseAnimation(e, t) {
    if (
      (console.warn(
        "THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"
      ),
      !e)
    )
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const r = function (f, p, m, v, y) {
        if (m.length !== 0) {
          const x = [],
            g = [];
          QC(m, x, g, v), x.length !== 0 && y.push(new f(p, x, g));
        }
      },
      i = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let f = 0; f < c.length; f++) {
      const p = c[f].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let y = 0; y < p[v].morphTargets.length; y++)
                m[p[v].morphTargets[y]] = -1;
          for (const y in m) {
            const x = [],
              g = [];
            for (let _ = 0; _ !== p[v].morphTargets.length; ++_) {
              const S = p[v];
              x.push(S.time), g.push(S.morphTarget === y ? 1 : 0);
            }
            i.push(new rm(".morphTargetInfluence[" + y + "]", x, g));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[f].name + "]";
          r(im, m + ".position", p, "pos", i),
            r(Nm, m + ".quaternion", p, "rot", i),
            r(im, m + ".scale", p, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let r = 0, i = e.length; r !== i; ++r) {
      const s = this.tracks[r];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function hie(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return rm;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return im;
    case "color":
      return tA;
    case "quaternion":
      return Nm;
    case "bool":
    case "boolean":
      return eu;
    case "string":
      return tu;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function fie(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = hie(n.type);
  if (n.times === void 0) {
    const t = [],
      r = [];
    QC(n.keys, t, r, "value"), (n.times = t), (n.values = r);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const ao = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class nA {
  constructor(e, t, r) {
    const i = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = r),
      (this.abortController = new AbortController()),
      (this.itemStart = function (u) {
        a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), (s = !0);
      }),
      (this.itemEnd = function (u) {
        o++,
          i.onProgress !== void 0 && i.onProgress(u, o, a),
          o === a && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, f) {
        return c.push(u, f), this;
      }),
      (this.removeHandler = function (u) {
        const f = c.indexOf(u);
        return f !== -1 && c.splice(f, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let f = 0, p = c.length; f < p; f += 2) {
          const m = c[f],
            v = c[f + 1];
          if ((m.global && (m.lastIndex = 0), m.test(u))) return v;
        }
        return null;
      }),
      (this.abort = function () {
        return (
          this.abortController.abort(),
          (this.abortController = new AbortController()),
          this
        );
      });
  }
}
const BV = new nA();
class yi {
  constructor(e) {
    (this.manager = e !== void 0 ? e : BV),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const r = this;
    return new Promise(function (i, s) {
      r.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
  abort() {
    return this;
  }
}
yi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const ko = {};
class pie extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class oa extends yi {
  constructor(e) {
    super(e),
      (this.mimeType = ""),
      (this.responseType = ""),
      (this._abortController = new AbortController());
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = ao.get(`file:${e}`);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (ko[e] !== void 0) {
      ko[e].push({ onLoad: t, onProgress: r, onError: i });
      return;
    }
    (ko[e] = []), ko[e].push({ onLoad: t, onProgress: r, onError: i });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
        signal:
          typeof AbortSignal.any == "function"
            ? AbortSignal.any([
                this._abortController.signal,
                this.manager.abortController.signal,
              ])
            : this._abortController.signal,
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = ko[e],
            f = c.body.getReader(),
            p = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
            m = p ? parseInt(p) : 0,
            v = m !== 0;
          let y = 0;
          const x = new ReadableStream({
            start(g) {
              _();
              function _() {
                f.read().then(
                  ({ done: S, value: b }) => {
                    if (S) g.close();
                    else {
                      y += b.byteLength;
                      const C = new ProgressEvent("progress", {
                        lengthComputable: v,
                        loaded: y,
                        total: m,
                      });
                      for (let A = 0, R = u.length; A < R; A++) {
                        const O = u[A];
                        O.onProgress && O.onProgress(C);
                      }
                      g.enqueue(b), _();
                    }
                  },
                  (S) => {
                    g.error(S);
                  }
                );
              }
            },
          });
          return new Response(x);
        } else
          throw new pie(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, a));
          case "json":
            return c.json();
          default:
            if (a === "") return c.text();
            {
              const f = /charset="?([^;"\s]*)"?/i.exec(a),
                p = f && f[1] ? f[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return c.arrayBuffer().then((v) => m.decode(v));
            }
        }
      })
      .then((c) => {
        ao.add(`file:${e}`, c);
        const u = ko[e];
        delete ko[e];
        for (let f = 0, p = u.length; f < p; f++) {
          const m = u[f];
          m.onLoad && m.onLoad(c);
        }
      })
      .catch((c) => {
        const u = ko[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete ko[e];
        for (let f = 0, p = u.length; f < p; f++) {
          const m = u[f];
          m.onError && m.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
class mie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new oa(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = [];
    for (let r = 0; r < e.length; r++) {
      const i = sm.parse(e[r]);
      t.push(i);
    }
    return t;
  }
}
class gie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = [],
      a = new c_(),
      l = new oa(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let c = 0;
    function u(f) {
      l.load(
        e[f],
        function (p) {
          const m = s.parse(p, !0);
          (o[f] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = Zn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        r,
        i
      );
    }
    if (Array.isArray(e)) for (let f = 0, p = e.length; f < p; ++f) u(f);
    else
      l.load(
        e,
        function (f) {
          const p = s.parse(f, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < m; v++) {
              o[v] = { mipmaps: [] };
              for (let y = 0; y < p.mipmapCount; y++)
                o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + y]),
                  (o[v].format = p.format),
                  (o[v].width = p.width),
                  (o[v].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = Zn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        r,
        i
      );
    return a;
  }
}
const Hu = new WeakMap();
class om extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = ao.get(`image:${e}`);
    if (o !== void 0) {
      if (o.complete === !0)
        s.manager.itemStart(e),
          setTimeout(function () {
            t && t(o), s.manager.itemEnd(e);
          }, 0);
      else {
        let f = Hu.get(o);
        f === void 0 && ((f = []), Hu.set(o, f)),
          f.push({ onLoad: t, onError: i });
      }
      return o;
    }
    const a = Qp("img");
    function l() {
      u(), t && t(this);
      const f = Hu.get(this) || [];
      for (let p = 0; p < f.length; p++) {
        const m = f[p];
        m.onLoad && m.onLoad(this);
      }
      Hu.delete(this), s.manager.itemEnd(e);
    }
    function c(f) {
      u(), i && i(f), ao.remove(`image:${e}`);
      const p = Hu.get(this) || [];
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        v.onError && v.onError(f);
      }
      Hu.delete(this), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      ao.add(`image:${e}`, a),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class vie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new Mm();
    s.colorSpace = li;
    const o = new om(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(
        e[c],
        function (u) {
          (s.images[c] = u), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        i
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return s;
  }
}
class yie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new vo(),
      a = new oa(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          let c;
          try {
            c = s.parse(l);
          } catch (u) {
            if (i !== void 0) i(u);
            else {
              console.error(u);
              return;
            }
          }
          c.image !== void 0
            ? (o.image = c.image)
            : c.data !== void 0 &&
              ((o.image.width = c.width),
              (o.image.height = c.height),
              (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : rs),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : rs),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : Zn),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : Zn),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = oo)),
            c.mipmapCount === 1 && (o.minFilter = Zn),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c);
        },
        r,
        i
      ),
      o
    );
  }
}
class xie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = new Nn(),
      o = new om(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        r,
        i
      ),
      s
    );
  }
}
class El extends Xt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Je(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      this.target !== void 0 && (t.object.target = this.target.uuid),
      t
    );
  }
}
class zV extends El {
  constructor(e, t, r) {
    super(e, r),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Xt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Je(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const C1 = new Tt(),
  RL = new z(),
  PL = new z();
class rA {
  constructor(e) {
    (this.camera = e),
      (this.intensity = 1),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new xe(512, 512)),
      (this.mapType = ls),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Tt()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Lh()),
      (this._frameExtents = new xe(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Gt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      r = this.matrix;
    RL.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(RL),
      PL.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(PL),
      t.updateMatrixWorld(),
      C1.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(
        C1,
        t.coordinateSystem,
        t.reversedDepth
      ),
      t.reversedDepth
        ? r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 1, 0, 0, 0, 0, 1)
        : r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      r.multiply(C1);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.intensity = e.intensity),
      (this.bias = e.bias),
      (this.radius = e.radius),
      (this.autoUpdate = e.autoUpdate),
      (this.needsUpdate = e.needsUpdate),
      (this.normalBias = e.normalBias),
      (this.blurSamples = e.blurSamples),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.intensity !== 1 && (e.intensity = this.intensity),
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class _ie extends rA {
  constructor() {
    super(new lr(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1),
      (this.aspect = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      r = uh * 2 * e.angle * this.focus,
      i = (this.mapSize.width / this.mapSize.height) * this.aspect,
      s = e.distance || t.far;
    (r !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = r), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class VV extends El {
  constructor(e, t, r = 0, i = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Xt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Xt()),
      (this.distance = r),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new _ie());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const IL = new Tt(),
  Tf = new z(),
  A1 = new z();
class wie extends rA {
  constructor() {
    super(new lr(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new xe(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Gt(2, 1, 1, 1),
        new Gt(0, 1, 1, 1),
        new Gt(3, 1, 1, 1),
        new Gt(1, 1, 1, 1),
        new Gt(3, 0, 1, 1),
        new Gt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new z(1, 0, 0),
        new z(-1, 0, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
        new z(0, 1, 0),
        new z(0, -1, 0),
      ]),
      (this._cubeUps = [
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 1, 0),
        new z(0, 0, 1),
        new z(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const r = this.camera,
      i = this.matrix,
      s = e.distance || r.far;
    s !== r.far && ((r.far = s), r.updateProjectionMatrix()),
      Tf.setFromMatrixPosition(e.matrixWorld),
      r.position.copy(Tf),
      A1.copy(r.position),
      A1.add(this._cubeDirections[t]),
      r.up.copy(this._cubeUps[t]),
      r.lookAt(A1),
      r.updateMatrixWorld(),
      i.makeTranslation(-Tf.x, -Tf.y, -Tf.z),
      IL.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(
        IL,
        r.coordinateSystem,
        r.reversedDepth
      );
  }
}
class jV extends El {
  constructor(e, t, r = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = r),
      (this.decay = i),
      (this.shadow = new wie());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Lm extends Tm {
  constructor(e = -1, t = 1, r = 1, i = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = r),
      (this.bottom = i),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, r, i, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = r),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      r = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = r - e,
      o = r + e,
      a = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= u * this.view.offsetY),
        (l = a - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      o,
      a,
      l,
      this.near,
      this.far,
      this.coordinateSystem,
      this.reversedDepth
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
class Sie extends rA {
  constructor() {
    super(new Lm(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class HV extends El {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Xt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Xt()),
      (this.shadow = new Sie());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class WV extends El {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class GV extends El {
  constructor(e, t, r = 10, i = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = r),
      (this.height = i);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class $V {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new z());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * i),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * r),
      t.addScaledVector(o[4], 1.092548 * (r * i)),
      t.addScaledVector(o[5], 1.092548 * (i * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (r * s)),
      t.addScaledVector(o[8], 0.546274 * (r * r - i * i)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * i),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * r),
      t.addScaledVector(o[4], 2 * 0.429043 * r * i),
      t.addScaledVector(o[5], 2 * 0.429043 * i * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * r * s),
      t.addScaledVector(o[8], 0.429043 * (r * r - i * i)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let r = 0; r < 9; r++)
      this.coefficients[r].addScaledVector(e.coefficients[r], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let r = 0; r < 9; r++) this.coefficients[r].lerp(e.coefficients[r], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].fromArray(e, t + i * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const r = this.coefficients;
    for (let i = 0; i < 9; i++) r[i].toArray(e, t + i * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const r = e.x,
      i = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * i),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * r),
      (t[4] = 1.092548 * r * i),
      (t[5] = 1.092548 * i * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * r * s),
      (t[8] = 0.546274 * (r * r - i * i));
  }
}
class XV extends El {
  constructor(e = new $V(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class b_ extends yi {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, r, i) {
    const s = this,
      o = new oa(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = this.textures;
    function r(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const i = this.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (i.uuid = e.uuid),
      e.name !== void 0 && (i.name = e.name),
      e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color),
      e.roughness !== void 0 && (i.roughness = e.roughness),
      e.metalness !== void 0 && (i.metalness = e.metalness),
      e.sheen !== void 0 && (i.sheen = e.sheen),
      e.sheenColor !== void 0 && (i.sheenColor = new Je().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        i.emissive !== void 0 &&
        i.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        i.specular !== void 0 &&
        i.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (i.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        i.specularColor !== void 0 &&
        i.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (i.shininess = e.shininess),
      e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = e.clearcoatRoughness),
      e.dispersion !== void 0 && (i.dispersion = e.dispersion),
      e.iridescence !== void 0 && (i.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (i.transmission = e.transmission),
      e.thickness !== void 0 && (i.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (i.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        i.attenuationColor !== void 0 &&
        i.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (i.fog = e.fog),
      e.flatShading !== void 0 && (i.flatShading = e.flatShading),
      e.blending !== void 0 && (i.blending = e.blending),
      e.combine !== void 0 && (i.combine = e.combine),
      e.side !== void 0 && (i.side = e.side),
      e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (i.opacity = e.opacity),
      e.transparent !== void 0 && (i.transparent = e.transparent),
      e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash),
      e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc),
      e.depthTest !== void 0 && (i.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite),
      e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc),
      e.blendDst !== void 0 && (i.blendDst = e.blendDst),
      e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation),
      e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha),
      e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha),
      e.blendEquationAlpha !== void 0 &&
        (i.blendEquationAlpha = e.blendEquationAlpha),
      e.blendColor !== void 0 &&
        i.blendColor !== void 0 &&
        i.blendColor.setHex(e.blendColor),
      e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha),
      e.stencilWriteMask !== void 0 &&
        (i.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass),
      e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite),
      e.wireframe !== void 0 && (i.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (i.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (i.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (i.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (i.rotation = e.rotation),
      e.linewidth !== void 0 && (i.linewidth = e.linewidth),
      e.dashSize !== void 0 && (i.dashSize = e.dashSize),
      e.gapSize !== void 0 && (i.gapSize = e.gapSize),
      e.scale !== void 0 && (i.scale = e.scale),
      e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (i.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (i.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (i.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (i.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (i.visible = e.visible),
      e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped),
      e.userData !== void 0 && (i.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (i.vertexColors = e.vertexColors > 0)
          : (i.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((i.uniforms[s] = {}), o.type)) {
          case "t":
            i.uniforms[s].value = r(o.value);
            break;
          case "c":
            i.uniforms[s].value = new Je().setHex(o.value);
            break;
          case "v2":
            i.uniforms[s].value = new xe().fromArray(o.value);
            break;
          case "v3":
            i.uniforms[s].value = new z().fromArray(o.value);
            break;
          case "v4":
            i.uniforms[s].value = new Gt().fromArray(o.value);
            break;
          case "m3":
            i.uniforms[s].value = new Nt().fromArray(o.value);
            break;
          case "m4":
            i.uniforms[s].value = new Tt().fromArray(o.value);
            break;
          default:
            i.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (i.defines = e.defines),
      e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) i.extensions[s] = e.extensions[s];
    if (
      (e.lights !== void 0 && (i.lights = e.lights),
      e.clipping !== void 0 && (i.clipping = e.clipping),
      e.size !== void 0 && (i.size = e.size),
      e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (i.map = r(e.map)),
      e.matcap !== void 0 && (i.matcap = r(e.matcap)),
      e.alphaMap !== void 0 && (i.alphaMap = r(e.alphaMap)),
      e.bumpMap !== void 0 && (i.bumpMap = r(e.bumpMap)),
      e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (i.normalMap = r(e.normalMap)),
      e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (i.normalScale = new xe().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (i.displacementMap = r(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (i.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (i.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (i.roughnessMap = r(e.roughnessMap)),
      e.metalnessMap !== void 0 && (i.metalnessMap = r(e.metalnessMap)),
      e.emissiveMap !== void 0 && (i.emissiveMap = r(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (i.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (i.specularMap = r(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (i.specularIntensityMap = r(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (i.specularColorMap = r(e.specularColorMap)),
      e.envMap !== void 0 && (i.envMap = r(e.envMap)),
      e.envMapRotation !== void 0 &&
        i.envMapRotation.fromArray(e.envMapRotation),
      e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (i.lightMap = r(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (i.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (i.aoMap = r(e.aoMap)),
      e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (i.gradientMap = r(e.gradientMap)),
      e.clearcoatMap !== void 0 && (i.clearcoatMap = r(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (i.clearcoatRoughnessMap = r(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (i.clearcoatNormalMap = r(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (i.clearcoatNormalScale = new xe().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (i.iridescenceMap = r(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (i.iridescenceThicknessMap = r(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (i.transmissionMap = r(e.transmissionMap)),
      e.thicknessMap !== void 0 && (i.thicknessMap = r(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (i.anisotropyMap = r(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (i.sheenColorMap = r(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (i.sheenRoughnessMap = r(e.sheenRoughnessMap)),
      i
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  createMaterialFromType(e) {
    return b_.createMaterialFromType(e);
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: TV,
      SpriteMaterial: zC,
      RawShaderMaterial: MV,
      ShaderMaterial: cs,
      PointsMaterial: jC,
      MeshPhysicalMaterial: CV,
      MeshStandardMaterial: YC,
      MeshPhongMaterial: AV,
      MeshToonMaterial: RV,
      MeshNormalMaterial: PV,
      MeshLambertMaterial: IV,
      MeshDepthMaterial: JC,
      MeshDistanceMaterial: ZC,
      MeshBasicMaterial: Sl,
      MeshMatcapMaterial: NV,
      LineDashedMaterial: LV,
      LineBasicMaterial: ei,
      Material: Ur,
    };
    return new t[e]();
  }
}
class qE {
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class qV extends kt {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class KV extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new oa(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            i ? i(l) : console.error(l), s.manager.itemError(e);
          }
        },
        r,
        i
      );
  }
  parse(e) {
    const t = {},
      r = {};
    function i(m, v) {
      if (t[v] !== void 0) return t[v];
      const x = m.interleavedBuffers[v],
        g = s(m, x.buffer),
        _ = xd(x.type, g),
        S = new o_(_, x.stride);
      return (S.uuid = x.uuid), (t[v] = S), S;
    }
    function s(m, v) {
      if (r[v] !== void 0) return r[v];
      const x = m.arrayBuffers[v],
        g = new Uint32Array(x).buffer;
      return (r[v] = g), g;
    }
    const o = e.isInstancedBufferGeometry ? new qV() : new kt(),
      a = e.data.index;
    if (a !== void 0) {
      const m = xd(a.type, a.array);
      o.setIndex(new sn(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const v = l[m];
      let y;
      if (v.isInterleavedBufferAttribute) {
        const x = i(e.data, v.data);
        y = new jc(x, v.itemSize, v.offset, v.normalized);
      } else {
        const x = xd(v.type, v.array),
          g = v.isInstancedBufferAttribute ? hh : sn;
        y = new g(x, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (y.name = v.name),
        v.usage !== void 0 && y.setUsage(v.usage),
        o.setAttribute(m, y);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const m in c) {
        const v = c[m],
          y = [];
        for (let x = 0, g = v.length; x < g; x++) {
          const _ = v[x];
          let S;
          if (_.isInterleavedBufferAttribute) {
            const b = i(e.data, _.data);
            S = new jc(b, _.itemSize, _.offset, _.normalized);
          } else {
            const b = xd(_.type, _.array);
            S = new sn(b, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (S.name = _.name), y.push(S);
        }
        o.morphAttributes[m] = y;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const f = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (f !== void 0)
      for (let m = 0, v = f.length; m !== v; ++m) {
        const y = f[m];
        o.addGroup(y.start, y.count, y.materialIndex);
      }
    const p = e.data.boundingSphere;
    return (
      p !== void 0 && (o.boundingSphere = new gr().fromJSON(p)),
      e.name && (o.name = e.name),
      e.userData && (o.userData = e.userData),
      o
    );
  }
}
class bie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = this.path === "" ? qE.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new oa(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (f) {
            i !== void 0 && i(f),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                f.message
              );
            return;
          }
          const u = c.metadata;
          if (
            u === void 0 ||
            u.type === void 0 ||
            u.type.toLowerCase() === "geometry"
          ) {
            i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(c, t);
        },
        r,
        i
      );
  }
  async loadAsync(e, t) {
    const r = this,
      i = this.path === "" ? qE.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || i;
    const s = new oa(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await r.parseAsync(a);
  }
  parse(e, t) {
    const r = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, i),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, s, l, a, r),
      u = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, u), this.bindLightTargets(c), t !== void 0)) {
      let f = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          f = !0;
          break;
        }
      f === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      i = this.parseGeometries(e.geometries, r),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, i, a, o, t),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), this.bindLightTargets(l), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0, i = e.length; r < i; r++) {
        const s = new Nc().fromJSON(e[r]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const r = {},
      i = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (i[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new a_().fromJSON(e[s], i);
        r[a.uuid] = a;
      }
    return r;
  }
  parseGeometries(e, t) {
    const r = {};
    if (e !== void 0) {
      const i = new KV();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = i.parse(l);
            break;
          default:
            l.type in AL
              ? (a = AL[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (r[l.uuid] = a);
      }
    }
    return r;
  }
  parseMaterials(e, t) {
    const r = {},
      i = {};
    if (e !== void 0) {
      const s = new b_();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        r[l.uuid] === void 0 && (r[l.uuid] = s.parse(l)),
          (i[l.uuid] = r[l.uuid]);
      }
    }
    return i;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let r = 0; r < e.length; r++) {
        const i = e[r],
          s = sm.parse(i);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const r = this,
      i = {};
    let s;
    function o(l) {
      return (
        r.manager.itemStart(l),
        s.load(
          l,
          function () {
            r.manager.itemEnd(l);
          },
          void 0,
          function () {
            r.manager.itemError(l), r.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l,
          u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : r.resourcePath + c;
        return o(u);
      } else
        return l.data
          ? { data: xd(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new nA(t);
      (s = new om(l)), s.setCrossOrigin(this.crossOrigin);
      for (let c = 0, u = e.length; c < u; c++) {
        const f = e[c],
          p = f.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, y = p.length; v < y; v++) {
            const x = p[v],
              g = a(x);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new vo(g.data, g.width, g.height)));
          }
          i[f.uuid] = new Ya(m);
        } else {
          const m = a(f.url);
          i[f.uuid] = new Ya(m);
        }
      }
    }
    return i;
  }
  async parseImagesAsync(e) {
    const t = this,
      r = {};
    let i;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await i.loadAsync(l);
      } else
        return o.data
          ? { data: xd(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (i = new om(this.manager)), i.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          c = l.url;
        if (Array.isArray(c)) {
          const u = [];
          for (let f = 0, p = c.length; f < p; f++) {
            const m = c[f],
              v = await s(m);
            v !== null &&
              (v instanceof HTMLImageElement
                ? u.push(v)
                : u.push(new vo(v.data, v.width, v.height)));
          }
          r[l.uuid] = new Ya(u);
        } else {
          const u = await s(l.url);
          r[l.uuid] = new Ya(u);
        }
      }
    }
    return r;
  }
  parseTextures(e, t) {
    function r(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const i = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          c = l.data;
        let u;
        Array.isArray(c)
          ? ((u = new Mm()), c.length === 6 && (u.needsUpdate = !0))
          : (c && c.data ? (u = new vo()) : (u = new Nn()),
            c && (u.needsUpdate = !0)),
          (u.source = l),
          (u.uuid = a.uuid),
          a.name !== void 0 && (u.name = a.name),
          a.mapping !== void 0 && (u.mapping = r(a.mapping, Eie)),
          a.channel !== void 0 && (u.channel = a.channel),
          a.offset !== void 0 && u.offset.fromArray(a.offset),
          a.repeat !== void 0 && u.repeat.fromArray(a.repeat),
          a.center !== void 0 && u.center.fromArray(a.center),
          a.rotation !== void 0 && (u.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((u.wrapS = r(a.wrap[0], NL)), (u.wrapT = r(a.wrap[1], NL))),
          a.format !== void 0 && (u.format = a.format),
          a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat),
          a.type !== void 0 && (u.type = a.type),
          a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace),
          a.minFilter !== void 0 && (u.minFilter = r(a.minFilter, LL)),
          a.magFilter !== void 0 && (u.magFilter = r(a.magFilter, LL)),
          a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (u.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (u.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (u.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (u.unpackAlignment = a.unpackAlignment),
          a.compareFunction !== void 0 &&
            (u.compareFunction = a.compareFunction),
          a.userData !== void 0 && (u.userData = a.userData),
          (i[a.uuid] = u);
      }
    return i;
  }
  parseObject(e, t, r, i, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, y = p.length; v < y; v++) {
            const x = p[v];
            r[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              m.push(r[x]);
          }
          return m;
        }
        return (
          r[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          r[p]
        );
      }
    }
    function c(p) {
      return (
        i[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        i[p]
      );
    }
    let u, f;
    switch (e.type) {
      case "Scene":
        (o = new BC()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Je(e.background))
              : (o.background = c(e.background))),
          e.environment !== void 0 && (o.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new s_(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new i_(e.fog.color, e.fog.density)),
            e.fog.name !== "" && (o.fog.name = e.fog.name)),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity),
          e.backgroundRotation !== void 0 &&
            o.backgroundRotation.fromArray(e.backgroundRotation),
          e.environmentIntensity !== void 0 &&
            (o.environmentIntensity = e.environmentIntensity),
          e.environmentRotation !== void 0 &&
            o.environmentRotation.fromArray(e.environmentRotation);
        break;
      case "PerspectiveCamera":
        (o = new lr(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new Lm(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new WV(e.color, e.intensity);
        break;
      case "DirectionalLight":
        (o = new HV(e.color, e.intensity)), (o.target = e.target || "");
        break;
      case "PointLight":
        o = new jV(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new GV(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        (o = new VV(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )),
          (o.target = e.target || "");
        break;
      case "HemisphereLight":
        o = new zV(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new XV().fromJSON(e);
        break;
      case "SkinnedMesh":
        (u = a(e.geometry)),
          (f = l(e.material)),
          (o = new lV(u, f)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (u = a(e.geometry)), (f = l(e.material)), (o = new $n(u, f));
        break;
      case "InstancedMesh":
        (u = a(e.geometry)), (f = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          v = e.instanceColor;
        (o = new cV(u, f, p)),
          (o.instanceMatrix = new hh(new Float32Array(m.array), 16)),
          v !== void 0 &&
            (o.instanceColor = new hh(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        (u = a(e.geometry)),
          (f = l(e.material)),
          (o = new uV(
            e.maxInstanceCount,
            e.maxVertexCount,
            e.maxIndexCount,
            f
          )),
          (o.geometry = u),
          (o.perObjectFrustumCulled = e.perObjectFrustumCulled),
          (o.sortObjects = e.sortObjects),
          (o._drawRanges = e.drawRanges),
          (o._reservedRanges = e.reservedRanges),
          (o._geometryInfo = e.geometryInfo.map((y) => {
            let x = null,
              g = null;
            return (
              y.boundingBox !== void 0 &&
                (x = new Dr().fromJSON(y.boundingBox)),
              y.boundingSphere !== void 0 &&
                (g = new gr().fromJSON(y.boundingSphere)),
              { ...y, boundingBox: x, boundingSphere: g }
            );
          })),
          (o._instanceInfo = e.instanceInfo),
          (o._availableInstanceIds = e._availableInstanceIds),
          (o._availableGeometryIds = e._availableGeometryIds),
          (o._nextIndexStart = e.nextIndexStart),
          (o._nextVertexStart = e.nextVertexStart),
          (o._geometryCount = e.geometryCount),
          (o._maxInstanceCount = e.maxInstanceCount),
          (o._maxVertexCount = e.maxVertexCount),
          (o._maxIndexCount = e.maxIndexCount),
          (o._geometryInitialized = e.geometryInitialized),
          (o._matricesTexture = c(e.matricesTexture.uuid)),
          (o._indirectTexture = c(e.indirectTexture.uuid)),
          e.colorsTexture !== void 0 &&
            (o._colorsTexture = c(e.colorsTexture.uuid)),
          e.boundingSphere !== void 0 &&
            (o.boundingSphere = new gr().fromJSON(e.boundingSphere)),
          e.boundingBox !== void 0 &&
            (o.boundingBox = new Dr().fromJSON(e.boundingBox));
        break;
      case "LOD":
        o = new aV();
        break;
      case "Line":
        o = new pl(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new dV(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new So(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new hV(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new oV(l(e.material));
        break;
      case "Group":
        o = new _d();
        break;
      case "Bone":
        o = new VC();
        break;
      default:
        o = new Xt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.intensity !== void 0 &&
          (o.shadow.intensity = e.shadow.intensity),
        e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, r, i, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const v = p[m],
          y = o.getObjectByProperty("uuid", v.object);
        y !== void 0 && o.addLevel(y, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (r) {
        if (r.isSkinnedMesh === !0 && r.skeleton !== void 0) {
          const i = t[r.skeleton];
          i === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                r.skeleton
              )
            : r.bind(i, r.bindMatrix);
        }
      });
  }
  bindLightTargets(e) {
    e.traverse(function (t) {
      if (t.isDirectionalLight || t.isSpotLight) {
        const r = t.target,
          i = e.getObjectByProperty("uuid", r);
        i !== void 0 ? (t.target = i) : (t.target = new Xt());
      }
    });
  }
}
const Eie = {
    UVMapping: qx,
    CubeReflectionMapping: ia,
    CubeRefractionMapping: fl,
    EquirectangularReflectionMapping: Gp,
    EquirectangularRefractionMapping: $p,
    CubeUVReflectionMapping: Ph,
  },
  NL = {
    RepeatWrapping: Xp,
    ClampToEdgeWrapping: rs,
    MirroredRepeatWrapping: qp,
  },
  LL = {
    NearestFilter: mr,
    NearestMipmapNearestFilter: TC,
    NearestMipmapLinearFilter: yd,
    LinearFilter: Zn,
    LinearMipmapNearestFilter: rp,
    LinearMipmapLinearFilter: oo,
  },
  R1 = new WeakMap();
class Tie extends yi {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" }),
      (this._abortController = new AbortController());
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, r, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = ao.get(`image-bitmap:${e}`);
    if (o !== void 0) {
      if ((s.manager.itemStart(e), o.then)) {
        o.then((c) => {
          if (R1.has(o) === !0)
            i && i(R1.get(o)), s.manager.itemError(e), s.manager.itemEnd(e);
          else return t && t(c), s.manager.itemEnd(e), c;
        });
        return;
      }
      return (
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    }
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      (a.signal =
        typeof AbortSignal.any == "function"
          ? AbortSignal.any([
              this._abortController.signal,
              this.manager.abortController.signal,
            ])
          : this._abortController.signal);
    const l = fetch(e, a)
      .then(function (c) {
        return c.blob();
      })
      .then(function (c) {
        return createImageBitmap(
          c,
          Object.assign(s.options, { colorSpaceConversion: "none" })
        );
      })
      .then(function (c) {
        return (
          ao.add(`image-bitmap:${e}`, c), t && t(c), s.manager.itemEnd(e), c
        );
      })
      .catch(function (c) {
        i && i(c),
          R1.set(l, c),
          ao.remove(`image-bitmap:${e}`),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      });
    ao.add(`image-bitmap:${e}`, l), s.manager.itemStart(e);
  }
  abort() {
    return (
      this._abortController.abort(),
      (this._abortController = new AbortController()),
      this
    );
  }
}
let Yv;
class iA {
  static getContext() {
    return (
      Yv === void 0 &&
        (Yv = new (window.AudioContext || window.webkitAudioContext)()),
      Yv
    );
  }
  static setContext(e) {
    Yv = e;
  }
}
class Mie extends yi {
  constructor(e) {
    super(e);
  }
  load(e, t, r, i) {
    const s = this,
      o = new oa(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (l) {
          try {
            const c = l.slice(0);
            iA.getContext()
              .decodeAudioData(c, function (f) {
                t(f);
              })
              .catch(a);
          } catch (c) {
            a(c);
          }
        },
        r,
        i
      );
    function a(l) {
      i ? i(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
const OL = new Tt(),
  DL = new Tt(),
  Gl = new Tt();
class Cie {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new lr()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new lr()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        Gl.copy(e.projectionMatrix);
      const i = t.eyeSep / 2,
        s = (i * t.near) / t.focus,
        o = (t.near * Math.tan(Pc * t.fov * 0.5)) / t.zoom;
      let a, l;
      (DL.elements[12] = -i),
        (OL.elements[12] = i),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (Gl.elements[0] = (2 * t.near) / (l - a)),
        (Gl.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(Gl),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (Gl.elements[0] = (2 * t.near) / (l - a)),
        (Gl.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(Gl);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(DL),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(OL);
  }
}
class YV extends lr {
  constructor(e = []) {
    super(),
      (this.isArrayCamera = !0),
      (this.isMultiViewCamera = !1),
      (this.cameras = e);
  }
}
class sA {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = performance.now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = performance.now();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
const $l = new z(),
  P1 = new vi(),
  Aie = new z(),
  Xl = new z(),
  ql = new z();
class Rie extends Xt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = iA.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new sA());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose($l, P1, Aie),
      Xl.set(0, 0, -1).applyQuaternion(P1),
      ql.set(0, 1, 0).applyQuaternion(P1),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime($l.x, r),
        t.positionY.linearRampToValueAtTime($l.y, r),
        t.positionZ.linearRampToValueAtTime($l.z, r),
        t.forwardX.linearRampToValueAtTime(Xl.x, r),
        t.forwardY.linearRampToValueAtTime(Xl.y, r),
        t.forwardZ.linearRampToValueAtTime(Xl.z, r),
        t.upX.linearRampToValueAtTime(ql.x, r),
        t.upY.linearRampToValueAtTime(ql.y, r),
        t.upZ.linearRampToValueAtTime(ql.z, r);
    } else
      t.setPosition($l.x, $l.y, $l.z),
        t.setOrientation(Xl.x, Xl.y, Xl.z, ql.x, ql.y, ql.z);
  }
}
class JV extends Xt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop(e = 0) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(this.context.currentTime + e),
        (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++)
          this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return (this._connected = !1), this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    return (
      (this.detune = e),
      this.isPlaying === !0 &&
        this.source.detune !== void 0 &&
        this.source.detune.setTargetAtTime(
          this.detune,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    (this.isPlaying = !1), (this._progress = 0);
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.sourceType !== "buffer"
        ? (console.warn("THREE.Audio: Audio source type cannot be copied."),
          this)
        : ((this.autoplay = e.autoplay),
          (this.buffer = e.buffer),
          (this.detune = e.detune),
          (this.loop = e.loop),
          (this.loopStart = e.loopStart),
          (this.loopEnd = e.loopEnd),
          (this.offset = e.offset),
          (this.duration = e.duration),
          (this.playbackRate = e.playbackRate),
          (this.hasPlaybackControl = e.hasPlaybackControl),
          (this.sourceType = e.sourceType),
          (this.filters = e.filters.slice()),
          this)
    );
  }
  clone(e) {
    return new this.constructor(this.listener).copy(this, e);
  }
}
const Kl = new z(),
  kL = new vi(),
  Pie = new z(),
  Yl = new z();
class Iie extends JV {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  connect() {
    return super.connect(), this.panner.connect(this.gain), this;
  }
  disconnect() {
    return super.disconnect(), this.panner.disconnect(this.gain), this;
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, r) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = r),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Kl, kL, Pie),
      Yl.set(0, 0, 1).applyQuaternion(kL);
    const t = this.panner;
    if (t.positionX) {
      const r = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Kl.x, r),
        t.positionY.linearRampToValueAtTime(Kl.y, r),
        t.positionZ.linearRampToValueAtTime(Kl.z, r),
        t.orientationX.linearRampToValueAtTime(Yl.x, r),
        t.orientationY.linearRampToValueAtTime(Yl.y, r),
        t.orientationZ.linearRampToValueAtTime(Yl.z, r);
    } else t.setPosition(Kl.x, Kl.y, Kl.z), t.setOrientation(Yl.x, Yl.y, Yl.z);
  }
}
class Nie {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let r = 0; r < t.length; r++) e += t[r];
    return e / t.length;
  }
}
class ZV {
  constructor(e, t, r) {
    (this.binding = e), (this.valueSize = r);
    let i, s, o;
    switch (t) {
      case "quaternion":
        (i = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(r * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (i = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(r * 5));
        break;
      default:
        (i = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(r * 5));
    }
    (this._mixBufferRegion = i),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const r = this.buffer,
      i = this.valueSize,
      s = e * i + i;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== i; ++a) r[s + a] = r[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(r, s, 0, a, i);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      r = this.valueSize,
      i = r * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, i, 0, e, r),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      r = this.buffer,
      i = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(r, i, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(r, i, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (r[l] !== r[l + t]) {
        a.setValue(r, i);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      r = this.valueSize,
      i = r * this._origIndex;
    e.getValue(t, i);
    for (let s = r, o = i; s !== o; ++s) t[s] = t[i + (s % r)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let r = e; r < t; r++) this.buffer[r] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let r = 0; r < this.valueSize; r++)
      this.buffer[t + r] = this.buffer[e + r];
  }
  _select(e, t, r, i, s) {
    if (i >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[r + o];
  }
  _slerp(e, t, r, i) {
    vi.slerpFlat(e, t, e, t, e, r, i);
  }
  _slerpAdditive(e, t, r, i, s) {
    const o = this._workIndex * s;
    vi.multiplyQuaternionsFlat(e, o, e, t, e, r),
      vi.slerpFlat(e, t, e, t, e, o, i);
  }
  _lerp(e, t, r, i, s) {
    const o = 1 - i;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[r + a] * i;
    }
  }
  _lerpAdditive(e, t, r, i, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[r + o] * i;
    }
  }
}
const oA = "\\[\\]\\.:\\/",
  Lie = new RegExp("[" + oA + "]", "g"),
  aA = "[^" + oA + "]",
  Oie = "[^" + oA.replace("\\.", "") + "]",
  Die = /((?:WC+[\/:])*)/.source.replace("WC", aA),
  kie = /(WCOD+)?/.source.replace("WCOD", Oie),
  Uie = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", aA),
  Fie = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", aA),
  Bie = new RegExp("^" + Die + kie + Uie + Fie + "$"),
  zie = ["material", "materials", "bones", "map"];
class Vie {
  constructor(e, t, r) {
    const i = r || Wt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const r = this._targetGroup.nCachedObjects_,
      i = this._bindings[r];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const r = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = r.length; i !== s; ++i)
      r[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, r = e.length; t !== r; ++t)
      e[t].unbind();
  }
}
class Wt {
  constructor(e, t, r) {
    (this.path = t),
      (this.parsedPath = r || Wt.parseTrackName(t)),
      (this.node = Wt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, r) {
    return e && e.isAnimationObjectGroup
      ? new Wt.Composite(e, t, r)
      : new Wt(e, t, r);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Lie, "");
  }
  static parseTrackName(e) {
    const t = Bie.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const r = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = r.nodeName && r.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = r.nodeName.substring(i + 1);
      zie.indexOf(s) !== -1 &&
        ((r.nodeName = r.nodeName.substring(0, i)), (r.objectName = s));
    }
    if (r.propertyName === null || r.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return r;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const r = e.skeleton.getBoneByName(t);
      if (r !== void 0) return r;
    }
    if (e.children) {
      const r = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = r(a.children);
            if (l) return l;
          }
          return null;
        },
        i = r(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) e[t++] = r[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const r = this.resolvedProperty;
    for (let i = 0, s = r.length; i !== s; ++i) r[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      r = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Wt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
      return;
    }
    if (r) {
      let c = t.objectIndex;
      switch (r) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[r] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[r];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[i];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.isMaterial === !0
        ? (a = this.Versioning.NeedsUpdate)
        : e.isObject3D === !0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
Wt.Composite = Vie;
Wt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
Wt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
Wt.prototype.GetterByBindingType = [
  Wt.prototype._getValue_direct,
  Wt.prototype._getValue_array,
  Wt.prototype._getValue_arrayElement,
  Wt.prototype._getValue_toArray,
];
Wt.prototype.SetterByBindingTypeAndVersioning = [
  [
    Wt.prototype._setValue_direct,
    Wt.prototype._setValue_direct_setNeedsUpdate,
    Wt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_array,
    Wt.prototype._setValue_array_setNeedsUpdate,
    Wt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_arrayElement,
    Wt.prototype._setValue_arrayElement_setNeedsUpdate,
    Wt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    Wt.prototype._setValue_fromArray,
    Wt.prototype._setValue_fromArray_setNeedsUpdate,
    Wt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class jie {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = Li()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let r = 0, i = arguments.length; r !== i; ++r)
      e[arguments[r].uuid] = r;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._paths,
      i = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      c = this.nCachedObjects_;
    for (let u = 0, f = arguments.length; u !== f; ++u) {
      const p = arguments[u],
        m = p.uuid;
      let v = t[m];
      if (v === void 0) {
        (v = l++), (t[m] = v), e.push(p);
        for (let y = 0, x = o; y !== x; ++y) s[y].push(new Wt(p, r[y], i[y]));
      } else if (v < c) {
        a = e[v];
        const y = --c,
          x = e[y];
        (t[x.uuid] = v), (e[v] = x), (t[m] = y), (e[y] = p);
        for (let g = 0, _ = o; g !== _; ++g) {
          const S = s[g],
            b = S[y];
          let C = S[v];
          (S[v] = b), C === void 0 && (C = new Wt(p, r[g], i[g])), (S[y] = C);
        }
      } else
        e[v] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        c = l.uuid,
        u = t[c];
      if (u !== void 0 && u >= s) {
        const f = s++,
          p = e[f];
        (t[p.uuid] = u), (e[u] = p), (t[c] = f), (e[f] = l);
        for (let m = 0, v = i; m !== v; ++m) {
          const y = r[m],
            x = y[f],
            g = y[u];
          (y[u] = x), (y[f] = g);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      r = this._bindings,
      i = r.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        u = c.uuid,
        f = t[u];
      if (f !== void 0)
        if ((delete t[u], f < s)) {
          const p = --s,
            m = e[p],
            v = --o,
            y = e[v];
          (t[m.uuid] = f), (e[f] = m), (t[y.uuid] = p), (e[p] = y), e.pop();
          for (let x = 0, g = i; x !== g; ++x) {
            const _ = r[x],
              S = _[p],
              b = _[v];
            (_[f] = S), (_[p] = b), _.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = f), (e[f] = m), e.pop();
          for (let v = 0, y = i; v !== y; ++v) {
            const x = r[v];
            (x[f] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const r = this._bindingsIndicesByPath;
    let i = r[e];
    const s = this._bindings;
    if (i !== void 0) return s[i];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      c = l.length,
      u = this.nCachedObjects_,
      f = new Array(c);
    (i = s.length), (r[e] = i), o.push(e), a.push(t), s.push(f);
    for (let p = u, m = l.length; p !== m; ++p) {
      const v = l[p];
      f[p] = new Wt(v, e, t);
    }
    return f;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      r = t[e];
    if (r !== void 0) {
      const i = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        c = e[a];
      (t[c] = r),
        (o[r] = l),
        o.pop(),
        (s[r] = s[a]),
        s.pop(),
        (i[r] = i[a]),
        i.pop();
    }
  }
}
class QV {
  constructor(e, t, r = null, i = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = r),
      (this.blendMode = i);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: gc, endingEnd: gc };
    for (let c = 0; c !== o; ++c) {
      const u = s[c].createInterpolant(null);
      (a[c] = u), (u.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = B4),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, r = !1) {
    if ((e.fadeOut(t), this.fadeIn(t), r === !0)) {
      const i = this._clip.duration,
        s = e._clip.duration,
        o = s / i,
        a = i / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, r = !1) {
    return e.crossFadeFrom(this, t, r);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, r) {
    const i = this._mixer,
      s = i.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = i._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = s), (l[1] = s + r), (c[0] = e / o), (c[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, r, i) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * r;
      l < 0 || r === 0 ? (t = 0) : ((this._startTime = null), (t = r * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case LC:
          for (let u = 0, f = l.length; u !== f; ++u)
            l[u].evaluate(o), c[u].accumulateAdditive(a);
          break;
        case t_:
        default:
          for (let u = 0, f = l.length; u !== f; ++u)
            l[u].evaluate(o), c[u].accumulate(i, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const r = this._weightInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopFading(), i === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const r = this._timeScaleInterpolant;
      if (r !== null) {
        const i = r.evaluate(e)[0];
        (t *= i),
          e > r.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      r = this.loop;
    let i = this.time + e,
      s = this._loopCount;
    const o = r === z4;
    if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
    if (r === F4) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (i >= t) i = t;
        else if (i < 0) i = 0;
        else {
          this.time = i;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = i),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        i >= t || i < 0)
      ) {
        const a = Math.floor(i / t);
        (i -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (i = e > 0 ? t : 0),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = i),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = i;
      if (o && (s & 1) === 1) return t - i;
    }
    return i;
  }
  _setEndings(e, t, r) {
    const i = this._interpolantSettings;
    r
      ? ((i.endingStart = vc), (i.endingEnd = vc))
      : (e
          ? (i.endingStart = this.zeroSlopeAtStart ? vc : gc)
          : (i.endingStart = Yp),
        t ? (i.endingEnd = this.zeroSlopeAtEnd ? vc : gc) : (i.endingEnd = Yp));
  }
  _scheduleFading(e, t, r) {
    const i = this._mixer,
      s = i.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = i._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = r), this;
  }
}
const Hie = new Float32Array(1);
class Wie extends wo {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const r = e._localRoot || this._root,
      i = e._clip.tracks,
      s = i.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = r.uuid,
      c = this._bindingsByRootAndName;
    let u = c[l];
    u === void 0 && ((u = {}), (c[l] = u));
    for (let f = 0; f !== s; ++f) {
      const p = i[f],
        m = p.name;
      let v = u[m];
      if (v !== void 0) ++v.referenceCount, (o[f] = v);
      else {
        if (((v = o[f]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, m));
          continue;
        }
        const y = t && t._propertyBindings[f].binding.parsedPath;
        (v = new ZV(Wt.create(r, m, y), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, m),
          (o[f] = v);
      }
      a[f].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const r = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          s = this._actionsByClip[i];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, i, r);
      }
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let r = 0, i = t.length; r !== i; ++r) {
        const s = t[r];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, r) {
    const i = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = i.length), i.push(e), (o.actionByRoot[r] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      r = t[t.length - 1],
      i = e._cacheIndex;
    (r._cacheIndex = i), (t[i] = r), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      c = l[l.length - 1],
      u = e._byClipCacheIndex;
    (c._byClipCacheIndex = u),
      (l[u] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const f = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete f[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let r = 0, i = t.length; r !== i; ++r) {
      const s = t[r];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = this._nActiveActions++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      r = e._cacheIndex,
      i = --this._nActiveActions,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _addInactiveBinding(e, t, r) {
    const i = this._bindingsByRootAndName,
      s = this._bindings;
    let o = i[t];
    o === void 0 && ((o = {}), (i[t] = o)),
      (o[r] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      r = e.binding,
      i = r.rootNode.uuid,
      s = r.path,
      o = this._bindingsByRootAndName,
      a = o[i],
      l = t[t.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[i];
  }
  _lendBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = this._nActiveBindings++,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      r = e._cacheIndex,
      i = --this._nActiveBindings,
      s = t[i];
    (e._cacheIndex = i), (t[i] = e), (s._cacheIndex = r), (t[r] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let r = e[t];
    return (
      r === void 0 &&
        ((r = new eA(new Float32Array(2), new Float32Array(2), 1, Hie)),
        (r.__cacheIndex = t),
        (e[t] = r)),
      r
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      r = e.__cacheIndex,
      i = --this._nActiveControlInterpolants,
      s = t[i];
    (e.__cacheIndex = i), (t[i] = e), (s.__cacheIndex = r), (t[r] = s);
  }
  clipAction(e, t, r) {
    const i = t || this._root,
      s = i.uuid;
    let o = typeof e == "string" ? sm.findByName(i, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (r === void 0 && (o !== null ? (r = o.blendMode) : (r = t_)),
      l !== void 0)
    ) {
      const f = l.actionByRoot[s];
      if (f !== void 0 && f.blendMode === r) return f;
      (c = l.knownActions[0]), o === null && (o = c._clip);
    }
    if (o === null) return null;
    const u = new QV(this, o, t, r);
    return this._bindAction(u, c), this._addInactiveAction(u, a, s), u;
  }
  existingAction(e, t) {
    const r = t || this._root,
      i = r.uuid,
      s = typeof e == "string" ? sm.findByName(r, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[i]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let r = t - 1; r >= 0; --r) e[r].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      r = this._nActiveActions,
      i = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let c = 0; c !== r; ++c) t[c]._update(i, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      r = e.uuid,
      i = this._actionsByClip,
      s = i[r];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const u = c._cacheIndex,
          f = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (f._cacheIndex = u),
          (t[u] = f),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete i[r];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      r = this._actionsByClip;
    for (const o in r) {
      const a = r[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const i = this._bindingsByRootAndName,
      s = i[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const r = this.existingAction(e, t);
    r !== null && (this._deactivateAction(r), this._removeInactiveAction(r));
  }
}
class Gie extends kC {
  constructor(e = 1, t = 1, r = 1, i = {}) {
    super(e, t, i),
      (this.isRenderTarget3D = !0),
      (this.depth = r),
      (this.texture = new r_(null, e, t, r)),
      this._setTextureOptions(i),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class lA {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new lA(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let $ie = 0;
class Xie extends wo {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: $ie++ }),
      (this.name = ""),
      (this.usage = Zp),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let r = 0, i = t.length; r < i; r++) {
      const s = Array.isArray(t[r]) ? t[r] : [t[r]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class qie extends o_ {
  constructor(e, t, r = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class Kie {
  constructor(e, t, r, i, s, o = !1) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = r),
      (this.elementSize = i),
      (this.count = s),
      (this.normalized = o),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
const UL = new Tt();
class ej {
  constructor(e, t, r = 0, i = 1 / 0) {
    (this.ray = new Nh(e, t)),
      (this.near = r),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Ic()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  setFromXRController(e) {
    return (
      UL.identity().extractRotation(e.matrixWorld),
      this.ray.origin.setFromMatrixPosition(e.matrixWorld),
      this.ray.direction.set(0, 0, -1).applyMatrix4(UL),
      this
    );
  }
  intersectObject(e, t = !0, r = []) {
    return KE(e, this, r, t), r.sort(FL), r;
  }
  intersectObjects(e, t = !0, r = []) {
    for (let i = 0, s = e.length; i < s; i++) KE(e[i], this, r, t);
    return r.sort(FL), r;
  }
}
function FL(n, e) {
  return n.distance - e.distance;
}
function KE(n, e, t, r) {
  let i = !0;
  if (
    (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (i = !1),
    i === !0 && r === !0)
  ) {
    const s = n.children;
    for (let o = 0, a = s.length; o < a; o++) KE(s[o], e, t, !0);
  }
}
class Yie {
  constructor() {
    (this._previousTime = 0),
      (this._currentTime = 0),
      (this._startTime = performance.now()),
      (this._delta = 0),
      (this._elapsed = 0),
      (this._timescale = 1),
      (this._document = null),
      (this._pageVisibilityHandler = null);
  }
  connect(e) {
    (this._document = e),
      e.hidden !== void 0 &&
        ((this._pageVisibilityHandler = Jie.bind(this)),
        e.addEventListener(
          "visibilitychange",
          this._pageVisibilityHandler,
          !1
        ));
  }
  disconnect() {
    this._pageVisibilityHandler !== null &&
      (this._document.removeEventListener(
        "visibilitychange",
        this._pageVisibilityHandler
      ),
      (this._pageVisibilityHandler = null)),
      (this._document = null);
  }
  getDelta() {
    return this._delta / 1e3;
  }
  getElapsed() {
    return this._elapsed / 1e3;
  }
  getTimescale() {
    return this._timescale;
  }
  setTimescale(e) {
    return (this._timescale = e), this;
  }
  reset() {
    return (this._currentTime = performance.now() - this._startTime), this;
  }
  dispose() {
    this.disconnect();
  }
  update(e) {
    return (
      this._pageVisibilityHandler !== null && this._document.hidden === !0
        ? (this._delta = 0)
        : ((this._previousTime = this._currentTime),
          (this._currentTime =
            (e !== void 0 ? e : performance.now()) - this._startTime),
          (this._delta =
            (this._currentTime - this._previousTime) * this._timescale),
          (this._elapsed += this._delta)),
      this
    );
  }
}
function Jie() {
  this._document.hidden === !1 && this.reset();
}
class Zie {
  constructor(e = 1, t = 0, r = 0) {
    (this.radius = e), (this.phi = t), (this.theta = r);
  }
  set(e, t, r) {
    return (this.radius = e), (this.phi = t), (this.theta = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (this.phi = St(this.phi, 1e-6, Math.PI - 1e-6)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + r * r)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, r)),
          (this.phi = Math.acos(St(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Qie {
  constructor(e = 1, t = 0, r = 0) {
    (this.radius = e), (this.theta = t), (this.y = r);
  }
  set(e, t, r) {
    return (this.radius = e), (this.theta = t), (this.y = r), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, r) {
    return (
      (this.radius = Math.sqrt(e * e + r * r)),
      (this.theta = Math.atan2(e, r)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class cA {
  constructor(e, t, r, i) {
    (cA.prototype.isMatrix2 = !0),
      (this.elements = [1, 0, 0, 1]),
      e !== void 0 && this.set(e, t, r, i);
  }
  identity() {
    return this.set(1, 0, 0, 1), this;
  }
  fromArray(e, t = 0) {
    for (let r = 0; r < 4; r++) this.elements[r] = e[r + t];
    return this;
  }
  set(e, t, r, i) {
    const s = this.elements;
    return (s[0] = e), (s[2] = t), (s[1] = r), (s[3] = i), this;
  }
}
const BL = new xe();
class ese {
  constructor(e = new xe(1 / 0, 1 / 0), t = new xe(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const r = BL.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return (
      e.x >= this.min.x &&
      e.x <= this.max.x &&
      e.y >= this.min.y &&
      e.y <= this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return (
      e.max.x >= this.min.x &&
      e.min.x <= this.max.x &&
      e.max.y >= this.min.y &&
      e.min.y <= this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, BL).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const zL = new z(),
  Jv = new z(),
  Wu = new z(),
  Gu = new z(),
  I1 = new z(),
  tse = new z(),
  nse = new z();
class rse {
  constructor(e = new z(), t = new z()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    zL.subVectors(e, this.start), Jv.subVectors(this.end, this.start);
    const r = Jv.dot(Jv);
    let s = Jv.dot(zL) / r;
    return t && (s = St(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, r) {
    const i = this.closestPointToPointParameter(e, t);
    return this.delta(r).multiplyScalar(i).add(this.start);
  }
  distanceSqToLine3(e, t = tse, r = nse) {
    const i = 10000000000000001e-32;
    let s, o;
    const a = this.start,
      l = e.start,
      c = this.end,
      u = e.end;
    Wu.subVectors(c, a), Gu.subVectors(u, l), I1.subVectors(a, l);
    const f = Wu.dot(Wu),
      p = Gu.dot(Gu),
      m = Gu.dot(I1);
    if (f <= i && p <= i) return t.copy(a), r.copy(l), t.sub(r), t.dot(t);
    if (f <= i) (s = 0), (o = m / p), (o = St(o, 0, 1));
    else {
      const v = Wu.dot(I1);
      if (p <= i) (o = 0), (s = St(-v / f, 0, 1));
      else {
        const y = Wu.dot(Gu),
          x = f * p - y * y;
        x !== 0 ? (s = St((y * m - v * p) / x, 0, 1)) : (s = 0),
          (o = (y * s + m) / p),
          o < 0
            ? ((o = 0), (s = St(-v / f, 0, 1)))
            : o > 1 && ((o = 1), (s = St((y - v) / f, 0, 1)));
      }
    }
    return (
      t.copy(a).add(Wu.multiplyScalar(s)),
      r.copy(l).add(Gu.multiplyScalar(o)),
      t.sub(r),
      t.dot(t)
    );
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const VL = new z();
class ise extends Xt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const r = new kt(),
      i = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = (o / l) * Math.PI * 2,
        u = (a / l) * Math.PI * 2;
      i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1);
    }
    r.setAttribute("position", new st(i, 3));
    const s = new ei({ fog: !1, toneMapped: !1 });
    (this.cone = new So(r, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      this.parent
        ? (this.parent.updateWorldMatrix(!0),
          this.matrix
            .copy(this.parent.matrixWorld)
            .invert()
            .multiply(this.light.matrixWorld))
        : this.matrix.copy(this.light.matrixWorld),
      this.matrixWorld.copy(this.light.matrixWorld);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      VL.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(VL),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const Aa = new z(),
  Zv = new Tt(),
  N1 = new Tt();
class sse extends So {
  constructor(e) {
    const t = tj(e),
      r = new kt(),
      i = [],
      s = [];
    for (let c = 0; c < t.length; c++) {
      const u = t[c];
      u.parent &&
        u.parent.isBone &&
        (i.push(0, 0, 0), i.push(0, 0, 0), s.push(0, 0, 0), s.push(0, 0, 0));
    }
    r.setAttribute("position", new st(i, 3)),
      r.setAttribute("color", new st(s, 3));
    const o = new ei({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(r, o),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
    const a = new Je(255),
      l = new Je(65280);
    this.setColors(a, l);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      r = this.geometry,
      i = r.getAttribute("position");
    N1.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Zv.multiplyMatrices(N1, a.matrixWorld),
        Aa.setFromMatrixPosition(Zv),
        i.setXYZ(o, Aa.x, Aa.y, Aa.z),
        Zv.multiplyMatrices(N1, a.parent.matrixWorld),
        Aa.setFromMatrixPosition(Zv),
        i.setXYZ(o + 1, Aa.x, Aa.y, Aa.z),
        (o += 2));
    }
    (r.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  setColors(e, t) {
    const i = this.geometry.getAttribute("color");
    for (let s = 0; s < i.count; s += 2)
      i.setXYZ(s, e.r, e.g, e.b), i.setXYZ(s + 1, t.r, t.g, t.b);
    return (i.needsUpdate = !0), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function tj(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++) e.push(...tj(n.children[t]));
  return e;
}
class ose extends $n {
  constructor(e, t, r) {
    const i = new Pm(t, 4, 2),
      s = new Sl({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(i, s),
      (this.light = e),
      (this.color = r),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const ase = new z(),
  jL = new Je(),
  HL = new Je();
class lse extends Xt {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "HemisphereLightHelper");
    const i = new Rm(t);
    i.rotateY(Math.PI * 0.5),
      (this.material = new Sl({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = i.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    i.setAttribute("color", new sn(o, 3)),
      this.add(new $n(i, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      jL.copy(this.light.color), HL.copy(this.light.groundColor);
      for (let r = 0, i = t.count; r < i; r++) {
        const s = r < i / 2 ? jL : HL;
        t.setXYZ(r, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(ase.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class cse extends So {
  constructor(e = 10, t = 10, r = 4473924, i = 8947848) {
    (r = new Je(r)), (i = new Je(i));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      c = [];
    for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const y = p === s ? r : i;
      y.toArray(c, m),
        (m += 3),
        y.toArray(c, m),
        (m += 3),
        y.toArray(c, m),
        (m += 3),
        y.toArray(c, m),
        (m += 3);
    }
    const u = new kt();
    u.setAttribute("position", new st(l, 3)),
      u.setAttribute("color", new st(c, 3));
    const f = new ei({ vertexColors: !0, toneMapped: !1 });
    super(u, f), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class use extends So {
  constructor(e = 10, t = 16, r = 8, i = 64, s = 4473924, o = 8947848) {
    (s = new Je(s)), (o = new Je(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let f = 0; f < t; f++) {
        const p = (f / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          v = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, v);
        const y = f & 1 ? s : o;
        l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b);
      }
    for (let f = 0; f < r; f++) {
      const p = f & 1 ? s : o,
        m = e - (e / r) * f;
      for (let v = 0; v < i; v++) {
        let y = (v / i) * (Math.PI * 2),
          x = Math.sin(y) * m,
          g = Math.cos(y) * m;
        a.push(x, 0, g),
          l.push(p.r, p.g, p.b),
          (y = ((v + 1) / i) * (Math.PI * 2)),
          (x = Math.sin(y) * m),
          (g = Math.cos(y) * m),
          a.push(x, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const c = new kt();
    c.setAttribute("position", new st(a, 3)),
      c.setAttribute("color", new st(l, 3));
    const u = new ei({ vertexColors: !0, toneMapped: !1 });
    super(c, u), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const WL = new z(),
  Qv = new z(),
  GL = new z();
class dse extends Xt {
  constructor(e, t, r) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = r),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let i = new kt();
    i.setAttribute(
      "position",
      new st([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new ei({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new pl(i, s)),
      this.add(this.lightPlane),
      (i = new kt()),
      i.setAttribute("position", new st([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new pl(i, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      WL.setFromMatrixPosition(this.light.matrixWorld),
      Qv.setFromMatrixPosition(this.light.target.matrixWorld),
      GL.subVectors(Qv, WL),
      this.lightPlane.lookAt(Qv),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Qv),
      (this.targetLine.scale.z = GL.length());
  }
}
const ey = new z(),
  An = new Tm();
class hse extends So {
  constructor(e) {
    const t = new kt(),
      r = new ei({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      i = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(v, y) {
      l(v), l(y);
    }
    function l(v) {
      i.push(0, 0, 0),
        s.push(0, 0, 0),
        o[v] === void 0 && (o[v] = []),
        o[v].push(i.length / 3 - 1);
    }
    t.setAttribute("position", new st(i, 3)),
      t.setAttribute("color", new st(s, 3)),
      super(t, r),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const c = new Je(16755200),
      u = new Je(16711680),
      f = new Je(43775),
      p = new Je(16777215),
      m = new Je(3355443);
    this.setColors(c, u, f, p, m);
  }
  setColors(e, t, r, i, s) {
    const a = this.geometry.getAttribute("color");
    return (
      a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, r.r, r.g, r.b),
      a.setXYZ(33, r.r, r.g, r.b),
      a.setXYZ(34, r.r, r.g, r.b),
      a.setXYZ(35, r.r, r.g, r.b),
      a.setXYZ(36, r.r, r.g, r.b),
      a.setXYZ(37, r.r, r.g, r.b),
      a.setXYZ(38, i.r, i.g, i.b),
      a.setXYZ(39, i.r, i.g, i.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0),
      this
    );
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      r = 1,
      i = 1;
    let s, o;
    if (
      (An.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      this.camera.reversedDepth === !0)
    )
      (s = 1), (o = 0);
    else if (this.camera.coordinateSystem === Pi) (s = -1), (o = 1);
    else if (this.camera.coordinateSystem === ch) (s = 0), (o = 1);
    else
      throw new Error(
        "THREE.CameraHelper.update(): Invalid coordinate system: " +
          this.camera.coordinateSystem
      );
    Un("c", t, e, An, 0, 0, s),
      Un("t", t, e, An, 0, 0, o),
      Un("n1", t, e, An, -r, -i, s),
      Un("n2", t, e, An, r, -i, s),
      Un("n3", t, e, An, -r, i, s),
      Un("n4", t, e, An, r, i, s),
      Un("f1", t, e, An, -r, -i, o),
      Un("f2", t, e, An, r, -i, o),
      Un("f3", t, e, An, -r, i, o),
      Un("f4", t, e, An, r, i, o),
      Un("u1", t, e, An, r * 0.7, i * 1.1, s),
      Un("u2", t, e, An, -r * 0.7, i * 1.1, s),
      Un("u3", t, e, An, 0, i * 2, s),
      Un("cf1", t, e, An, -r, 0, o),
      Un("cf2", t, e, An, r, 0, o),
      Un("cf3", t, e, An, 0, -i, o),
      Un("cf4", t, e, An, 0, i, o),
      Un("cn1", t, e, An, -r, 0, s),
      Un("cn2", t, e, An, r, 0, s),
      Un("cn3", t, e, An, 0, -i, s),
      Un("cn4", t, e, An, 0, i, s),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Un(n, e, t, r, i, s, o) {
  ey.set(i, s, o).unproject(r);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, u = a.length; c < u; c++) l.setXYZ(a[c], ey.x, ey.y, ey.z);
  }
}
const ty = new Dr();
class fse extends So {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = new Float32Array(8 * 3),
      s = new kt();
    s.setIndex(new sn(r, 1)),
      s.setAttribute("position", new sn(i, 3)),
      super(s, new ei({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update() {
    if ((this.object !== void 0 && ty.setFromObject(this.object), ty.isEmpty()))
      return;
    const e = ty.min,
      t = ty.max,
      r = this.geometry.attributes.position,
      i = r.array;
    (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = e.x),
      (i[4] = t.y),
      (i[5] = t.z),
      (i[6] = e.x),
      (i[7] = e.y),
      (i[8] = t.z),
      (i[9] = t.x),
      (i[10] = e.y),
      (i[11] = t.z),
      (i[12] = t.x),
      (i[13] = t.y),
      (i[14] = e.z),
      (i[15] = e.x),
      (i[16] = t.y),
      (i[17] = e.z),
      (i[18] = e.x),
      (i[19] = e.y),
      (i[20] = e.z),
      (i[21] = t.x),
      (i[22] = e.y),
      (i[23] = e.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class pse extends So {
  constructor(e, t = 16776960) {
    const r = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      i = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new kt();
    s.setIndex(new sn(r, 1)),
      s.setAttribute("position", new st(i, 3)),
      super(s, new ei({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class mse extends pl {
  constructor(e, t = 1, r = 16776960) {
    const i = r,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new kt();
    o.setAttribute("position", new st(s, 3)),
      o.computeBoundingSphere(),
      super(o, new ei({ color: i, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new kt();
    l.setAttribute("position", new st(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new $n(
          l,
          new Sl({
            color: i,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const $L = new z();
let ny, L1;
class gse extends Xt {
  constructor(
    e = new z(0, 0, 1),
    t = new z(0, 0, 0),
    r = 1,
    i = 16776960,
    s = r * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      ny === void 0 &&
        ((ny = new kt()),
        ny.setAttribute("position", new st([0, 0, 0, 0, 1, 0], 3)),
        (L1 = new Am(0.5, 1, 5, 1)),
        L1.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new pl(ny, new ei({ color: i, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new $n(L1, new Sl({ color: i, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(r, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      $L.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle($L, t);
    }
  }
  setLength(e, t = e * 0.2, r = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(r, t, r),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class vse extends So {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      r = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      i = new kt();
    i.setAttribute("position", new st(t, 3)),
      i.setAttribute("color", new st(r, 3));
    const s = new ei({ vertexColors: !0, toneMapped: !1 });
    super(i, s), (this.type = "AxesHelper");
  }
  setColors(e, t, r) {
    const i = new Je(),
      s = this.geometry.attributes.color.array;
    return (
      i.set(e),
      i.toArray(s, 0),
      i.toArray(s, 3),
      i.set(t),
      i.toArray(s, 6),
      i.toArray(s, 9),
      i.set(r),
      i.toArray(s, 12),
      i.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class yse {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Je()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new lx()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, r, i) {
    return this.currentPath.quadraticCurveTo(e, t, r, i), this;
  }
  bezierCurveTo(e, t, r, i, s, o) {
    return this.currentPath.bezierCurveTo(e, t, r, i, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const _ = [];
      for (let S = 0, b = g.length; S < b; S++) {
        const C = g[S],
          A = new Nc();
        (A.curves = C.curves), _.push(A);
      }
      return _;
    }
    function r(g, _) {
      const S = _.length;
      let b = !1;
      for (let C = S - 1, A = 0; A < S; C = A++) {
        let R = _[C],
          O = _[A],
          I = O.x - R.x,
          N = O.y - R.y;
        if (Math.abs(N) > Number.EPSILON) {
          if (
            (N < 0 && ((R = _[A]), (I = -I), (O = _[C]), (N = -N)),
            g.y < R.y || g.y > O.y)
          )
            continue;
          if (g.y === R.y) {
            if (g.x === R.x) return !0;
          } else {
            const D = N * (g.x - R.x) - I * (g.y - R.y);
            if (D === 0) return !0;
            if (D < 0) continue;
            b = !b;
          }
        } else {
          if (g.y !== R.y) continue;
          if ((O.x <= g.x && g.x <= R.x) || (R.x <= g.x && g.x <= O.x))
            return !0;
        }
      }
      return b;
    }
    const i = Ns.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const c = [];
    if (s.length === 1)
      return (a = s[0]), (l = new Nc()), (l.curves = a.curves), c.push(l), c;
    let u = !i(s[0].getPoints());
    u = e ? !u : u;
    const f = [],
      p = [];
    let m = [],
      v = 0,
      y;
    (p[v] = void 0), (m[v] = []);
    for (let g = 0, _ = s.length; g < _; g++)
      (a = s[g]),
        (y = a.getPoints()),
        (o = i(y)),
        (o = e ? !o : o),
        o
          ? (!u && p[v] && v++,
            (p[v] = { s: new Nc(), p: y }),
            (p[v].s.curves = a.curves),
            u && v++,
            (m[v] = []))
          : m[v].push({ h: a, p: y[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let g = !1,
        _ = 0;
      for (let S = 0, b = p.length; S < b; S++) f[S] = [];
      for (let S = 0, b = p.length; S < b; S++) {
        const C = m[S];
        for (let A = 0; A < C.length; A++) {
          const R = C[A];
          let O = !0;
          for (let I = 0; I < p.length; I++)
            r(R.p, p[I].p) &&
              (S !== I && _++, O ? ((O = !1), f[I].push(R)) : (g = !0));
          O && f[S].push(R);
        }
      }
      _ > 0 && g === !1 && (m = f);
    }
    let x;
    for (let g = 0, _ = p.length; g < _; g++) {
      (l = p[g].s), c.push(l), (x = m[g]);
      for (let S = 0, b = x.length; S < b; S++) l.holes.push(x[S].h);
    }
    return c;
  }
}
class xse extends wo {
  constructor(e, t = null) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.enabled = !0),
      (this.state = -1),
      (this.keys = {}),
      (this.mouseButtons = { LEFT: null, MIDDLE: null, RIGHT: null }),
      (this.touches = { ONE: null, TWO: null });
  }
  connect(e) {
    if (e === void 0) {
      console.warn("THREE.Controls: connect() now requires an element.");
      return;
    }
    this.domElement !== null && this.disconnect(), (this.domElement = e);
  }
  disconnect() {}
  dispose() {}
  update() {}
}
function _se(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2))
      : ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0)),
    n
  );
}
function wse(n, e) {
  const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
  return (
    t > e
      ? ((n.repeat.x = e / t),
        (n.repeat.y = 1),
        (n.offset.x = (1 - n.repeat.x) / 2),
        (n.offset.y = 0))
      : ((n.repeat.x = 1),
        (n.repeat.y = t / e),
        (n.offset.x = 0),
        (n.offset.y = (1 - n.repeat.y) / 2)),
    n
  );
}
function Sse(n) {
  return (
    (n.repeat.x = 1), (n.repeat.y = 1), (n.offset.x = 0), (n.offset.y = 0), n
  );
}
function YE(n, e, t, r) {
  const i = bse(r);
  switch (t) {
    case RC:
      return n * e;
    case Zx:
      return ((n * e) / i.components) * i.byteLength;
    case Em:
      return ((n * e) / i.components) * i.byteLength;
    case IC:
      return ((n * e * 2) / i.components) * i.byteLength;
    case Qx:
      return ((n * e * 2) / i.components) * i.byteLength;
    case PC:
      return ((n * e * 3) / i.components) * i.byteLength;
    case Or:
      return ((n * e * 4) / i.components) * i.byteLength;
    case e_:
      return ((n * e * 4) / i.components) * i.byteLength;
    case ip:
    case sp:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case op:
    case ap:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case N0:
    case O0:
      return (Math.max(n, 16) * Math.max(e, 8)) / 4;
    case I0:
    case L0:
      return (Math.max(n, 8) * Math.max(e, 8)) / 2;
    case D0:
    case k0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case U0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case F0:
      return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case B0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case z0:
      return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case V0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case j0:
      return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case H0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case W0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case G0:
      return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case $0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case X0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case q0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case K0:
      return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case Y0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case J0:
      return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case lp:
    case Z0:
    case Q0:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case NC:
    case ex:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case tx:
    case nx:
      return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
  }
  throw new Error(`Unable to determine texture byte length for ${t} format.`);
}
function bse(n) {
  switch (n) {
    case ls:
    case MC:
      return { byteLength: 1, components: 1 };
    case sh:
    case CC:
    case Ih:
      return { byteLength: 2, components: 1 };
    case Yx:
    case Jx:
      return { byteLength: 2, components: 4 };
    case sa:
    case Kx:
    case fi:
      return { byteLength: 4, components: 1 };
    case AC:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${n}.`);
}
class Ese {
  static contain(e, t) {
    return _se(e, t);
  }
  static cover(e, t) {
    return wse(e, t);
  }
  static fill(e) {
    return Sse(e);
  }
  static getByteLength(e, t, r, i) {
    return YE(e, t, r, i);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: $x } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = $x));
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ function nj() {
  let n = null,
    e = !1,
    t = null,
    r = null;
  function i(s, o) {
    t(s, o), (r = n.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((r = n.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(r), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function Tse(n) {
  const e = new WeakMap();
  function t(a, l) {
    const c = a.array,
      u = a.usage,
      f = c.byteLength,
      p = n.createBuffer();
    n.bindBuffer(l, p), n.bufferData(l, c, u), a.onUploadCallback();
    let m;
    if (c instanceof Float32Array) m = n.FLOAT;
    else if (typeof Float16Array < "u" && c instanceof Float16Array)
      m = n.HALF_FLOAT;
    else if (c instanceof Uint16Array)
      a.isFloat16BufferAttribute ? (m = n.HALF_FLOAT) : (m = n.UNSIGNED_SHORT);
    else if (c instanceof Int16Array) m = n.SHORT;
    else if (c instanceof Uint32Array) m = n.UNSIGNED_INT;
    else if (c instanceof Int32Array) m = n.INT;
    else if (c instanceof Int8Array) m = n.BYTE;
    else if (c instanceof Uint8Array) m = n.UNSIGNED_BYTE;
    else if (c instanceof Uint8ClampedArray) m = n.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + c
      );
    return {
      buffer: p,
      type: m,
      bytesPerElement: c.BYTES_PER_ELEMENT,
      version: a.version,
      size: f,
    };
  }
  function r(a, l, c) {
    const u = l.array,
      f = l.updateRanges;
    if ((n.bindBuffer(c, a), f.length === 0)) n.bufferSubData(c, 0, u);
    else {
      f.sort((m, v) => m.start - v.start);
      let p = 0;
      for (let m = 1; m < f.length; m++) {
        const v = f[p],
          y = f[m];
        y.start <= v.start + v.count + 1
          ? (v.count = Math.max(v.count, y.start + y.count - v.start))
          : (++p, (f[p] = y));
      }
      f.length = p + 1;
      for (let m = 0, v = f.length; m < v; m++) {
        const y = f[m];
        n.bufferSubData(c, y.start * u.BYTES_PER_ELEMENT, u, y.start, y.count);
      }
      l.clearUpdateRanges();
    }
    l.onUploadCallback();
  }
  function i(a) {
    return a.isInterleavedBufferAttribute && (a = a.data), e.get(a);
  }
  function s(a) {
    a.isInterleavedBufferAttribute && (a = a.data);
    const l = e.get(a);
    l && (n.deleteBuffer(l.buffer), e.delete(a));
  }
  function o(a, l) {
    if (
      (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute)
    ) {
      const u = e.get(a);
      (!u || u.version < a.version) &&
        e.set(a, {
          buffer: a.buffer,
          type: a.type,
          bytesPerElement: a.elementSize,
          version: a.version,
        });
      return;
    }
    const c = e.get(a);
    if (c === void 0) e.set(a, t(a, l));
    else if (c.version < a.version) {
      if (c.size !== a.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      r(c.buffer, a, l), (c.version = a.version);
    }
  }
  return { get: i, remove: s, update: o };
}
var Mse = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  Cse = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  Ase = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  Rse = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  Pse = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  Ise = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  Nse = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  Lse = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  Ose = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
  Dse = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
  kse = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  Use = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Fse = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  Bse = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  zse = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Vse = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  jse = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Hse = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Wse = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Gse = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  $se = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Xse = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
  qse = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
  Kse = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Yse = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Jse = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Zse = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Qse = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  eoe = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  toe = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  noe = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  roe = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  ioe = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  soe = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  ooe = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  aoe = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  loe = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  coe = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  uoe = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  doe = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  hoe = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  foe = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  poe = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  moe = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  goe = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  voe = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  yoe = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  xoe = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  _oe = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  woe = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  Soe = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  boe = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  Eoe = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  Toe = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  Moe = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  Coe = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  Aoe = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  Roe = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Poe = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  Ioe = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
  Noe = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  Loe = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  Ooe = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  Doe = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  koe = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  Uoe = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  Foe = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  Boe = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  zoe = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Voe = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
  joe = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
  Hoe = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  Woe = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  Goe = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  $oe = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  Xoe = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  qoe = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  Koe = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  Yoe = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  Joe = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  Zoe = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  Qoe = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  eae = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  tae = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  nae = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  rae = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  iae = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  sae = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  oae = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  aae = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		float depth = unpackRGBAToDepth( texture2D( depths, uv ) );
		#ifdef USE_REVERSEDEPTHBUF
			return step( depth, compare );
		#else
			return step( compare, depth );
		#endif
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		#ifdef USE_REVERSEDEPTHBUF
			float hard_shadow = step( distribution.x, compare );
		#else
			float hard_shadow = step( compare , distribution.x );
		#endif
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
  lae = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  cae = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  uae = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  dae = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  hae = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  fae = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  pae = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  mae = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  gae = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  vae = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  yae = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  xae = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  _ae = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  wae = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Sae = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  bae = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Eae = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const Tae = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  Mae = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Cae = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Aae = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Rae = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  Pae = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Iae = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  Nae = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	#ifdef USE_REVERSEDEPTHBUF
		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];
	#else
		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;
	#endif
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
  Lae = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  Oae = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  Dae = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  kae = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Uae = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Fae = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Bae = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  zae = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Vae = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  jae = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Hae = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Wae = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Gae = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  $ae = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  Xae = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  qae = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Kae = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  Yae = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Jae = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Zae = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Qae = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  ele = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  tle = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  nle = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  rle = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  ile = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  Ft = {
    alphahash_fragment: Mse,
    alphahash_pars_fragment: Cse,
    alphamap_fragment: Ase,
    alphamap_pars_fragment: Rse,
    alphatest_fragment: Pse,
    alphatest_pars_fragment: Ise,
    aomap_fragment: Nse,
    aomap_pars_fragment: Lse,
    batching_pars_vertex: Ose,
    batching_vertex: Dse,
    begin_vertex: kse,
    beginnormal_vertex: Use,
    bsdfs: Fse,
    iridescence_fragment: Bse,
    bumpmap_pars_fragment: zse,
    clipping_planes_fragment: Vse,
    clipping_planes_pars_fragment: jse,
    clipping_planes_pars_vertex: Hse,
    clipping_planes_vertex: Wse,
    color_fragment: Gse,
    color_pars_fragment: $se,
    color_pars_vertex: Xse,
    color_vertex: qse,
    common: Kse,
    cube_uv_reflection_fragment: Yse,
    defaultnormal_vertex: Jse,
    displacementmap_pars_vertex: Zse,
    displacementmap_vertex: Qse,
    emissivemap_fragment: eoe,
    emissivemap_pars_fragment: toe,
    colorspace_fragment: noe,
    colorspace_pars_fragment: roe,
    envmap_fragment: ioe,
    envmap_common_pars_fragment: soe,
    envmap_pars_fragment: ooe,
    envmap_pars_vertex: aoe,
    envmap_physical_pars_fragment: yoe,
    envmap_vertex: loe,
    fog_vertex: coe,
    fog_pars_vertex: uoe,
    fog_fragment: doe,
    fog_pars_fragment: hoe,
    gradientmap_pars_fragment: foe,
    lightmap_pars_fragment: poe,
    lights_lambert_fragment: moe,
    lights_lambert_pars_fragment: goe,
    lights_pars_begin: voe,
    lights_toon_fragment: xoe,
    lights_toon_pars_fragment: _oe,
    lights_phong_fragment: woe,
    lights_phong_pars_fragment: Soe,
    lights_physical_fragment: boe,
    lights_physical_pars_fragment: Eoe,
    lights_fragment_begin: Toe,
    lights_fragment_maps: Moe,
    lights_fragment_end: Coe,
    logdepthbuf_fragment: Aoe,
    logdepthbuf_pars_fragment: Roe,
    logdepthbuf_pars_vertex: Poe,
    logdepthbuf_vertex: Ioe,
    map_fragment: Noe,
    map_pars_fragment: Loe,
    map_particle_fragment: Ooe,
    map_particle_pars_fragment: Doe,
    metalnessmap_fragment: koe,
    metalnessmap_pars_fragment: Uoe,
    morphinstance_vertex: Foe,
    morphcolor_vertex: Boe,
    morphnormal_vertex: zoe,
    morphtarget_pars_vertex: Voe,
    morphtarget_vertex: joe,
    normal_fragment_begin: Hoe,
    normal_fragment_maps: Woe,
    normal_pars_fragment: Goe,
    normal_pars_vertex: $oe,
    normal_vertex: Xoe,
    normalmap_pars_fragment: qoe,
    clearcoat_normal_fragment_begin: Koe,
    clearcoat_normal_fragment_maps: Yoe,
    clearcoat_pars_fragment: Joe,
    iridescence_pars_fragment: Zoe,
    opaque_fragment: Qoe,
    packing: eae,
    premultiplied_alpha_fragment: tae,
    project_vertex: nae,
    dithering_fragment: rae,
    dithering_pars_fragment: iae,
    roughnessmap_fragment: sae,
    roughnessmap_pars_fragment: oae,
    shadowmap_pars_fragment: aae,
    shadowmap_pars_vertex: lae,
    shadowmap_vertex: cae,
    shadowmask_pars_fragment: uae,
    skinbase_vertex: dae,
    skinning_pars_vertex: hae,
    skinning_vertex: fae,
    skinnormal_vertex: pae,
    specularmap_fragment: mae,
    specularmap_pars_fragment: gae,
    tonemapping_fragment: vae,
    tonemapping_pars_fragment: yae,
    transmission_fragment: xae,
    transmission_pars_fragment: _ae,
    uv_pars_fragment: wae,
    uv_pars_vertex: Sae,
    uv_vertex: bae,
    worldpos_vertex: Eae,
    background_vert: Tae,
    background_frag: Mae,
    backgroundCube_vert: Cae,
    backgroundCube_frag: Aae,
    cube_vert: Rae,
    cube_frag: Pae,
    depth_vert: Iae,
    depth_frag: Nae,
    distanceRGBA_vert: Lae,
    distanceRGBA_frag: Oae,
    equirect_vert: Dae,
    equirect_frag: kae,
    linedashed_vert: Uae,
    linedashed_frag: Fae,
    meshbasic_vert: Bae,
    meshbasic_frag: zae,
    meshlambert_vert: Vae,
    meshlambert_frag: jae,
    meshmatcap_vert: Hae,
    meshmatcap_frag: Wae,
    meshnormal_vert: Gae,
    meshnormal_frag: $ae,
    meshphong_vert: Xae,
    meshphong_frag: qae,
    meshphysical_vert: Kae,
    meshphysical_frag: Yae,
    meshtoon_vert: Jae,
    meshtoon_frag: Zae,
    points_vert: Qae,
    points_frag: ele,
    shadow_vert: tle,
    shadow_frag: nle,
    sprite_vert: rle,
    sprite_frag: ile,
  },
  Ge = {
    common: {
      diffuse: { value: new Je(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Nt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Nt() },
    },
    envmap: {
      envMap: { value: null },
      envMapRotation: { value: new Nt() },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Nt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Nt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Nt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Nt() },
      normalScale: { value: new xe(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Nt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Nt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Nt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Nt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Je(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowIntensity: 1,
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Je(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Nt() },
    },
    sprite: {
      diffuse: { value: new Je(16777215) },
      opacity: { value: 1 },
      center: { value: new xe(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Nt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Nt() },
      alphaTest: { value: 0 },
    },
  },
  Is = {
    basic: {
      uniforms: Hr([
        Ge.common,
        Ge.specularmap,
        Ge.envmap,
        Ge.aomap,
        Ge.lightmap,
        Ge.fog,
      ]),
      vertexShader: Ft.meshbasic_vert,
      fragmentShader: Ft.meshbasic_frag,
    },
    lambert: {
      uniforms: Hr([
        Ge.common,
        Ge.specularmap,
        Ge.envmap,
        Ge.aomap,
        Ge.lightmap,
        Ge.emissivemap,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        Ge.fog,
        Ge.lights,
        { emissive: { value: new Je(0) } },
      ]),
      vertexShader: Ft.meshlambert_vert,
      fragmentShader: Ft.meshlambert_frag,
    },
    phong: {
      uniforms: Hr([
        Ge.common,
        Ge.specularmap,
        Ge.envmap,
        Ge.aomap,
        Ge.lightmap,
        Ge.emissivemap,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        Ge.fog,
        Ge.lights,
        {
          emissive: { value: new Je(0) },
          specular: { value: new Je(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ft.meshphong_vert,
      fragmentShader: Ft.meshphong_frag,
    },
    standard: {
      uniforms: Hr([
        Ge.common,
        Ge.envmap,
        Ge.aomap,
        Ge.lightmap,
        Ge.emissivemap,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        Ge.roughnessmap,
        Ge.metalnessmap,
        Ge.fog,
        Ge.lights,
        {
          emissive: { value: new Je(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ft.meshphysical_vert,
      fragmentShader: Ft.meshphysical_frag,
    },
    toon: {
      uniforms: Hr([
        Ge.common,
        Ge.aomap,
        Ge.lightmap,
        Ge.emissivemap,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        Ge.gradientmap,
        Ge.fog,
        Ge.lights,
        { emissive: { value: new Je(0) } },
      ]),
      vertexShader: Ft.meshtoon_vert,
      fragmentShader: Ft.meshtoon_frag,
    },
    matcap: {
      uniforms: Hr([
        Ge.common,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        Ge.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ft.meshmatcap_vert,
      fragmentShader: Ft.meshmatcap_frag,
    },
    points: {
      uniforms: Hr([Ge.points, Ge.fog]),
      vertexShader: Ft.points_vert,
      fragmentShader: Ft.points_frag,
    },
    dashed: {
      uniforms: Hr([
        Ge.common,
        Ge.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ft.linedashed_vert,
      fragmentShader: Ft.linedashed_frag,
    },
    depth: {
      uniforms: Hr([Ge.common, Ge.displacementmap]),
      vertexShader: Ft.depth_vert,
      fragmentShader: Ft.depth_frag,
    },
    normal: {
      uniforms: Hr([
        Ge.common,
        Ge.bumpmap,
        Ge.normalmap,
        Ge.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ft.meshnormal_vert,
      fragmentShader: Ft.meshnormal_frag,
    },
    sprite: {
      uniforms: Hr([Ge.sprite, Ge.fog]),
      vertexShader: Ft.sprite_vert,
      fragmentShader: Ft.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Nt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ft.background_vert,
      fragmentShader: Ft.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
        backgroundRotation: { value: new Nt() },
      },
      vertexShader: Ft.backgroundCube_vert,
      fragmentShader: Ft.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ft.cube_vert,
      fragmentShader: Ft.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ft.equirect_vert,
      fragmentShader: Ft.equirect_frag,
    },
    distanceRGBA: {
      uniforms: Hr([
        Ge.common,
        Ge.displacementmap,
        {
          referencePosition: { value: new z() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ft.distanceRGBA_vert,
      fragmentShader: Ft.distanceRGBA_frag,
    },
    shadow: {
      uniforms: Hr([
        Ge.lights,
        Ge.fog,
        { color: { value: new Je(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ft.shadow_vert,
      fragmentShader: Ft.shadow_frag,
    },
  };
Is.physical = {
  uniforms: Hr([
    Is.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Nt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Nt() },
      clearcoatNormalScale: { value: new xe(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Nt() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Nt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Nt() },
      sheen: { value: 0 },
      sheenColor: { value: new Je(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Nt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Nt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Nt() },
      transmissionSamplerSize: { value: new xe() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Nt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Je(0) },
      specularColor: { value: new Je(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Nt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Nt() },
      anisotropyVector: { value: new xe() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Nt() },
    },
  ]),
  vertexShader: Ft.meshphysical_vert,
  fragmentShader: Ft.meshphysical_frag,
};
const ry = { r: 0, b: 0, g: 0 },
  Jl = new Di(),
  sle = new Tt();
function ole(n, e, t, r, i, s, o) {
  const a = new Je(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    f = null,
    p = 0,
    m = null;
  function v(S) {
    let b = S.isScene === !0 ? S.background : null;
    return (
      b && b.isTexture && (b = (S.backgroundBlurriness > 0 ? t : e).get(b)), b
    );
  }
  function y(S) {
    let b = !1;
    const C = v(S);
    C === null ? g(a, l) : C && C.isColor && (g(C, 1), (b = !0));
    const A = n.xr.getEnvironmentBlendMode();
    A === "additive"
      ? r.buffers.color.setClear(0, 0, 0, 1, o)
      : A === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, o),
      (n.autoClear || b) &&
        (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
  }
  function x(S, b) {
    const C = v(b);
    C && (C.isCubeTexture || C.mapping === Ph)
      ? (u === void 0 &&
          ((u = new $n(
            new Qc(1, 1, 1),
            new cs({
              name: "BackgroundCubeMaterial",
              uniforms: dh(Is.backgroundCube.uniforms),
              vertexShader: Is.backgroundCube.vertexShader,
              fragmentShader: Is.backgroundCube.fragmentShader,
              side: Jr,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          u.geometry.deleteAttribute("normal"),
          u.geometry.deleteAttribute("uv"),
          (u.onBeforeRender = function (A, R, O) {
            this.matrixWorld.copyPosition(O.matrixWorld);
          }),
          Object.defineProperty(u.material, "envMap", {
            get: function () {
              return this.uniforms.envMap.value;
            },
          }),
          i.update(u)),
        Jl.copy(b.backgroundRotation),
        (Jl.x *= -1),
        (Jl.y *= -1),
        (Jl.z *= -1),
        C.isCubeTexture &&
          C.isRenderTargetTexture === !1 &&
          ((Jl.y *= -1), (Jl.z *= -1)),
        (u.material.uniforms.envMap.value = C),
        (u.material.uniforms.flipEnvMap.value =
          C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1),
        (u.material.uniforms.backgroundBlurriness.value =
          b.backgroundBlurriness),
        (u.material.uniforms.backgroundIntensity.value = b.backgroundIntensity),
        u.material.uniforms.backgroundRotation.value.setFromMatrix4(
          sle.makeRotationFromEuler(Jl)
        ),
        (u.material.toneMapped = Ht.getTransfer(C.colorSpace) !== nn),
        (f !== C || p !== C.version || m !== n.toneMapping) &&
          ((u.material.needsUpdate = !0),
          (f = C),
          (p = C.version),
          (m = n.toneMapping)),
        u.layers.enableAll(),
        S.unshift(u, u.geometry, u.material, 0, 0, null))
      : C &&
        C.isTexture &&
        (c === void 0 &&
          ((c = new $n(
            new Oh(2, 2),
            new cs({
              name: "BackgroundMaterial",
              uniforms: dh(Is.background.uniforms),
              vertexShader: Is.background.vertexShader,
              fragmentShader: Is.background.fragmentShader,
              side: ra,
              depthTest: !1,
              depthWrite: !1,
              fog: !1,
              allowOverride: !1,
            })
          )),
          c.geometry.deleteAttribute("normal"),
          Object.defineProperty(c.material, "map", {
            get: function () {
              return this.uniforms.t2D.value;
            },
          }),
          i.update(c)),
        (c.material.uniforms.t2D.value = C),
        (c.material.uniforms.backgroundIntensity.value = b.backgroundIntensity),
        (c.material.toneMapped = Ht.getTransfer(C.colorSpace) !== nn),
        C.matrixAutoUpdate === !0 && C.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(C.matrix),
        (f !== C || p !== C.version || m !== n.toneMapping) &&
          ((c.material.needsUpdate = !0),
          (f = C),
          (p = C.version),
          (m = n.toneMapping)),
        c.layers.enableAll(),
        S.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function g(S, b) {
    S.getRGB(ry, tV(n)), r.buffers.color.setClear(ry.r, ry.g, ry.b, b, o);
  }
  function _() {
    u !== void 0 && (u.geometry.dispose(), u.material.dispose(), (u = void 0)),
      c !== void 0 &&
        (c.geometry.dispose(), c.material.dispose(), (c = void 0));
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (S, b = 1) {
      a.set(S), (l = b), g(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (S) {
      (l = S), g(a, l);
    },
    render: y,
    addToRenderList: x,
    dispose: _,
  };
}
function ale(n, e) {
  const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    r = {},
    i = p(null);
  let s = i,
    o = !1;
  function a(N, D, j, $, G) {
    let Z = !1;
    const q = f($, j, D);
    s !== q && ((s = q), c(s.object)),
      (Z = m(N, $, j, G)),
      Z && v(N, $, j, G),
      G !== null && e.update(G, n.ELEMENT_ARRAY_BUFFER),
      (Z || o) &&
        ((o = !1),
        b(N, D, j, $),
        G !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(G).buffer));
  }
  function l() {
    return n.createVertexArray();
  }
  function c(N) {
    return n.bindVertexArray(N);
  }
  function u(N) {
    return n.deleteVertexArray(N);
  }
  function f(N, D, j) {
    const $ = j.wireframe === !0;
    let G = r[N.id];
    G === void 0 && ((G = {}), (r[N.id] = G));
    let Z = G[D.id];
    Z === void 0 && ((Z = {}), (G[D.id] = Z));
    let q = Z[$];
    return q === void 0 && ((q = p(l())), (Z[$] = q)), q;
  }
  function p(N) {
    const D = [],
      j = [],
      $ = [];
    for (let G = 0; G < t; G++) (D[G] = 0), (j[G] = 0), ($[G] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: D,
      enabledAttributes: j,
      attributeDivisors: $,
      object: N,
      attributes: {},
      index: null,
    };
  }
  function m(N, D, j, $) {
    const G = s.attributes,
      Z = D.attributes;
    let q = 0;
    const Y = j.getAttributes();
    for (const U in Y)
      if (Y[U].location >= 0) {
        const X = G[U];
        let ie = Z[U];
        if (
          (ie === void 0 &&
            (U === "instanceMatrix" &&
              N.instanceMatrix &&
              (ie = N.instanceMatrix),
            U === "instanceColor" && N.instanceColor && (ie = N.instanceColor)),
          X === void 0 || X.attribute !== ie || (ie && X.data !== ie.data))
        )
          return !0;
        q++;
      }
    return s.attributesNum !== q || s.index !== $;
  }
  function v(N, D, j, $) {
    const G = {},
      Z = D.attributes;
    let q = 0;
    const Y = j.getAttributes();
    for (const U in Y)
      if (Y[U].location >= 0) {
        let X = Z[U];
        X === void 0 &&
          (U === "instanceMatrix" && N.instanceMatrix && (X = N.instanceMatrix),
          U === "instanceColor" && N.instanceColor && (X = N.instanceColor));
        const ie = {};
        (ie.attribute = X), X && X.data && (ie.data = X.data), (G[U] = ie), q++;
      }
    (s.attributes = G), (s.attributesNum = q), (s.index = $);
  }
  function y() {
    const N = s.newAttributes;
    for (let D = 0, j = N.length; D < j; D++) N[D] = 0;
  }
  function x(N) {
    g(N, 0);
  }
  function g(N, D) {
    const j = s.newAttributes,
      $ = s.enabledAttributes,
      G = s.attributeDivisors;
    (j[N] = 1),
      $[N] === 0 && (n.enableVertexAttribArray(N), ($[N] = 1)),
      G[N] !== D && (n.vertexAttribDivisor(N, D), (G[N] = D));
  }
  function _() {
    const N = s.newAttributes,
      D = s.enabledAttributes;
    for (let j = 0, $ = D.length; j < $; j++)
      D[j] !== N[j] && (n.disableVertexAttribArray(j), (D[j] = 0));
  }
  function S(N, D, j, $, G, Z, q) {
    q === !0
      ? n.vertexAttribIPointer(N, D, j, G, Z)
      : n.vertexAttribPointer(N, D, j, $, G, Z);
  }
  function b(N, D, j, $) {
    y();
    const G = $.attributes,
      Z = j.getAttributes(),
      q = D.defaultAttributeValues;
    for (const Y in Z) {
      const U = Z[Y];
      if (U.location >= 0) {
        let H = G[Y];
        if (
          (H === void 0 &&
            (Y === "instanceMatrix" &&
              N.instanceMatrix &&
              (H = N.instanceMatrix),
            Y === "instanceColor" && N.instanceColor && (H = N.instanceColor)),
          H !== void 0)
        ) {
          const X = H.normalized,
            ie = H.itemSize,
            de = e.get(H);
          if (de === void 0) continue;
          const Ee = de.buffer,
            Ie = de.type,
            se = de.bytesPerElement,
            _e = Ie === n.INT || Ie === n.UNSIGNED_INT || H.gpuType === Kx;
          if (H.isInterleavedBufferAttribute) {
            const re = H.data,
              Be = re.stride,
              Ue = H.offset;
            if (re.isInstancedInterleavedBuffer) {
              for (let Fe = 0; Fe < U.locationSize; Fe++)
                g(U.location + Fe, re.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let Fe = 0; Fe < U.locationSize; Fe++) x(U.location + Fe);
            n.bindBuffer(n.ARRAY_BUFFER, Ee);
            for (let Fe = 0; Fe < U.locationSize; Fe++)
              S(
                U.location + Fe,
                ie / U.locationSize,
                Ie,
                X,
                Be * se,
                (Ue + (ie / U.locationSize) * Fe) * se,
                _e
              );
          } else {
            if (H.isInstancedBufferAttribute) {
              for (let re = 0; re < U.locationSize; re++)
                g(U.location + re, H.meshPerAttribute);
              N.isInstancedMesh !== !0 &&
                $._maxInstanceCount === void 0 &&
                ($._maxInstanceCount = H.meshPerAttribute * H.count);
            } else
              for (let re = 0; re < U.locationSize; re++) x(U.location + re);
            n.bindBuffer(n.ARRAY_BUFFER, Ee);
            for (let re = 0; re < U.locationSize; re++)
              S(
                U.location + re,
                ie / U.locationSize,
                Ie,
                X,
                ie * se,
                (ie / U.locationSize) * re * se,
                _e
              );
          }
        } else if (q !== void 0) {
          const X = q[Y];
          if (X !== void 0)
            switch (X.length) {
              case 2:
                n.vertexAttrib2fv(U.location, X);
                break;
              case 3:
                n.vertexAttrib3fv(U.location, X);
                break;
              case 4:
                n.vertexAttrib4fv(U.location, X);
                break;
              default:
                n.vertexAttrib1fv(U.location, X);
            }
        }
      }
    }
    _();
  }
  function C() {
    O();
    for (const N in r) {
      const D = r[N];
      for (const j in D) {
        const $ = D[j];
        for (const G in $) u($[G].object), delete $[G];
        delete D[j];
      }
      delete r[N];
    }
  }
  function A(N) {
    if (r[N.id] === void 0) return;
    const D = r[N.id];
    for (const j in D) {
      const $ = D[j];
      for (const G in $) u($[G].object), delete $[G];
      delete D[j];
    }
    delete r[N.id];
  }
  function R(N) {
    for (const D in r) {
      const j = r[D];
      if (j[N.id] === void 0) continue;
      const $ = j[N.id];
      for (const G in $) u($[G].object), delete $[G];
      delete j[N.id];
    }
  }
  function O() {
    I(), (o = !0), s !== i && ((s = i), c(s.object));
  }
  function I() {
    (i.geometry = null), (i.program = null), (i.wireframe = !1);
  }
  return {
    setup: a,
    reset: O,
    resetDefaultState: I,
    dispose: C,
    releaseStatesOfGeometry: A,
    releaseStatesOfProgram: R,
    initAttributes: y,
    enableAttribute: x,
    disableUnusedAttributes: _,
  };
}
function lle(n, e, t) {
  let r;
  function i(c) {
    r = c;
  }
  function s(c, u) {
    n.drawArrays(r, c, u), t.update(u, r, 1);
  }
  function o(c, u, f) {
    f !== 0 && (n.drawArraysInstanced(r, c, u, f), t.update(u, r, f));
  }
  function a(c, u, f) {
    if (f === 0) return;
    e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, c, 0, u, 0, f);
    let m = 0;
    for (let v = 0; v < f; v++) m += u[v];
    t.update(m, r, 1);
  }
  function l(c, u, f, p) {
    if (f === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let v = 0; v < c.length; v++) o(c[v], u[v], p[v]);
    else {
      m.multiDrawArraysInstancedWEBGL(r, c, 0, u, 0, p, 0, f);
      let v = 0;
      for (let y = 0; y < f; y++) v += u[y] * p[y];
      t.update(v, r, 1);
    }
  }
  (this.setMode = i),
    (this.render = s),
    (this.renderInstances = o),
    (this.renderMultiDraw = a),
    (this.renderMultiDrawInstances = l);
}
function cle(n, e, t, r) {
  let i;
  function s() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const R = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function o(R) {
    return !(
      R !== Or &&
      r.convert(R) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT)
    );
  }
  function a(R) {
    const O =
      R === Ih &&
      (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
    return !(
      R !== ls &&
      r.convert(R) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) &&
      R !== fi &&
      !O
    );
  }
  function l(R) {
    if (R === "highp") {
      if (
        n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision >
          0 &&
        n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      R = "mediump";
    }
    return R === "mediump" &&
      n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision >
        0 &&
      n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  let c = t.precision !== void 0 ? t.precision : "highp";
  const u = l(c);
  u !== c &&
    (console.warn(
      "THREE.WebGLRenderer:",
      c,
      "not supported, using",
      u,
      "instead."
    ),
    (c = u));
  const f = t.logarithmicDepthBuffer === !0,
    p = t.reversedDepthBuffer === !0 && e.has("EXT_clip_control"),
    m = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
    v = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    y = n.getParameter(n.MAX_TEXTURE_SIZE),
    x = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
    g = n.getParameter(n.MAX_VERTEX_ATTRIBS),
    _ = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
    S = n.getParameter(n.MAX_VARYING_VECTORS),
    b = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
    C = v > 0,
    A = n.getParameter(n.MAX_SAMPLES);
  return {
    isWebGL2: !0,
    getMaxAnisotropy: s,
    getMaxPrecision: l,
    textureFormatReadable: o,
    textureTypeReadable: a,
    precision: c,
    logarithmicDepthBuffer: f,
    reversedDepthBuffer: p,
    maxTextures: m,
    maxVertexTextures: v,
    maxTextureSize: y,
    maxCubemapSize: x,
    maxAttributes: g,
    maxVertexUniforms: _,
    maxVaryings: S,
    maxFragmentUniforms: b,
    vertexTextures: C,
    maxSamples: A,
  };
}
function ule(n) {
  const e = this;
  let t = null,
    r = 0,
    i = !1,
    s = !1;
  const o = new Ua(),
    a = new Nt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (f, p) {
      const m = f.length !== 0 || p || r !== 0 || i;
      return (i = p), (r = f.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (f, p) {
      t = u(f, p, 0);
    }),
    (this.setState = function (f, p, m) {
      const v = f.clippingPlanes,
        y = f.clipIntersection,
        x = f.clipShadows,
        g = n.get(f);
      if (!i || v === null || v.length === 0 || (s && !x)) s ? u(null) : c();
      else {
        const _ = s ? 0 : r,
          S = _ * 4;
        let b = g.clippingState || null;
        (l.value = b), (b = u(v, p, S, m));
        for (let C = 0; C !== S; ++C) b[C] = t[C];
        (g.clippingState = b),
          (this.numIntersection = y ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = r > 0)),
      (e.numPlanes = r),
      (e.numIntersection = 0);
  }
  function u(f, p, m, v) {
    const y = f !== null ? f.length : 0;
    let x = null;
    if (y !== 0) {
      if (((x = l.value), v !== !0 || x === null)) {
        const g = m + y * 4,
          _ = p.matrixWorldInverse;
        a.getNormalMatrix(_),
          (x === null || x.length < g) && (x = new Float32Array(g));
        for (let S = 0, b = m; S !== y; ++S, b += 4)
          o.copy(f[S]).applyMatrix4(_, a),
            o.normal.toArray(x, b),
            (x[b + 3] = o.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = y), (e.numIntersection = 0), x;
  }
}
function dle(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Gp ? (o.mapping = ia) : a === $p && (o.mapping = fl), o;
  }
  function r(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Gp || a === $p)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new iV(l.height);
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", i),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function i(o) {
    const a = o.target;
    a.removeEventListener("dispose", i);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: r, dispose: s };
}
const wd = 4,
  XL = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  cc = 20,
  O1 = new Lm(),
  qL = new Je();
let D1 = null,
  k1 = 0,
  U1 = 0,
  F1 = !1;
const sc = (1 + Math.sqrt(5)) / 2,
  $u = 1 / sc,
  KL = [
    new z(-sc, $u, 0),
    new z(sc, $u, 0),
    new z(-$u, 0, sc),
    new z($u, 0, sc),
    new z(0, sc, -$u),
    new z(0, sc, $u),
    new z(-1, 1, -1),
    new z(1, 1, -1),
    new z(-1, 1, 1),
    new z(1, 1, 1),
  ],
  hle = new z();
class JE {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, r = 0.1, i = 100, s = {}) {
    const { size: o = 256, position: a = hle } = s;
    (D1 = this._renderer.getRenderTarget()),
      (k1 = this._renderer.getActiveCubeFace()),
      (U1 = this._renderer.getActiveMipmapLevel()),
      (F1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1),
      this._setSize(o);
    const l = this._allocateTargets();
    return (
      (l.depthBuffer = !0),
      this._sceneToCubeUV(e, r, i, l, a),
      t > 0 && this._blur(l, 0, 0, t),
      this._applyPMREM(l),
      this._cleanup(l),
      l
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = ZL()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = JL()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(D1, k1, U1),
      (this._renderer.xr.enabled = F1),
      (e.scissorTest = !1),
      iy(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === ia || e.mapping === fl
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (D1 = this._renderer.getRenderTarget()),
      (k1 = this._renderer.getActiveCubeFace()),
      (U1 = this._renderer.getActiveMipmapLevel()),
      (F1 = this._renderer.xr.enabled),
      (this._renderer.xr.enabled = !1);
    const r = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      r = {
        magFilter: Zn,
        minFilter: Zn,
        generateMipmaps: !1,
        type: Ih,
        format: Or,
        colorSpace: Vc,
        depthBuffer: !1,
      },
      i = YL(e, t, r);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = YL(e, t, r));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = fle(s)),
        (this._blurMaterial = ple(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new $n(this._lodPlanes[0], e);
    this._renderer.compile(t, O1);
  }
  _sceneToCubeUV(e, t, r, i, s) {
    const l = new lr(90, 1, t, r),
      c = [1, -1, 1, 1, 1, 1],
      u = [1, 1, 1, -1, -1, -1],
      f = this._renderer,
      p = f.autoClear,
      m = f.toneMapping;
    f.getClearColor(qL),
      (f.toneMapping = go),
      (f.autoClear = !1),
      f.state.buffers.depth.getReversed() &&
        (f.setRenderTarget(i), f.clearDepth(), f.setRenderTarget(null));
    const y = new Sl({
        name: "PMREM.Background",
        side: Jr,
        depthWrite: !1,
        depthTest: !1,
      }),
      x = new $n(new Qc(), y);
    let g = !1;
    const _ = e.background;
    _
      ? _.isColor && (y.color.copy(_), (e.background = null), (g = !0))
      : (y.color.copy(qL), (g = !0));
    for (let S = 0; S < 6; S++) {
      const b = S % 3;
      b === 0
        ? (l.up.set(0, c[S], 0),
          l.position.set(s.x, s.y, s.z),
          l.lookAt(s.x + u[S], s.y, s.z))
        : b === 1
        ? (l.up.set(0, 0, c[S]),
          l.position.set(s.x, s.y, s.z),
          l.lookAt(s.x, s.y + u[S], s.z))
        : (l.up.set(0, c[S], 0),
          l.position.set(s.x, s.y, s.z),
          l.lookAt(s.x, s.y, s.z + u[S]));
      const C = this._cubeSize;
      iy(i, b * C, S > 2 ? C : 0, C, C),
        f.setRenderTarget(i),
        g && f.render(x, l),
        f.render(e, l);
    }
    x.geometry.dispose(),
      x.material.dispose(),
      (f.toneMapping = m),
      (f.autoClear = p),
      (e.background = _);
  }
  _textureToCubeUV(e, t) {
    const r = this._renderer,
      i = e.mapping === ia || e.mapping === fl;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = ZL()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = JL());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      o = new $n(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    iy(t, 0, 0, 3 * l, 2 * l), r.setRenderTarget(t), r.render(o, O1);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      r = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let s = 1; s < i; s++) {
      const o = Math.sqrt(
          this._sigmas[s] * this._sigmas[s] -
            this._sigmas[s - 1] * this._sigmas[s - 1]
        ),
        a = KL[(i - s - 1) % KL.length];
      this._blur(e, s - 1, s, o, a);
    }
    t.autoClear = r;
  }
  _blur(e, t, r, i, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, r, i, "latitudinal", s),
      this._halfBlur(o, e, r, r, i, "longitudinal", s);
  }
  _halfBlur(e, t, r, i, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      f = new $n(this._lodPlanes[i], c),
      p = c.uniforms,
      m = this._sizeLods[r] - 1,
      v = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * cc - 1),
      y = s / v,
      x = isFinite(s) ? 1 + Math.floor(u * y) : cc;
    x > cc &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${cc}`
      );
    const g = [];
    let _ = 0;
    for (let R = 0; R < cc; ++R) {
      const O = R / y,
        I = Math.exp((-O * O) / 2);
      g.push(I), R === 0 ? (_ += I) : R < x && (_ += 2 * I);
    }
    for (let R = 0; R < g.length; R++) g[R] = g[R] / _;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = g),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: S } = this;
    (p.dTheta.value = v), (p.mipInt.value = S - r);
    const b = this._sizeLods[i],
      C = 3 * b * (i > S - wd ? i - S + wd : 0),
      A = 4 * (this._cubeSize - b);
    iy(t, C, A, 3 * b, 2 * b), l.setRenderTarget(t), l.render(f, O1);
  }
}
function fle(n) {
  const e = [],
    t = [],
    r = [];
  let i = n;
  const s = n - wd + 1 + XL.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, i);
    t.push(a);
    let l = 1 / a;
    o > n - wd ? (l = XL[o - n + wd - 1]) : o === 0 && (l = 0), r.push(l);
    const c = 1 / (a - 2),
      u = -c,
      f = 1 + c,
      p = [u, u, f, u, f, f, u, u, f, f, u, f],
      m = 6,
      v = 6,
      y = 3,
      x = 2,
      g = 1,
      _ = new Float32Array(y * v * m),
      S = new Float32Array(x * v * m),
      b = new Float32Array(g * v * m);
    for (let A = 0; A < m; A++) {
      const R = ((A % 3) * 2) / 3 - 1,
        O = A > 2 ? 0 : -1,
        I = [
          R,
          O,
          0,
          R + 2 / 3,
          O,
          0,
          R + 2 / 3,
          O + 1,
          0,
          R,
          O,
          0,
          R + 2 / 3,
          O + 1,
          0,
          R,
          O + 1,
          0,
        ];
      _.set(I, y * v * A), S.set(p, x * v * A);
      const N = [A, A, A, A, A, A];
      b.set(N, g * v * A);
    }
    const C = new kt();
    C.setAttribute("position", new sn(_, y)),
      C.setAttribute("uv", new sn(S, x)),
      C.setAttribute("faceIndex", new sn(b, g)),
      e.push(C),
      i > wd && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: r };
}
function YL(n, e, t) {
  const r = new xo(n, e, t);
  return (
    (r.texture.mapping = Ph),
    (r.texture.name = "PMREM.cubeUv"),
    (r.scissorTest = !0),
    r
  );
}
function iy(n, e, t, r, i) {
  n.viewport.set(e, t, r, i), n.scissor.set(e, t, r, i);
}
function ple(n, e, t) {
  const r = new Float32Array(cc),
    i = new z(0, 1, 0);
  return new cs({
    name: "SphericalGaussianBlur",
    defines: {
      n: cc,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: r },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: uA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Xo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function JL() {
  return new cs({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: uA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Xo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function ZL() {
  return new cs({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: uA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Xo,
    depthTest: !1,
    depthWrite: !1,
  });
}
function uA() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function mle(n) {
  let e = new WeakMap(),
    t = null;
  function r(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === Gp || l === $p,
        u = l === ia || l === fl;
      if (c || u) {
        let f = e.get(a);
        const p = f !== void 0 ? f.texture.pmremVersion : 0;
        if (a.isRenderTargetTexture && a.pmremVersion !== p)
          return (
            t === null && (t = new JE(n)),
            (f = c ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f)),
            (f.texture.pmremVersion = a.pmremVersion),
            e.set(a, f),
            f.texture
          );
        if (f !== void 0) return f.texture;
        {
          const m = a.image;
          return (c && m && m.height > 0) || (u && m && i(m))
            ? (t === null && (t = new JE(n)),
              (f = c ? t.fromEquirectangular(a) : t.fromCubemap(a)),
              (f.texture.pmremVersion = a.pmremVersion),
              e.set(a, f),
              a.addEventListener("dispose", s),
              f.texture)
            : null;
        }
      }
    }
    return a;
  }
  function i(a) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: r, dispose: o };
}
function gle(n) {
  const e = {};
  function t(r) {
    if (e[r] !== void 0) return e[r];
    let i;
    switch (r) {
      case "WEBGL_depth_texture":
        i =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = n.getExtension(r);
    }
    return (e[r] = i), i;
  }
  return {
    has: function (r) {
      return t(r) !== null;
    },
    init: function () {
      t("EXT_color_buffer_float"),
        t("WEBGL_clip_cull_distance"),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture"),
        t("WEBGL_render_shared_exponent");
    },
    get: function (r) {
      const i = t(r);
      return (
        i === null &&
          Dd("THREE.WebGLRenderer: " + r + " extension not supported."),
        i
      );
    },
  };
}
function vle(n, e, t, r) {
  const i = {},
    s = new WeakMap();
  function o(f) {
    const p = f.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    p.removeEventListener("dispose", o), delete i[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      r.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(f, p) {
    return (
      i[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (i[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(f) {
    const p = f.attributes;
    for (const m in p) e.update(p[m], n.ARRAY_BUFFER);
  }
  function c(f) {
    const p = [],
      m = f.index,
      v = f.attributes.position;
    let y = 0;
    if (m !== null) {
      const _ = m.array;
      y = m.version;
      for (let S = 0, b = _.length; S < b; S += 3) {
        const C = _[S + 0],
          A = _[S + 1],
          R = _[S + 2];
        p.push(C, A, A, R, R, C);
      }
    } else if (v !== void 0) {
      const _ = v.array;
      y = v.version;
      for (let S = 0, b = _.length / 3 - 1; S < b; S += 3) {
        const C = S + 0,
          A = S + 1,
          R = S + 2;
        p.push(C, A, A, R, R, C);
      }
    } else return;
    const x = new (J4(p) ? FC : UC)(p, 1);
    x.version = y;
    const g = s.get(f);
    g && e.remove(g), s.set(f, x);
  }
  function u(f) {
    const p = s.get(f);
    if (p) {
      const m = f.index;
      m !== null && p.version < m.version && c(f);
    } else c(f);
    return s.get(f);
  }
  return { get: a, update: l, getWireframeAttribute: u };
}
function yle(n, e, t) {
  let r;
  function i(p) {
    r = p;
  }
  let s, o;
  function a(p) {
    (s = p.type), (o = p.bytesPerElement);
  }
  function l(p, m) {
    n.drawElements(r, m, s, p * o), t.update(m, r, 1);
  }
  function c(p, m, v) {
    v !== 0 && (n.drawElementsInstanced(r, m, s, p * o, v), t.update(m, r, v));
  }
  function u(p, m, v) {
    if (v === 0) return;
    e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, m, 0, s, p, 0, v);
    let x = 0;
    for (let g = 0; g < v; g++) x += m[g];
    t.update(x, r, 1);
  }
  function f(p, m, v, y) {
    if (v === 0) return;
    const x = e.get("WEBGL_multi_draw");
    if (x === null) for (let g = 0; g < p.length; g++) c(p[g] / o, m[g], y[g]);
    else {
      x.multiDrawElementsInstancedWEBGL(r, m, 0, s, p, 0, y, 0, v);
      let g = 0;
      for (let _ = 0; _ < v; _++) g += m[_] * y[_];
      t.update(g, r, 1);
    }
  }
  (this.setMode = i),
    (this.setIndex = a),
    (this.render = l),
    (this.renderInstances = c),
    (this.renderMultiDraw = u),
    (this.renderMultiDrawInstances = f);
}
function xle(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function r(s, o, a) {
    switch ((t.calls++, o)) {
      case n.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n.LINES:
        t.lines += a * (s / 2);
        break;
      case n.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n.LINE_LOOP:
        t.lines += a * s;
        break;
      case n.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function i() {
    (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: r,
  };
}
function _le(n, e, t) {
  const r = new WeakMap(),
    i = new Gt();
  function s(o, a, l) {
    const c = o.morphTargetInfluences,
      u =
        a.morphAttributes.position ||
        a.morphAttributes.normal ||
        a.morphAttributes.color,
      f = u !== void 0 ? u.length : 0;
    let p = r.get(a);
    if (p === void 0 || p.count !== f) {
      let N = function () {
        O.dispose(), r.delete(a), a.removeEventListener("dispose", N);
      };
      var m = N;
      p !== void 0 && p.texture.dispose();
      const v = a.morphAttributes.position !== void 0,
        y = a.morphAttributes.normal !== void 0,
        x = a.morphAttributes.color !== void 0,
        g = a.morphAttributes.position || [],
        _ = a.morphAttributes.normal || [],
        S = a.morphAttributes.color || [];
      let b = 0;
      v === !0 && (b = 1), y === !0 && (b = 2), x === !0 && (b = 3);
      let C = a.attributes.position.count * b,
        A = 1;
      C > e.maxTextureSize &&
        ((A = Math.ceil(C / e.maxTextureSize)), (C = e.maxTextureSize));
      const R = new Float32Array(C * A * 4 * f),
        O = new n_(R, C, A, f);
      (O.type = fi), (O.needsUpdate = !0);
      const I = b * 4;
      for (let D = 0; D < f; D++) {
        const j = g[D],
          $ = _[D],
          G = S[D],
          Z = C * A * 4 * D;
        for (let q = 0; q < j.count; q++) {
          const Y = q * I;
          v === !0 &&
            (i.fromBufferAttribute(j, q),
            (R[Z + Y + 0] = i.x),
            (R[Z + Y + 1] = i.y),
            (R[Z + Y + 2] = i.z),
            (R[Z + Y + 3] = 0)),
            y === !0 &&
              (i.fromBufferAttribute($, q),
              (R[Z + Y + 4] = i.x),
              (R[Z + Y + 5] = i.y),
              (R[Z + Y + 6] = i.z),
              (R[Z + Y + 7] = 0)),
            x === !0 &&
              (i.fromBufferAttribute(G, q),
              (R[Z + Y + 8] = i.x),
              (R[Z + Y + 9] = i.y),
              (R[Z + Y + 10] = i.z),
              (R[Z + Y + 11] = G.itemSize === 4 ? i.w : 1));
        }
      }
      (p = { count: f, texture: O, size: new xe(C, A) }),
        r.set(a, p),
        a.addEventListener("dispose", N);
    }
    if (o.isInstancedMesh === !0 && o.morphTexture !== null)
      l.getUniforms().setValue(n, "morphTexture", o.morphTexture, t);
    else {
      let v = 0;
      for (let x = 0; x < c.length; x++) v += c[x];
      const y = a.morphTargetsRelative ? 1 : 1 - v;
      l.getUniforms().setValue(n, "morphTargetBaseInfluence", y),
        l.getUniforms().setValue(n, "morphTargetInfluences", c);
    }
    l.getUniforms().setValue(n, "morphTargetsTexture", p.texture, t),
      l.getUniforms().setValue(n, "morphTargetsTextureSize", p.size);
  }
  return { update: s };
}
function wle(n, e, t, r) {
  let i = new WeakMap();
  function s(l) {
    const c = r.render.frame,
      u = l.geometry,
      f = e.get(l, u);
    if (
      (i.get(f) !== c && (e.update(f), i.set(f, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        i.get(l) !== c &&
          (t.update(l.instanceMatrix, n.ARRAY_BUFFER),
          l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER),
          i.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const p = l.skeleton;
      i.get(p) !== c && (p.update(), i.set(p, c));
    }
    return f;
  }
  function o() {
    i = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: o };
}
const rj = new Nn(),
  QL = new HC(1, 1),
  ij = new n_(),
  sj = new r_(),
  oj = new Mm(),
  eO = [],
  tO = [],
  nO = new Float32Array(16),
  rO = new Float32Array(9),
  iO = new Float32Array(4);
function Dh(n, e, t) {
  const r = n[0];
  if (r <= 0 || r > 0) return n;
  const i = e * t;
  let s = eO[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (eO[i] = s)), e !== 0)) {
    r.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Qn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, r = n.length; t < r; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function er(n, e) {
  for (let t = 0, r = e.length; t < r; t++) n[t] = e[t];
}
function E_(n, e) {
  let t = tO[e];
  t === void 0 && ((t = new Int32Array(e)), (tO[e] = t));
  for (let r = 0; r !== e; ++r) t[r] = n.allocateTextureUnit();
  return t;
}
function Sle(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function ble(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Qn(t, e)) return;
    n.uniform2fv(this.addr, e), er(t, e);
  }
}
function Ele(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Qn(t, e)) return;
    n.uniform3fv(this.addr, e), er(t, e);
  }
}
function Tle(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Qn(t, e)) return;
    n.uniform4fv(this.addr, e), er(t, e);
  }
}
function Mle(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Qn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), er(t, e);
  } else {
    if (Qn(t, r)) return;
    iO.set(r), n.uniformMatrix2fv(this.addr, !1, iO), er(t, r);
  }
}
function Cle(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Qn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), er(t, e);
  } else {
    if (Qn(t, r)) return;
    rO.set(r), n.uniformMatrix3fv(this.addr, !1, rO), er(t, r);
  }
}
function Ale(n, e) {
  const t = this.cache,
    r = e.elements;
  if (r === void 0) {
    if (Qn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), er(t, e);
  } else {
    if (Qn(t, r)) return;
    nO.set(r), n.uniformMatrix4fv(this.addr, !1, nO), er(t, r);
  }
}
function Rle(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function Ple(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Qn(t, e)) return;
    n.uniform2iv(this.addr, e), er(t, e);
  }
}
function Ile(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Qn(t, e)) return;
    n.uniform3iv(this.addr, e), er(t, e);
  }
}
function Nle(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Qn(t, e)) return;
    n.uniform4iv(this.addr, e), er(t, e);
  }
}
function Lle(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function Ole(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Qn(t, e)) return;
    n.uniform2uiv(this.addr, e), er(t, e);
  }
}
function Dle(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Qn(t, e)) return;
    n.uniform3uiv(this.addr, e), er(t, e);
  }
}
function kle(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Qn(t, e)) return;
    n.uniform4uiv(this.addr, e), er(t, e);
  }
}
function Ule(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i));
  let s;
  this.type === n.SAMPLER_2D_SHADOW
    ? ((QL.compareFunction = OC), (s = QL))
    : (s = rj),
    t.setTexture2D(e || s, i);
}
function Fle(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture3D(e || sj, i);
}
function Ble(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTextureCube(e || oj, i);
}
function zle(n, e, t) {
  const r = this.cache,
    i = t.allocateTextureUnit();
  r[0] !== i && (n.uniform1i(this.addr, i), (r[0] = i)),
    t.setTexture2DArray(e || ij, i);
}
function Vle(n) {
  switch (n) {
    case 5126:
      return Sle;
    case 35664:
      return ble;
    case 35665:
      return Ele;
    case 35666:
      return Tle;
    case 35674:
      return Mle;
    case 35675:
      return Cle;
    case 35676:
      return Ale;
    case 5124:
    case 35670:
      return Rle;
    case 35667:
    case 35671:
      return Ple;
    case 35668:
    case 35672:
      return Ile;
    case 35669:
    case 35673:
      return Nle;
    case 5125:
      return Lle;
    case 36294:
      return Ole;
    case 36295:
      return Dle;
    case 36296:
      return kle;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Ule;
    case 35679:
    case 36299:
    case 36307:
      return Fle;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Ble;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return zle;
  }
}
function jle(n, e) {
  n.uniform1fv(this.addr, e);
}
function Hle(n, e) {
  const t = Dh(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function Wle(n, e) {
  const t = Dh(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function Gle(n, e) {
  const t = Dh(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function $le(n, e) {
  const t = Dh(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function Xle(n, e) {
  const t = Dh(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function qle(n, e) {
  const t = Dh(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function Kle(n, e) {
  n.uniform1iv(this.addr, e);
}
function Yle(n, e) {
  n.uniform2iv(this.addr, e);
}
function Jle(n, e) {
  n.uniform3iv(this.addr, e);
}
function Zle(n, e) {
  n.uniform4iv(this.addr, e);
}
function Qle(n, e) {
  n.uniform1uiv(this.addr, e);
}
function ece(n, e) {
  n.uniform2uiv(this.addr, e);
}
function tce(n, e) {
  n.uniform3uiv(this.addr, e);
}
function nce(n, e) {
  n.uniform4uiv(this.addr, e);
}
function rce(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E_(t, i);
  Qn(r, s) || (n.uniform1iv(this.addr, s), er(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || rj, s[o]);
}
function ice(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E_(t, i);
  Qn(r, s) || (n.uniform1iv(this.addr, s), er(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || sj, s[o]);
}
function sce(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E_(t, i);
  Qn(r, s) || (n.uniform1iv(this.addr, s), er(r, s));
  for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || oj, s[o]);
}
function oce(n, e, t) {
  const r = this.cache,
    i = e.length,
    s = E_(t, i);
  Qn(r, s) || (n.uniform1iv(this.addr, s), er(r, s));
  for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || ij, s[o]);
}
function ace(n) {
  switch (n) {
    case 5126:
      return jle;
    case 35664:
      return Hle;
    case 35665:
      return Wle;
    case 35666:
      return Gle;
    case 35674:
      return $le;
    case 35675:
      return Xle;
    case 35676:
      return qle;
    case 5124:
    case 35670:
      return Kle;
    case 35667:
    case 35671:
      return Yle;
    case 35668:
    case 35672:
      return Jle;
    case 35669:
    case 35673:
      return Zle;
    case 5125:
      return Qle;
    case 36294:
      return ece;
    case 36295:
      return tce;
    case 36296:
      return nce;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return rce;
    case 35679:
    case 36299:
    case 36307:
      return ice;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return sce;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return oce;
  }
}
class lce {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.setValue = Vle(t.type));
  }
}
class cce {
  constructor(e, t, r) {
    (this.id = e),
      (this.addr = r),
      (this.cache = []),
      (this.type = t.type),
      (this.size = t.size),
      (this.setValue = ace(t.type));
  }
}
class uce {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, r) {
    const i = this.seq;
    for (let s = 0, o = i.length; s !== o; ++s) {
      const a = i[s];
      a.setValue(e, t[a.id], r);
    }
  }
}
const B1 = /(\w+)(\])?(\[|\.)?/g;
function sO(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function dce(n, e, t) {
  const r = n.name,
    i = r.length;
  for (B1.lastIndex = 0; ; ) {
    const s = B1.exec(r),
      o = B1.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === i))) {
      sO(t, c === void 0 ? new lce(a, n, e) : new cce(a, n, e));
      break;
    } else {
      let f = t.map[a];
      f === void 0 && ((f = new uce(a)), sO(t, f)), (t = f);
    }
  }
}
class Ny {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; ++i) {
      const s = e.getActiveUniform(t, i),
        o = e.getUniformLocation(t, s.name);
      dce(s, o, this);
    }
  }
  setValue(e, t, r, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, r, i);
  }
  setOptional(e, t, r) {
    const i = t[r];
    i !== void 0 && this.setValue(e, r, i);
  }
  static upload(e, t, r, i) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = r[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const r = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const o = e[i];
      o.id in t && r.push(o);
    }
    return r;
  }
}
function oO(n, e, t) {
  const r = n.createShader(e);
  return n.shaderSource(r, t), n.compileShader(r), r;
}
const hce = 37297;
let fce = 0;
function pce(n, e) {
  const t = n.split(`
`),
    r = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = i; o < s; o++) {
    const a = o + 1;
    r.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return r.join(`
`);
}
const aO = new Nt();
function mce(n) {
  Ht._getMatrix(aO, Ht.workingColorSpace, n);
  const e = `mat3( ${aO.elements.map((t) => t.toFixed(4))} )`;
  switch (Ht.getTransfer(n)) {
    case Jp:
      return [e, "LinearTransferOETF"];
    case nn:
      return [e, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space: ", n),
        [e, "LinearTransferOETF"]
      );
  }
}
function lO(n, e, t) {
  const r = n.getShaderParameter(e, n.COMPILE_STATUS),
    s = (n.getShaderInfoLog(e) || "").trim();
  if (r && s === "") return "";
  const o = /ERROR: 0:(\d+)/.exec(s);
  if (o) {
    const a = parseInt(o[1]);
    return (
      t.toUpperCase() +
      `

` +
      s +
      `

` +
      pce(n.getShaderSource(e), a)
    );
  } else return s;
}
function gce(n, e) {
  const t = mce(e);
  return [
    `vec4 ${n}( vec4 value ) {`,
    `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
    "}",
  ].join(`
`);
}
function vce(n, e) {
  let t;
  switch (e) {
    case I4:
      t = "Linear";
      break;
    case N4:
      t = "Reinhard";
      break;
    case L4:
      t = "Cineon";
      break;
    case EC:
      t = "ACESFilmic";
      break;
    case D4:
      t = "AgX";
      break;
    case k4:
      t = "Neutral";
      break;
    case O4:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
const sy = new z();
function yce() {
  Ht.getLuminanceCoefficients(sy);
  const n = sy.x.toFixed(4),
    e = sy.y.toFixed(4),
    t = sy.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
    "	return dot( weights, rgb );",
    "}",
  ].join(`
`);
}
function xce(n) {
  return [
    n.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(kf).join(`
`);
}
function _ce(n) {
  const e = [];
  for (const t in n) {
    const r = n[t];
    r !== !1 && e.push("#define " + t + " " + r);
  }
  return e.join(`
`);
}
function wce(n, e) {
  const t = {},
    r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < r; i++) {
    const s = n.getActiveAttrib(e, i),
      o = s.name;
    let a = 1;
    s.type === n.FLOAT_MAT2 && (a = 2),
      s.type === n.FLOAT_MAT3 && (a = 3),
      s.type === n.FLOAT_MAT4 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function kf(n) {
  return n !== "";
}
function cO(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function uO(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Sce = /^[ \t]*#include +<([\w\d./]+)>/gm;
function ZE(n) {
  return n.replace(Sce, Ece);
}
const bce = new Map();
function Ece(n, e) {
  let t = Ft[e];
  if (t === void 0) {
    const r = bce.get(e);
    if (r !== void 0)
      (t = Ft[r]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          r
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return ZE(t);
}
const Tce =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function dO(n) {
  return n.replace(Tce, Mce);
}
function Mce(n, e, t, r) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += r
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function hO(n) {
  let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function Cce(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Xx
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === np
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ts && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function Ace(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case ia:
      case fl:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case Ph:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function Rce(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case fl:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function Pce(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case bm:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case R4:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case P4:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function Ice(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    r = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: r,
    maxMip: t,
  };
}
function Nce(n, e, t, r) {
  const i = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = Cce(t),
    c = Ace(t),
    u = Rce(t),
    f = Pce(t),
    p = Ice(t),
    m = xce(t),
    v = _ce(s),
    y = i.createProgram();
  let x,
    g,
    _ = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((x = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(kf).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (g = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
      ].filter(kf).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((x = [
        hO(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv
          : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reversedDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(kf).join(`
`)),
      (g = [
        hO(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + f : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor
          ? "#define USE_COLOR"
          : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive
          ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
          : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reversedDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== go ? "#define TONE_MAPPING" : "",
        t.toneMapping !== go ? Ft.tonemapping_pars_fragment : "",
        t.toneMapping !== go ? vce("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ft.colorspace_pars_fragment,
        gce("linearToOutputTexel", t.outputColorSpace),
        yce(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(kf).join(`
`))),
    (o = ZE(o)),
    (o = cO(o, t)),
    (o = uO(o, t)),
    (a = ZE(a)),
    (a = cO(a, t)),
    (a = uO(a, t)),
    (o = dO(o)),
    (a = dO(a)),
    t.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (x =
        [
          m,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (g =
        [
          "#define varying in",
          t.glslVersion === ix
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === ix ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const S = _ + x + o,
    b = _ + g + a,
    C = oO(i, i.VERTEX_SHADER, S),
    A = oO(i, i.FRAGMENT_SHADER, b);
  i.attachShader(y, C),
    i.attachShader(y, A),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(y, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"),
    i.linkProgram(y);
  function R(D) {
    if (n.debug.checkShaderErrors) {
      const j = i.getProgramInfoLog(y) || "",
        $ = i.getShaderInfoLog(C) || "",
        G = i.getShaderInfoLog(A) || "",
        Z = j.trim(),
        q = $.trim(),
        Y = G.trim();
      let U = !0,
        H = !0;
      if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
        if (((U = !1), typeof n.debug.onShaderError == "function"))
          n.debug.onShaderError(i, y, C, A);
        else {
          const X = lO(i, C, "vertex"),
            ie = lO(i, A, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              i.getError() +
              " - VALIDATE_STATUS " +
              i.getProgramParameter(y, i.VALIDATE_STATUS) +
              `

Material Name: ` +
              D.name +
              `
Material Type: ` +
              D.type +
              `

Program Info Log: ` +
              Z +
              `
` +
              X +
              `
` +
              ie
          );
        }
      else
        Z !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", Z)
          : (q === "" || Y === "") && (H = !1);
      H &&
        (D.diagnostics = {
          runnable: U,
          programLog: Z,
          vertexShader: { log: q, prefix: x },
          fragmentShader: { log: Y, prefix: g },
        });
    }
    i.deleteShader(C), i.deleteShader(A), (O = new Ny(i, y)), (I = wce(i, y));
  }
  let O;
  this.getUniforms = function () {
    return O === void 0 && R(this), O;
  };
  let I;
  this.getAttributes = function () {
    return I === void 0 && R(this), I;
  };
  let N = t.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return N === !1 && (N = i.getProgramParameter(y, hce)), N;
    }),
    (this.destroy = function () {
      r.releaseStatesOfProgram(this),
        i.deleteProgram(y),
        (this.program = void 0);
    }),
    (this.type = t.shaderType),
    (this.name = t.shaderName),
    (this.id = fce++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = y),
    (this.vertexShader = C),
    (this.fragmentShader = A),
    this
  );
}
let Lce = 0;
class Oce {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      r = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(r),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(i) === !1 && (o.add(i), i.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const r of t)
      r.usedTimes--, r.usedTimes === 0 && this.shaderCache.delete(r.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Set()), t.set(e, r)), r;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let r = t.get(e);
    return r === void 0 && ((r = new Dce(e)), t.set(e, r)), r;
  }
}
class Dce {
  constructor(e) {
    (this.id = Lce++), (this.code = e), (this.usedTimes = 0);
  }
}
function kce(n, e, t, r, i, s, o) {
  const a = new Ic(),
    l = new Oce(),
    c = new Set(),
    u = [],
    f = i.logarithmicDepthBuffer,
    p = i.vertexTextures;
  let m = i.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function y(I) {
    return c.add(I), I === 0 ? "uv" : `uv${I}`;
  }
  function x(I, N, D, j, $) {
    const G = j.fog,
      Z = $.geometry,
      q = I.isMeshStandardMaterial ? j.environment : null,
      Y = (I.isMeshStandardMaterial ? t : e).get(I.envMap || q),
      U = Y && Y.mapping === Ph ? Y.image.height : null,
      H = v[I.type];
    I.precision !== null &&
      ((m = i.getMaxPrecision(I.precision)),
      m !== I.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          I.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const X =
        Z.morphAttributes.position ||
        Z.morphAttributes.normal ||
        Z.morphAttributes.color,
      ie = X !== void 0 ? X.length : 0;
    let de = 0;
    Z.morphAttributes.position !== void 0 && (de = 1),
      Z.morphAttributes.normal !== void 0 && (de = 2),
      Z.morphAttributes.color !== void 0 && (de = 3);
    let Ee, Ie, se, _e;
    if (H) {
      const At = Is[H];
      (Ee = At.vertexShader), (Ie = At.fragmentShader);
    } else
      (Ee = I.vertexShader),
        (Ie = I.fragmentShader),
        l.update(I),
        (se = l.getVertexShaderID(I)),
        (_e = l.getFragmentShaderID(I));
    const re = n.getRenderTarget(),
      Be = n.state.buffers.depth.getReversed(),
      Ue = $.isInstancedMesh === !0,
      Fe = $.isBatchedMesh === !0,
      Ke = !!I.map,
      Ve = !!I.matcap,
      W = !!Y,
      ge = !!I.aoMap,
      pe = !!I.lightMap,
      Se = !!I.bumpMap,
      me = !!I.normalMap,
      Oe = !!I.displacementMap,
      Te = !!I.emissiveMap,
      De = !!I.metalnessMap,
      _t = !!I.roughnessMap,
      wt = I.anisotropy > 0,
      B = I.clearcoat > 0,
      k = I.dispersion > 0,
      ne = I.iridescence > 0,
      ae = I.sheen > 0,
      we = I.transmission > 0,
      he = wt && !!I.anisotropyMap,
      ot = B && !!I.clearcoatMap,
      Ne = B && !!I.clearcoatNormalMap,
      it = B && !!I.clearcoatRoughnessMap,
      tt = ne && !!I.iridescenceMap,
      Ce = ne && !!I.iridescenceThicknessMap,
      je = ae && !!I.sheenColorMap,
      vt = ae && !!I.sheenRoughnessMap,
      Qe = !!I.specularMap,
      He = !!I.specularColorMap,
      Ct = !!I.specularIntensityMap,
      K = we && !!I.transmissionMap,
      Re = we && !!I.thicknessMap,
      ze = !!I.gradientMap,
      Ye = !!I.alphaMap,
      Me = I.alphaTest > 0,
      ye = !!I.alphaHash,
      be = !!I.extensions;
    let $e = go;
    I.toneMapped &&
      (re === null || re.isXRRenderTarget === !0) &&
      ($e = n.toneMapping);
    const mt = {
      shaderID: H,
      shaderType: I.type,
      shaderName: I.name,
      vertexShader: Ee,
      fragmentShader: Ie,
      defines: I.defines,
      customVertexShaderID: se,
      customFragmentShaderID: _e,
      isRawShaderMaterial: I.isRawShaderMaterial === !0,
      glslVersion: I.glslVersion,
      precision: m,
      batching: Fe,
      batchingColor: Fe && $._colorsTexture !== null,
      instancing: Ue,
      instancingColor: Ue && $.instanceColor !== null,
      instancingMorph: Ue && $.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        re === null
          ? n.outputColorSpace
          : re.isXRRenderTarget === !0
          ? re.texture.colorSpace
          : Vc,
      alphaToCoverage: !!I.alphaToCoverage,
      map: Ke,
      matcap: Ve,
      envMap: W,
      envMapMode: W && Y.mapping,
      envMapCubeUVHeight: U,
      aoMap: ge,
      lightMap: pe,
      bumpMap: Se,
      normalMap: me,
      displacementMap: p && Oe,
      emissiveMap: Te,
      normalMapObjectSpace: me && I.normalMapType === H4,
      normalMapTangentSpace: me && I.normalMapType === wl,
      metalnessMap: De,
      roughnessMap: _t,
      anisotropy: wt,
      anisotropyMap: he,
      clearcoat: B,
      clearcoatMap: ot,
      clearcoatNormalMap: Ne,
      clearcoatRoughnessMap: it,
      dispersion: k,
      iridescence: ne,
      iridescenceMap: tt,
      iridescenceThicknessMap: Ce,
      sheen: ae,
      sheenColorMap: je,
      sheenRoughnessMap: vt,
      specularMap: Qe,
      specularColorMap: He,
      specularIntensityMap: Ct,
      transmission: we,
      transmissionMap: K,
      thicknessMap: Re,
      gradientMap: ze,
      opaque:
        I.transparent === !1 && I.blending === Rc && I.alphaToCoverage === !1,
      alphaMap: Ye,
      alphaTest: Me,
      alphaHash: ye,
      combine: I.combine,
      mapUv: Ke && y(I.map.channel),
      aoMapUv: ge && y(I.aoMap.channel),
      lightMapUv: pe && y(I.lightMap.channel),
      bumpMapUv: Se && y(I.bumpMap.channel),
      normalMapUv: me && y(I.normalMap.channel),
      displacementMapUv: Oe && y(I.displacementMap.channel),
      emissiveMapUv: Te && y(I.emissiveMap.channel),
      metalnessMapUv: De && y(I.metalnessMap.channel),
      roughnessMapUv: _t && y(I.roughnessMap.channel),
      anisotropyMapUv: he && y(I.anisotropyMap.channel),
      clearcoatMapUv: ot && y(I.clearcoatMap.channel),
      clearcoatNormalMapUv: Ne && y(I.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: it && y(I.clearcoatRoughnessMap.channel),
      iridescenceMapUv: tt && y(I.iridescenceMap.channel),
      iridescenceThicknessMapUv: Ce && y(I.iridescenceThicknessMap.channel),
      sheenColorMapUv: je && y(I.sheenColorMap.channel),
      sheenRoughnessMapUv: vt && y(I.sheenRoughnessMap.channel),
      specularMapUv: Qe && y(I.specularMap.channel),
      specularColorMapUv: He && y(I.specularColorMap.channel),
      specularIntensityMapUv: Ct && y(I.specularIntensityMap.channel),
      transmissionMapUv: K && y(I.transmissionMap.channel),
      thicknessMapUv: Re && y(I.thicknessMap.channel),
      alphaMapUv: Ye && y(I.alphaMap.channel),
      vertexTangents: !!Z.attributes.tangent && (me || wt),
      vertexColors: I.vertexColors,
      vertexAlphas:
        I.vertexColors === !0 &&
        !!Z.attributes.color &&
        Z.attributes.color.itemSize === 4,
      pointsUvs: $.isPoints === !0 && !!Z.attributes.uv && (Ke || Ye),
      fog: !!G,
      useFog: I.fog === !0,
      fogExp2: !!G && G.isFogExp2,
      flatShading: I.flatShading === !0 && I.wireframe === !1,
      sizeAttenuation: I.sizeAttenuation === !0,
      logarithmicDepthBuffer: f,
      reversedDepthBuffer: Be,
      skinning: $.isSkinnedMesh === !0,
      morphTargets: Z.morphAttributes.position !== void 0,
      morphNormals: Z.morphAttributes.normal !== void 0,
      morphColors: Z.morphAttributes.color !== void 0,
      morphTargetsCount: ie,
      morphTextureStride: de,
      numDirLights: N.directional.length,
      numPointLights: N.point.length,
      numSpotLights: N.spot.length,
      numSpotLightMaps: N.spotLightMap.length,
      numRectAreaLights: N.rectArea.length,
      numHemiLights: N.hemi.length,
      numDirLightShadows: N.directionalShadowMap.length,
      numPointLightShadows: N.pointShadowMap.length,
      numSpotLightShadows: N.spotShadowMap.length,
      numSpotLightShadowsWithMaps: N.numSpotLightShadowsWithMaps,
      numLightProbes: N.numLightProbes,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: I.dithering,
      shadowMapEnabled: n.shadowMap.enabled && D.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: $e,
      decodeVideoTexture:
        Ke &&
        I.map.isVideoTexture === !0 &&
        Ht.getTransfer(I.map.colorSpace) === nn,
      decodeVideoTextureEmissive:
        Te &&
        I.emissiveMap.isVideoTexture === !0 &&
        Ht.getTransfer(I.emissiveMap.colorSpace) === nn,
      premultipliedAlpha: I.premultipliedAlpha,
      doubleSided: I.side === io,
      flipSided: I.side === Jr,
      useDepthPacking: I.depthPacking >= 0,
      depthPacking: I.depthPacking || 0,
      index0AttributeName: I.index0AttributeName,
      extensionClipCullDistance:
        be &&
        I.extensions.clipCullDistance === !0 &&
        r.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ((be && I.extensions.multiDraw === !0) || Fe) &&
        r.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: r.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: I.customProgramCacheKey(),
    };
    return (
      (mt.vertexUv1s = c.has(1)),
      (mt.vertexUv2s = c.has(2)),
      (mt.vertexUv3s = c.has(3)),
      c.clear(),
      mt
    );
  }
  function g(I) {
    const N = [];
    if (
      (I.shaderID
        ? N.push(I.shaderID)
        : (N.push(I.customVertexShaderID), N.push(I.customFragmentShaderID)),
      I.defines !== void 0)
    )
      for (const D in I.defines) N.push(D), N.push(I.defines[D]);
    return (
      I.isRawShaderMaterial === !1 &&
        (_(N, I), S(N, I), N.push(n.outputColorSpace)),
      N.push(I.customProgramCacheKey),
      N.join()
    );
  }
  function _(I, N) {
    I.push(N.precision),
      I.push(N.outputColorSpace),
      I.push(N.envMapMode),
      I.push(N.envMapCubeUVHeight),
      I.push(N.mapUv),
      I.push(N.alphaMapUv),
      I.push(N.lightMapUv),
      I.push(N.aoMapUv),
      I.push(N.bumpMapUv),
      I.push(N.normalMapUv),
      I.push(N.displacementMapUv),
      I.push(N.emissiveMapUv),
      I.push(N.metalnessMapUv),
      I.push(N.roughnessMapUv),
      I.push(N.anisotropyMapUv),
      I.push(N.clearcoatMapUv),
      I.push(N.clearcoatNormalMapUv),
      I.push(N.clearcoatRoughnessMapUv),
      I.push(N.iridescenceMapUv),
      I.push(N.iridescenceThicknessMapUv),
      I.push(N.sheenColorMapUv),
      I.push(N.sheenRoughnessMapUv),
      I.push(N.specularMapUv),
      I.push(N.specularColorMapUv),
      I.push(N.specularIntensityMapUv),
      I.push(N.transmissionMapUv),
      I.push(N.thicknessMapUv),
      I.push(N.combine),
      I.push(N.fogExp2),
      I.push(N.sizeAttenuation),
      I.push(N.morphTargetsCount),
      I.push(N.morphAttributeCount),
      I.push(N.numDirLights),
      I.push(N.numPointLights),
      I.push(N.numSpotLights),
      I.push(N.numSpotLightMaps),
      I.push(N.numHemiLights),
      I.push(N.numRectAreaLights),
      I.push(N.numDirLightShadows),
      I.push(N.numPointLightShadows),
      I.push(N.numSpotLightShadows),
      I.push(N.numSpotLightShadowsWithMaps),
      I.push(N.numLightProbes),
      I.push(N.shadowMapType),
      I.push(N.toneMapping),
      I.push(N.numClippingPlanes),
      I.push(N.numClipIntersection),
      I.push(N.depthPacking);
  }
  function S(I, N) {
    a.disableAll(),
      N.supportsVertexTextures && a.enable(0),
      N.instancing && a.enable(1),
      N.instancingColor && a.enable(2),
      N.instancingMorph && a.enable(3),
      N.matcap && a.enable(4),
      N.envMap && a.enable(5),
      N.normalMapObjectSpace && a.enable(6),
      N.normalMapTangentSpace && a.enable(7),
      N.clearcoat && a.enable(8),
      N.iridescence && a.enable(9),
      N.alphaTest && a.enable(10),
      N.vertexColors && a.enable(11),
      N.vertexAlphas && a.enable(12),
      N.vertexUv1s && a.enable(13),
      N.vertexUv2s && a.enable(14),
      N.vertexUv3s && a.enable(15),
      N.vertexTangents && a.enable(16),
      N.anisotropy && a.enable(17),
      N.alphaHash && a.enable(18),
      N.batching && a.enable(19),
      N.dispersion && a.enable(20),
      N.batchingColor && a.enable(21),
      N.gradientMap && a.enable(22),
      I.push(a.mask),
      a.disableAll(),
      N.fog && a.enable(0),
      N.useFog && a.enable(1),
      N.flatShading && a.enable(2),
      N.logarithmicDepthBuffer && a.enable(3),
      N.reversedDepthBuffer && a.enable(4),
      N.skinning && a.enable(5),
      N.morphTargets && a.enable(6),
      N.morphNormals && a.enable(7),
      N.morphColors && a.enable(8),
      N.premultipliedAlpha && a.enable(9),
      N.shadowMapEnabled && a.enable(10),
      N.doubleSided && a.enable(11),
      N.flipSided && a.enable(12),
      N.useDepthPacking && a.enable(13),
      N.dithering && a.enable(14),
      N.transmission && a.enable(15),
      N.sheen && a.enable(16),
      N.opaque && a.enable(17),
      N.pointsUvs && a.enable(18),
      N.decodeVideoTexture && a.enable(19),
      N.decodeVideoTextureEmissive && a.enable(20),
      N.alphaToCoverage && a.enable(21),
      I.push(a.mask);
  }
  function b(I) {
    const N = v[I.type];
    let D;
    if (N) {
      const j = Is[N];
      D = nV.clone(j.uniforms);
    } else D = I.uniforms;
    return D;
  }
  function C(I, N) {
    let D;
    for (let j = 0, $ = u.length; j < $; j++) {
      const G = u[j];
      if (G.cacheKey === N) {
        (D = G), ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && ((D = new Nce(n, N, I, s)), u.push(D)), D;
  }
  function A(I) {
    if (--I.usedTimes === 0) {
      const N = u.indexOf(I);
      (u[N] = u[u.length - 1]), u.pop(), I.destroy();
    }
  }
  function R(I) {
    l.remove(I);
  }
  function O() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: g,
    getUniforms: b,
    acquireProgram: C,
    releaseProgram: A,
    releaseShaderCache: R,
    programs: u,
    dispose: O,
  };
}
function Uce() {
  let n = new WeakMap();
  function e(o) {
    return n.has(o);
  }
  function t(o) {
    let a = n.get(o);
    return a === void 0 && ((a = {}), n.set(o, a)), a;
  }
  function r(o) {
    n.delete(o);
  }
  function i(o, a, l) {
    n.get(o)[a] = l;
  }
  function s() {
    n = new WeakMap();
  }
  return { has: e, get: t, remove: r, update: i, dispose: s };
}
function Fce(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function fO(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function pO() {
  const n = [];
  let e = 0;
  const t = [],
    r = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (r.length = 0), (i.length = 0);
  }
  function o(f, p, m, v, y, x) {
    let g = n[e];
    return (
      g === void 0
        ? ((g = {
            id: f.id,
            object: f,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: f.renderOrder,
            z: y,
            group: x,
          }),
          (n[e] = g))
        : ((g.id = f.id),
          (g.object = f),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = v),
          (g.renderOrder = f.renderOrder),
          (g.z = y),
          (g.group = x)),
      e++,
      g
    );
  }
  function a(f, p, m, v, y, x) {
    const g = o(f, p, m, v, y, x);
    m.transmission > 0
      ? r.push(g)
      : m.transparent === !0
      ? i.push(g)
      : t.push(g);
  }
  function l(f, p, m, v, y, x) {
    const g = o(f, p, m, v, y, x);
    m.transmission > 0
      ? r.unshift(g)
      : m.transparent === !0
      ? i.unshift(g)
      : t.unshift(g);
  }
  function c(f, p) {
    t.length > 1 && t.sort(f || Fce),
      r.length > 1 && r.sort(p || fO),
      i.length > 1 && i.sort(p || fO);
  }
  function u() {
    for (let f = e, p = n.length; f < p; f++) {
      const m = n[f];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: r,
    transparent: i,
    init: s,
    push: a,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function Bce() {
  let n = new WeakMap();
  function e(r, i) {
    const s = n.get(r);
    let o;
    return (
      s === void 0
        ? ((o = new pO()), n.set(r, [o]))
        : i >= s.length
        ? ((o = new pO()), s.push(o))
        : (o = s[i]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function zce() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new z(), color: new Je() };
          break;
        case "SpotLight":
          t = {
            position: new z(),
            direction: new z(),
            color: new Je(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new z(), color: new Je(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new z(), skyColor: new Je(), groundColor: new Je() };
          break;
        case "RectAreaLight":
          t = {
            color: new Je(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function Vce() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe(),
          };
          break;
        case "SpotLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe(),
          };
          break;
        case "PointLight":
          t = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new xe(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let jce = 0;
function Hce(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function Wce(n) {
  const e = new zce(),
    t = Vce(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let c = 0; c < 9; c++) r.probe.push(new z());
  const i = new z(),
    s = new Tt(),
    o = new Tt();
  function a(c) {
    let u = 0,
      f = 0,
      p = 0;
    for (let I = 0; I < 9; I++) r.probe[I].set(0, 0, 0);
    let m = 0,
      v = 0,
      y = 0,
      x = 0,
      g = 0,
      _ = 0,
      S = 0,
      b = 0,
      C = 0,
      A = 0,
      R = 0;
    c.sort(Hce);
    for (let I = 0, N = c.length; I < N; I++) {
      const D = c[I],
        j = D.color,
        $ = D.intensity,
        G = D.distance,
        Z = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight) (u += j.r * $), (f += j.g * $), (p += j.b * $);
      else if (D.isLightProbe) {
        for (let q = 0; q < 9; q++)
          r.probe[q].addScaledVector(D.sh.coefficients[q], $);
        R++;
      } else if (D.isDirectionalLight) {
        const q = e.get(D);
        if ((q.color.copy(D.color).multiplyScalar(D.intensity), D.castShadow)) {
          const Y = D.shadow,
            U = t.get(D);
          (U.shadowIntensity = Y.intensity),
            (U.shadowBias = Y.bias),
            (U.shadowNormalBias = Y.normalBias),
            (U.shadowRadius = Y.radius),
            (U.shadowMapSize = Y.mapSize),
            (r.directionalShadow[m] = U),
            (r.directionalShadowMap[m] = Z),
            (r.directionalShadowMatrix[m] = D.shadow.matrix),
            _++;
        }
        (r.directional[m] = q), m++;
      } else if (D.isSpotLight) {
        const q = e.get(D);
        q.position.setFromMatrixPosition(D.matrixWorld),
          q.color.copy(j).multiplyScalar($),
          (q.distance = G),
          (q.coneCos = Math.cos(D.angle)),
          (q.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (q.decay = D.decay),
          (r.spot[y] = q);
        const Y = D.shadow;
        if (
          (D.map &&
            ((r.spotLightMap[C] = D.map),
            C++,
            Y.updateMatrices(D),
            D.castShadow && A++),
          (r.spotLightMatrix[y] = Y.matrix),
          D.castShadow)
        ) {
          const U = t.get(D);
          (U.shadowIntensity = Y.intensity),
            (U.shadowBias = Y.bias),
            (U.shadowNormalBias = Y.normalBias),
            (U.shadowRadius = Y.radius),
            (U.shadowMapSize = Y.mapSize),
            (r.spotShadow[y] = U),
            (r.spotShadowMap[y] = Z),
            b++;
        }
        y++;
      } else if (D.isRectAreaLight) {
        const q = e.get(D);
        q.color.copy(j).multiplyScalar($),
          q.halfWidth.set(D.width * 0.5, 0, 0),
          q.halfHeight.set(0, D.height * 0.5, 0),
          (r.rectArea[x] = q),
          x++;
      } else if (D.isPointLight) {
        const q = e.get(D);
        if (
          (q.color.copy(D.color).multiplyScalar(D.intensity),
          (q.distance = D.distance),
          (q.decay = D.decay),
          D.castShadow)
        ) {
          const Y = D.shadow,
            U = t.get(D);
          (U.shadowIntensity = Y.intensity),
            (U.shadowBias = Y.bias),
            (U.shadowNormalBias = Y.normalBias),
            (U.shadowRadius = Y.radius),
            (U.shadowMapSize = Y.mapSize),
            (U.shadowCameraNear = Y.camera.near),
            (U.shadowCameraFar = Y.camera.far),
            (r.pointShadow[v] = U),
            (r.pointShadowMap[v] = Z),
            (r.pointShadowMatrix[v] = D.shadow.matrix),
            S++;
        }
        (r.point[v] = q), v++;
      } else if (D.isHemisphereLight) {
        const q = e.get(D);
        q.skyColor.copy(D.color).multiplyScalar($),
          q.groundColor.copy(D.groundColor).multiplyScalar($),
          (r.hemi[g] = q),
          g++;
      }
    }
    x > 0 &&
      (n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = Ge.LTC_FLOAT_1), (r.rectAreaLTC2 = Ge.LTC_FLOAT_2))
        : ((r.rectAreaLTC1 = Ge.LTC_HALF_1), (r.rectAreaLTC2 = Ge.LTC_HALF_2))),
      (r.ambient[0] = u),
      (r.ambient[1] = f),
      (r.ambient[2] = p);
    const O = r.hash;
    (O.directionalLength !== m ||
      O.pointLength !== v ||
      O.spotLength !== y ||
      O.rectAreaLength !== x ||
      O.hemiLength !== g ||
      O.numDirectionalShadows !== _ ||
      O.numPointShadows !== S ||
      O.numSpotShadows !== b ||
      O.numSpotMaps !== C ||
      O.numLightProbes !== R) &&
      ((r.directional.length = m),
      (r.spot.length = y),
      (r.rectArea.length = x),
      (r.point.length = v),
      (r.hemi.length = g),
      (r.directionalShadow.length = _),
      (r.directionalShadowMap.length = _),
      (r.pointShadow.length = S),
      (r.pointShadowMap.length = S),
      (r.spotShadow.length = b),
      (r.spotShadowMap.length = b),
      (r.directionalShadowMatrix.length = _),
      (r.pointShadowMatrix.length = S),
      (r.spotLightMatrix.length = b + C - A),
      (r.spotLightMap.length = C),
      (r.numSpotLightShadowsWithMaps = A),
      (r.numLightProbes = R),
      (O.directionalLength = m),
      (O.pointLength = v),
      (O.spotLength = y),
      (O.rectAreaLength = x),
      (O.hemiLength = g),
      (O.numDirectionalShadows = _),
      (O.numPointShadows = S),
      (O.numSpotShadows = b),
      (O.numSpotMaps = C),
      (O.numLightProbes = R),
      (r.version = jce++));
  }
  function l(c, u) {
    let f = 0,
      p = 0,
      m = 0,
      v = 0,
      y = 0;
    const x = u.matrixWorldInverse;
    for (let g = 0, _ = c.length; g < _; g++) {
      const S = c[g];
      if (S.isDirectionalLight) {
        const b = r.directional[f];
        b.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          b.direction.sub(i),
          b.direction.transformDirection(x),
          f++;
      } else if (S.isSpotLight) {
        const b = r.spot[m];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(x),
          b.direction.setFromMatrixPosition(S.matrixWorld),
          i.setFromMatrixPosition(S.target.matrixWorld),
          b.direction.sub(i),
          b.direction.transformDirection(x),
          m++;
      } else if (S.isRectAreaLight) {
        const b = r.rectArea[v];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(x),
          o.identity(),
          s.copy(S.matrixWorld),
          s.premultiply(x),
          o.extractRotation(s),
          b.halfWidth.set(S.width * 0.5, 0, 0),
          b.halfHeight.set(0, S.height * 0.5, 0),
          b.halfWidth.applyMatrix4(o),
          b.halfHeight.applyMatrix4(o),
          v++;
      } else if (S.isPointLight) {
        const b = r.point[p];
        b.position.setFromMatrixPosition(S.matrixWorld),
          b.position.applyMatrix4(x),
          p++;
      } else if (S.isHemisphereLight) {
        const b = r.hemi[y];
        b.direction.setFromMatrixPosition(S.matrixWorld),
          b.direction.transformDirection(x),
          y++;
      }
    }
  }
  return { setup: a, setupView: l, state: r };
}
function mO(n) {
  const e = new Wce(n),
    t = [],
    r = [];
  function i(u) {
    (c.camera = u), (t.length = 0), (r.length = 0);
  }
  function s(u) {
    t.push(u);
  }
  function o(u) {
    r.push(u);
  }
  function a() {
    e.setup(t);
  }
  function l(u) {
    e.setupView(t, u);
  }
  const c = {
    lightsArray: t,
    shadowsArray: r,
    camera: null,
    lights: e,
    transmissionRenderTarget: {},
  };
  return {
    init: i,
    state: c,
    setupLights: a,
    setupLightsView: l,
    pushLight: s,
    pushShadow: o,
  };
}
function Gce(n) {
  let e = new WeakMap();
  function t(i, s = 0) {
    const o = e.get(i);
    let a;
    return (
      o === void 0
        ? ((a = new mO(n)), e.set(i, [a]))
        : s >= o.length
        ? ((a = new mO(n)), o.push(a))
        : (a = o[s]),
      a
    );
  }
  function r() {
    e = new WeakMap();
  }
  return { get: t, dispose: r };
}
const $ce = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  Xce = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function qce(n, e, t) {
  let r = new Lh();
  const i = new xe(),
    s = new xe(),
    o = new Gt(),
    a = new JC({ depthPacking: j4 }),
    l = new ZC(),
    c = {},
    u = t.maxTextureSize,
    f = { [ra]: Jr, [Jr]: ra, [io]: io },
    p = new cs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new xe() },
        radius: { value: 4 },
      },
      vertexShader: $ce,
      fragmentShader: Xce,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new kt();
  v.setAttribute(
    "position",
    new sn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const y = new $n(v, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Xx);
  let g = this.type;
  this.render = function (A, R, O) {
    if (
      x.enabled === !1 ||
      (x.autoUpdate === !1 && x.needsUpdate === !1) ||
      A.length === 0
    )
      return;
    const I = n.getRenderTarget(),
      N = n.getActiveCubeFace(),
      D = n.getActiveMipmapLevel(),
      j = n.state;
    j.setBlending(Xo),
      j.buffers.depth.getReversed()
        ? j.buffers.color.setClear(0, 0, 0, 0)
        : j.buffers.color.setClear(1, 1, 1, 1),
      j.buffers.depth.setTest(!0),
      j.setScissorTest(!1);
    const $ = g !== Ts && this.type === Ts,
      G = g === Ts && this.type !== Ts;
    for (let Z = 0, q = A.length; Z < q; Z++) {
      const Y = A[Z],
        U = Y.shadow;
      if (U === void 0) {
        console.warn("THREE.WebGLShadowMap:", Y, "has no shadow.");
        continue;
      }
      if (U.autoUpdate === !1 && U.needsUpdate === !1) continue;
      i.copy(U.mapSize);
      const H = U.getFrameExtents();
      if (
        (i.multiply(H),
        s.copy(U.mapSize),
        (i.x > u || i.y > u) &&
          (i.x > u &&
            ((s.x = Math.floor(u / H.x)),
            (i.x = s.x * H.x),
            (U.mapSize.x = s.x)),
          i.y > u &&
            ((s.y = Math.floor(u / H.y)),
            (i.y = s.y * H.y),
            (U.mapSize.y = s.y))),
        U.map === null || $ === !0 || G === !0)
      ) {
        const ie = this.type !== Ts ? { minFilter: mr, magFilter: mr } : {};
        U.map !== null && U.map.dispose(),
          (U.map = new xo(i.x, i.y, ie)),
          (U.map.texture.name = Y.name + ".shadowMap"),
          U.camera.updateProjectionMatrix();
      }
      n.setRenderTarget(U.map), n.clear();
      const X = U.getViewportCount();
      for (let ie = 0; ie < X; ie++) {
        const de = U.getViewport(ie);
        o.set(s.x * de.x, s.y * de.y, s.x * de.z, s.y * de.w),
          j.viewport(o),
          U.updateMatrices(Y, ie),
          (r = U.getFrustum()),
          b(R, O, U.camera, Y, this.type);
      }
      U.isPointLightShadow !== !0 && this.type === Ts && _(U, O),
        (U.needsUpdate = !1);
    }
    (g = this.type), (x.needsUpdate = !1), n.setRenderTarget(I, N, D);
  };
  function _(A, R) {
    const O = e.update(y);
    p.defines.VSM_SAMPLES !== A.blurSamples &&
      ((p.defines.VSM_SAMPLES = A.blurSamples),
      (m.defines.VSM_SAMPLES = A.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      A.mapPass === null && (A.mapPass = new xo(i.x, i.y)),
      (p.uniforms.shadow_pass.value = A.map.texture),
      (p.uniforms.resolution.value = A.mapSize),
      (p.uniforms.radius.value = A.radius),
      n.setRenderTarget(A.mapPass),
      n.clear(),
      n.renderBufferDirect(R, null, O, p, y, null),
      (m.uniforms.shadow_pass.value = A.mapPass.texture),
      (m.uniforms.resolution.value = A.mapSize),
      (m.uniforms.radius.value = A.radius),
      n.setRenderTarget(A.map),
      n.clear(),
      n.renderBufferDirect(R, null, O, m, y, null);
  }
  function S(A, R, O, I) {
    let N = null;
    const D =
      O.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
    if (D !== void 0) N = D;
    else if (
      ((N = O.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        R.clipShadows === !0 &&
        Array.isArray(R.clippingPlanes) &&
        R.clippingPlanes.length !== 0) ||
        (R.displacementMap && R.displacementScale !== 0) ||
        (R.alphaMap && R.alphaTest > 0) ||
        (R.map && R.alphaTest > 0) ||
        R.alphaToCoverage === !0)
    ) {
      const j = N.uuid,
        $ = R.uuid;
      let G = c[j];
      G === void 0 && ((G = {}), (c[j] = G));
      let Z = G[$];
      Z === void 0 &&
        ((Z = N.clone()), (G[$] = Z), R.addEventListener("dispose", C)),
        (N = Z);
    }
    if (
      ((N.visible = R.visible),
      (N.wireframe = R.wireframe),
      I === Ts
        ? (N.side = R.shadowSide !== null ? R.shadowSide : R.side)
        : (N.side = R.shadowSide !== null ? R.shadowSide : f[R.side]),
      (N.alphaMap = R.alphaMap),
      (N.alphaTest = R.alphaToCoverage === !0 ? 0.5 : R.alphaTest),
      (N.map = R.map),
      (N.clipShadows = R.clipShadows),
      (N.clippingPlanes = R.clippingPlanes),
      (N.clipIntersection = R.clipIntersection),
      (N.displacementMap = R.displacementMap),
      (N.displacementScale = R.displacementScale),
      (N.displacementBias = R.displacementBias),
      (N.wireframeLinewidth = R.wireframeLinewidth),
      (N.linewidth = R.linewidth),
      O.isPointLight === !0 && N.isMeshDistanceMaterial === !0)
    ) {
      const j = n.properties.get(N);
      j.light = O;
    }
    return N;
  }
  function b(A, R, O, I, N) {
    if (A.visible === !1) return;
    if (
      A.layers.test(R.layers) &&
      (A.isMesh || A.isLine || A.isPoints) &&
      (A.castShadow || (A.receiveShadow && N === Ts)) &&
      (!A.frustumCulled || r.intersectsObject(A))
    ) {
      A.modelViewMatrix.multiplyMatrices(O.matrixWorldInverse, A.matrixWorld);
      const $ = e.update(A),
        G = A.material;
      if (Array.isArray(G)) {
        const Z = $.groups;
        for (let q = 0, Y = Z.length; q < Y; q++) {
          const U = Z[q],
            H = G[U.materialIndex];
          if (H && H.visible) {
            const X = S(A, H, I, N);
            A.onBeforeShadow(n, A, R, O, $, X, U),
              n.renderBufferDirect(O, null, $, X, A, U),
              A.onAfterShadow(n, A, R, O, $, X, U);
          }
        }
      } else if (G.visible) {
        const Z = S(A, G, I, N);
        A.onBeforeShadow(n, A, R, O, $, Z, null),
          n.renderBufferDirect(O, null, $, Z, A, null),
          A.onAfterShadow(n, A, R, O, $, Z, null);
      }
    }
    const j = A.children;
    for (let $ = 0, G = j.length; $ < G; $++) b(j[$], R, O, I, N);
  }
  function C(A) {
    A.target.removeEventListener("dispose", C);
    for (const O in c) {
      const I = c[O],
        N = A.target.uuid;
      N in I && (I[N].dispose(), delete I[N]);
    }
  }
}
const Kce = {
  [E0]: T0,
  [M0]: R0,
  [C0]: P0,
  [zc]: A0,
  [T0]: E0,
  [R0]: M0,
  [P0]: C0,
  [A0]: zc,
};
function Yce(n, e) {
  function t() {
    let K = !1;
    const Re = new Gt();
    let ze = null;
    const Ye = new Gt(0, 0, 0, 0);
    return {
      setMask: function (Me) {
        ze !== Me && !K && (n.colorMask(Me, Me, Me, Me), (ze = Me));
      },
      setLocked: function (Me) {
        K = Me;
      },
      setClear: function (Me, ye, be, $e, mt) {
        mt === !0 && ((Me *= $e), (ye *= $e), (be *= $e)),
          Re.set(Me, ye, be, $e),
          Ye.equals(Re) === !1 && (n.clearColor(Me, ye, be, $e), Ye.copy(Re));
      },
      reset: function () {
        (K = !1), (ze = null), Ye.set(-1, 0, 0, 0);
      },
    };
  }
  function r() {
    let K = !1,
      Re = !1,
      ze = null,
      Ye = null,
      Me = null;
    return {
      setReversed: function (ye) {
        if (Re !== ye) {
          const be = e.get("EXT_clip_control");
          ye
            ? be.clipControlEXT(be.LOWER_LEFT_EXT, be.ZERO_TO_ONE_EXT)
            : be.clipControlEXT(be.LOWER_LEFT_EXT, be.NEGATIVE_ONE_TO_ONE_EXT),
            (Re = ye);
          const $e = Me;
          (Me = null), this.setClear($e);
        }
      },
      getReversed: function () {
        return Re;
      },
      setTest: function (ye) {
        ye ? re(n.DEPTH_TEST) : Be(n.DEPTH_TEST);
      },
      setMask: function (ye) {
        ze !== ye && !K && (n.depthMask(ye), (ze = ye));
      },
      setFunc: function (ye) {
        if ((Re && (ye = Kce[ye]), Ye !== ye)) {
          switch (ye) {
            case E0:
              n.depthFunc(n.NEVER);
              break;
            case T0:
              n.depthFunc(n.ALWAYS);
              break;
            case M0:
              n.depthFunc(n.LESS);
              break;
            case zc:
              n.depthFunc(n.LEQUAL);
              break;
            case C0:
              n.depthFunc(n.EQUAL);
              break;
            case A0:
              n.depthFunc(n.GEQUAL);
              break;
            case R0:
              n.depthFunc(n.GREATER);
              break;
            case P0:
              n.depthFunc(n.NOTEQUAL);
              break;
            default:
              n.depthFunc(n.LEQUAL);
          }
          Ye = ye;
        }
      },
      setLocked: function (ye) {
        K = ye;
      },
      setClear: function (ye) {
        Me !== ye && (Re && (ye = 1 - ye), n.clearDepth(ye), (Me = ye));
      },
      reset: function () {
        (K = !1), (ze = null), (Ye = null), (Me = null), (Re = !1);
      },
    };
  }
  function i() {
    let K = !1,
      Re = null,
      ze = null,
      Ye = null,
      Me = null,
      ye = null,
      be = null,
      $e = null,
      mt = null;
    return {
      setTest: function (At) {
        K || (At ? re(n.STENCIL_TEST) : Be(n.STENCIL_TEST));
      },
      setMask: function (At) {
        Re !== At && !K && (n.stencilMask(At), (Re = At));
      },
      setFunc: function (At, mn, On) {
        (ze !== At || Ye !== mn || Me !== On) &&
          (n.stencilFunc(At, mn, On), (ze = At), (Ye = mn), (Me = On));
      },
      setOp: function (At, mn, On) {
        (ye !== At || be !== mn || $e !== On) &&
          (n.stencilOp(At, mn, On), (ye = At), (be = mn), ($e = On));
      },
      setLocked: function (At) {
        K = At;
      },
      setClear: function (At) {
        mt !== At && (n.clearStencil(At), (mt = At));
      },
      reset: function () {
        (K = !1),
          (Re = null),
          (ze = null),
          (Ye = null),
          (Me = null),
          (ye = null),
          (be = null),
          ($e = null),
          (mt = null);
      },
    };
  }
  const s = new t(),
    o = new r(),
    a = new i(),
    l = new WeakMap(),
    c = new WeakMap();
  let u = {},
    f = {},
    p = new WeakMap(),
    m = [],
    v = null,
    y = !1,
    x = null,
    g = null,
    _ = null,
    S = null,
    b = null,
    C = null,
    A = null,
    R = new Je(0, 0, 0),
    O = 0,
    I = !1,
    N = null,
    D = null,
    j = null,
    $ = null,
    G = null;
  const Z = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let q = !1,
    Y = 0;
  const U = n.getParameter(n.VERSION);
  U.indexOf("WebGL") !== -1
    ? ((Y = parseFloat(/^WebGL (\d)/.exec(U)[1])), (q = Y >= 1))
    : U.indexOf("OpenGL ES") !== -1 &&
      ((Y = parseFloat(/^OpenGL ES (\d)/.exec(U)[1])), (q = Y >= 2));
  let H = null,
    X = {};
  const ie = n.getParameter(n.SCISSOR_BOX),
    de = n.getParameter(n.VIEWPORT),
    Ee = new Gt().fromArray(ie),
    Ie = new Gt().fromArray(de);
  function se(K, Re, ze, Ye) {
    const Me = new Uint8Array(4),
      ye = n.createTexture();
    n.bindTexture(K, ye),
      n.texParameteri(K, n.TEXTURE_MIN_FILTER, n.NEAREST),
      n.texParameteri(K, n.TEXTURE_MAG_FILTER, n.NEAREST);
    for (let be = 0; be < ze; be++)
      K === n.TEXTURE_3D || K === n.TEXTURE_2D_ARRAY
        ? n.texImage3D(Re, 0, n.RGBA, 1, 1, Ye, 0, n.RGBA, n.UNSIGNED_BYTE, Me)
        : n.texImage2D(
            Re + be,
            0,
            n.RGBA,
            1,
            1,
            0,
            n.RGBA,
            n.UNSIGNED_BYTE,
            Me
          );
    return ye;
  }
  const _e = {};
  (_e[n.TEXTURE_2D] = se(n.TEXTURE_2D, n.TEXTURE_2D, 1)),
    (_e[n.TEXTURE_CUBE_MAP] = se(
      n.TEXTURE_CUBE_MAP,
      n.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    (_e[n.TEXTURE_2D_ARRAY] = se(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1)),
    (_e[n.TEXTURE_3D] = se(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1)),
    s.setClear(0, 0, 0, 1),
    o.setClear(1),
    a.setClear(0),
    re(n.DEPTH_TEST),
    o.setFunc(zc),
    Se(!1),
    me(FE),
    re(n.CULL_FACE),
    ge(Xo);
  function re(K) {
    u[K] !== !0 && (n.enable(K), (u[K] = !0));
  }
  function Be(K) {
    u[K] !== !1 && (n.disable(K), (u[K] = !1));
  }
  function Ue(K, Re) {
    return f[K] !== Re
      ? (n.bindFramebuffer(K, Re),
        (f[K] = Re),
        K === n.DRAW_FRAMEBUFFER && (f[n.FRAMEBUFFER] = Re),
        K === n.FRAMEBUFFER && (f[n.DRAW_FRAMEBUFFER] = Re),
        !0)
      : !1;
  }
  function Fe(K, Re) {
    let ze = m,
      Ye = !1;
    if (K) {
      (ze = p.get(Re)), ze === void 0 && ((ze = []), p.set(Re, ze));
      const Me = K.textures;
      if (ze.length !== Me.length || ze[0] !== n.COLOR_ATTACHMENT0) {
        for (let ye = 0, be = Me.length; ye < be; ye++)
          ze[ye] = n.COLOR_ATTACHMENT0 + ye;
        (ze.length = Me.length), (Ye = !0);
      }
    } else ze[0] !== n.BACK && ((ze[0] = n.BACK), (Ye = !0));
    Ye && n.drawBuffers(ze);
  }
  function Ke(K) {
    return v !== K ? (n.useProgram(K), (v = K), !0) : !1;
  }
  const Ve = {
    [Va]: n.FUNC_ADD,
    [f4]: n.FUNC_SUBTRACT,
    [p4]: n.FUNC_REVERSE_SUBTRACT,
  };
  (Ve[m4] = n.MIN), (Ve[g4] = n.MAX);
  const W = {
    [v4]: n.ZERO,
    [bC]: n.ONE,
    [y4]: n.SRC_COLOR,
    [Wp]: n.SRC_ALPHA,
    [E4]: n.SRC_ALPHA_SATURATE,
    [S4]: n.DST_COLOR,
    [_4]: n.DST_ALPHA,
    [x4]: n.ONE_MINUS_SRC_COLOR,
    [b0]: n.ONE_MINUS_SRC_ALPHA,
    [b4]: n.ONE_MINUS_DST_COLOR,
    [w4]: n.ONE_MINUS_DST_ALPHA,
    [T4]: n.CONSTANT_COLOR,
    [M4]: n.ONE_MINUS_CONSTANT_COLOR,
    [C4]: n.CONSTANT_ALPHA,
    [A4]: n.ONE_MINUS_CONSTANT_ALPHA,
  };
  function ge(K, Re, ze, Ye, Me, ye, be, $e, mt, At) {
    if (K === Xo) {
      y === !0 && (Be(n.BLEND), (y = !1));
      return;
    }
    if ((y === !1 && (re(n.BLEND), (y = !0)), K !== SC)) {
      if (K !== x || At !== I) {
        if (
          ((g !== Va || b !== Va) &&
            (n.blendEquation(n.FUNC_ADD), (g = Va), (b = Va)),
          At)
        )
          switch (K) {
            case Rc:
              n.blendFuncSeparate(
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case BE:
              n.blendFunc(n.ONE, n.ONE);
              break;
            case zE:
              n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
              break;
            case VE:
              n.blendFuncSeparate(
                n.DST_COLOR,
                n.ONE_MINUS_SRC_ALPHA,
                n.ZERO,
                n.ONE
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        else
          switch (K) {
            case Rc:
              n.blendFuncSeparate(
                n.SRC_ALPHA,
                n.ONE_MINUS_SRC_ALPHA,
                n.ONE,
                n.ONE_MINUS_SRC_ALPHA
              );
              break;
            case BE:
              n.blendFuncSeparate(n.SRC_ALPHA, n.ONE, n.ONE, n.ONE);
              break;
            case zE:
              console.error(
                "THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true"
              );
              break;
            case VE:
              console.error(
                "THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true"
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        (_ = null),
          (S = null),
          (C = null),
          (A = null),
          R.set(0, 0, 0),
          (O = 0),
          (x = K),
          (I = At);
      }
      return;
    }
    (Me = Me || Re),
      (ye = ye || ze),
      (be = be || Ye),
      (Re !== g || Me !== b) &&
        (n.blendEquationSeparate(Ve[Re], Ve[Me]), (g = Re), (b = Me)),
      (ze !== _ || Ye !== S || ye !== C || be !== A) &&
        (n.blendFuncSeparate(W[ze], W[Ye], W[ye], W[be]),
        (_ = ze),
        (S = Ye),
        (C = ye),
        (A = be)),
      ($e.equals(R) === !1 || mt !== O) &&
        (n.blendColor($e.r, $e.g, $e.b, mt), R.copy($e), (O = mt)),
      (x = K),
      (I = !1);
  }
  function pe(K, Re) {
    K.side === io ? Be(n.CULL_FACE) : re(n.CULL_FACE);
    let ze = K.side === Jr;
    Re && (ze = !ze),
      Se(ze),
      K.blending === Rc && K.transparent === !1
        ? ge(Xo)
        : ge(
            K.blending,
            K.blendEquation,
            K.blendSrc,
            K.blendDst,
            K.blendEquationAlpha,
            K.blendSrcAlpha,
            K.blendDstAlpha,
            K.blendColor,
            K.blendAlpha,
            K.premultipliedAlpha
          ),
      o.setFunc(K.depthFunc),
      o.setTest(K.depthTest),
      o.setMask(K.depthWrite),
      s.setMask(K.colorWrite);
    const Ye = K.stencilWrite;
    a.setTest(Ye),
      Ye &&
        (a.setMask(K.stencilWriteMask),
        a.setFunc(K.stencilFunc, K.stencilRef, K.stencilFuncMask),
        a.setOp(K.stencilFail, K.stencilZFail, K.stencilZPass)),
      Te(K.polygonOffset, K.polygonOffsetFactor, K.polygonOffsetUnits),
      K.alphaToCoverage === !0
        ? re(n.SAMPLE_ALPHA_TO_COVERAGE)
        : Be(n.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Se(K) {
    N !== K && (K ? n.frontFace(n.CW) : n.frontFace(n.CCW), (N = K));
  }
  function me(K) {
    K !== u4
      ? (re(n.CULL_FACE),
        K !== D &&
          (K === FE
            ? n.cullFace(n.BACK)
            : K === d4
            ? n.cullFace(n.FRONT)
            : n.cullFace(n.FRONT_AND_BACK)))
      : Be(n.CULL_FACE),
      (D = K);
  }
  function Oe(K) {
    K !== j && (q && n.lineWidth(K), (j = K));
  }
  function Te(K, Re, ze) {
    K
      ? (re(n.POLYGON_OFFSET_FILL),
        ($ !== Re || G !== ze) && (n.polygonOffset(Re, ze), ($ = Re), (G = ze)))
      : Be(n.POLYGON_OFFSET_FILL);
  }
  function De(K) {
    K ? re(n.SCISSOR_TEST) : Be(n.SCISSOR_TEST);
  }
  function _t(K) {
    K === void 0 && (K = n.TEXTURE0 + Z - 1),
      H !== K && (n.activeTexture(K), (H = K));
  }
  function wt(K, Re, ze) {
    ze === void 0 && (H === null ? (ze = n.TEXTURE0 + Z - 1) : (ze = H));
    let Ye = X[ze];
    Ye === void 0 && ((Ye = { type: void 0, texture: void 0 }), (X[ze] = Ye)),
      (Ye.type !== K || Ye.texture !== Re) &&
        (H !== ze && (n.activeTexture(ze), (H = ze)),
        n.bindTexture(K, Re || _e[K]),
        (Ye.type = K),
        (Ye.texture = Re));
  }
  function B() {
    const K = X[H];
    K !== void 0 &&
      K.type !== void 0 &&
      (n.bindTexture(K.type, null), (K.type = void 0), (K.texture = void 0));
  }
  function k() {
    try {
      n.compressedTexImage2D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function ne() {
    try {
      n.compressedTexImage3D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function ae() {
    try {
      n.texSubImage2D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function we() {
    try {
      n.texSubImage3D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function he() {
    try {
      n.compressedTexSubImage2D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function ot() {
    try {
      n.compressedTexSubImage3D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ne() {
    try {
      n.texStorage2D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function it() {
    try {
      n.texStorage3D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function tt() {
    try {
      n.texImage2D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ce() {
    try {
      n.texImage3D(...arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function je(K) {
    Ee.equals(K) === !1 && (n.scissor(K.x, K.y, K.z, K.w), Ee.copy(K));
  }
  function vt(K) {
    Ie.equals(K) === !1 && (n.viewport(K.x, K.y, K.z, K.w), Ie.copy(K));
  }
  function Qe(K, Re) {
    let ze = c.get(Re);
    ze === void 0 && ((ze = new WeakMap()), c.set(Re, ze));
    let Ye = ze.get(K);
    Ye === void 0 && ((Ye = n.getUniformBlockIndex(Re, K.name)), ze.set(K, Ye));
  }
  function He(K, Re) {
    const Ye = c.get(Re).get(K);
    l.get(Re) !== Ye &&
      (n.uniformBlockBinding(Re, Ye, K.__bindingPointIndex), l.set(Re, Ye));
  }
  function Ct() {
    n.disable(n.BLEND),
      n.disable(n.CULL_FACE),
      n.disable(n.DEPTH_TEST),
      n.disable(n.POLYGON_OFFSET_FILL),
      n.disable(n.SCISSOR_TEST),
      n.disable(n.STENCIL_TEST),
      n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
      n.blendEquation(n.FUNC_ADD),
      n.blendFunc(n.ONE, n.ZERO),
      n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
      n.blendColor(0, 0, 0, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(n.LESS),
      o.setReversed(!1),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(n.ALWAYS, 0, 4294967295),
      n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
      n.clearStencil(0),
      n.cullFace(n.BACK),
      n.frontFace(n.CCW),
      n.polygonOffset(0, 0),
      n.activeTexture(n.TEXTURE0),
      n.bindFramebuffer(n.FRAMEBUFFER, null),
      n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
      n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (u = {}),
      (H = null),
      (X = {}),
      (f = {}),
      (p = new WeakMap()),
      (m = []),
      (v = null),
      (y = !1),
      (x = null),
      (g = null),
      (_ = null),
      (S = null),
      (b = null),
      (C = null),
      (A = null),
      (R = new Je(0, 0, 0)),
      (O = 0),
      (I = !1),
      (N = null),
      (D = null),
      (j = null),
      ($ = null),
      (G = null),
      Ee.set(0, 0, n.canvas.width, n.canvas.height),
      Ie.set(0, 0, n.canvas.width, n.canvas.height),
      s.reset(),
      o.reset(),
      a.reset();
  }
  return {
    buffers: { color: s, depth: o, stencil: a },
    enable: re,
    disable: Be,
    bindFramebuffer: Ue,
    drawBuffers: Fe,
    useProgram: Ke,
    setBlending: ge,
    setMaterial: pe,
    setFlipSided: Se,
    setCullFace: me,
    setLineWidth: Oe,
    setPolygonOffset: Te,
    setScissorTest: De,
    activeTexture: _t,
    bindTexture: wt,
    unbindTexture: B,
    compressedTexImage2D: k,
    compressedTexImage3D: ne,
    texImage2D: tt,
    texImage3D: Ce,
    updateUBOMapping: Qe,
    uniformBlockBinding: He,
    texStorage2D: Ne,
    texStorage3D: it,
    texSubImage2D: ae,
    texSubImage3D: we,
    compressedTexSubImage2D: he,
    compressedTexSubImage3D: ot,
    scissor: je,
    viewport: vt,
    reset: Ct,
  };
}
function Jce(n, e, t, r, i, s, o) {
  const a = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    l =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    c = new xe(),
    u = new WeakMap();
  let f;
  const p = new WeakMap();
  let m = !1;
  try {
    m =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function v(B, k) {
    return m ? new OffscreenCanvas(B, k) : Qp("canvas");
  }
  function y(B, k, ne) {
    let ae = 1;
    const we = wt(B);
    if (
      ((we.width > ne || we.height > ne) &&
        (ae = ne / Math.max(we.width, we.height)),
      ae < 1)
    )
      if (
        (typeof HTMLImageElement < "u" && B instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && B instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && B instanceof VideoFrame)
      ) {
        const he = Math.floor(ae * we.width),
          ot = Math.floor(ae * we.height);
        f === void 0 && (f = v(he, ot));
        const Ne = k ? v(he, ot) : f;
        return (
          (Ne.width = he),
          (Ne.height = ot),
          Ne.getContext("2d").drawImage(B, 0, 0, he, ot),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              we.width +
              "x" +
              we.height +
              ") to (" +
              he +
              "x" +
              ot +
              ")."
          ),
          Ne
        );
      } else
        return (
          "data" in B &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                we.width +
                "x" +
                we.height +
                ")."
            ),
          B
        );
    return B;
  }
  function x(B) {
    return B.generateMipmaps;
  }
  function g(B) {
    n.generateMipmap(B);
  }
  function _(B) {
    return B.isWebGLCubeRenderTarget
      ? n.TEXTURE_CUBE_MAP
      : B.isWebGL3DRenderTarget
      ? n.TEXTURE_3D
      : B.isWebGLArrayRenderTarget || B.isCompressedArrayTexture
      ? n.TEXTURE_2D_ARRAY
      : n.TEXTURE_2D;
  }
  function S(B, k, ne, ae, we = !1) {
    if (B !== null) {
      if (n[B] !== void 0) return n[B];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          B +
          "'"
      );
    }
    let he = k;
    if (
      (k === n.RED &&
        (ne === n.FLOAT && (he = n.R32F),
        ne === n.HALF_FLOAT && (he = n.R16F),
        ne === n.UNSIGNED_BYTE && (he = n.R8)),
      k === n.RED_INTEGER &&
        (ne === n.UNSIGNED_BYTE && (he = n.R8UI),
        ne === n.UNSIGNED_SHORT && (he = n.R16UI),
        ne === n.UNSIGNED_INT && (he = n.R32UI),
        ne === n.BYTE && (he = n.R8I),
        ne === n.SHORT && (he = n.R16I),
        ne === n.INT && (he = n.R32I)),
      k === n.RG &&
        (ne === n.FLOAT && (he = n.RG32F),
        ne === n.HALF_FLOAT && (he = n.RG16F),
        ne === n.UNSIGNED_BYTE && (he = n.RG8)),
      k === n.RG_INTEGER &&
        (ne === n.UNSIGNED_BYTE && (he = n.RG8UI),
        ne === n.UNSIGNED_SHORT && (he = n.RG16UI),
        ne === n.UNSIGNED_INT && (he = n.RG32UI),
        ne === n.BYTE && (he = n.RG8I),
        ne === n.SHORT && (he = n.RG16I),
        ne === n.INT && (he = n.RG32I)),
      k === n.RGB_INTEGER &&
        (ne === n.UNSIGNED_BYTE && (he = n.RGB8UI),
        ne === n.UNSIGNED_SHORT && (he = n.RGB16UI),
        ne === n.UNSIGNED_INT && (he = n.RGB32UI),
        ne === n.BYTE && (he = n.RGB8I),
        ne === n.SHORT && (he = n.RGB16I),
        ne === n.INT && (he = n.RGB32I)),
      k === n.RGBA_INTEGER &&
        (ne === n.UNSIGNED_BYTE && (he = n.RGBA8UI),
        ne === n.UNSIGNED_SHORT && (he = n.RGBA16UI),
        ne === n.UNSIGNED_INT && (he = n.RGBA32UI),
        ne === n.BYTE && (he = n.RGBA8I),
        ne === n.SHORT && (he = n.RGBA16I),
        ne === n.INT && (he = n.RGBA32I)),
      k === n.RGB && ne === n.UNSIGNED_INT_5_9_9_9_REV && (he = n.RGB9_E5),
      k === n.RGBA)
    ) {
      const ot = we ? Jp : Ht.getTransfer(ae);
      ne === n.FLOAT && (he = n.RGBA32F),
        ne === n.HALF_FLOAT && (he = n.RGBA16F),
        ne === n.UNSIGNED_BYTE && (he = ot === nn ? n.SRGB8_ALPHA8 : n.RGBA8),
        ne === n.UNSIGNED_SHORT_4_4_4_4 && (he = n.RGBA4),
        ne === n.UNSIGNED_SHORT_5_5_5_1 && (he = n.RGB5_A1);
    }
    return (
      (he === n.R16F ||
        he === n.R32F ||
        he === n.RG16F ||
        he === n.RG32F ||
        he === n.RGBA16F ||
        he === n.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      he
    );
  }
  function b(B, k) {
    let ne;
    return (
      B
        ? k === null || k === sa || k === oh
          ? (ne = n.DEPTH24_STENCIL8)
          : k === fi
          ? (ne = n.DEPTH32F_STENCIL8)
          : k === sh &&
            ((ne = n.DEPTH24_STENCIL8),
            console.warn(
              "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
            ))
        : k === null || k === sa || k === oh
        ? (ne = n.DEPTH_COMPONENT24)
        : k === fi
        ? (ne = n.DEPTH_COMPONENT32F)
        : k === sh && (ne = n.DEPTH_COMPONENT16),
      ne
    );
  }
  function C(B, k) {
    return x(B) === !0 ||
      (B.isFramebufferTexture && B.minFilter !== mr && B.minFilter !== Zn)
      ? Math.log2(Math.max(k.width, k.height)) + 1
      : B.mipmaps !== void 0 && B.mipmaps.length > 0
      ? B.mipmaps.length
      : B.isCompressedTexture && Array.isArray(B.image)
      ? k.mipmaps.length
      : 1;
  }
  function A(B) {
    const k = B.target;
    k.removeEventListener("dispose", A), O(k), k.isVideoTexture && u.delete(k);
  }
  function R(B) {
    const k = B.target;
    k.removeEventListener("dispose", R), N(k);
  }
  function O(B) {
    const k = r.get(B);
    if (k.__webglInit === void 0) return;
    const ne = B.source,
      ae = p.get(ne);
    if (ae) {
      const we = ae[k.__cacheKey];
      we.usedTimes--,
        we.usedTimes === 0 && I(B),
        Object.keys(ae).length === 0 && p.delete(ne);
    }
    r.remove(B);
  }
  function I(B) {
    const k = r.get(B);
    n.deleteTexture(k.__webglTexture);
    const ne = B.source,
      ae = p.get(ne);
    delete ae[k.__cacheKey], o.memory.textures--;
  }
  function N(B) {
    const k = r.get(B);
    if (
      (B.depthTexture && (B.depthTexture.dispose(), r.remove(B.depthTexture)),
      B.isWebGLCubeRenderTarget)
    )
      for (let ae = 0; ae < 6; ae++) {
        if (Array.isArray(k.__webglFramebuffer[ae]))
          for (let we = 0; we < k.__webglFramebuffer[ae].length; we++)
            n.deleteFramebuffer(k.__webglFramebuffer[ae][we]);
        else n.deleteFramebuffer(k.__webglFramebuffer[ae]);
        k.__webglDepthbuffer && n.deleteRenderbuffer(k.__webglDepthbuffer[ae]);
      }
    else {
      if (Array.isArray(k.__webglFramebuffer))
        for (let ae = 0; ae < k.__webglFramebuffer.length; ae++)
          n.deleteFramebuffer(k.__webglFramebuffer[ae]);
      else n.deleteFramebuffer(k.__webglFramebuffer);
      if (
        (k.__webglDepthbuffer && n.deleteRenderbuffer(k.__webglDepthbuffer),
        k.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(k.__webglMultisampledFramebuffer),
        k.__webglColorRenderbuffer)
      )
        for (let ae = 0; ae < k.__webglColorRenderbuffer.length; ae++)
          k.__webglColorRenderbuffer[ae] &&
            n.deleteRenderbuffer(k.__webglColorRenderbuffer[ae]);
      k.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(k.__webglDepthRenderbuffer);
    }
    const ne = B.textures;
    for (let ae = 0, we = ne.length; ae < we; ae++) {
      const he = r.get(ne[ae]);
      he.__webglTexture &&
        (n.deleteTexture(he.__webglTexture), o.memory.textures--),
        r.remove(ne[ae]);
    }
    r.remove(B);
  }
  let D = 0;
  function j() {
    D = 0;
  }
  function $() {
    const B = D;
    return (
      B >= i.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            B +
            " texture units while this GPU supports only " +
            i.maxTextures
        ),
      (D += 1),
      B
    );
  }
  function G(B) {
    const k = [];
    return (
      k.push(B.wrapS),
      k.push(B.wrapT),
      k.push(B.wrapR || 0),
      k.push(B.magFilter),
      k.push(B.minFilter),
      k.push(B.anisotropy),
      k.push(B.internalFormat),
      k.push(B.format),
      k.push(B.type),
      k.push(B.generateMipmaps),
      k.push(B.premultiplyAlpha),
      k.push(B.flipY),
      k.push(B.unpackAlignment),
      k.push(B.colorSpace),
      k.join()
    );
  }
  function Z(B, k) {
    const ne = r.get(B);
    if (
      (B.isVideoTexture && De(B),
      B.isRenderTargetTexture === !1 &&
        B.isExternalTexture !== !0 &&
        B.version > 0 &&
        ne.__version !== B.version)
    ) {
      const ae = B.image;
      if (ae === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ae.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        _e(ne, B, k);
        return;
      }
    } else
      B.isExternalTexture &&
        (ne.__webglTexture = B.sourceTexture ? B.sourceTexture : null);
    t.bindTexture(n.TEXTURE_2D, ne.__webglTexture, n.TEXTURE0 + k);
  }
  function q(B, k) {
    const ne = r.get(B);
    if (
      B.isRenderTargetTexture === !1 &&
      B.version > 0 &&
      ne.__version !== B.version
    ) {
      _e(ne, B, k);
      return;
    }
    t.bindTexture(n.TEXTURE_2D_ARRAY, ne.__webglTexture, n.TEXTURE0 + k);
  }
  function Y(B, k) {
    const ne = r.get(B);
    if (
      B.isRenderTargetTexture === !1 &&
      B.version > 0 &&
      ne.__version !== B.version
    ) {
      _e(ne, B, k);
      return;
    }
    t.bindTexture(n.TEXTURE_3D, ne.__webglTexture, n.TEXTURE0 + k);
  }
  function U(B, k) {
    const ne = r.get(B);
    if (B.version > 0 && ne.__version !== B.version) {
      re(ne, B, k);
      return;
    }
    t.bindTexture(n.TEXTURE_CUBE_MAP, ne.__webglTexture, n.TEXTURE0 + k);
  }
  const H = { [Xp]: n.REPEAT, [rs]: n.CLAMP_TO_EDGE, [qp]: n.MIRRORED_REPEAT },
    X = {
      [mr]: n.NEAREST,
      [TC]: n.NEAREST_MIPMAP_NEAREST,
      [yd]: n.NEAREST_MIPMAP_LINEAR,
      [Zn]: n.LINEAR,
      [rp]: n.LINEAR_MIPMAP_NEAREST,
      [oo]: n.LINEAR_MIPMAP_LINEAR,
    },
    ie = {
      [W4]: n.NEVER,
      [Y4]: n.ALWAYS,
      [G4]: n.LESS,
      [OC]: n.LEQUAL,
      [$4]: n.EQUAL,
      [K4]: n.GEQUAL,
      [X4]: n.GREATER,
      [q4]: n.NOTEQUAL,
    };
  function de(B, k) {
    if (
      (k.type === fi &&
        e.has("OES_texture_float_linear") === !1 &&
        (k.magFilter === Zn ||
          k.magFilter === rp ||
          k.magFilter === yd ||
          k.magFilter === oo ||
          k.minFilter === Zn ||
          k.minFilter === rp ||
          k.minFilter === yd ||
          k.minFilter === oo) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      n.texParameteri(B, n.TEXTURE_WRAP_S, H[k.wrapS]),
      n.texParameteri(B, n.TEXTURE_WRAP_T, H[k.wrapT]),
      (B === n.TEXTURE_3D || B === n.TEXTURE_2D_ARRAY) &&
        n.texParameteri(B, n.TEXTURE_WRAP_R, H[k.wrapR]),
      n.texParameteri(B, n.TEXTURE_MAG_FILTER, X[k.magFilter]),
      n.texParameteri(B, n.TEXTURE_MIN_FILTER, X[k.minFilter]),
      k.compareFunction &&
        (n.texParameteri(B, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(B, n.TEXTURE_COMPARE_FUNC, ie[k.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        k.magFilter === mr ||
        (k.minFilter !== yd && k.minFilter !== oo) ||
        (k.type === fi && e.has("OES_texture_float_linear") === !1)
      )
        return;
      if (k.anisotropy > 1 || r.get(k).__currentAnisotropy) {
        const ne = e.get("EXT_texture_filter_anisotropic");
        n.texParameterf(
          B,
          ne.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(k.anisotropy, i.getMaxAnisotropy())
        ),
          (r.get(k).__currentAnisotropy = k.anisotropy);
      }
    }
  }
  function Ee(B, k) {
    let ne = !1;
    B.__webglInit === void 0 &&
      ((B.__webglInit = !0), k.addEventListener("dispose", A));
    const ae = k.source;
    let we = p.get(ae);
    we === void 0 && ((we = {}), p.set(ae, we));
    const he = G(k);
    if (he !== B.__cacheKey) {
      we[he] === void 0 &&
        ((we[he] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (ne = !0)),
        we[he].usedTimes++;
      const ot = we[B.__cacheKey];
      ot !== void 0 &&
        (we[B.__cacheKey].usedTimes--, ot.usedTimes === 0 && I(k)),
        (B.__cacheKey = he),
        (B.__webglTexture = we[he].texture);
    }
    return ne;
  }
  function Ie(B, k, ne) {
    return Math.floor(Math.floor(B / ne) / k);
  }
  function se(B, k, ne, ae) {
    const he = B.updateRanges;
    if (he.length === 0)
      t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, k.width, k.height, ne, ae, k.data);
    else {
      he.sort((Ce, je) => Ce.start - je.start);
      let ot = 0;
      for (let Ce = 1; Ce < he.length; Ce++) {
        const je = he[ot],
          vt = he[Ce],
          Qe = je.start + je.count,
          He = Ie(vt.start, k.width, 4),
          Ct = Ie(je.start, k.width, 4);
        vt.start <= Qe + 1 &&
        He === Ct &&
        Ie(vt.start + vt.count - 1, k.width, 4) === He
          ? (je.count = Math.max(je.count, vt.start + vt.count - je.start))
          : (++ot, (he[ot] = vt));
      }
      he.length = ot + 1;
      const Ne = n.getParameter(n.UNPACK_ROW_LENGTH),
        it = n.getParameter(n.UNPACK_SKIP_PIXELS),
        tt = n.getParameter(n.UNPACK_SKIP_ROWS);
      n.pixelStorei(n.UNPACK_ROW_LENGTH, k.width);
      for (let Ce = 0, je = he.length; Ce < je; Ce++) {
        const vt = he[Ce],
          Qe = Math.floor(vt.start / 4),
          He = Math.ceil(vt.count / 4),
          Ct = Qe % k.width,
          K = Math.floor(Qe / k.width),
          Re = He,
          ze = 1;
        n.pixelStorei(n.UNPACK_SKIP_PIXELS, Ct),
          n.pixelStorei(n.UNPACK_SKIP_ROWS, K),
          t.texSubImage2D(n.TEXTURE_2D, 0, Ct, K, Re, ze, ne, ae, k.data);
      }
      B.clearUpdateRanges(),
        n.pixelStorei(n.UNPACK_ROW_LENGTH, Ne),
        n.pixelStorei(n.UNPACK_SKIP_PIXELS, it),
        n.pixelStorei(n.UNPACK_SKIP_ROWS, tt);
    }
  }
  function _e(B, k, ne) {
    let ae = n.TEXTURE_2D;
    (k.isDataArrayTexture || k.isCompressedArrayTexture) &&
      (ae = n.TEXTURE_2D_ARRAY),
      k.isData3DTexture && (ae = n.TEXTURE_3D);
    const we = Ee(B, k),
      he = k.source;
    t.bindTexture(ae, B.__webglTexture, n.TEXTURE0 + ne);
    const ot = r.get(he);
    if (he.version !== ot.__version || we === !0) {
      t.activeTexture(n.TEXTURE0 + ne);
      const Ne = Ht.getPrimaries(Ht.workingColorSpace),
        it = k.colorSpace === jo ? null : Ht.getPrimaries(k.colorSpace),
        tt =
          k.colorSpace === jo || Ne === it ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, k.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, k.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, tt);
      let Ce = y(k.image, !1, i.maxTextureSize);
      Ce = _t(k, Ce);
      const je = s.convert(k.format, k.colorSpace),
        vt = s.convert(k.type);
      let Qe = S(k.internalFormat, je, vt, k.colorSpace, k.isVideoTexture);
      de(ae, k);
      let He;
      const Ct = k.mipmaps,
        K = k.isVideoTexture !== !0,
        Re = ot.__version === void 0 || we === !0,
        ze = he.dataReady,
        Ye = C(k, Ce);
      if (k.isDepthTexture)
        (Qe = b(k.format === lh, k.type)),
          Re &&
            (K
              ? t.texStorage2D(n.TEXTURE_2D, 1, Qe, Ce.width, Ce.height)
              : t.texImage2D(
                  n.TEXTURE_2D,
                  0,
                  Qe,
                  Ce.width,
                  Ce.height,
                  0,
                  je,
                  vt,
                  null
                ));
      else if (k.isDataTexture)
        if (Ct.length > 0) {
          K &&
            Re &&
            t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Ct[0].width, Ct[0].height);
          for (let Me = 0, ye = Ct.length; Me < ye; Me++)
            (He = Ct[Me]),
              K
                ? ze &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Me,
                    0,
                    0,
                    He.width,
                    He.height,
                    je,
                    vt,
                    He.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Me,
                    Qe,
                    He.width,
                    He.height,
                    0,
                    je,
                    vt,
                    He.data
                  );
          k.generateMipmaps = !1;
        } else
          K
            ? (Re && t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Ce.width, Ce.height),
              ze && se(k, Ce, je, vt))
            : t.texImage2D(
                n.TEXTURE_2D,
                0,
                Qe,
                Ce.width,
                Ce.height,
                0,
                je,
                vt,
                Ce.data
              );
      else if (k.isCompressedTexture)
        if (k.isCompressedArrayTexture) {
          K &&
            Re &&
            t.texStorage3D(
              n.TEXTURE_2D_ARRAY,
              Ye,
              Qe,
              Ct[0].width,
              Ct[0].height,
              Ce.depth
            );
          for (let Me = 0, ye = Ct.length; Me < ye; Me++)
            if (((He = Ct[Me]), k.format !== Or))
              if (je !== null)
                if (K) {
                  if (ze)
                    if (k.layerUpdates.size > 0) {
                      const be = YE(He.width, He.height, k.format, k.type);
                      for (const $e of k.layerUpdates) {
                        const mt = He.data.subarray(
                          ($e * be) / He.data.BYTES_PER_ELEMENT,
                          (($e + 1) * be) / He.data.BYTES_PER_ELEMENT
                        );
                        t.compressedTexSubImage3D(
                          n.TEXTURE_2D_ARRAY,
                          Me,
                          0,
                          0,
                          $e,
                          He.width,
                          He.height,
                          1,
                          je,
                          mt
                        );
                      }
                      k.clearLayerUpdates();
                    } else
                      t.compressedTexSubImage3D(
                        n.TEXTURE_2D_ARRAY,
                        Me,
                        0,
                        0,
                        0,
                        He.width,
                        He.height,
                        Ce.depth,
                        je,
                        He.data
                      );
                } else
                  t.compressedTexImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Me,
                    Qe,
                    He.width,
                    He.height,
                    Ce.depth,
                    0,
                    He.data,
                    0,
                    0
                  );
              else
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                );
            else
              K
                ? ze &&
                  t.texSubImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Me,
                    0,
                    0,
                    0,
                    He.width,
                    He.height,
                    Ce.depth,
                    je,
                    vt,
                    He.data
                  )
                : t.texImage3D(
                    n.TEXTURE_2D_ARRAY,
                    Me,
                    Qe,
                    He.width,
                    He.height,
                    Ce.depth,
                    0,
                    je,
                    vt,
                    He.data
                  );
        } else {
          K &&
            Re &&
            t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Ct[0].width, Ct[0].height);
          for (let Me = 0, ye = Ct.length; Me < ye; Me++)
            (He = Ct[Me]),
              k.format !== Or
                ? je !== null
                  ? K
                    ? ze &&
                      t.compressedTexSubImage2D(
                        n.TEXTURE_2D,
                        Me,
                        0,
                        0,
                        He.width,
                        He.height,
                        je,
                        He.data
                      )
                    : t.compressedTexImage2D(
                        n.TEXTURE_2D,
                        Me,
                        Qe,
                        He.width,
                        He.height,
                        0,
                        He.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : K
                ? ze &&
                  t.texSubImage2D(
                    n.TEXTURE_2D,
                    Me,
                    0,
                    0,
                    He.width,
                    He.height,
                    je,
                    vt,
                    He.data
                  )
                : t.texImage2D(
                    n.TEXTURE_2D,
                    Me,
                    Qe,
                    He.width,
                    He.height,
                    0,
                    je,
                    vt,
                    He.data
                  );
        }
      else if (k.isDataArrayTexture)
        if (K) {
          if (
            (Re &&
              t.texStorage3D(
                n.TEXTURE_2D_ARRAY,
                Ye,
                Qe,
                Ce.width,
                Ce.height,
                Ce.depth
              ),
            ze)
          )
            if (k.layerUpdates.size > 0) {
              const Me = YE(Ce.width, Ce.height, k.format, k.type);
              for (const ye of k.layerUpdates) {
                const be = Ce.data.subarray(
                  (ye * Me) / Ce.data.BYTES_PER_ELEMENT,
                  ((ye + 1) * Me) / Ce.data.BYTES_PER_ELEMENT
                );
                t.texSubImage3D(
                  n.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  ye,
                  Ce.width,
                  Ce.height,
                  1,
                  je,
                  vt,
                  be
                );
              }
              k.clearLayerUpdates();
            } else
              t.texSubImage3D(
                n.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                Ce.width,
                Ce.height,
                Ce.depth,
                je,
                vt,
                Ce.data
              );
        } else
          t.texImage3D(
            n.TEXTURE_2D_ARRAY,
            0,
            Qe,
            Ce.width,
            Ce.height,
            Ce.depth,
            0,
            je,
            vt,
            Ce.data
          );
      else if (k.isData3DTexture)
        K
          ? (Re &&
              t.texStorage3D(
                n.TEXTURE_3D,
                Ye,
                Qe,
                Ce.width,
                Ce.height,
                Ce.depth
              ),
            ze &&
              t.texSubImage3D(
                n.TEXTURE_3D,
                0,
                0,
                0,
                0,
                Ce.width,
                Ce.height,
                Ce.depth,
                je,
                vt,
                Ce.data
              ))
          : t.texImage3D(
              n.TEXTURE_3D,
              0,
              Qe,
              Ce.width,
              Ce.height,
              Ce.depth,
              0,
              je,
              vt,
              Ce.data
            );
      else if (k.isFramebufferTexture) {
        if (Re)
          if (K) t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Ce.width, Ce.height);
          else {
            let Me = Ce.width,
              ye = Ce.height;
            for (let be = 0; be < Ye; be++)
              t.texImage2D(n.TEXTURE_2D, be, Qe, Me, ye, 0, je, vt, null),
                (Me >>= 1),
                (ye >>= 1);
          }
      } else if (Ct.length > 0) {
        if (K && Re) {
          const Me = wt(Ct[0]);
          t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Me.width, Me.height);
        }
        for (let Me = 0, ye = Ct.length; Me < ye; Me++)
          (He = Ct[Me]),
            K
              ? ze && t.texSubImage2D(n.TEXTURE_2D, Me, 0, 0, je, vt, He)
              : t.texImage2D(n.TEXTURE_2D, Me, Qe, je, vt, He);
        k.generateMipmaps = !1;
      } else if (K) {
        if (Re) {
          const Me = wt(Ce);
          t.texStorage2D(n.TEXTURE_2D, Ye, Qe, Me.width, Me.height);
        }
        ze && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, je, vt, Ce);
      } else t.texImage2D(n.TEXTURE_2D, 0, Qe, je, vt, Ce);
      x(k) && g(ae), (ot.__version = he.version), k.onUpdate && k.onUpdate(k);
    }
    B.__version = k.version;
  }
  function re(B, k, ne) {
    if (k.image.length !== 6) return;
    const ae = Ee(B, k),
      we = k.source;
    t.bindTexture(n.TEXTURE_CUBE_MAP, B.__webglTexture, n.TEXTURE0 + ne);
    const he = r.get(we);
    if (we.version !== he.__version || ae === !0) {
      t.activeTexture(n.TEXTURE0 + ne);
      const ot = Ht.getPrimaries(Ht.workingColorSpace),
        Ne = k.colorSpace === jo ? null : Ht.getPrimaries(k.colorSpace),
        it =
          k.colorSpace === jo || ot === Ne ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
      n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, k.flipY),
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, k.premultiplyAlpha),
        n.pixelStorei(n.UNPACK_ALIGNMENT, k.unpackAlignment),
        n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, it);
      const tt = k.isCompressedTexture || k.image[0].isCompressedTexture,
        Ce = k.image[0] && k.image[0].isDataTexture,
        je = [];
      for (let ye = 0; ye < 6; ye++)
        !tt && !Ce
          ? (je[ye] = y(k.image[ye], !0, i.maxCubemapSize))
          : (je[ye] = Ce ? k.image[ye].image : k.image[ye]),
          (je[ye] = _t(k, je[ye]));
      const vt = je[0],
        Qe = s.convert(k.format, k.colorSpace),
        He = s.convert(k.type),
        Ct = S(k.internalFormat, Qe, He, k.colorSpace),
        K = k.isVideoTexture !== !0,
        Re = he.__version === void 0 || ae === !0,
        ze = we.dataReady;
      let Ye = C(k, vt);
      de(n.TEXTURE_CUBE_MAP, k);
      let Me;
      if (tt) {
        K &&
          Re &&
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ye, Ct, vt.width, vt.height);
        for (let ye = 0; ye < 6; ye++) {
          Me = je[ye].mipmaps;
          for (let be = 0; be < Me.length; be++) {
            const $e = Me[be];
            k.format !== Or
              ? Qe !== null
                ? K
                  ? ze &&
                    t.compressedTexSubImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      be,
                      0,
                      0,
                      $e.width,
                      $e.height,
                      Qe,
                      $e.data
                    )
                  : t.compressedTexImage2D(
                      n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                      be,
                      Ct,
                      $e.width,
                      $e.height,
                      0,
                      $e.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : K
              ? ze &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  be,
                  0,
                  0,
                  $e.width,
                  $e.height,
                  Qe,
                  He,
                  $e.data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  be,
                  Ct,
                  $e.width,
                  $e.height,
                  0,
                  Qe,
                  He,
                  $e.data
                );
          }
        }
      } else {
        if (((Me = k.mipmaps), K && Re)) {
          Me.length > 0 && Ye++;
          const ye = wt(je[0]);
          t.texStorage2D(n.TEXTURE_CUBE_MAP, Ye, Ct, ye.width, ye.height);
        }
        for (let ye = 0; ye < 6; ye++)
          if (Ce) {
            K
              ? ze &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  je[ye].width,
                  je[ye].height,
                  Qe,
                  He,
                  je[ye].data
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  Ct,
                  je[ye].width,
                  je[ye].height,
                  0,
                  Qe,
                  He,
                  je[ye].data
                );
            for (let be = 0; be < Me.length; be++) {
              const mt = Me[be].image[ye].image;
              K
                ? ze &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    be + 1,
                    0,
                    0,
                    mt.width,
                    mt.height,
                    Qe,
                    He,
                    mt.data
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    be + 1,
                    Ct,
                    mt.width,
                    mt.height,
                    0,
                    Qe,
                    He,
                    mt.data
                  );
            }
          } else {
            K
              ? ze &&
                t.texSubImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  0,
                  0,
                  Qe,
                  He,
                  je[ye]
                )
              : t.texImage2D(
                  n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                  0,
                  Ct,
                  Qe,
                  He,
                  je[ye]
                );
            for (let be = 0; be < Me.length; be++) {
              const $e = Me[be];
              K
                ? ze &&
                  t.texSubImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    be + 1,
                    0,
                    0,
                    Qe,
                    He,
                    $e.image[ye]
                  )
                : t.texImage2D(
                    n.TEXTURE_CUBE_MAP_POSITIVE_X + ye,
                    be + 1,
                    Ct,
                    Qe,
                    He,
                    $e.image[ye]
                  );
            }
          }
      }
      x(k) && g(n.TEXTURE_CUBE_MAP),
        (he.__version = we.version),
        k.onUpdate && k.onUpdate(k);
    }
    B.__version = k.version;
  }
  function Be(B, k, ne, ae, we, he) {
    const ot = s.convert(ne.format, ne.colorSpace),
      Ne = s.convert(ne.type),
      it = S(ne.internalFormat, ot, Ne, ne.colorSpace),
      tt = r.get(k),
      Ce = r.get(ne);
    if (((Ce.__renderTarget = k), !tt.__hasExternalTextures)) {
      const je = Math.max(1, k.width >> he),
        vt = Math.max(1, k.height >> he);
      we === n.TEXTURE_3D || we === n.TEXTURE_2D_ARRAY
        ? t.texImage3D(we, he, it, je, vt, k.depth, 0, ot, Ne, null)
        : t.texImage2D(we, he, it, je, vt, 0, ot, Ne, null);
    }
    t.bindFramebuffer(n.FRAMEBUFFER, B),
      Te(k)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            ae,
            we,
            Ce.__webglTexture,
            0,
            Oe(k)
          )
        : (we === n.TEXTURE_2D ||
            (we >= n.TEXTURE_CUBE_MAP_POSITIVE_X &&
              we <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          n.framebufferTexture2D(n.FRAMEBUFFER, ae, we, Ce.__webglTexture, he),
      t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ue(B, k, ne) {
    if ((n.bindRenderbuffer(n.RENDERBUFFER, B), k.depthBuffer)) {
      const ae = k.depthTexture,
        we = ae && ae.isDepthTexture ? ae.type : null,
        he = b(k.stencilBuffer, we),
        ot = k.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
        Ne = Oe(k);
      Te(k)
        ? a.renderbufferStorageMultisampleEXT(
            n.RENDERBUFFER,
            Ne,
            he,
            k.width,
            k.height
          )
        : ne
        ? n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            Ne,
            he,
            k.width,
            k.height
          )
        : n.renderbufferStorage(n.RENDERBUFFER, he, k.width, k.height),
        n.framebufferRenderbuffer(n.FRAMEBUFFER, ot, n.RENDERBUFFER, B);
    } else {
      const ae = k.textures;
      for (let we = 0; we < ae.length; we++) {
        const he = ae[we],
          ot = s.convert(he.format, he.colorSpace),
          Ne = s.convert(he.type),
          it = S(he.internalFormat, ot, Ne, he.colorSpace),
          tt = Oe(k);
        ne && Te(k) === !1
          ? n.renderbufferStorageMultisample(
              n.RENDERBUFFER,
              tt,
              it,
              k.width,
              k.height
            )
          : Te(k)
          ? a.renderbufferStorageMultisampleEXT(
              n.RENDERBUFFER,
              tt,
              it,
              k.width,
              k.height
            )
          : n.renderbufferStorage(n.RENDERBUFFER, it, k.width, k.height);
      }
    }
    n.bindRenderbuffer(n.RENDERBUFFER, null);
  }
  function Fe(B, k) {
    if (k && k.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(n.FRAMEBUFFER, B),
      !(k.depthTexture && k.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    const ae = r.get(k.depthTexture);
    (ae.__renderTarget = k),
      (!ae.__webglTexture ||
        k.depthTexture.image.width !== k.width ||
        k.depthTexture.image.height !== k.height) &&
        ((k.depthTexture.image.width = k.width),
        (k.depthTexture.image.height = k.height),
        (k.depthTexture.needsUpdate = !0)),
      Z(k.depthTexture, 0);
    const we = ae.__webglTexture,
      he = Oe(k);
    if (k.depthTexture.format === ah)
      Te(k)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0,
            he
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0
          );
    else if (k.depthTexture.format === lh)
      Te(k)
        ? a.framebufferTexture2DMultisampleEXT(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0,
            he
          )
        : n.framebufferTexture2D(
            n.FRAMEBUFFER,
            n.DEPTH_STENCIL_ATTACHMENT,
            n.TEXTURE_2D,
            we,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Ke(B) {
    const k = r.get(B),
      ne = B.isWebGLCubeRenderTarget === !0;
    if (k.__boundDepthTexture !== B.depthTexture) {
      const ae = B.depthTexture;
      if ((k.__depthDisposeCallback && k.__depthDisposeCallback(), ae)) {
        const we = () => {
          delete k.__boundDepthTexture,
            delete k.__depthDisposeCallback,
            ae.removeEventListener("dispose", we);
        };
        ae.addEventListener("dispose", we), (k.__depthDisposeCallback = we);
      }
      k.__boundDepthTexture = ae;
    }
    if (B.depthTexture && !k.__autoAllocateDepthBuffer) {
      if (ne)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      const ae = B.texture.mipmaps;
      ae && ae.length > 0
        ? Fe(k.__webglFramebuffer[0], B)
        : Fe(k.__webglFramebuffer, B);
    } else if (ne) {
      k.__webglDepthbuffer = [];
      for (let ae = 0; ae < 6; ae++)
        if (
          (t.bindFramebuffer(n.FRAMEBUFFER, k.__webglFramebuffer[ae]),
          k.__webglDepthbuffer[ae] === void 0)
        )
          (k.__webglDepthbuffer[ae] = n.createRenderbuffer()),
            Ue(k.__webglDepthbuffer[ae], B, !1);
        else {
          const we = B.stencilBuffer
              ? n.DEPTH_STENCIL_ATTACHMENT
              : n.DEPTH_ATTACHMENT,
            he = k.__webglDepthbuffer[ae];
          n.bindRenderbuffer(n.RENDERBUFFER, he),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, we, n.RENDERBUFFER, he);
        }
    } else {
      const ae = B.texture.mipmaps;
      if (
        (ae && ae.length > 0
          ? t.bindFramebuffer(n.FRAMEBUFFER, k.__webglFramebuffer[0])
          : t.bindFramebuffer(n.FRAMEBUFFER, k.__webglFramebuffer),
        k.__webglDepthbuffer === void 0)
      )
        (k.__webglDepthbuffer = n.createRenderbuffer()),
          Ue(k.__webglDepthbuffer, B, !1);
      else {
        const we = B.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          he = k.__webglDepthbuffer;
        n.bindRenderbuffer(n.RENDERBUFFER, he),
          n.framebufferRenderbuffer(n.FRAMEBUFFER, we, n.RENDERBUFFER, he);
      }
    }
    t.bindFramebuffer(n.FRAMEBUFFER, null);
  }
  function Ve(B, k, ne) {
    const ae = r.get(B);
    k !== void 0 &&
      Be(
        ae.__webglFramebuffer,
        B,
        B.texture,
        n.COLOR_ATTACHMENT0,
        n.TEXTURE_2D,
        0
      ),
      ne !== void 0 && Ke(B);
  }
  function W(B) {
    const k = B.texture,
      ne = r.get(B),
      ae = r.get(k);
    B.addEventListener("dispose", R);
    const we = B.textures,
      he = B.isWebGLCubeRenderTarget === !0,
      ot = we.length > 1;
    if (
      (ot ||
        (ae.__webglTexture === void 0 &&
          (ae.__webglTexture = n.createTexture()),
        (ae.__version = k.version),
        o.memory.textures++),
      he)
    ) {
      ne.__webglFramebuffer = [];
      for (let Ne = 0; Ne < 6; Ne++)
        if (k.mipmaps && k.mipmaps.length > 0) {
          ne.__webglFramebuffer[Ne] = [];
          for (let it = 0; it < k.mipmaps.length; it++)
            ne.__webglFramebuffer[Ne][it] = n.createFramebuffer();
        } else ne.__webglFramebuffer[Ne] = n.createFramebuffer();
    } else {
      if (k.mipmaps && k.mipmaps.length > 0) {
        ne.__webglFramebuffer = [];
        for (let Ne = 0; Ne < k.mipmaps.length; Ne++)
          ne.__webglFramebuffer[Ne] = n.createFramebuffer();
      } else ne.__webglFramebuffer = n.createFramebuffer();
      if (ot)
        for (let Ne = 0, it = we.length; Ne < it; Ne++) {
          const tt = r.get(we[Ne]);
          tt.__webglTexture === void 0 &&
            ((tt.__webglTexture = n.createTexture()), o.memory.textures++);
        }
      if (B.samples > 0 && Te(B) === !1) {
        (ne.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (ne.__webglColorRenderbuffer = []),
          t.bindFramebuffer(n.FRAMEBUFFER, ne.__webglMultisampledFramebuffer);
        for (let Ne = 0; Ne < we.length; Ne++) {
          const it = we[Ne];
          (ne.__webglColorRenderbuffer[Ne] = n.createRenderbuffer()),
            n.bindRenderbuffer(n.RENDERBUFFER, ne.__webglColorRenderbuffer[Ne]);
          const tt = s.convert(it.format, it.colorSpace),
            Ce = s.convert(it.type),
            je = S(
              it.internalFormat,
              tt,
              Ce,
              it.colorSpace,
              B.isXRRenderTarget === !0
            ),
            vt = Oe(B);
          n.renderbufferStorageMultisample(
            n.RENDERBUFFER,
            vt,
            je,
            B.width,
            B.height
          ),
            n.framebufferRenderbuffer(
              n.FRAMEBUFFER,
              n.COLOR_ATTACHMENT0 + Ne,
              n.RENDERBUFFER,
              ne.__webglColorRenderbuffer[Ne]
            );
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null),
          B.depthBuffer &&
            ((ne.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Ue(ne.__webglDepthRenderbuffer, B, !0)),
          t.bindFramebuffer(n.FRAMEBUFFER, null);
      }
    }
    if (he) {
      t.bindTexture(n.TEXTURE_CUBE_MAP, ae.__webglTexture),
        de(n.TEXTURE_CUBE_MAP, k);
      for (let Ne = 0; Ne < 6; Ne++)
        if (k.mipmaps && k.mipmaps.length > 0)
          for (let it = 0; it < k.mipmaps.length; it++)
            Be(
              ne.__webglFramebuffer[Ne][it],
              B,
              k,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne,
              it
            );
        else
          Be(
            ne.__webglFramebuffer[Ne],
            B,
            k,
            n.COLOR_ATTACHMENT0,
            n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne,
            0
          );
      x(k) && g(n.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ot) {
      for (let Ne = 0, it = we.length; Ne < it; Ne++) {
        const tt = we[Ne],
          Ce = r.get(tt);
        let je = n.TEXTURE_2D;
        (B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) &&
          (je = B.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
          t.bindTexture(je, Ce.__webglTexture),
          de(je, tt),
          Be(ne.__webglFramebuffer, B, tt, n.COLOR_ATTACHMENT0 + Ne, je, 0),
          x(tt) && g(je);
      }
      t.unbindTexture();
    } else {
      let Ne = n.TEXTURE_2D;
      if (
        ((B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) &&
          (Ne = B.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
        t.bindTexture(Ne, ae.__webglTexture),
        de(Ne, k),
        k.mipmaps && k.mipmaps.length > 0)
      )
        for (let it = 0; it < k.mipmaps.length; it++)
          Be(ne.__webglFramebuffer[it], B, k, n.COLOR_ATTACHMENT0, Ne, it);
      else Be(ne.__webglFramebuffer, B, k, n.COLOR_ATTACHMENT0, Ne, 0);
      x(k) && g(Ne), t.unbindTexture();
    }
    B.depthBuffer && Ke(B);
  }
  function ge(B) {
    const k = B.textures;
    for (let ne = 0, ae = k.length; ne < ae; ne++) {
      const we = k[ne];
      if (x(we)) {
        const he = _(B),
          ot = r.get(we).__webglTexture;
        t.bindTexture(he, ot), g(he), t.unbindTexture();
      }
    }
  }
  const pe = [],
    Se = [];
  function me(B) {
    if (B.samples > 0) {
      if (Te(B) === !1) {
        const k = B.textures,
          ne = B.width,
          ae = B.height;
        let we = n.COLOR_BUFFER_BIT;
        const he = B.stencilBuffer
            ? n.DEPTH_STENCIL_ATTACHMENT
            : n.DEPTH_ATTACHMENT,
          ot = r.get(B),
          Ne = k.length > 1;
        if (Ne)
          for (let tt = 0; tt < k.length; tt++)
            t.bindFramebuffer(n.FRAMEBUFFER, ot.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + tt,
                n.RENDERBUFFER,
                null
              ),
              t.bindFramebuffer(n.FRAMEBUFFER, ot.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + tt,
                n.TEXTURE_2D,
                null,
                0
              );
        t.bindFramebuffer(
          n.READ_FRAMEBUFFER,
          ot.__webglMultisampledFramebuffer
        );
        const it = B.texture.mipmaps;
        it && it.length > 0
          ? t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ot.__webglFramebuffer[0])
          : t.bindFramebuffer(n.DRAW_FRAMEBUFFER, ot.__webglFramebuffer);
        for (let tt = 0; tt < k.length; tt++) {
          if (
            (B.resolveDepthBuffer &&
              (B.depthBuffer && (we |= n.DEPTH_BUFFER_BIT),
              B.stencilBuffer &&
                B.resolveStencilBuffer &&
                (we |= n.STENCIL_BUFFER_BIT)),
            Ne)
          ) {
            n.framebufferRenderbuffer(
              n.READ_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.RENDERBUFFER,
              ot.__webglColorRenderbuffer[tt]
            );
            const Ce = r.get(k[tt]).__webglTexture;
            n.framebufferTexture2D(
              n.DRAW_FRAMEBUFFER,
              n.COLOR_ATTACHMENT0,
              n.TEXTURE_2D,
              Ce,
              0
            );
          }
          n.blitFramebuffer(0, 0, ne, ae, 0, 0, ne, ae, we, n.NEAREST),
            l === !0 &&
              ((pe.length = 0),
              (Se.length = 0),
              pe.push(n.COLOR_ATTACHMENT0 + tt),
              B.depthBuffer &&
                B.resolveDepthBuffer === !1 &&
                (pe.push(he),
                Se.push(he),
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, Se)),
              n.invalidateFramebuffer(n.READ_FRAMEBUFFER, pe));
        }
        if (
          (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
          t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
          Ne)
        )
          for (let tt = 0; tt < k.length; tt++) {
            t.bindFramebuffer(n.FRAMEBUFFER, ot.__webglMultisampledFramebuffer),
              n.framebufferRenderbuffer(
                n.FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + tt,
                n.RENDERBUFFER,
                ot.__webglColorRenderbuffer[tt]
              );
            const Ce = r.get(k[tt]).__webglTexture;
            t.bindFramebuffer(n.FRAMEBUFFER, ot.__webglFramebuffer),
              n.framebufferTexture2D(
                n.DRAW_FRAMEBUFFER,
                n.COLOR_ATTACHMENT0 + tt,
                n.TEXTURE_2D,
                Ce,
                0
              );
          }
        t.bindFramebuffer(
          n.DRAW_FRAMEBUFFER,
          ot.__webglMultisampledFramebuffer
        );
      } else if (B.depthBuffer && B.resolveDepthBuffer === !1 && l) {
        const k = B.stencilBuffer
          ? n.DEPTH_STENCIL_ATTACHMENT
          : n.DEPTH_ATTACHMENT;
        n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [k]);
      }
    }
  }
  function Oe(B) {
    return Math.min(i.maxSamples, B.samples);
  }
  function Te(B) {
    const k = r.get(B);
    return (
      B.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      k.__useRenderToTexture !== !1
    );
  }
  function De(B) {
    const k = o.render.frame;
    u.get(B) !== k && (u.set(B, k), B.update());
  }
  function _t(B, k) {
    const ne = B.colorSpace,
      ae = B.format,
      we = B.type;
    return (
      B.isCompressedTexture === !0 ||
        B.isVideoTexture === !0 ||
        (ne !== Vc &&
          ne !== jo &&
          (Ht.getTransfer(ne) === nn
            ? (ae !== Or || we !== ls) &&
              console.warn(
                "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
              )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                ne
              ))),
      k
    );
  }
  function wt(B) {
    return (
      typeof HTMLImageElement < "u" && B instanceof HTMLImageElement
        ? ((c.width = B.naturalWidth || B.width),
          (c.height = B.naturalHeight || B.height))
        : typeof VideoFrame < "u" && B instanceof VideoFrame
        ? ((c.width = B.displayWidth), (c.height = B.displayHeight))
        : ((c.width = B.width), (c.height = B.height)),
      c
    );
  }
  (this.allocateTextureUnit = $),
    (this.resetTextureUnits = j),
    (this.setTexture2D = Z),
    (this.setTexture2DArray = q),
    (this.setTexture3D = Y),
    (this.setTextureCube = U),
    (this.rebindTextures = Ve),
    (this.setupRenderTarget = W),
    (this.updateRenderTargetMipmap = ge),
    (this.updateMultisampleRenderTarget = me),
    (this.setupDepthRenderbuffer = Ke),
    (this.setupFrameBufferTexture = Be),
    (this.useMultisampledRTT = Te);
}
function aj(n, e) {
  function t(r, i = jo) {
    let s;
    const o = Ht.getTransfer(i);
    if (r === ls) return n.UNSIGNED_BYTE;
    if (r === Yx) return n.UNSIGNED_SHORT_4_4_4_4;
    if (r === Jx) return n.UNSIGNED_SHORT_5_5_5_1;
    if (r === AC) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (r === MC) return n.BYTE;
    if (r === CC) return n.SHORT;
    if (r === sh) return n.UNSIGNED_SHORT;
    if (r === Kx) return n.INT;
    if (r === sa) return n.UNSIGNED_INT;
    if (r === fi) return n.FLOAT;
    if (r === Ih) return n.HALF_FLOAT;
    if (r === RC) return n.ALPHA;
    if (r === PC) return n.RGB;
    if (r === Or) return n.RGBA;
    if (r === ah) return n.DEPTH_COMPONENT;
    if (r === lh) return n.DEPTH_STENCIL;
    if (r === Zx) return n.RED;
    if (r === Em) return n.RED_INTEGER;
    if (r === IC) return n.RG;
    if (r === Qx) return n.RG_INTEGER;
    if (r === e_) return n.RGBA_INTEGER;
    if (r === ip || r === sp || r === op || r === ap)
      if (o === nn)
        if (((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), s !== null)) {
          if (r === ip) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (r === sp) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (r === op) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (r === ap) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((s = e.get("WEBGL_compressed_texture_s3tc")), s !== null)) {
        if (r === ip) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (r === sp) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (r === op) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (r === ap) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (r === I0 || r === N0 || r === L0 || r === O0)
      if (((s = e.get("WEBGL_compressed_texture_pvrtc")), s !== null)) {
        if (r === I0) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (r === N0) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (r === L0) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (r === O0) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (r === D0 || r === k0 || r === U0)
      if (((s = e.get("WEBGL_compressed_texture_etc")), s !== null)) {
        if (r === D0 || r === k0)
          return o === nn ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
        if (r === U0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : s.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      r === F0 ||
      r === B0 ||
      r === z0 ||
      r === V0 ||
      r === j0 ||
      r === H0 ||
      r === W0 ||
      r === G0 ||
      r === $0 ||
      r === X0 ||
      r === q0 ||
      r === K0 ||
      r === Y0 ||
      r === J0
    )
      if (((s = e.get("WEBGL_compressed_texture_astc")), s !== null)) {
        if (r === F0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (r === B0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (r === z0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (r === V0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (r === j0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (r === H0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (r === W0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (r === G0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (r === $0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (r === X0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (r === q0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (r === K0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (r === Y0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (r === J0)
          return o === nn
            ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (r === lp || r === Z0 || r === Q0)
      if (((s = e.get("EXT_texture_compression_bptc")), s !== null)) {
        if (r === lp)
          return o === nn
            ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (r === Z0) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (r === Q0) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (r === NC || r === ex || r === tx || r === nx)
      if (((s = e.get("EXT_texture_compression_rgtc")), s !== null)) {
        if (r === lp) return s.COMPRESSED_RED_RGTC1_EXT;
        if (r === ex) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (r === tx) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (r === nx) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return r === oh ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null;
  }
  return { convert: t };
}
class lj extends Nn {
  constructor(e = null) {
    super(), (this.sourceTexture = e), (this.isExternalTexture = !0);
  }
}
const Zce = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  Qce = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class eue {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, t) {
    if (this.texture === null) {
      const r = new lj(e.texture);
      (e.depthNear !== t.depthNear || e.depthFar !== t.depthFar) &&
        ((this.depthNear = e.depthNear), (this.depthFar = e.depthFar)),
        (this.texture = r);
    }
  }
  getMesh(e) {
    if (this.texture !== null && this.mesh === null) {
      const t = e.cameras[0].viewport,
        r = new cs({
          vertexShader: Zce,
          fragmentShader: Qce,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: t.z },
            depthHeight: { value: t.w },
          },
        });
      this.mesh = new $n(new Oh(20, 20), r);
    }
    return this.mesh;
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
  getDepthTexture() {
    return this.texture;
  }
}
class tue extends wo {
  constructor(e, t) {
    super();
    const r = this;
    let i = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      u = null,
      f = null,
      p = null,
      m = null,
      v = null;
    const y = new eue(),
      x = {},
      g = t.getContextAttributes();
    let _ = null,
      S = null;
    const b = [],
      C = [],
      A = new xe();
    let R = null;
    const O = new lr();
    O.viewport = new Gt();
    const I = new lr();
    I.viewport = new Gt();
    const N = [O, I],
      D = new YV();
    let j = null,
      $ = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (se) {
        let _e = b[se];
        return (
          _e === void 0 && ((_e = new Iy()), (b[se] = _e)),
          _e.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (se) {
        let _e = b[se];
        return (
          _e === void 0 && ((_e = new Iy()), (b[se] = _e)), _e.getGripSpace()
        );
      }),
      (this.getHand = function (se) {
        let _e = b[se];
        return (
          _e === void 0 && ((_e = new Iy()), (b[se] = _e)), _e.getHandSpace()
        );
      });
    function G(se) {
      const _e = C.indexOf(se.inputSource);
      if (_e === -1) return;
      const re = b[_e];
      re !== void 0 &&
        (re.update(se.inputSource, se.frame, c || o),
        re.dispatchEvent({ type: se.type, data: se.inputSource }));
    }
    function Z() {
      i.removeEventListener("select", G),
        i.removeEventListener("selectstart", G),
        i.removeEventListener("selectend", G),
        i.removeEventListener("squeeze", G),
        i.removeEventListener("squeezestart", G),
        i.removeEventListener("squeezeend", G),
        i.removeEventListener("end", Z),
        i.removeEventListener("inputsourceschange", q);
      for (let se = 0; se < b.length; se++) {
        const _e = C[se];
        _e !== null && ((C[se] = null), b[se].disconnect(_e));
      }
      (j = null), ($ = null), y.reset();
      for (const se in x) delete x[se];
      e.setRenderTarget(_),
        (m = null),
        (p = null),
        (f = null),
        (i = null),
        (S = null),
        Ie.stop(),
        (r.isPresenting = !1),
        e.setPixelRatio(R),
        e.setSize(A.width, A.height, !1),
        r.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (se) {
      (s = se),
        r.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (se) {
        (a = se),
          r.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (se) {
        c = se;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return f;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (se) {
        if (((i = se), i !== null)) {
          if (
            ((_ = e.getRenderTarget()),
            i.addEventListener("select", G),
            i.addEventListener("selectstart", G),
            i.addEventListener("selectend", G),
            i.addEventListener("squeeze", G),
            i.addEventListener("squeezestart", G),
            i.addEventListener("squeezeend", G),
            i.addEventListener("end", Z),
            i.addEventListener("inputsourceschange", q),
            g.xrCompatible !== !0 && (await t.makeXRCompatible()),
            (R = e.getPixelRatio()),
            e.getSize(A),
            typeof XRWebGLBinding < "u" && (f = new XRWebGLBinding(i, t)),
            f !== null && "createProjectionLayer" in XRWebGLBinding.prototype)
          ) {
            let re = null,
              Be = null,
              Ue = null;
            g.depth &&
              ((Ue = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (re = g.stencil ? lh : ah),
              (Be = g.stencil ? oh : sa));
            const Fe = {
              colorFormat: t.RGBA8,
              depthFormat: Ue,
              scaleFactor: s,
            };
            (p = f.createProjectionLayer(Fe)),
              i.updateRenderState({ layers: [p] }),
              e.setPixelRatio(1),
              e.setSize(p.textureWidth, p.textureHeight, !1),
              (S = new xo(p.textureWidth, p.textureHeight, {
                format: Or,
                type: ls,
                depthTexture: new HC(
                  p.textureWidth,
                  p.textureHeight,
                  Be,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  re
                ),
                stencilBuffer: g.stencil,
                colorSpace: e.outputColorSpace,
                samples: g.antialias ? 4 : 0,
                resolveDepthBuffer: p.ignoreDepthValues === !1,
                resolveStencilBuffer: p.ignoreDepthValues === !1,
              }));
          } else {
            const re = {
              antialias: g.antialias,
              alpha: !0,
              depth: g.depth,
              stencil: g.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(i, t, re)),
              i.updateRenderState({ baseLayer: m }),
              e.setPixelRatio(1),
              e.setSize(m.framebufferWidth, m.framebufferHeight, !1),
              (S = new xo(m.framebufferWidth, m.framebufferHeight, {
                format: Or,
                type: ls,
                colorSpace: e.outputColorSpace,
                stencilBuffer: g.stencil,
                resolveDepthBuffer: m.ignoreDepthValues === !1,
                resolveStencilBuffer: m.ignoreDepthValues === !1,
              }));
          }
          (S.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await i.requestReferenceSpace(a)),
            Ie.setContext(i),
            Ie.start(),
            (r.isPresenting = !0),
            r.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      }),
      (this.getDepthTexture = function () {
        return y.getDepthTexture();
      });
    function q(se) {
      for (let _e = 0; _e < se.removed.length; _e++) {
        const re = se.removed[_e],
          Be = C.indexOf(re);
        Be >= 0 && ((C[Be] = null), b[Be].disconnect(re));
      }
      for (let _e = 0; _e < se.added.length; _e++) {
        const re = se.added[_e];
        let Be = C.indexOf(re);
        if (Be === -1) {
          for (let Fe = 0; Fe < b.length; Fe++)
            if (Fe >= C.length) {
              C.push(re), (Be = Fe);
              break;
            } else if (C[Fe] === null) {
              (C[Fe] = re), (Be = Fe);
              break;
            }
          if (Be === -1) break;
        }
        const Ue = b[Be];
        Ue && Ue.connect(re);
      }
    }
    const Y = new z(),
      U = new z();
    function H(se, _e, re) {
      Y.setFromMatrixPosition(_e.matrixWorld),
        U.setFromMatrixPosition(re.matrixWorld);
      const Be = Y.distanceTo(U),
        Ue = _e.projectionMatrix.elements,
        Fe = re.projectionMatrix.elements,
        Ke = Ue[14] / (Ue[10] - 1),
        Ve = Ue[14] / (Ue[10] + 1),
        W = (Ue[9] + 1) / Ue[5],
        ge = (Ue[9] - 1) / Ue[5],
        pe = (Ue[8] - 1) / Ue[0],
        Se = (Fe[8] + 1) / Fe[0],
        me = Ke * pe,
        Oe = Ke * Se,
        Te = Be / (-pe + Se),
        De = Te * -pe;
      if (
        (_e.matrixWorld.decompose(se.position, se.quaternion, se.scale),
        se.translateX(De),
        se.translateZ(Te),
        se.matrixWorld.compose(se.position, se.quaternion, se.scale),
        se.matrixWorldInverse.copy(se.matrixWorld).invert(),
        Ue[10] === -1)
      )
        se.projectionMatrix.copy(_e.projectionMatrix),
          se.projectionMatrixInverse.copy(_e.projectionMatrixInverse);
      else {
        const _t = Ke + Te,
          wt = Ve + Te,
          B = me - De,
          k = Oe + (Be - De),
          ne = ((W * Ve) / wt) * _t,
          ae = ((ge * Ve) / wt) * _t;
        se.projectionMatrix.makePerspective(B, k, ne, ae, _t, wt),
          se.projectionMatrixInverse.copy(se.projectionMatrix).invert();
      }
    }
    function X(se, _e) {
      _e === null
        ? se.matrixWorld.copy(se.matrix)
        : se.matrixWorld.multiplyMatrices(_e.matrixWorld, se.matrix),
        se.matrixWorldInverse.copy(se.matrixWorld).invert();
    }
    this.updateCamera = function (se) {
      if (i === null) return;
      let _e = se.near,
        re = se.far;
      y.texture !== null &&
        (y.depthNear > 0 && (_e = y.depthNear),
        y.depthFar > 0 && (re = y.depthFar)),
        (D.near = I.near = O.near = _e),
        (D.far = I.far = O.far = re),
        (j !== D.near || $ !== D.far) &&
          (i.updateRenderState({ depthNear: D.near, depthFar: D.far }),
          (j = D.near),
          ($ = D.far)),
        (D.layers.mask = se.layers.mask | 6),
        (O.layers.mask = D.layers.mask & 3),
        (I.layers.mask = D.layers.mask & 5);
      const Be = se.parent,
        Ue = D.cameras;
      X(D, Be);
      for (let Fe = 0; Fe < Ue.length; Fe++) X(Ue[Fe], Be);
      Ue.length === 2
        ? H(D, O, I)
        : D.projectionMatrix.copy(O.projectionMatrix),
        ie(se, D, Be);
    };
    function ie(se, _e, re) {
      re === null
        ? se.matrix.copy(_e.matrixWorld)
        : (se.matrix.copy(re.matrixWorld),
          se.matrix.invert(),
          se.matrix.multiply(_e.matrixWorld)),
        se.matrix.decompose(se.position, se.quaternion, se.scale),
        se.updateMatrixWorld(!0),
        se.projectionMatrix.copy(_e.projectionMatrix),
        se.projectionMatrixInverse.copy(_e.projectionMatrixInverse),
        se.isPerspectiveCamera &&
          ((se.fov = uh * 2 * Math.atan(1 / se.projectionMatrix.elements[5])),
          (se.zoom = 1));
    }
    (this.getCamera = function () {
      return D;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (se) {
        (l = se),
          p !== null && (p.fixedFoveation = se),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = se);
      }),
      (this.hasDepthSensing = function () {
        return y.texture !== null;
      }),
      (this.getDepthSensingMesh = function () {
        return y.getMesh(D);
      }),
      (this.getCameraTexture = function (se) {
        return x[se];
      });
    let de = null;
    function Ee(se, _e) {
      if (((u = _e.getViewerPose(c || o)), (v = _e), u !== null)) {
        const re = u.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(S, m.framebuffer),
          e.setRenderTarget(S));
        let Be = !1;
        re.length !== D.cameras.length && ((D.cameras.length = 0), (Be = !0));
        for (let Ve = 0; Ve < re.length; Ve++) {
          const W = re[Ve];
          let ge = null;
          if (m !== null) ge = m.getViewport(W);
          else {
            const Se = f.getViewSubImage(p, W);
            (ge = Se.viewport),
              Ve === 0 &&
                (e.setRenderTargetTextures(
                  S,
                  Se.colorTexture,
                  Se.depthStencilTexture
                ),
                e.setRenderTarget(S));
          }
          let pe = N[Ve];
          pe === void 0 &&
            ((pe = new lr()),
            pe.layers.enable(Ve),
            (pe.viewport = new Gt()),
            (N[Ve] = pe)),
            pe.matrix.fromArray(W.transform.matrix),
            pe.matrix.decompose(pe.position, pe.quaternion, pe.scale),
            pe.projectionMatrix.fromArray(W.projectionMatrix),
            pe.projectionMatrixInverse.copy(pe.projectionMatrix).invert(),
            pe.viewport.set(ge.x, ge.y, ge.width, ge.height),
            Ve === 0 &&
              (D.matrix.copy(pe.matrix),
              D.matrix.decompose(D.position, D.quaternion, D.scale)),
            Be === !0 && D.cameras.push(pe);
        }
        const Ue = i.enabledFeatures;
        if (
          Ue &&
          Ue.includes("depth-sensing") &&
          i.depthUsage == "gpu-optimized" &&
          f
        ) {
          const Ve = f.getDepthInformation(re[0]);
          Ve && Ve.isValid && Ve.texture && y.init(Ve, i.renderState);
        }
        if (Ue && Ue.includes("camera-access") && (e.state.unbindTexture(), f))
          for (let Ve = 0; Ve < re.length; Ve++) {
            const W = re[Ve].camera;
            if (W) {
              let ge = x[W];
              ge || ((ge = new lj()), (x[W] = ge));
              const pe = f.getCameraImage(W);
              ge.sourceTexture = pe;
            }
          }
      }
      for (let re = 0; re < b.length; re++) {
        const Be = C[re],
          Ue = b[re];
        Be !== null && Ue !== void 0 && Ue.update(Be, _e, c || o);
      }
      de && de(se, _e),
        _e.detectedPlanes &&
          r.dispatchEvent({ type: "planesdetected", data: _e }),
        (v = null);
    }
    const Ie = new nj();
    Ie.setAnimationLoop(Ee),
      (this.setAnimationLoop = function (se) {
        de = se;
      }),
      (this.dispose = function () {});
  }
}
const Zl = new Di(),
  nue = new Tt();
function rue(n, e) {
  function t(x, g) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
  }
  function r(x, g) {
    g.color.getRGB(x.fogColor.value, tV(n)),
      g.isFog
        ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
        : g.isFogExp2 && (x.fogDensity.value = g.density);
  }
  function i(x, g, _, S, b) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(x, g)
      : g.isMeshToonMaterial
      ? (s(x, g), f(x, g))
      : g.isMeshPhongMaterial
      ? (s(x, g), u(x, g))
      : g.isMeshStandardMaterial
      ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, b))
      : g.isMeshMatcapMaterial
      ? (s(x, g), v(x, g))
      : g.isMeshDepthMaterial
      ? s(x, g)
      : g.isMeshDistanceMaterial
      ? (s(x, g), y(x, g))
      : g.isMeshNormalMaterial
      ? s(x, g)
      : g.isLineBasicMaterial
      ? (o(x, g), g.isLineDashedMaterial && a(x, g))
      : g.isPointsMaterial
      ? l(x, g, _, S)
      : g.isSpriteMaterial
      ? c(x, g)
      : g.isShadowMaterial
      ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(x, g) {
    (x.opacity.value = g.opacity),
      g.color && x.diffuse.value.copy(g.color),
      g.emissive &&
        x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.bumpMap &&
        ((x.bumpMap.value = g.bumpMap),
        t(g.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = g.bumpScale),
        g.side === Jr && (x.bumpScale.value *= -1)),
      g.normalMap &&
        ((x.normalMap.value = g.normalMap),
        t(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === Jr && x.normalScale.value.negate()),
      g.displacementMap &&
        ((x.displacementMap.value = g.displacementMap),
        t(g.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = g.displacementScale),
        (x.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((x.emissiveMap.value = g.emissiveMap),
        t(g.emissiveMap, x.emissiveMapTransform)),
      g.specularMap &&
        ((x.specularMap.value = g.specularMap),
        t(g.specularMap, x.specularMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    const _ = e.get(g),
      S = _.envMap,
      b = _.envMapRotation;
    S &&
      ((x.envMap.value = S),
      Zl.copy(b),
      (Zl.x *= -1),
      (Zl.y *= -1),
      (Zl.z *= -1),
      S.isCubeTexture &&
        S.isRenderTargetTexture === !1 &&
        ((Zl.y *= -1), (Zl.z *= -1)),
      x.envMapRotation.value.setFromMatrix4(nue.makeRotationFromEuler(Zl)),
      (x.flipEnvMap.value =
        S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
      (x.reflectivity.value = g.reflectivity),
      (x.ior.value = g.ior),
      (x.refractionRatio.value = g.refractionRatio)),
      g.lightMap &&
        ((x.lightMap.value = g.lightMap),
        (x.lightMapIntensity.value = g.lightMapIntensity),
        t(g.lightMap, x.lightMapTransform)),
      g.aoMap &&
        ((x.aoMap.value = g.aoMap),
        (x.aoMapIntensity.value = g.aoMapIntensity),
        t(g.aoMap, x.aoMapTransform));
  }
  function o(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform));
  }
  function a(x, g) {
    (x.dashSize.value = g.dashSize),
      (x.totalSize.value = g.dashSize + g.gapSize),
      (x.scale.value = g.scale);
  }
  function l(x, g, _, S) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.size.value = g.size * _),
      (x.scale.value = S * 0.5),
      g.map && ((x.map.value = g.map), t(g.map, x.uvTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function c(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.rotation.value = g.rotation),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function u(x, g) {
    x.specular.value.copy(g.specular),
      (x.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function f(x, g) {
    g.gradientMap && (x.gradientMap.value = g.gradientMap);
  }
  function p(x, g) {
    (x.metalness.value = g.metalness),
      g.metalnessMap &&
        ((x.metalnessMap.value = g.metalnessMap),
        t(g.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = g.roughness),
      g.roughnessMap &&
        ((x.roughnessMap.value = g.roughnessMap),
        t(g.roughnessMap, x.roughnessMapTransform)),
      g.envMap && (x.envMapIntensity.value = g.envMapIntensity);
  }
  function m(x, g, _) {
    (x.ior.value = g.ior),
      g.sheen > 0 &&
        (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (x.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((x.sheenColorMap.value = g.sheenColorMap),
          t(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
          t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((x.clearcoat.value = g.clearcoat),
        (x.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((x.clearcoatMap.value = g.clearcoatMap),
          t(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
          t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === Jr && x.clearcoatNormalScale.value.negate())),
      g.dispersion > 0 && (x.dispersion.value = g.dispersion),
      g.iridescence > 0 &&
        ((x.iridescence.value = g.iridescence),
        (x.iridescenceIOR.value = g.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((x.iridescenceMap.value = g.iridescenceMap),
          t(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((x.transmission.value = g.transmission),
        (x.transmissionSamplerMap.value = _.texture),
        x.transmissionSamplerSize.value.set(_.width, _.height),
        g.transmissionMap &&
          ((x.transmissionMap.value = g.transmissionMap),
          t(g.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = g.thickness),
        g.thicknessMap &&
          ((x.thicknessMap.value = g.thicknessMap),
          t(g.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = g.attenuationDistance),
        x.attenuationColor.value.copy(g.attenuationColor)),
      g.anisotropy > 0 &&
        (x.anisotropyVector.value.set(
          g.anisotropy * Math.cos(g.anisotropyRotation),
          g.anisotropy * Math.sin(g.anisotropyRotation)
        ),
        g.anisotropyMap &&
          ((x.anisotropyMap.value = g.anisotropyMap),
          t(g.anisotropyMap, x.anisotropyMapTransform))),
      (x.specularIntensity.value = g.specularIntensity),
      x.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((x.specularColorMap.value = g.specularColorMap),
        t(g.specularColorMap, x.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((x.specularIntensityMap.value = g.specularIntensityMap),
        t(g.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function v(x, g) {
    g.matcap && (x.matcap.value = g.matcap);
  }
  function y(x, g) {
    const _ = e.get(g).light;
    x.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (x.nearDistance.value = _.shadow.camera.near),
      (x.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: r, refreshMaterialUniforms: i };
}
function iue(n, e, t, r) {
  let i = {},
    s = {},
    o = [];
  const a = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
  function l(_, S) {
    const b = S.program;
    r.uniformBlockBinding(_, b);
  }
  function c(_, S) {
    let b = i[_.id];
    b === void 0 &&
      (v(_), (b = u(_)), (i[_.id] = b), _.addEventListener("dispose", x));
    const C = S.program;
    r.updateUBOMapping(_, C);
    const A = e.render.frame;
    s[_.id] !== A && (p(_), (s[_.id] = A));
  }
  function u(_) {
    const S = f();
    _.__bindingPointIndex = S;
    const b = n.createBuffer(),
      C = _.__size,
      A = _.usage;
    return (
      n.bindBuffer(n.UNIFORM_BUFFER, b),
      n.bufferData(n.UNIFORM_BUFFER, C, A),
      n.bindBuffer(n.UNIFORM_BUFFER, null),
      n.bindBufferBase(n.UNIFORM_BUFFER, S, b),
      b
    );
  }
  function f() {
    for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(_) {
    const S = i[_.id],
      b = _.uniforms,
      C = _.__cache;
    n.bindBuffer(n.UNIFORM_BUFFER, S);
    for (let A = 0, R = b.length; A < R; A++) {
      const O = Array.isArray(b[A]) ? b[A] : [b[A]];
      for (let I = 0, N = O.length; I < N; I++) {
        const D = O[I];
        if (m(D, A, I, C) === !0) {
          const j = D.__offset,
            $ = Array.isArray(D.value) ? D.value : [D.value];
          let G = 0;
          for (let Z = 0; Z < $.length; Z++) {
            const q = $[Z],
              Y = y(q);
            typeof q == "number" || typeof q == "boolean"
              ? ((D.__data[0] = q),
                n.bufferSubData(n.UNIFORM_BUFFER, j + G, D.__data))
              : q.isMatrix3
              ? ((D.__data[0] = q.elements[0]),
                (D.__data[1] = q.elements[1]),
                (D.__data[2] = q.elements[2]),
                (D.__data[3] = 0),
                (D.__data[4] = q.elements[3]),
                (D.__data[5] = q.elements[4]),
                (D.__data[6] = q.elements[5]),
                (D.__data[7] = 0),
                (D.__data[8] = q.elements[6]),
                (D.__data[9] = q.elements[7]),
                (D.__data[10] = q.elements[8]),
                (D.__data[11] = 0))
              : (q.toArray(D.__data, G),
                (G += Y.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          n.bufferSubData(n.UNIFORM_BUFFER, j, D.__data);
        }
      }
    }
    n.bindBuffer(n.UNIFORM_BUFFER, null);
  }
  function m(_, S, b, C) {
    const A = _.value,
      R = S + "_" + b;
    if (C[R] === void 0)
      return (
        typeof A == "number" || typeof A == "boolean"
          ? (C[R] = A)
          : (C[R] = A.clone()),
        !0
      );
    {
      const O = C[R];
      if (typeof A == "number" || typeof A == "boolean") {
        if (O !== A) return (C[R] = A), !0;
      } else if (O.equals(A) === !1) return O.copy(A), !0;
    }
    return !1;
  }
  function v(_) {
    const S = _.uniforms;
    let b = 0;
    const C = 16;
    for (let R = 0, O = S.length; R < O; R++) {
      const I = Array.isArray(S[R]) ? S[R] : [S[R]];
      for (let N = 0, D = I.length; N < D; N++) {
        const j = I[N],
          $ = Array.isArray(j.value) ? j.value : [j.value];
        for (let G = 0, Z = $.length; G < Z; G++) {
          const q = $[G],
            Y = y(q),
            U = b % C,
            H = U % Y.boundary,
            X = U + H;
          (b += H),
            X !== 0 && C - X < Y.storage && (b += C - X),
            (j.__data = new Float32Array(
              Y.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (j.__offset = b),
            (b += Y.storage);
        }
      }
    }
    const A = b % C;
    return A > 0 && (b += C - A), (_.__size = b), (_.__cache = {}), this;
  }
  function y(_) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number" || typeof _ == "boolean"
        ? ((S.boundary = 4), (S.storage = 4))
        : _.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : _.isVector3 || _.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : _.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : _.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : _.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      S
    );
  }
  function x(_) {
    const S = _.target;
    S.removeEventListener("dispose", x);
    const b = o.indexOf(S.__bindingPointIndex);
    o.splice(b, 1), n.deleteBuffer(i[S.id]), delete i[S.id], delete s[S.id];
  }
  function g() {
    for (const _ in i) n.deleteBuffer(i[_]);
    (o = []), (i = {}), (s = {});
  }
  return { bind: l, update: c, dispose: g };
}
class cj {
  constructor(e = {}) {
    const {
      canvas: t = Z4(),
      context: r = null,
      depth: i = !0,
      stencil: s = !1,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: f = !1,
      reversedDepthBuffer: p = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let m;
    if (r !== null) {
      if (
        typeof WebGLRenderingContext < "u" &&
        r instanceof WebGLRenderingContext
      )
        throw new Error(
          "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
        );
      m = r.getContextAttributes().alpha;
    } else m = o;
    const v = new Uint32Array(4),
      y = new Int32Array(4);
    let x = null,
      g = null;
    const _ = [],
      S = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.toneMapping = go),
      (this.toneMappingExposure = 1),
      (this.transmissionResolutionScale = 1);
    const b = this;
    let C = !1;
    this._outputColorSpace = li;
    let A = 0,
      R = 0,
      O = null,
      I = -1,
      N = null;
    const D = new Gt(),
      j = new Gt();
    let $ = null;
    const G = new Je(0);
    let Z = 0,
      q = t.width,
      Y = t.height,
      U = 1,
      H = null,
      X = null;
    const ie = new Gt(0, 0, q, Y),
      de = new Gt(0, 0, q, Y);
    let Ee = !1;
    const Ie = new Lh();
    let se = !1,
      _e = !1;
    const re = new Tt(),
      Be = new z(),
      Ue = new Gt(),
      Fe = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    let Ke = !1;
    function Ve() {
      return O === null ? U : 1;
    }
    let W = r;
    function ge(F, ee) {
      return t.getContext(F, ee);
    }
    try {
      const F = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: f,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${$x}`),
        t.addEventListener("webglcontextlost", ze, !1),
        t.addEventListener("webglcontextrestored", Ye, !1),
        t.addEventListener("webglcontextcreationerror", Me, !1),
        W === null)
      ) {
        const ee = "webgl2";
        if (((W = ge(ee, F)), W === null))
          throw ge(ee)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
    } catch (F) {
      throw (console.error("THREE.WebGLRenderer: " + F.message), F);
    }
    let pe,
      Se,
      me,
      Oe,
      Te,
      De,
      _t,
      wt,
      B,
      k,
      ne,
      ae,
      we,
      he,
      ot,
      Ne,
      it,
      tt,
      Ce,
      je,
      vt,
      Qe,
      He,
      Ct;
    function K() {
      (pe = new gle(W)),
        pe.init(),
        (Qe = new aj(W, pe)),
        (Se = new cle(W, pe, e, Qe)),
        (me = new Yce(W, pe)),
        Se.reversedDepthBuffer && p && me.buffers.depth.setReversed(!0),
        (Oe = new xle(W)),
        (Te = new Uce()),
        (De = new Jce(W, pe, me, Te, Se, Qe, Oe)),
        (_t = new dle(b)),
        (wt = new mle(b)),
        (B = new Tse(W)),
        (He = new ale(W, B)),
        (k = new vle(W, B, Oe, He)),
        (ne = new wle(W, k, B, Oe)),
        (Ce = new _le(W, Se, De)),
        (Ne = new ule(Te)),
        (ae = new kce(b, _t, wt, pe, Se, He, Ne)),
        (we = new rue(b, Te)),
        (he = new Bce()),
        (ot = new Gce(pe)),
        (tt = new ole(b, _t, wt, me, ne, m, l)),
        (it = new qce(b, ne, Se)),
        (Ct = new iue(W, Oe, Se, me)),
        (je = new lle(W, pe, Oe)),
        (vt = new yle(W, pe, Oe)),
        (Oe.programs = ae.programs),
        (b.capabilities = Se),
        (b.extensions = pe),
        (b.properties = Te),
        (b.renderLists = he),
        (b.shadowMap = it),
        (b.state = me),
        (b.info = Oe);
    }
    K();
    const Re = new tue(b, W);
    (this.xr = Re),
      (this.getContext = function () {
        return W;
      }),
      (this.getContextAttributes = function () {
        return W.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const F = pe.get("WEBGL_lose_context");
        F && F.loseContext();
      }),
      (this.forceContextRestore = function () {
        const F = pe.get("WEBGL_lose_context");
        F && F.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return U;
      }),
      (this.setPixelRatio = function (F) {
        F !== void 0 && ((U = F), this.setSize(q, Y, !1));
      }),
      (this.getSize = function (F) {
        return F.set(q, Y);
      }),
      (this.setSize = function (F, ee, le = !0) {
        if (Re.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (q = F),
          (Y = ee),
          (t.width = Math.floor(F * U)),
          (t.height = Math.floor(ee * U)),
          le === !0 &&
            ((t.style.width = F + "px"), (t.style.height = ee + "px")),
          this.setViewport(0, 0, F, ee);
      }),
      (this.getDrawingBufferSize = function (F) {
        return F.set(q * U, Y * U).floor();
      }),
      (this.setDrawingBufferSize = function (F, ee, le) {
        (q = F),
          (Y = ee),
          (U = le),
          (t.width = Math.floor(F * le)),
          (t.height = Math.floor(ee * le)),
          this.setViewport(0, 0, F, ee);
      }),
      (this.getCurrentViewport = function (F) {
        return F.copy(D);
      }),
      (this.getViewport = function (F) {
        return F.copy(ie);
      }),
      (this.setViewport = function (F, ee, le, ce) {
        F.isVector4 ? ie.set(F.x, F.y, F.z, F.w) : ie.set(F, ee, le, ce),
          me.viewport(D.copy(ie).multiplyScalar(U).round());
      }),
      (this.getScissor = function (F) {
        return F.copy(de);
      }),
      (this.setScissor = function (F, ee, le, ce) {
        F.isVector4 ? de.set(F.x, F.y, F.z, F.w) : de.set(F, ee, le, ce),
          me.scissor(j.copy(de).multiplyScalar(U).round());
      }),
      (this.getScissorTest = function () {
        return Ee;
      }),
      (this.setScissorTest = function (F) {
        me.setScissorTest((Ee = F));
      }),
      (this.setOpaqueSort = function (F) {
        H = F;
      }),
      (this.setTransparentSort = function (F) {
        X = F;
      }),
      (this.getClearColor = function (F) {
        return F.copy(tt.getClearColor());
      }),
      (this.setClearColor = function () {
        tt.setClearColor(...arguments);
      }),
      (this.getClearAlpha = function () {
        return tt.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        tt.setClearAlpha(...arguments);
      }),
      (this.clear = function (F = !0, ee = !0, le = !0) {
        let ce = 0;
        if (F) {
          let te = !1;
          if (O !== null) {
            const Ae = O.texture.format;
            te = Ae === e_ || Ae === Qx || Ae === Em;
          }
          if (te) {
            const Ae = O.texture.type,
              We =
                Ae === ls ||
                Ae === sa ||
                Ae === sh ||
                Ae === oh ||
                Ae === Yx ||
                Ae === Jx,
              nt = tt.getClearColor(),
              Ze = tt.getClearAlpha(),
              yt = nt.r,
              gt = nt.g,
              at = nt.b;
            We
              ? ((v[0] = yt),
                (v[1] = gt),
                (v[2] = at),
                (v[3] = Ze),
                W.clearBufferuiv(W.COLOR, 0, v))
              : ((y[0] = yt),
                (y[1] = gt),
                (y[2] = at),
                (y[3] = Ze),
                W.clearBufferiv(W.COLOR, 0, y));
          } else ce |= W.COLOR_BUFFER_BIT;
        }
        ee && (ce |= W.DEPTH_BUFFER_BIT),
          le &&
            ((ce |= W.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          W.clear(ce);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", ze, !1),
          t.removeEventListener("webglcontextrestored", Ye, !1),
          t.removeEventListener("webglcontextcreationerror", Me, !1),
          tt.dispose(),
          he.dispose(),
          ot.dispose(),
          Te.dispose(),
          _t.dispose(),
          wt.dispose(),
          ne.dispose(),
          He.dispose(),
          Ct.dispose(),
          ae.dispose(),
          Re.dispose(),
          Re.removeEventListener("sessionstart", On),
          Re.removeEventListener("sessionend", Fi),
          Dn.stop();
      });
    function ze(F) {
      F.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (C = !0);
    }
    function Ye() {
      console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
      const F = Oe.autoReset,
        ee = it.enabled,
        le = it.autoUpdate,
        ce = it.needsUpdate,
        te = it.type;
      K(),
        (Oe.autoReset = F),
        (it.enabled = ee),
        (it.autoUpdate = le),
        (it.needsUpdate = ce),
        (it.type = te);
    }
    function Me(F) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        F.statusMessage
      );
    }
    function ye(F) {
      const ee = F.target;
      ee.removeEventListener("dispose", ye), be(ee);
    }
    function be(F) {
      $e(F), Te.remove(F);
    }
    function $e(F) {
      const ee = Te.get(F).programs;
      ee !== void 0 &&
        (ee.forEach(function (le) {
          ae.releaseProgram(le);
        }),
        F.isShaderMaterial && ae.releaseShaderCache(F));
    }
    this.renderBufferDirect = function (F, ee, le, ce, te, Ae) {
      ee === null && (ee = Fe);
      const We = te.isMesh && te.matrixWorld.determinant() < 0,
        nt = A_(F, ee, le, ce, te);
      me.setMaterial(ce, We);
      let Ze = le.index,
        yt = 1;
      if (ce.wireframe === !0) {
        if (((Ze = k.getWireframeAttribute(le)), Ze === void 0)) return;
        yt = 2;
      }
      const gt = le.drawRange,
        at = le.attributes.position;
      let lt = gt.start * yt,
        pt = (gt.start + gt.count) * yt;
      Ae !== null &&
        ((lt = Math.max(lt, Ae.start * yt)),
        (pt = Math.min(pt, (Ae.start + Ae.count) * yt))),
        Ze !== null
          ? ((lt = Math.max(lt, 0)), (pt = Math.min(pt, Ze.count)))
          : at != null &&
            ((lt = Math.max(lt, 0)), (pt = Math.min(pt, at.count)));
      const en = pt - lt;
      if (en < 0 || en === 1 / 0) return;
      He.setup(te, ce, nt, le, Ze);
      let Lt,
        Ot = je;
      if (
        (Ze !== null && ((Lt = B.get(Ze)), (Ot = vt), Ot.setIndex(Lt)),
        te.isMesh)
      )
        ce.wireframe === !0
          ? (me.setLineWidth(ce.wireframeLinewidth * Ve()), Ot.setMode(W.LINES))
          : Ot.setMode(W.TRIANGLES);
      else if (te.isLine) {
        let ut = ce.linewidth;
        ut === void 0 && (ut = 1),
          me.setLineWidth(ut * Ve()),
          te.isLineSegments
            ? Ot.setMode(W.LINES)
            : te.isLineLoop
            ? Ot.setMode(W.LINE_LOOP)
            : Ot.setMode(W.LINE_STRIP);
      } else
        te.isPoints
          ? Ot.setMode(W.POINTS)
          : te.isSprite && Ot.setMode(W.TRIANGLES);
      if (te.isBatchedMesh)
        if (te._multiDrawInstances !== null)
          Dd(
            "THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."
          ),
            Ot.renderMultiDrawInstances(
              te._multiDrawStarts,
              te._multiDrawCounts,
              te._multiDrawCount,
              te._multiDrawInstances
            );
        else if (pe.get("WEBGL_multi_draw"))
          Ot.renderMultiDraw(
            te._multiDrawStarts,
            te._multiDrawCounts,
            te._multiDrawCount
          );
        else {
          const ut = te._multiDrawStarts,
            tn = te._multiDrawCounts,
            Mt = te._multiDrawCount,
            tr = Ze ? B.get(Ze).bytesPerElement : 1,
            bo = Te.get(ce).currentProgram.getUniforms();
          for (let xr = 0; xr < Mt; xr++)
            bo.setValue(W, "_gl_DrawID", xr), Ot.render(ut[xr] / tr, tn[xr]);
        }
      else if (te.isInstancedMesh) Ot.renderInstances(lt, en, te.count);
      else if (le.isInstancedBufferGeometry) {
        const ut =
            le._maxInstanceCount !== void 0 ? le._maxInstanceCount : 1 / 0,
          tn = Math.min(le.instanceCount, ut);
        Ot.renderInstances(lt, en, tn);
      } else Ot.render(lt, en);
    };
    function mt(F, ee, le) {
      F.transparent === !0 && F.side === io && F.forceSinglePass === !1
        ? ((F.side = Jr),
          (F.needsUpdate = !0),
          iu(F, ee, le),
          (F.side = ra),
          (F.needsUpdate = !0),
          iu(F, ee, le),
          (F.side = io))
        : iu(F, ee, le);
    }
    (this.compile = function (F, ee, le = null) {
      le === null && (le = F),
        (g = ot.get(le)),
        g.init(ee),
        S.push(g),
        le.traverseVisible(function (te) {
          te.isLight &&
            te.layers.test(ee.layers) &&
            (g.pushLight(te), te.castShadow && g.pushShadow(te));
        }),
        F !== le &&
          F.traverseVisible(function (te) {
            te.isLight &&
              te.layers.test(ee.layers) &&
              (g.pushLight(te), te.castShadow && g.pushShadow(te));
          }),
        g.setupLights();
      const ce = new Set();
      return (
        F.traverse(function (te) {
          if (!(te.isMesh || te.isPoints || te.isLine || te.isSprite)) return;
          const Ae = te.material;
          if (Ae)
            if (Array.isArray(Ae))
              for (let We = 0; We < Ae.length; We++) {
                const nt = Ae[We];
                mt(nt, le, te), ce.add(nt);
              }
            else mt(Ae, le, te), ce.add(Ae);
        }),
        (g = S.pop()),
        ce
      );
    }),
      (this.compileAsync = function (F, ee, le = null) {
        const ce = this.compile(F, ee, le);
        return new Promise((te) => {
          function Ae() {
            if (
              (ce.forEach(function (We) {
                Te.get(We).currentProgram.isReady() && ce.delete(We);
              }),
              ce.size === 0)
            ) {
              te(F);
              return;
            }
            setTimeout(Ae, 10);
          }
          pe.get("KHR_parallel_shader_compile") !== null
            ? Ae()
            : setTimeout(Ae, 10);
        });
      });
    let At = null;
    function mn(F) {
      At && At(F);
    }
    function On() {
      Dn.stop();
    }
    function Fi() {
      Dn.start();
    }
    const Dn = new nj();
    Dn.setAnimationLoop(mn),
      typeof self < "u" && Dn.setContext(self),
      (this.setAnimationLoop = function (F) {
        (At = F), Re.setAnimationLoop(F), F === null ? Dn.stop() : Dn.start();
      }),
      Re.addEventListener("sessionstart", On),
      Re.addEventListener("sessionend", Fi),
      (this.render = function (F, ee) {
        if (ee !== void 0 && ee.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (C === !0) return;
        if (
          (F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(),
          ee.parent === null &&
            ee.matrixWorldAutoUpdate === !0 &&
            ee.updateMatrixWorld(),
          Re.enabled === !0 &&
            Re.isPresenting === !0 &&
            (Re.cameraAutoUpdate === !0 && Re.updateCamera(ee),
            (ee = Re.getCamera())),
          F.isScene === !0 && F.onBeforeRender(b, F, ee, O),
          (g = ot.get(F, S.length)),
          g.init(ee),
          S.push(g),
          re.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse),
          Ie.setFromProjectionMatrix(re, Pi, ee.reversedDepth),
          (_e = this.localClippingEnabled),
          (se = Ne.init(this.clippingPlanes, _e)),
          (x = he.get(F, _.length)),
          x.init(),
          _.push(x),
          Re.enabled === !0 && Re.isPresenting === !0)
        ) {
          const Ae = b.xr.getDepthSensingMesh();
          Ae !== null && Fr(Ae, ee, -1 / 0, b.sortObjects);
        }
        Fr(F, ee, 0, b.sortObjects),
          x.finish(),
          b.sortObjects === !0 && x.sort(H, X),
          (Ke =
            Re.enabled === !1 ||
            Re.isPresenting === !1 ||
            Re.hasDepthSensing() === !1),
          Ke && tt.addToRenderList(x, F),
          this.info.render.frame++,
          se === !0 && Ne.beginShadows();
        const le = g.state.shadowsArray;
        it.render(le, F, ee),
          se === !0 && Ne.endShadows(),
          this.info.autoReset === !0 && this.info.reset();
        const ce = x.opaque,
          te = x.transmissive;
        if ((g.setupLights(), ee.isArrayCamera)) {
          const Ae = ee.cameras;
          if (te.length > 0)
            for (let We = 0, nt = Ae.length; We < nt; We++) {
              const Ze = Ae[We];
              Dm(ce, te, F, Ze);
            }
          Ke && tt.render(F);
          for (let We = 0, nt = Ae.length; We < nt; We++) {
            const Ze = Ae[We];
            ru(x, F, Ze, Ze.viewport);
          }
        } else
          te.length > 0 && Dm(ce, te, F, ee), Ke && tt.render(F), ru(x, F, ee);
        O !== null &&
          R === 0 &&
          (De.updateMultisampleRenderTarget(O), De.updateRenderTargetMipmap(O)),
          F.isScene === !0 && F.onAfterRender(b, F, ee),
          He.resetDefaultState(),
          (I = -1),
          (N = null),
          S.pop(),
          S.length > 0
            ? ((g = S[S.length - 1]),
              se === !0 && Ne.setGlobalState(b.clippingPlanes, g.state.camera))
            : (g = null),
          _.pop(),
          _.length > 0 ? (x = _[_.length - 1]) : (x = null);
      });
    function Fr(F, ee, le, ce) {
      if (F.visible === !1) return;
      if (F.layers.test(ee.layers)) {
        if (F.isGroup) le = F.renderOrder;
        else if (F.isLOD) F.autoUpdate === !0 && F.update(ee);
        else if (F.isLight) g.pushLight(F), F.castShadow && g.pushShadow(F);
        else if (F.isSprite) {
          if (!F.frustumCulled || Ie.intersectsSprite(F)) {
            ce && Ue.setFromMatrixPosition(F.matrixWorld).applyMatrix4(re);
            const We = ne.update(F),
              nt = F.material;
            nt.visible && x.push(F, We, nt, le, Ue.z, null);
          }
        } else if (
          (F.isMesh || F.isLine || F.isPoints) &&
          (!F.frustumCulled || Ie.intersectsObject(F))
        ) {
          const We = ne.update(F),
            nt = F.material;
          if (
            (ce &&
              (F.boundingSphere !== void 0
                ? (F.boundingSphere === null && F.computeBoundingSphere(),
                  Ue.copy(F.boundingSphere.center))
                : (We.boundingSphere === null && We.computeBoundingSphere(),
                  Ue.copy(We.boundingSphere.center)),
              Ue.applyMatrix4(F.matrixWorld).applyMatrix4(re)),
            Array.isArray(nt))
          ) {
            const Ze = We.groups;
            for (let yt = 0, gt = Ze.length; yt < gt; yt++) {
              const at = Ze[yt],
                lt = nt[at.materialIndex];
              lt && lt.visible && x.push(F, We, lt, le, Ue.z, at);
            }
          } else nt.visible && x.push(F, We, nt, le, Ue.z, null);
        }
      }
      const Ae = F.children;
      for (let We = 0, nt = Ae.length; We < nt; We++) Fr(Ae[We], ee, le, ce);
    }
    function ru(F, ee, le, ce) {
      const te = F.opaque,
        Ae = F.transmissive,
        We = F.transparent;
      g.setupLightsView(le),
        se === !0 && Ne.setGlobalState(b.clippingPlanes, le),
        ce && me.viewport(D.copy(ce)),
        te.length > 0 && Vs(te, ee, le),
        Ae.length > 0 && Vs(Ae, ee, le),
        We.length > 0 && Vs(We, ee, le),
        me.buffers.depth.setTest(!0),
        me.buffers.depth.setMask(!0),
        me.buffers.color.setMask(!0),
        me.setPolygonOffset(!1);
    }
    function Dm(F, ee, le, ce) {
      if ((le.isScene === !0 ? le.overrideMaterial : null) !== null) return;
      g.state.transmissionRenderTarget[ce.id] === void 0 &&
        (g.state.transmissionRenderTarget[ce.id] = new xo(1, 1, {
          generateMipmaps: !0,
          type:
            pe.has("EXT_color_buffer_half_float") ||
            pe.has("EXT_color_buffer_float")
              ? Ih
              : ls,
          minFilter: oo,
          samples: 4,
          stencilBuffer: s,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1,
          colorSpace: Ht.workingColorSpace,
        }));
      const Ae = g.state.transmissionRenderTarget[ce.id],
        We = ce.viewport || D;
      Ae.setSize(
        We.z * b.transmissionResolutionScale,
        We.w * b.transmissionResolutionScale
      );
      const nt = b.getRenderTarget(),
        Ze = b.getActiveCubeFace(),
        yt = b.getActiveMipmapLevel();
      b.setRenderTarget(Ae),
        b.getClearColor(G),
        (Z = b.getClearAlpha()),
        Z < 1 && b.setClearColor(16777215, 0.5),
        b.clear(),
        Ke && tt.render(le);
      const gt = b.toneMapping;
      b.toneMapping = go;
      const at = ce.viewport;
      if (
        (ce.viewport !== void 0 && (ce.viewport = void 0),
        g.setupLightsView(ce),
        se === !0 && Ne.setGlobalState(b.clippingPlanes, ce),
        Vs(F, le, ce),
        De.updateMultisampleRenderTarget(Ae),
        De.updateRenderTargetMipmap(Ae),
        pe.has("WEBGL_multisampled_render_to_texture") === !1)
      ) {
        let lt = !1;
        for (let pt = 0, en = ee.length; pt < en; pt++) {
          const Lt = ee[pt],
            Ot = Lt.object,
            ut = Lt.geometry,
            tn = Lt.material,
            Mt = Lt.group;
          if (tn.side === io && Ot.layers.test(ce.layers)) {
            const tr = tn.side;
            (tn.side = Jr),
              (tn.needsUpdate = !0),
              km(Ot, le, ce, ut, tn, Mt),
              (tn.side = tr),
              (tn.needsUpdate = !0),
              (lt = !0);
          }
        }
        lt === !0 &&
          (De.updateMultisampleRenderTarget(Ae),
          De.updateRenderTargetMipmap(Ae));
      }
      b.setRenderTarget(nt, Ze, yt),
        b.setClearColor(G, Z),
        at !== void 0 && (ce.viewport = at),
        (b.toneMapping = gt);
    }
    function Vs(F, ee, le) {
      const ce = ee.isScene === !0 ? ee.overrideMaterial : null;
      for (let te = 0, Ae = F.length; te < Ae; te++) {
        const We = F[te],
          nt = We.object,
          Ze = We.geometry,
          yt = We.group;
        let gt = We.material;
        gt.allowOverride === !0 && ce !== null && (gt = ce),
          nt.layers.test(le.layers) && km(nt, ee, le, Ze, gt, yt);
      }
    }
    function km(F, ee, le, ce, te, Ae) {
      F.onBeforeRender(b, ee, le, ce, te, Ae),
        F.modelViewMatrix.multiplyMatrices(
          le.matrixWorldInverse,
          F.matrixWorld
        ),
        F.normalMatrix.getNormalMatrix(F.modelViewMatrix),
        te.onBeforeRender(b, ee, le, ce, F, Ae),
        te.transparent === !0 && te.side === io && te.forceSinglePass === !1
          ? ((te.side = Jr),
            (te.needsUpdate = !0),
            b.renderBufferDirect(le, ee, ce, te, F, Ae),
            (te.side = ra),
            (te.needsUpdate = !0),
            b.renderBufferDirect(le, ee, ce, te, F, Ae),
            (te.side = io))
          : b.renderBufferDirect(le, ee, ce, te, F, Ae),
        F.onAfterRender(b, ee, le, ce, te, Ae);
    }
    function iu(F, ee, le) {
      ee.isScene !== !0 && (ee = Fe);
      const ce = Te.get(F),
        te = g.state.lights,
        Ae = g.state.shadowsArray,
        We = te.state.version,
        nt = ae.getParameters(F, te.state, Ae, ee, le),
        Ze = ae.getProgramCacheKey(nt);
      let yt = ce.programs;
      (ce.environment = F.isMeshStandardMaterial ? ee.environment : null),
        (ce.fog = ee.fog),
        (ce.envMap = (F.isMeshStandardMaterial ? wt : _t).get(
          F.envMap || ce.environment
        )),
        (ce.envMapRotation =
          ce.environment !== null && F.envMap === null
            ? ee.environmentRotation
            : F.envMapRotation),
        yt === void 0 &&
          (F.addEventListener("dispose", ye),
          (yt = new Map()),
          (ce.programs = yt));
      let gt = yt.get(Ze);
      if (gt !== void 0) {
        if (ce.currentProgram === gt && ce.lightsStateVersion === We)
          return Fm(F, nt), gt;
      } else
        (nt.uniforms = ae.getUniforms(F)),
          F.onBeforeCompile(nt, b),
          (gt = ae.acquireProgram(nt, Ze)),
          yt.set(Ze, gt),
          (ce.uniforms = nt.uniforms);
      const at = ce.uniforms;
      return (
        ((!F.isShaderMaterial && !F.isRawShaderMaterial) ||
          F.clipping === !0) &&
          (at.clippingPlanes = Ne.uniform),
        Fm(F, nt),
        (ce.needsLights = P_(F)),
        (ce.lightsStateVersion = We),
        ce.needsLights &&
          ((at.ambientLightColor.value = te.state.ambient),
          (at.lightProbe.value = te.state.probe),
          (at.directionalLights.value = te.state.directional),
          (at.directionalLightShadows.value = te.state.directionalShadow),
          (at.spotLights.value = te.state.spot),
          (at.spotLightShadows.value = te.state.spotShadow),
          (at.rectAreaLights.value = te.state.rectArea),
          (at.ltc_1.value = te.state.rectAreaLTC1),
          (at.ltc_2.value = te.state.rectAreaLTC2),
          (at.pointLights.value = te.state.point),
          (at.pointLightShadows.value = te.state.pointShadow),
          (at.hemisphereLights.value = te.state.hemi),
          (at.directionalShadowMap.value = te.state.directionalShadowMap),
          (at.directionalShadowMatrix.value = te.state.directionalShadowMatrix),
          (at.spotShadowMap.value = te.state.spotShadowMap),
          (at.spotLightMatrix.value = te.state.spotLightMatrix),
          (at.spotLightMap.value = te.state.spotLightMap),
          (at.pointShadowMap.value = te.state.pointShadowMap),
          (at.pointShadowMatrix.value = te.state.pointShadowMatrix)),
        (ce.currentProgram = gt),
        (ce.uniformsList = null),
        gt
      );
    }
    function Um(F) {
      if (F.uniformsList === null) {
        const ee = F.currentProgram.getUniforms();
        F.uniformsList = Ny.seqWithValue(ee.seq, F.uniforms);
      }
      return F.uniformsList;
    }
    function Fm(F, ee) {
      const le = Te.get(F);
      (le.outputColorSpace = ee.outputColorSpace),
        (le.batching = ee.batching),
        (le.batchingColor = ee.batchingColor),
        (le.instancing = ee.instancing),
        (le.instancingColor = ee.instancingColor),
        (le.instancingMorph = ee.instancingMorph),
        (le.skinning = ee.skinning),
        (le.morphTargets = ee.morphTargets),
        (le.morphNormals = ee.morphNormals),
        (le.morphColors = ee.morphColors),
        (le.morphTargetsCount = ee.morphTargetsCount),
        (le.numClippingPlanes = ee.numClippingPlanes),
        (le.numIntersection = ee.numClipIntersection),
        (le.vertexAlphas = ee.vertexAlphas),
        (le.vertexTangents = ee.vertexTangents),
        (le.toneMapping = ee.toneMapping);
    }
    function A_(F, ee, le, ce, te) {
      ee.isScene !== !0 && (ee = Fe), De.resetTextureUnits();
      const Ae = ee.fog,
        We = ce.isMeshStandardMaterial ? ee.environment : null,
        nt =
          O === null
            ? b.outputColorSpace
            : O.isXRRenderTarget === !0
            ? O.texture.colorSpace
            : Vc,
        Ze = (ce.isMeshStandardMaterial ? wt : _t).get(ce.envMap || We),
        yt =
          ce.vertexColors === !0 &&
          !!le.attributes.color &&
          le.attributes.color.itemSize === 4,
        gt = !!le.attributes.tangent && (!!ce.normalMap || ce.anisotropy > 0),
        at = !!le.morphAttributes.position,
        lt = !!le.morphAttributes.normal,
        pt = !!le.morphAttributes.color;
      let en = go;
      ce.toneMapped &&
        (O === null || O.isXRRenderTarget === !0) &&
        (en = b.toneMapping);
      const Lt =
          le.morphAttributes.position ||
          le.morphAttributes.normal ||
          le.morphAttributes.color,
        Ot = Lt !== void 0 ? Lt.length : 0,
        ut = Te.get(ce),
        tn = g.state.lights;
      if (se === !0 && (_e === !0 || F !== N)) {
        const ur = F === N && ce.id === I;
        Ne.setState(ce, F, ur);
      }
      let Mt = !1;
      ce.version === ut.__version
        ? ((ut.needsLights && ut.lightsStateVersion !== tn.state.version) ||
            ut.outputColorSpace !== nt ||
            (te.isBatchedMesh && ut.batching === !1) ||
            (!te.isBatchedMesh && ut.batching === !0) ||
            (te.isBatchedMesh &&
              ut.batchingColor === !0 &&
              te.colorTexture === null) ||
            (te.isBatchedMesh &&
              ut.batchingColor === !1 &&
              te.colorTexture !== null) ||
            (te.isInstancedMesh && ut.instancing === !1) ||
            (!te.isInstancedMesh && ut.instancing === !0) ||
            (te.isSkinnedMesh && ut.skinning === !1) ||
            (!te.isSkinnedMesh && ut.skinning === !0) ||
            (te.isInstancedMesh &&
              ut.instancingColor === !0 &&
              te.instanceColor === null) ||
            (te.isInstancedMesh &&
              ut.instancingColor === !1 &&
              te.instanceColor !== null) ||
            (te.isInstancedMesh &&
              ut.instancingMorph === !0 &&
              te.morphTexture === null) ||
            (te.isInstancedMesh &&
              ut.instancingMorph === !1 &&
              te.morphTexture !== null) ||
            ut.envMap !== Ze ||
            (ce.fog === !0 && ut.fog !== Ae) ||
            (ut.numClippingPlanes !== void 0 &&
              (ut.numClippingPlanes !== Ne.numPlanes ||
                ut.numIntersection !== Ne.numIntersection)) ||
            ut.vertexAlphas !== yt ||
            ut.vertexTangents !== gt ||
            ut.morphTargets !== at ||
            ut.morphNormals !== lt ||
            ut.morphColors !== pt ||
            ut.toneMapping !== en ||
            ut.morphTargetsCount !== Ot) &&
          (Mt = !0)
        : ((Mt = !0), (ut.__version = ce.version));
      let tr = ut.currentProgram;
      Mt === !0 && (tr = iu(ce, ee, te));
      let bo = !1,
        xr = !1,
        js = !1;
      const an = tr.getUniforms(),
        gn = ut.uniforms;
      if (
        (me.useProgram(tr.program) && ((bo = !0), (xr = !0), (js = !0)),
        ce.id !== I && ((I = ce.id), (xr = !0)),
        bo || N !== F)
      ) {
        me.buffers.depth.getReversed() &&
          F.reversedDepth !== !0 &&
          ((F._reversedDepth = !0), F.updateProjectionMatrix()),
          an.setValue(W, "projectionMatrix", F.projectionMatrix),
          an.setValue(W, "viewMatrix", F.matrixWorldInverse);
        const _r = an.map.cameraPosition;
        _r !== void 0 &&
          _r.setValue(W, Be.setFromMatrixPosition(F.matrixWorld)),
          Se.logarithmicDepthBuffer &&
            an.setValue(
              W,
              "logDepthBufFC",
              2 / (Math.log(F.far + 1) / Math.LN2)
            ),
          (ce.isMeshPhongMaterial ||
            ce.isMeshToonMaterial ||
            ce.isMeshLambertMaterial ||
            ce.isMeshBasicMaterial ||
            ce.isMeshStandardMaterial ||
            ce.isShaderMaterial) &&
            an.setValue(W, "isOrthographic", F.isOrthographicCamera === !0),
          N !== F && ((N = F), (xr = !0), (js = !0));
      }
      if (te.isSkinnedMesh) {
        an.setOptional(W, te, "bindMatrix"),
          an.setOptional(W, te, "bindMatrixInverse");
        const ur = te.skeleton;
        ur &&
          (ur.boneTexture === null && ur.computeBoneTexture(),
          an.setValue(W, "boneTexture", ur.boneTexture, De));
      }
      te.isBatchedMesh &&
        (an.setOptional(W, te, "batchingTexture"),
        an.setValue(W, "batchingTexture", te._matricesTexture, De),
        an.setOptional(W, te, "batchingIdTexture"),
        an.setValue(W, "batchingIdTexture", te._indirectTexture, De),
        an.setOptional(W, te, "batchingColorTexture"),
        te._colorsTexture !== null &&
          an.setValue(W, "batchingColorTexture", te._colorsTexture, De));
      const ti = le.morphAttributes;
      if (
        ((ti.position !== void 0 ||
          ti.normal !== void 0 ||
          ti.color !== void 0) &&
          Ce.update(te, le, tr),
        (xr || ut.receiveShadow !== te.receiveShadow) &&
          ((ut.receiveShadow = te.receiveShadow),
          an.setValue(W, "receiveShadow", te.receiveShadow)),
        ce.isMeshGouraudMaterial &&
          ce.envMap !== null &&
          ((gn.envMap.value = Ze),
          (gn.flipEnvMap.value =
            Ze.isCubeTexture && Ze.isRenderTargetTexture === !1 ? -1 : 1)),
        ce.isMeshStandardMaterial &&
          ce.envMap === null &&
          ee.environment !== null &&
          (gn.envMapIntensity.value = ee.environmentIntensity),
        xr &&
          (an.setValue(W, "toneMappingExposure", b.toneMappingExposure),
          ut.needsLights && R_(gn, js),
          Ae && ce.fog === !0 && we.refreshFogUniforms(gn, Ae),
          we.refreshMaterialUniforms(
            gn,
            ce,
            U,
            Y,
            g.state.transmissionRenderTarget[F.id]
          ),
          Ny.upload(W, Um(ut), gn, De)),
        ce.isShaderMaterial &&
          ce.uniformsNeedUpdate === !0 &&
          (Ny.upload(W, Um(ut), gn, De), (ce.uniformsNeedUpdate = !1)),
        ce.isSpriteMaterial && an.setValue(W, "center", te.center),
        an.setValue(W, "modelViewMatrix", te.modelViewMatrix),
        an.setValue(W, "normalMatrix", te.normalMatrix),
        an.setValue(W, "modelMatrix", te.matrixWorld),
        ce.isShaderMaterial || ce.isRawShaderMaterial)
      ) {
        const ur = ce.uniformsGroups;
        for (let _r = 0, ca = ur.length; _r < ca; _r++) {
          const Bi = ur[_r];
          Ct.update(Bi, tr), Ct.bind(Bi, tr);
        }
      }
      return tr;
    }
    function R_(F, ee) {
      (F.ambientLightColor.needsUpdate = ee),
        (F.lightProbe.needsUpdate = ee),
        (F.directionalLights.needsUpdate = ee),
        (F.directionalLightShadows.needsUpdate = ee),
        (F.pointLights.needsUpdate = ee),
        (F.pointLightShadows.needsUpdate = ee),
        (F.spotLights.needsUpdate = ee),
        (F.spotLightShadows.needsUpdate = ee),
        (F.rectAreaLights.needsUpdate = ee),
        (F.hemisphereLights.needsUpdate = ee);
    }
    function P_(F) {
      return (
        F.isMeshLambertMaterial ||
        F.isMeshToonMaterial ||
        F.isMeshPhongMaterial ||
        F.isMeshStandardMaterial ||
        F.isShadowMaterial ||
        (F.isShaderMaterial && F.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return A;
    }),
      (this.getActiveMipmapLevel = function () {
        return R;
      }),
      (this.getRenderTarget = function () {
        return O;
      }),
      (this.setRenderTargetTextures = function (F, ee, le) {
        const ce = Te.get(F);
        (ce.__autoAllocateDepthBuffer = F.resolveDepthBuffer === !1),
          ce.__autoAllocateDepthBuffer === !1 && (ce.__useRenderToTexture = !1),
          (Te.get(F.texture).__webglTexture = ee),
          (Te.get(F.depthTexture).__webglTexture = ce.__autoAllocateDepthBuffer
            ? void 0
            : le),
          (ce.__hasExternalTextures = !0);
      }),
      (this.setRenderTargetFramebuffer = function (F, ee) {
        const le = Te.get(F);
        (le.__webglFramebuffer = ee),
          (le.__useDefaultFramebuffer = ee === void 0);
      });
    const Bm = W.createFramebuffer();
    (this.setRenderTarget = function (F, ee = 0, le = 0) {
      (O = F), (A = ee), (R = le);
      let ce = !0,
        te = null,
        Ae = !1,
        We = !1;
      if (F) {
        const Ze = Te.get(F);
        if (Ze.__useDefaultFramebuffer !== void 0)
          me.bindFramebuffer(W.FRAMEBUFFER, null), (ce = !1);
        else if (Ze.__webglFramebuffer === void 0) De.setupRenderTarget(F);
        else if (Ze.__hasExternalTextures)
          De.rebindTextures(
            F,
            Te.get(F.texture).__webglTexture,
            Te.get(F.depthTexture).__webglTexture
          );
        else if (F.depthBuffer) {
          const at = F.depthTexture;
          if (Ze.__boundDepthTexture !== at) {
            if (
              at !== null &&
              Te.has(at) &&
              (F.width !== at.image.width || F.height !== at.image.height)
            )
              throw new Error(
                "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
              );
            De.setupDepthRenderbuffer(F);
          }
        }
        const yt = F.texture;
        (yt.isData3DTexture ||
          yt.isDataArrayTexture ||
          yt.isCompressedArrayTexture) &&
          (We = !0);
        const gt = Te.get(F).__webglFramebuffer;
        F.isWebGLCubeRenderTarget
          ? (Array.isArray(gt[ee]) ? (te = gt[ee][le]) : (te = gt[ee]),
            (Ae = !0))
          : F.samples > 0 && De.useMultisampledRTT(F) === !1
          ? (te = Te.get(F).__webglMultisampledFramebuffer)
          : Array.isArray(gt)
          ? (te = gt[le])
          : (te = gt),
          D.copy(F.viewport),
          j.copy(F.scissor),
          ($ = F.scissorTest);
      } else
        D.copy(ie).multiplyScalar(U).floor(),
          j.copy(de).multiplyScalar(U).floor(),
          ($ = Ee);
      if (
        (le !== 0 && (te = Bm),
        me.bindFramebuffer(W.FRAMEBUFFER, te) && ce && me.drawBuffers(F, te),
        me.viewport(D),
        me.scissor(j),
        me.setScissorTest($),
        Ae)
      ) {
        const Ze = Te.get(F.texture);
        W.framebufferTexture2D(
          W.FRAMEBUFFER,
          W.COLOR_ATTACHMENT0,
          W.TEXTURE_CUBE_MAP_POSITIVE_X + ee,
          Ze.__webglTexture,
          le
        );
      } else if (We) {
        const Ze = ee;
        for (let yt = 0; yt < F.textures.length; yt++) {
          const gt = Te.get(F.textures[yt]);
          W.framebufferTextureLayer(
            W.FRAMEBUFFER,
            W.COLOR_ATTACHMENT0 + yt,
            gt.__webglTexture,
            le,
            Ze
          );
        }
      } else if (F !== null && le !== 0) {
        const Ze = Te.get(F.texture);
        W.framebufferTexture2D(
          W.FRAMEBUFFER,
          W.COLOR_ATTACHMENT0,
          W.TEXTURE_2D,
          Ze.__webglTexture,
          le
        );
      }
      I = -1;
    }),
      (this.readRenderTargetPixels = function (
        F,
        ee,
        le,
        ce,
        te,
        Ae,
        We,
        nt = 0
      ) {
        if (!(F && F.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Ze = Te.get(F).__webglFramebuffer;
        if ((F.isWebGLCubeRenderTarget && We !== void 0 && (Ze = Ze[We]), Ze)) {
          me.bindFramebuffer(W.FRAMEBUFFER, Ze);
          try {
            const yt = F.textures[nt],
              gt = yt.format,
              at = yt.type;
            if (!Se.textureFormatReadable(gt)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            if (!Se.textureTypeReadable(at)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            ee >= 0 &&
              ee <= F.width - ce &&
              le >= 0 &&
              le <= F.height - te &&
              (F.textures.length > 1 && W.readBuffer(W.COLOR_ATTACHMENT0 + nt),
              W.readPixels(ee, le, ce, te, Qe.convert(gt), Qe.convert(at), Ae));
          } finally {
            const yt = O !== null ? Te.get(O).__webglFramebuffer : null;
            me.bindFramebuffer(W.FRAMEBUFFER, yt);
          }
        }
      }),
      (this.readRenderTargetPixelsAsync = async function (
        F,
        ee,
        le,
        ce,
        te,
        Ae,
        We,
        nt = 0
      ) {
        if (!(F && F.isWebGLRenderTarget))
          throw new Error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let Ze = Te.get(F).__webglFramebuffer;
        if ((F.isWebGLCubeRenderTarget && We !== void 0 && (Ze = Ze[We]), Ze))
          if (ee >= 0 && ee <= F.width - ce && le >= 0 && le <= F.height - te) {
            me.bindFramebuffer(W.FRAMEBUFFER, Ze);
            const yt = F.textures[nt],
              gt = yt.format,
              at = yt.type;
            if (!Se.textureFormatReadable(gt))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
              );
            if (!Se.textureTypeReadable(at))
              throw new Error(
                "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            const lt = W.createBuffer();
            W.bindBuffer(W.PIXEL_PACK_BUFFER, lt),
              W.bufferData(W.PIXEL_PACK_BUFFER, Ae.byteLength, W.STREAM_READ),
              F.textures.length > 1 && W.readBuffer(W.COLOR_ATTACHMENT0 + nt),
              W.readPixels(ee, le, ce, te, Qe.convert(gt), Qe.convert(at), 0);
            const pt = O !== null ? Te.get(O).__webglFramebuffer : null;
            me.bindFramebuffer(W.FRAMEBUFFER, pt);
            const en = W.fenceSync(W.SYNC_GPU_COMMANDS_COMPLETE, 0);
            return (
              W.flush(),
              await jne(W, en, 4),
              W.bindBuffer(W.PIXEL_PACK_BUFFER, lt),
              W.getBufferSubData(W.PIXEL_PACK_BUFFER, 0, Ae),
              W.deleteBuffer(lt),
              W.deleteSync(en),
              Ae
            );
          } else
            throw new Error(
              "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
            );
      }),
      (this.copyFramebufferToTexture = function (F, ee = null, le = 0) {
        const ce = Math.pow(2, -le),
          te = Math.floor(F.image.width * ce),
          Ae = Math.floor(F.image.height * ce),
          We = ee !== null ? ee.x : 0,
          nt = ee !== null ? ee.y : 0;
        De.setTexture2D(F, 0),
          W.copyTexSubImage2D(W.TEXTURE_2D, le, 0, 0, We, nt, te, Ae),
          me.unbindTexture();
      });
    const I_ = W.createFramebuffer(),
      N_ = W.createFramebuffer();
    (this.copyTextureToTexture = function (
      F,
      ee,
      le = null,
      ce = null,
      te = 0,
      Ae = null
    ) {
      Ae === null &&
        (te !== 0
          ? (Dd(
              "WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."
            ),
            (Ae = te),
            (te = 0))
          : (Ae = 0));
      let We, nt, Ze, yt, gt, at, lt, pt, en;
      const Lt = F.isCompressedTexture ? F.mipmaps[Ae] : F.image;
      if (le !== null)
        (We = le.max.x - le.min.x),
          (nt = le.max.y - le.min.y),
          (Ze = le.isBox3 ? le.max.z - le.min.z : 1),
          (yt = le.min.x),
          (gt = le.min.y),
          (at = le.isBox3 ? le.min.z : 0);
      else {
        const ti = Math.pow(2, -te);
        (We = Math.floor(Lt.width * ti)),
          (nt = Math.floor(Lt.height * ti)),
          F.isDataArrayTexture
            ? (Ze = Lt.depth)
            : F.isData3DTexture
            ? (Ze = Math.floor(Lt.depth * ti))
            : (Ze = 1),
          (yt = 0),
          (gt = 0),
          (at = 0);
      }
      ce !== null
        ? ((lt = ce.x), (pt = ce.y), (en = ce.z))
        : ((lt = 0), (pt = 0), (en = 0));
      const Ot = Qe.convert(ee.format),
        ut = Qe.convert(ee.type);
      let tn;
      ee.isData3DTexture
        ? (De.setTexture3D(ee, 0), (tn = W.TEXTURE_3D))
        : ee.isDataArrayTexture || ee.isCompressedArrayTexture
        ? (De.setTexture2DArray(ee, 0), (tn = W.TEXTURE_2D_ARRAY))
        : (De.setTexture2D(ee, 0), (tn = W.TEXTURE_2D)),
        W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, ee.flipY),
        W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ee.premultiplyAlpha),
        W.pixelStorei(W.UNPACK_ALIGNMENT, ee.unpackAlignment);
      const Mt = W.getParameter(W.UNPACK_ROW_LENGTH),
        tr = W.getParameter(W.UNPACK_IMAGE_HEIGHT),
        bo = W.getParameter(W.UNPACK_SKIP_PIXELS),
        xr = W.getParameter(W.UNPACK_SKIP_ROWS),
        js = W.getParameter(W.UNPACK_SKIP_IMAGES);
      W.pixelStorei(W.UNPACK_ROW_LENGTH, Lt.width),
        W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, Lt.height),
        W.pixelStorei(W.UNPACK_SKIP_PIXELS, yt),
        W.pixelStorei(W.UNPACK_SKIP_ROWS, gt),
        W.pixelStorei(W.UNPACK_SKIP_IMAGES, at);
      const an = F.isDataArrayTexture || F.isData3DTexture,
        gn = ee.isDataArrayTexture || ee.isData3DTexture;
      if (F.isDepthTexture) {
        const ti = Te.get(F),
          ur = Te.get(ee),
          _r = Te.get(ti.__renderTarget),
          ca = Te.get(ur.__renderTarget);
        me.bindFramebuffer(W.READ_FRAMEBUFFER, _r.__webglFramebuffer),
          me.bindFramebuffer(W.DRAW_FRAMEBUFFER, ca.__webglFramebuffer);
        for (let Bi = 0; Bi < Ze; Bi++)
          an &&
            (W.framebufferTextureLayer(
              W.READ_FRAMEBUFFER,
              W.COLOR_ATTACHMENT0,
              Te.get(F).__webglTexture,
              te,
              at + Bi
            ),
            W.framebufferTextureLayer(
              W.DRAW_FRAMEBUFFER,
              W.COLOR_ATTACHMENT0,
              Te.get(ee).__webglTexture,
              Ae,
              en + Bi
            )),
            W.blitFramebuffer(
              yt,
              gt,
              We,
              nt,
              lt,
              pt,
              We,
              nt,
              W.DEPTH_BUFFER_BIT,
              W.NEAREST
            );
        me.bindFramebuffer(W.READ_FRAMEBUFFER, null),
          me.bindFramebuffer(W.DRAW_FRAMEBUFFER, null);
      } else if (te !== 0 || F.isRenderTargetTexture || Te.has(F)) {
        const ti = Te.get(F),
          ur = Te.get(ee);
        me.bindFramebuffer(W.READ_FRAMEBUFFER, I_),
          me.bindFramebuffer(W.DRAW_FRAMEBUFFER, N_);
        for (let _r = 0; _r < Ze; _r++)
          an
            ? W.framebufferTextureLayer(
                W.READ_FRAMEBUFFER,
                W.COLOR_ATTACHMENT0,
                ti.__webglTexture,
                te,
                at + _r
              )
            : W.framebufferTexture2D(
                W.READ_FRAMEBUFFER,
                W.COLOR_ATTACHMENT0,
                W.TEXTURE_2D,
                ti.__webglTexture,
                te
              ),
            gn
              ? W.framebufferTextureLayer(
                  W.DRAW_FRAMEBUFFER,
                  W.COLOR_ATTACHMENT0,
                  ur.__webglTexture,
                  Ae,
                  en + _r
                )
              : W.framebufferTexture2D(
                  W.DRAW_FRAMEBUFFER,
                  W.COLOR_ATTACHMENT0,
                  W.TEXTURE_2D,
                  ur.__webglTexture,
                  Ae
                ),
            te !== 0
              ? W.blitFramebuffer(
                  yt,
                  gt,
                  We,
                  nt,
                  lt,
                  pt,
                  We,
                  nt,
                  W.COLOR_BUFFER_BIT,
                  W.NEAREST
                )
              : gn
              ? W.copyTexSubImage3D(tn, Ae, lt, pt, en + _r, yt, gt, We, nt)
              : W.copyTexSubImage2D(tn, Ae, lt, pt, yt, gt, We, nt);
        me.bindFramebuffer(W.READ_FRAMEBUFFER, null),
          me.bindFramebuffer(W.DRAW_FRAMEBUFFER, null);
      } else
        gn
          ? F.isDataTexture || F.isData3DTexture
            ? W.texSubImage3D(tn, Ae, lt, pt, en, We, nt, Ze, Ot, ut, Lt.data)
            : ee.isCompressedArrayTexture
            ? W.compressedTexSubImage3D(
                tn,
                Ae,
                lt,
                pt,
                en,
                We,
                nt,
                Ze,
                Ot,
                Lt.data
              )
            : W.texSubImage3D(tn, Ae, lt, pt, en, We, nt, Ze, Ot, ut, Lt)
          : F.isDataTexture
          ? W.texSubImage2D(W.TEXTURE_2D, Ae, lt, pt, We, nt, Ot, ut, Lt.data)
          : F.isCompressedTexture
          ? W.compressedTexSubImage2D(
              W.TEXTURE_2D,
              Ae,
              lt,
              pt,
              Lt.width,
              Lt.height,
              Ot,
              Lt.data
            )
          : W.texSubImage2D(W.TEXTURE_2D, Ae, lt, pt, We, nt, Ot, ut, Lt);
      W.pixelStorei(W.UNPACK_ROW_LENGTH, Mt),
        W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, tr),
        W.pixelStorei(W.UNPACK_SKIP_PIXELS, bo),
        W.pixelStorei(W.UNPACK_SKIP_ROWS, xr),
        W.pixelStorei(W.UNPACK_SKIP_IMAGES, js),
        Ae === 0 && ee.generateMipmaps && W.generateMipmap(tn),
        me.unbindTexture();
    }),
      (this.copyTextureToTexture3D = function (
        F,
        ee,
        le = null,
        ce = null,
        te = 0
      ) {
        return (
          Dd(
            'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
          ),
          this.copyTextureToTexture(F, ee, le, ce, te)
        );
      }),
      (this.initRenderTarget = function (F) {
        Te.get(F).__webglFramebuffer === void 0 && De.setupRenderTarget(F);
      }),
      (this.initTexture = function (F) {
        F.isCubeTexture
          ? De.setTextureCube(F, 0)
          : F.isData3DTexture
          ? De.setTexture3D(F, 0)
          : F.isDataArrayTexture || F.isCompressedArrayTexture
          ? De.setTexture2DArray(F, 0)
          : De.setTexture2D(F, 0),
          me.unbindTexture();
      }),
      (this.resetState = function () {
        (A = 0), (R = 0), (O = null), me.reset(), He.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Pi;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    (t.drawingBufferColorSpace = Ht._getDrawingBufferColorSpace(e)),
      (t.unpackColorSpace = Ht._getUnpackColorSpace());
  }
}
const sue = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: EC,
      AddEquation: Va,
      AddOperation: P4,
      AdditiveAnimationBlendMode: LC,
      AdditiveBlending: BE,
      AgXToneMapping: D4,
      AlphaFormat: RC,
      AlwaysCompare: Y4,
      AlwaysDepth: T0,
      AlwaysStencilFunc: HE,
      AmbientLight: WV,
      AnimationAction: QV,
      AnimationClip: sm,
      AnimationLoader: mie,
      AnimationMixer: Wie,
      AnimationObjectGroup: jie,
      AnimationUtils: die,
      ArcCurve: mV,
      ArrayCamera: YV,
      ArrowHelper: gse,
      AttachedBindMode: jE,
      Audio: JV,
      AudioAnalyser: Nie,
      AudioContext: iA,
      AudioListener: Rie,
      AudioLoader: Mie,
      AxesHelper: vse,
      BackSide: Jr,
      BasicDepthPacking: V4,
      BasicShadowMap: h4,
      BatchedMesh: uV,
      Bone: VC,
      BooleanKeyframeTrack: eu,
      Box2: ese,
      Box3: Dr,
      Box3Helper: pse,
      BoxGeometry: Qc,
      BoxHelper: fse,
      BufferAttribute: sn,
      BufferGeometry: kt,
      BufferGeometryLoader: KV,
      ByteType: MC,
      Cache: ao,
      Camera: Tm,
      CameraHelper: hse,
      CanvasTexture: Ore,
      CapsuleGeometry: u_,
      CatmullRomCurve3: gV,
      CineonToneMapping: L4,
      CircleGeometry: d_,
      ClampToEdgeWrapping: rs,
      Clock: sA,
      Color: Je,
      ColorKeyframeTrack: tA,
      ColorManagement: Ht,
      CompressedArrayTexture: Nre,
      CompressedCubeTexture: Lre,
      CompressedTexture: c_,
      CompressedTextureLoader: gie,
      ConeGeometry: Am,
      ConstantAlphaFactor: C4,
      ConstantColorFactor: T4,
      Controls: xse,
      CubeCamera: rV,
      CubeReflectionMapping: ia,
      CubeRefractionMapping: fl,
      CubeTexture: Mm,
      CubeTextureLoader: vie,
      CubeUVReflectionMapping: Ph,
      CubicBezierCurve: GC,
      CubicBezierCurve3: vV,
      CubicInterpolant: kV,
      CullFaceBack: FE,
      CullFaceFront: d4,
      CullFaceFrontBack: Vte,
      CullFaceNone: u4,
      Curve: zs,
      CurvePath: xV,
      CustomBlending: SC,
      CustomToneMapping: O4,
      CylinderGeometry: Cm,
      Cylindrical: Qie,
      Data3DTexture: r_,
      DataArrayTexture: n_,
      DataTexture: vo,
      DataTextureLoader: yie,
      DataUtils: rre,
      DecrementStencilOp: tne,
      DecrementWrapStencilOp: rne,
      DefaultLoadingManager: BV,
      DepthFormat: ah,
      DepthStencilFormat: lh,
      DepthTexture: HC,
      DetachedBindMode: U4,
      DirectionalLight: HV,
      DirectionalLightHelper: dse,
      DiscreteInterpolant: UV,
      DodecahedronGeometry: h_,
      DoubleSide: io,
      DstAlphaFactor: _4,
      DstColorFactor: S4,
      DynamicCopyUsage: yne,
      DynamicDrawUsage: hne,
      DynamicReadUsage: mne,
      EdgesGeometry: pV,
      EllipseCurve: f_,
      EqualCompare: $4,
      EqualDepth: C0,
      EqualStencilFunc: ane,
      EquirectangularReflectionMapping: Gp,
      EquirectangularRefractionMapping: $p,
      Euler: Di,
      EventDispatcher: wo,
      ExtrudeGeometry: p_,
      FileLoader: oa,
      Float16BufferAttribute: ure,
      Float32BufferAttribute: st,
      FloatType: fi,
      Fog: s_,
      FogExp2: i_,
      FramebufferTexture: Ire,
      FrontSide: ra,
      Frustum: Lh,
      FrustumArray: l_,
      GLBufferAttribute: Kie,
      GLSL1: _ne,
      GLSL3: ix,
      GreaterCompare: X4,
      GreaterDepth: R0,
      GreaterEqualCompare: K4,
      GreaterEqualDepth: A0,
      GreaterEqualStencilFunc: dne,
      GreaterStencilFunc: cne,
      GridHelper: cse,
      Group: _d,
      HalfFloatType: Ih,
      HemisphereLight: zV,
      HemisphereLightHelper: lse,
      IcosahedronGeometry: m_,
      ImageBitmapLoader: Tie,
      ImageLoader: om,
      ImageUtils: Q4,
      IncrementStencilOp: ene,
      IncrementWrapStencilOp: nne,
      InstancedBufferAttribute: hh,
      InstancedBufferGeometry: qV,
      InstancedInterleavedBuffer: qie,
      InstancedMesh: cV,
      Int16BufferAttribute: lre,
      Int32BufferAttribute: cre,
      Int8BufferAttribute: sre,
      IntType: Kx,
      InterleavedBuffer: o_,
      InterleavedBufferAttribute: jc,
      Interpolant: Im,
      InterpolateDiscrete: Kp,
      InterpolateLinear: rx,
      InterpolateSmooth: Py,
      InterpolationSamplingMode: bne,
      InterpolationSamplingType: Sne,
      InvertStencilOp: ine,
      KeepStencilOp: ic,
      KeyframeTrack: us,
      LOD: aV,
      LatheGeometry: g_,
      Layers: Ic,
      LessCompare: G4,
      LessDepth: M0,
      LessEqualCompare: OC,
      LessEqualDepth: zc,
      LessEqualStencilFunc: lne,
      LessStencilFunc: one,
      Light: El,
      LightProbe: XV,
      Line: pl,
      Line3: rse,
      LineBasicMaterial: ei,
      LineCurve: $C,
      LineCurve3: yV,
      LineDashedMaterial: LV,
      LineLoop: dV,
      LineSegments: So,
      LinearFilter: Zn,
      LinearInterpolant: eA,
      LinearMipMapLinearFilter: Gte,
      LinearMipMapNearestFilter: Wte,
      LinearMipmapLinearFilter: oo,
      LinearMipmapNearestFilter: rp,
      LinearSRGBColorSpace: Vc,
      LinearToneMapping: I4,
      LinearTransfer: Jp,
      Loader: yi,
      LoaderUtils: qE,
      LoadingManager: nA,
      LoopOnce: F4,
      LoopPingPong: z4,
      LoopRepeat: B4,
      MOUSE: Bte,
      Material: Ur,
      MaterialLoader: b_,
      MathUtils: zne,
      Matrix2: cA,
      Matrix3: Nt,
      Matrix4: Tt,
      MaxEquation: g4,
      Mesh: $n,
      MeshBasicMaterial: Sl,
      MeshDepthMaterial: JC,
      MeshDistanceMaterial: ZC,
      MeshLambertMaterial: IV,
      MeshMatcapMaterial: NV,
      MeshNormalMaterial: PV,
      MeshPhongMaterial: AV,
      MeshPhysicalMaterial: CV,
      MeshStandardMaterial: YC,
      MeshToonMaterial: RV,
      MinEquation: m4,
      MirroredRepeatWrapping: qp,
      MixOperation: R4,
      MultiplyBlending: VE,
      MultiplyOperation: bm,
      NearestFilter: mr,
      NearestMipMapLinearFilter: Hte,
      NearestMipMapNearestFilter: jte,
      NearestMipmapLinearFilter: yd,
      NearestMipmapNearestFilter: TC,
      NeutralToneMapping: k4,
      NeverCompare: W4,
      NeverDepth: E0,
      NeverStencilFunc: sne,
      NoBlending: Xo,
      NoColorSpace: jo,
      NoToneMapping: go,
      NormalAnimationBlendMode: t_,
      NormalBlending: Rc,
      NotEqualCompare: q4,
      NotEqualDepth: P0,
      NotEqualStencilFunc: une,
      NumberKeyframeTrack: rm,
      Object3D: Xt,
      ObjectLoader: bie,
      ObjectSpaceNormalMap: H4,
      OctahedronGeometry: Rm,
      OneFactor: bC,
      OneMinusConstantAlphaFactor: A4,
      OneMinusConstantColorFactor: M4,
      OneMinusDstAlphaFactor: w4,
      OneMinusDstColorFactor: b4,
      OneMinusSrcAlphaFactor: b0,
      OneMinusSrcColorFactor: x4,
      OrthographicCamera: Lm,
      PCFShadowMap: Xx,
      PCFSoftShadowMap: np,
      PMREMGenerator: JE,
      Path: lx,
      PerspectiveCamera: lr,
      Plane: Ua,
      PlaneGeometry: Oh,
      PlaneHelper: mse,
      PointLight: jV,
      PointLightHelper: ose,
      Points: hV,
      PointsMaterial: jC,
      PolarGridHelper: use,
      PolyhedronGeometry: bl,
      PositionalAudio: Iie,
      PropertyBinding: Wt,
      PropertyMixer: ZV,
      QuadraticBezierCurve: XC,
      QuadraticBezierCurve3: qC,
      Quaternion: vi,
      QuaternionKeyframeTrack: Nm,
      QuaternionLinearInterpolant: FV,
      RED_GREEN_RGTC2_Format: tx,
      RED_RGTC1_Format: NC,
      REVISION: $x,
      RGBADepthPacking: j4,
      RGBAFormat: Or,
      RGBAIntegerFormat: e_,
      RGBA_ASTC_10x10_Format: K0,
      RGBA_ASTC_10x5_Format: $0,
      RGBA_ASTC_10x6_Format: X0,
      RGBA_ASTC_10x8_Format: q0,
      RGBA_ASTC_12x10_Format: Y0,
      RGBA_ASTC_12x12_Format: J0,
      RGBA_ASTC_4x4_Format: F0,
      RGBA_ASTC_5x4_Format: B0,
      RGBA_ASTC_5x5_Format: z0,
      RGBA_ASTC_6x5_Format: V0,
      RGBA_ASTC_6x6_Format: j0,
      RGBA_ASTC_8x5_Format: H0,
      RGBA_ASTC_8x6_Format: W0,
      RGBA_ASTC_8x8_Format: G0,
      RGBA_BPTC_Format: lp,
      RGBA_ETC2_EAC_Format: U0,
      RGBA_PVRTC_2BPPV1_Format: O0,
      RGBA_PVRTC_4BPPV1_Format: L0,
      RGBA_S3TC_DXT1_Format: sp,
      RGBA_S3TC_DXT3_Format: op,
      RGBA_S3TC_DXT5_Format: ap,
      RGBDepthPacking: Yte,
      RGBFormat: PC,
      RGBIntegerFormat: $te,
      RGB_BPTC_SIGNED_Format: Z0,
      RGB_BPTC_UNSIGNED_Format: Q0,
      RGB_ETC1_Format: D0,
      RGB_ETC2_Format: k0,
      RGB_PVRTC_2BPPV1_Format: N0,
      RGB_PVRTC_4BPPV1_Format: I0,
      RGB_S3TC_DXT1_Format: ip,
      RGDepthPacking: Jte,
      RGFormat: IC,
      RGIntegerFormat: Qx,
      RawShaderMaterial: MV,
      Ray: Nh,
      Raycaster: ej,
      RectAreaLight: GV,
      RedFormat: Zx,
      RedIntegerFormat: Em,
      ReinhardToneMapping: N4,
      RenderTarget: kC,
      RenderTarget3D: Gie,
      RepeatWrapping: Xp,
      ReplaceStencilOp: Qte,
      ReverseSubtractEquation: p4,
      RingGeometry: v_,
      SIGNED_RED_GREEN_RGTC2_Format: nx,
      SIGNED_RED_RGTC1_Format: ex,
      SRGBColorSpace: li,
      SRGBTransfer: nn,
      Scene: BC,
      ShaderChunk: Ft,
      ShaderLib: Is,
      ShaderMaterial: cs,
      ShadowMaterial: TV,
      Shape: Nc,
      ShapeGeometry: y_,
      ShapePath: yse,
      ShapeUtils: Ns,
      ShortType: CC,
      Skeleton: a_,
      SkeletonHelper: sse,
      SkinnedMesh: lV,
      Source: Ya,
      Sphere: gr,
      SphereGeometry: Pm,
      Spherical: Zie,
      SphericalHarmonics3: $V,
      SplineCurve: KC,
      SpotLight: VV,
      SpotLightHelper: ise,
      Sprite: oV,
      SpriteMaterial: zC,
      SrcAlphaFactor: Wp,
      SrcAlphaSaturateFactor: E4,
      SrcColorFactor: y4,
      StaticCopyUsage: vne,
      StaticDrawUsage: Zp,
      StaticReadUsage: pne,
      StereoCamera: Cie,
      StreamCopyUsage: xne,
      StreamDrawUsage: fne,
      StreamReadUsage: gne,
      StringKeyframeTrack: tu,
      SubtractEquation: f4,
      SubtractiveBlending: zE,
      TOUCH: zte,
      TangentSpaceNormalMap: wl,
      TetrahedronGeometry: x_,
      Texture: Nn,
      TextureLoader: xie,
      TextureUtils: Ese,
      Timer: Yie,
      TimestampQuery: wne,
      TorusGeometry: __,
      TorusKnotGeometry: w_,
      Triangle: ui,
      TriangleFanDrawMode: Kte,
      TriangleStripDrawMode: qte,
      TrianglesDrawMode: Xte,
      TubeGeometry: S_,
      UVMapping: qx,
      Uint16BufferAttribute: UC,
      Uint32BufferAttribute: FC,
      Uint8BufferAttribute: ore,
      Uint8ClampedBufferAttribute: are,
      Uniform: lA,
      UniformsGroup: Xie,
      UniformsLib: Ge,
      UniformsUtils: nV,
      UnsignedByteType: ls,
      UnsignedInt248Type: oh,
      UnsignedInt5999Type: AC,
      UnsignedIntType: sa,
      UnsignedShort4444Type: Yx,
      UnsignedShort5551Type: Jx,
      UnsignedShortType: sh,
      VSMShadowMap: Ts,
      Vector2: xe,
      Vector3: z,
      Vector4: Gt,
      VectorKeyframeTrack: im,
      VideoFrameTexture: Pre,
      VideoTexture: fV,
      WebGL3DRenderTarget: Xne,
      WebGLArrayRenderTarget: $ne,
      WebGLCoordinateSystem: Pi,
      WebGLCubeRenderTarget: iV,
      WebGLRenderTarget: xo,
      WebGLRenderer: cj,
      WebGLUtils: aj,
      WebGPUCoordinateSystem: ch,
      WebXRController: Iy,
      WireframeGeometry: EV,
      WrapAroundEnding: Yp,
      ZeroCurvatureEnding: gc,
      ZeroFactor: v4,
      ZeroSlopeEnding: vc,
      ZeroStencilOp: Zte,
      createCanvasElement: Z4,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var uj = { exports: {} },
  nu = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ nu.ConcurrentRoot = 1;
nu.ContinuousEventPriority = 4;
nu.DefaultEventPriority = 16;
nu.DiscreteEventPriority = 1;
nu.IdleEventPriority = 536870912;
nu.LegacyRoot = 0;
uj.exports = nu;
var Sd = uj.exports;
function oue(n) {
  let e;
  const t = new Set(),
    r = (c, u) => {
      const f = typeof c == "function" ? c(e) : c;
      if (f !== e) {
        const p = e;
        (e = u ? f : Object.assign({}, e, f)), t.forEach((m) => m(e, p));
      }
    },
    i = () => e,
    s = (c, u = i, f = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = u(e);
      function m() {
        const v = u(e);
        if (!f(p, v)) {
          const y = p;
          c((p = v), y);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: r,
      getState: i,
      subscribe: (c, u, f) =>
        u || f ? s(c, u, f) : (t.add(c), () => t.delete(c)),
      destroy: () => t.clear(),
    };
  return (e = n(r, i, l)), l;
}
const aue =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  gO = aue ? P.useEffect : P.useLayoutEffect;
function lue(n) {
  const e = typeof n == "function" ? oue(n) : n,
    t = (r = e.getState, i = Object.is) => {
      const [, s] = P.useReducer((x) => x + 1, 0),
        o = e.getState(),
        a = P.useRef(o),
        l = P.useRef(r),
        c = P.useRef(i),
        u = P.useRef(!1),
        f = P.useRef();
      f.current === void 0 && (f.current = r(o));
      let p,
        m = !1;
      (a.current !== o || l.current !== r || c.current !== i || u.current) &&
        ((p = r(o)), (m = !i(f.current, p))),
        gO(() => {
          m && (f.current = p),
            (a.current = o),
            (l.current = r),
            (c.current = i),
            (u.current = !1);
        });
      const v = P.useRef(o);
      gO(() => {
        const x = () => {
            try {
              const _ = e.getState(),
                S = l.current(_);
              c.current(f.current, S) ||
                ((a.current = _), (f.current = S), s());
            } catch {
              (u.current = !0), s();
            }
          },
          g = e.subscribe(x);
        return e.getState() !== v.current && x(), g;
      }, []);
      const y = m ? p : f.current;
      return P.useDebugValue(y), y;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const r = [t, e];
      return {
        next() {
          const i = r.length <= 0;
          return { value: r.shift(), done: i };
        },
      };
    }),
    t
  );
}
var dj = { exports: {} },
  hj = { exports: {} },
  fj = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(U, H) {
    var X = U.length;
    U.push(H);
    e: for (; 0 < X; ) {
      var ie = (X - 1) >>> 1,
        de = U[ie];
      if (0 < i(de, H)) (U[ie] = H), (U[X] = de), (X = ie);
      else break e;
    }
  }
  function t(U) {
    return U.length === 0 ? null : U[0];
  }
  function r(U) {
    if (U.length === 0) return null;
    var H = U[0],
      X = U.pop();
    if (X !== H) {
      U[0] = X;
      e: for (var ie = 0, de = U.length, Ee = de >>> 1; ie < Ee; ) {
        var Ie = 2 * (ie + 1) - 1,
          se = U[Ie],
          _e = Ie + 1,
          re = U[_e];
        if (0 > i(se, X))
          _e < de && 0 > i(re, se)
            ? ((U[ie] = re), (U[_e] = X), (ie = _e))
            : ((U[ie] = se), (U[Ie] = X), (ie = Ie));
        else if (_e < de && 0 > i(re, X)) (U[ie] = re), (U[_e] = X), (ie = _e);
        else break e;
      }
    }
    return H;
  }
  function i(U, H) {
    var X = U.sortIndex - H.sortIndex;
    return X !== 0 ? X : U.id - H.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    u = 1,
    f = null,
    p = 3,
    m = !1,
    v = !1,
    y = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(U) {
    for (var H = t(c); H !== null; ) {
      if (H.callback === null) r(c);
      else if (H.startTime <= U)
        r(c), (H.sortIndex = H.expirationTime), e(l, H);
      else break;
      H = t(c);
    }
  }
  function b(U) {
    if (((y = !1), S(U), !v))
      if (t(l) !== null) (v = !0), q(C);
      else {
        var H = t(c);
        H !== null && Y(b, H.startTime - U);
      }
  }
  function C(U, H) {
    (v = !1), y && ((y = !1), g(O), (O = -1)), (m = !0);
    var X = p;
    try {
      for (
        S(H), f = t(l);
        f !== null && (!(f.expirationTime > H) || (U && !D()));

      ) {
        var ie = f.callback;
        if (typeof ie == "function") {
          (f.callback = null), (p = f.priorityLevel);
          var de = ie(f.expirationTime <= H);
          (H = n.unstable_now()),
            typeof de == "function" ? (f.callback = de) : f === t(l) && r(l),
            S(H);
        } else r(l);
        f = t(l);
      }
      if (f !== null) var Ee = !0;
      else {
        var Ie = t(c);
        Ie !== null && Y(b, Ie.startTime - H), (Ee = !1);
      }
      return Ee;
    } finally {
      (f = null), (p = X), (m = !1);
    }
  }
  var A = !1,
    R = null,
    O = -1,
    I = 5,
    N = -1;
  function D() {
    return !(n.unstable_now() - N < I);
  }
  function j() {
    if (R !== null) {
      var U = n.unstable_now();
      N = U;
      var H = !0;
      try {
        H = R(!0, U);
      } finally {
        H ? $() : ((A = !1), (R = null));
      }
    } else A = !1;
  }
  var $;
  if (typeof _ == "function")
    $ = function () {
      _(j);
    };
  else if (typeof MessageChannel < "u") {
    var G = new MessageChannel(),
      Z = G.port2;
    (G.port1.onmessage = j),
      ($ = function () {
        Z.postMessage(null);
      });
  } else
    $ = function () {
      x(j, 0);
    };
  function q(U) {
    (R = U), A || ((A = !0), $());
  }
  function Y(U, H) {
    O = x(function () {
      U(n.unstable_now());
    }, H);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (U) {
      U.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), q(C));
    }),
    (n.unstable_forceFrameRate = function (U) {
      0 > U || 125 < U
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (I = 0 < U ? Math.floor(1e3 / U) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (U) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = p;
      }
      var X = p;
      p = H;
      try {
        return U();
      } finally {
        p = X;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (U, H) {
      switch (U) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          U = 3;
      }
      var X = p;
      p = U;
      try {
        return H();
      } finally {
        p = X;
      }
    }),
    (n.unstable_scheduleCallback = function (U, H, X) {
      var ie = n.unstable_now();
      switch (
        (typeof X == "object" && X !== null
          ? ((X = X.delay), (X = typeof X == "number" && 0 < X ? ie + X : ie))
          : (X = ie),
        U)
      ) {
        case 1:
          var de = -1;
          break;
        case 2:
          de = 250;
          break;
        case 5:
          de = 1073741823;
          break;
        case 4:
          de = 1e4;
          break;
        default:
          de = 5e3;
      }
      return (
        (de = X + de),
        (U = {
          id: u++,
          callback: H,
          priorityLevel: U,
          startTime: X,
          expirationTime: de,
          sortIndex: -1,
        }),
        X > ie
          ? ((U.sortIndex = X),
            e(c, U),
            t(l) === null &&
              U === t(c) &&
              (y ? (g(O), (O = -1)) : (y = !0), Y(b, X - ie)))
          : ((U.sortIndex = de), e(l, U), v || m || ((v = !0), q(C))),
        U
      );
    }),
    (n.unstable_shouldYield = D),
    (n.unstable_wrapCallback = function (U) {
      var H = p;
      return function () {
        var X = p;
        p = H;
        try {
          return U.apply(this, arguments);
        } finally {
          p = X;
        }
      };
    });
})(fj);
hj.exports = fj;
var QE = hj.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var cue = function (e) {
  var t = {},
    r = P,
    i = QE,
    s = Object.assign;
  function o(d) {
    for (
      var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + d,
        w = 1;
      w < arguments.length;
      w++
    )
      h += "&args[]=" + encodeURIComponent(arguments[w]);
    return (
      "Minified React error #" +
      d +
      "; visit " +
      h +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    u = Symbol.for("react.fragment"),
    f = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    y = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    _ = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    b = Symbol.for("react.offscreen"),
    C = Symbol.iterator;
  function A(d) {
    return d === null || typeof d != "object"
      ? null
      : ((d = (C && d[C]) || d["@@iterator"]),
        typeof d == "function" ? d : null);
  }
  function R(d) {
    if (d == null) return null;
    if (typeof d == "function") return d.displayName || d.name || null;
    if (typeof d == "string") return d;
    switch (d) {
      case u:
        return "Fragment";
      case c:
        return "Portal";
      case p:
        return "Profiler";
      case f:
        return "StrictMode";
      case x:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof d == "object")
      switch (d.$$typeof) {
        case v:
          return (d.displayName || "Context") + ".Consumer";
        case m:
          return (d._context.displayName || "Context") + ".Provider";
        case y:
          var h = d.render;
          return (
            (d = d.displayName),
            d ||
              ((d = h.displayName || h.name || ""),
              (d = d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")),
            d
          );
        case _:
          return (
            (h = d.displayName || null), h !== null ? h : R(d.type) || "Memo"
          );
        case S:
          (h = d._payload), (d = d._init);
          try {
            return R(d(h));
          } catch {}
      }
    return null;
  }
  function O(d) {
    var h = d.type;
    switch (d.tag) {
      case 24:
        return "Cache";
      case 9:
        return (h.displayName || "Context") + ".Consumer";
      case 10:
        return (h._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (d = h.render),
          (d = d.displayName || d.name || ""),
          h.displayName || (d !== "" ? "ForwardRef(" + d + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return h;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return R(h);
      case 8:
        return h === f ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
    }
    return null;
  }
  function I(d) {
    var h = d,
      w = d;
    if (d.alternate) for (; h.return; ) h = h.return;
    else {
      d = h;
      do (h = d), h.flags & 4098 && (w = h.return), (d = h.return);
      while (d);
    }
    return h.tag === 3 ? w : null;
  }
  function N(d) {
    if (I(d) !== d) throw Error(o(188));
  }
  function D(d) {
    var h = d.alternate;
    if (!h) {
      if (((h = I(d)), h === null)) throw Error(o(188));
      return h !== d ? null : d;
    }
    for (var w = d, E = h; ; ) {
      var M = w.return;
      if (M === null) break;
      var L = M.alternate;
      if (L === null) {
        if (((E = M.return), E !== null)) {
          w = E;
          continue;
        }
        break;
      }
      if (M.child === L.child) {
        for (L = M.child; L; ) {
          if (L === w) return N(M), d;
          if (L === E) return N(M), h;
          L = L.sibling;
        }
        throw Error(o(188));
      }
      if (w.return !== E.return) (w = M), (E = L);
      else {
        for (var V = !1, J = M.child; J; ) {
          if (J === w) {
            (V = !0), (w = M), (E = L);
            break;
          }
          if (J === E) {
            (V = !0), (E = M), (w = L);
            break;
          }
          J = J.sibling;
        }
        if (!V) {
          for (J = L.child; J; ) {
            if (J === w) {
              (V = !0), (w = L), (E = M);
              break;
            }
            if (J === E) {
              (V = !0), (E = L), (w = M);
              break;
            }
            J = J.sibling;
          }
          if (!V) throw Error(o(189));
        }
      }
      if (w.alternate !== E) throw Error(o(190));
    }
    if (w.tag !== 3) throw Error(o(188));
    return w.stateNode.current === w ? d : h;
  }
  function j(d) {
    return (d = D(d)), d !== null ? $(d) : null;
  }
  function $(d) {
    if (d.tag === 5 || d.tag === 6) return d;
    for (d = d.child; d !== null; ) {
      var h = $(d);
      if (h !== null) return h;
      d = d.sibling;
    }
    return null;
  }
  function G(d) {
    if (d.tag === 5 || d.tag === 6) return d;
    for (d = d.child; d !== null; ) {
      if (d.tag !== 4) {
        var h = G(d);
        if (h !== null) return h;
      }
      d = d.sibling;
    }
    return null;
  }
  var Z = Array.isArray,
    q = e.getPublicInstance,
    Y = e.getRootHostContext,
    U = e.getChildHostContext,
    H = e.prepareForCommit,
    X = e.resetAfterCommit,
    ie = e.createInstance,
    de = e.appendInitialChild,
    Ee = e.finalizeInitialChildren,
    Ie = e.prepareUpdate,
    se = e.shouldSetTextContent,
    _e = e.createTextInstance,
    re = e.scheduleTimeout,
    Be = e.cancelTimeout,
    Ue = e.noTimeout,
    Fe = e.isPrimaryRenderer,
    Ke = e.supportsMutation,
    Ve = e.supportsPersistence,
    W = e.supportsHydration,
    ge = e.getInstanceFromNode,
    pe = e.preparePortalMount,
    Se = e.getCurrentEventPriority,
    me = e.detachDeletedInstance,
    Oe = e.supportsMicrotasks,
    Te = e.scheduleMicrotask,
    De = e.supportsTestSelectors,
    _t = e.findFiberRoot,
    wt = e.getBoundingRect,
    B = e.getTextContent,
    k = e.isHiddenSubtree,
    ne = e.matchAccessibilityRole,
    ae = e.setFocusIfFocusable,
    we = e.setupIntersectionObserver,
    he = e.appendChild,
    ot = e.appendChildToContainer,
    Ne = e.commitTextUpdate,
    it = e.commitMount,
    tt = e.commitUpdate,
    Ce = e.insertBefore,
    je = e.insertInContainerBefore,
    vt = e.removeChild,
    Qe = e.removeChildFromContainer,
    He = e.resetTextContent,
    Ct = e.hideInstance,
    K = e.hideTextInstance,
    Re = e.unhideInstance,
    ze = e.unhideTextInstance,
    Ye = e.clearContainer,
    Me = e.cloneInstance,
    ye = e.createContainerChildSet,
    be = e.appendChildToContainerChildSet,
    $e = e.finalizeContainerChildren,
    mt = e.replaceContainerChildren,
    At = e.cloneHiddenInstance,
    mn = e.cloneHiddenTextInstance,
    On = e.canHydrateInstance,
    Fi = e.canHydrateTextInstance,
    Dn = e.canHydrateSuspenseInstance,
    Fr = e.isSuspenseInstancePending,
    ru = e.isSuspenseInstanceFallback,
    Dm = e.registerSuspenseInstanceRetry,
    Vs = e.getNextHydratableSibling,
    km = e.getFirstHydratableChild,
    iu = e.getFirstHydratableChildWithinContainer,
    Um = e.getFirstHydratableChildWithinSuspenseInstance,
    Fm = e.hydrateInstance,
    A_ = e.hydrateTextInstance,
    R_ = e.hydrateSuspenseInstance,
    P_ = e.getNextHydratableInstanceAfterSuspenseInstance,
    Bm = e.commitHydratedContainer,
    I_ = e.commitHydratedSuspenseInstance,
    N_ = e.clearSuspenseBoundary,
    F = e.clearSuspenseBoundaryFromContainer,
    ee = e.shouldDeleteUnhydratedTailInstances,
    le = e.didNotMatchHydratedContainerTextInstance,
    ce = e.didNotMatchHydratedTextInstance,
    te;
  function Ae(d) {
    if (te === void 0)
      try {
        throw Error();
      } catch (w) {
        var h = w.stack.trim().match(/\n( *(at )?)/);
        te = (h && h[1]) || "";
      }
    return (
      `
` +
      te +
      d
    );
  }
  var We = !1;
  function nt(d, h) {
    if (!d || We) return "";
    We = !0;
    var w = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (h)
        if (
          ((h = function () {
            throw Error();
          }),
          Object.defineProperty(h.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(h, []);
          } catch (ke) {
            var E = ke;
          }
          Reflect.construct(d, [], h);
        } else {
          try {
            h.call();
          } catch (ke) {
            E = ke;
          }
          d.call(h.prototype);
        }
      else {
        try {
          throw Error();
        } catch (ke) {
          E = ke;
        }
        d();
      }
    } catch (ke) {
      if (ke && E && typeof ke.stack == "string") {
        for (
          var M = ke.stack.split(`
`),
            L = E.stack.split(`
`),
            V = M.length - 1,
            J = L.length - 1;
          1 <= V && 0 <= J && M[V] !== L[J];

        )
          J--;
        for (; 1 <= V && 0 <= J; V--, J--)
          if (M[V] !== L[J]) {
            if (V !== 1 || J !== 1)
              do
                if ((V--, J--, 0 > J || M[V] !== L[J])) {
                  var fe =
                    `
` + M[V].replace(" at new ", " at ");
                  return (
                    d.displayName &&
                      fe.includes("<anonymous>") &&
                      (fe = fe.replace("<anonymous>", d.displayName)),
                    fe
                  );
                }
              while (1 <= V && 0 <= J);
            break;
          }
      }
    } finally {
      (We = !1), (Error.prepareStackTrace = w);
    }
    return (d = d ? d.displayName || d.name : "") ? Ae(d) : "";
  }
  var Ze = Object.prototype.hasOwnProperty,
    yt = [],
    gt = -1;
  function at(d) {
    return { current: d };
  }
  function lt(d) {
    0 > gt || ((d.current = yt[gt]), (yt[gt] = null), gt--);
  }
  function pt(d, h) {
    gt++, (yt[gt] = d.current), (d.current = h);
  }
  var en = {},
    Lt = at(en),
    Ot = at(!1),
    ut = en;
  function tn(d, h) {
    var w = d.type.contextTypes;
    if (!w) return en;
    var E = d.stateNode;
    if (E && E.__reactInternalMemoizedUnmaskedChildContext === h)
      return E.__reactInternalMemoizedMaskedChildContext;
    var M = {},
      L;
    for (L in w) M[L] = h[L];
    return (
      E &&
        ((d = d.stateNode),
        (d.__reactInternalMemoizedUnmaskedChildContext = h),
        (d.__reactInternalMemoizedMaskedChildContext = M)),
      M
    );
  }
  function Mt(d) {
    return (d = d.childContextTypes), d != null;
  }
  function tr() {
    lt(Ot), lt(Lt);
  }
  function bo(d, h, w) {
    if (Lt.current !== en) throw Error(o(168));
    pt(Lt, h), pt(Ot, w);
  }
  function xr(d, h, w) {
    var E = d.stateNode;
    if (((h = h.childContextTypes), typeof E.getChildContext != "function"))
      return w;
    E = E.getChildContext();
    for (var M in E) if (!(M in h)) throw Error(o(108, O(d) || "Unknown", M));
    return s({}, w, E);
  }
  function js(d) {
    return (
      (d =
        ((d = d.stateNode) && d.__reactInternalMemoizedMergedChildContext) ||
        en),
      (ut = Lt.current),
      pt(Lt, d),
      pt(Ot, Ot.current),
      !0
    );
  }
  function an(d, h, w) {
    var E = d.stateNode;
    if (!E) throw Error(o(169));
    w
      ? ((d = xr(d, h, ut)),
        (E.__reactInternalMemoizedMergedChildContext = d),
        lt(Ot),
        lt(Lt),
        pt(Lt, d))
      : lt(Ot),
      pt(Ot, w);
  }
  var gn = Math.clz32 ? Math.clz32 : _r,
    ti = Math.log,
    ur = Math.LN2;
  function _r(d) {
    return (d >>>= 0), d === 0 ? 32 : (31 - ((ti(d) / ur) | 0)) | 0;
  }
  var ca = 64,
    Bi = 4194304;
  function Uh(d) {
    switch (d & -d) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return d & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return d & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return d;
    }
  }
  function zm(d, h) {
    var w = d.pendingLanes;
    if (w === 0) return 0;
    var E = 0,
      M = d.suspendedLanes,
      L = d.pingedLanes,
      V = w & 268435455;
    if (V !== 0) {
      var J = V & ~M;
      J !== 0 ? (E = Uh(J)) : ((L &= V), L !== 0 && (E = Uh(L)));
    } else (V = w & ~M), V !== 0 ? (E = Uh(V)) : L !== 0 && (E = Uh(L));
    if (E === 0) return 0;
    if (
      h !== 0 &&
      h !== E &&
      !(h & M) &&
      ((M = E & -E), (L = h & -h), M >= L || (M === 16 && (L & 4194240) !== 0))
    )
      return h;
    if ((E & 4 && (E |= w & 16), (h = d.entangledLanes), h !== 0))
      for (d = d.entanglements, h &= E; 0 < h; )
        (w = 31 - gn(h)), (M = 1 << w), (E |= d[w]), (h &= ~M);
    return E;
  }
  function f5(d, h) {
    switch (d) {
      case 1:
      case 2:
      case 4:
        return h + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return h + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function p5(d, h) {
    for (
      var w = d.suspendedLanes,
        E = d.pingedLanes,
        M = d.expirationTimes,
        L = d.pendingLanes;
      0 < L;

    ) {
      var V = 31 - gn(L),
        J = 1 << V,
        fe = M[V];
      fe === -1
        ? (!(J & w) || J & E) && (M[V] = f5(J, h))
        : fe <= h && (d.expiredLanes |= J),
        (L &= ~J);
    }
  }
  function L_(d) {
    return (
      (d = d.pendingLanes & -1073741825),
      d !== 0 ? d : d & 1073741824 ? 1073741824 : 0
    );
  }
  function O_(d) {
    for (var h = [], w = 0; 31 > w; w++) h.push(d);
    return h;
  }
  function Fh(d, h, w) {
    (d.pendingLanes |= h),
      h !== 536870912 && ((d.suspendedLanes = 0), (d.pingedLanes = 0)),
      (d = d.eventTimes),
      (h = 31 - gn(h)),
      (d[h] = w);
  }
  function m5(d, h) {
    var w = d.pendingLanes & ~h;
    (d.pendingLanes = h),
      (d.suspendedLanes = 0),
      (d.pingedLanes = 0),
      (d.expiredLanes &= h),
      (d.mutableReadLanes &= h),
      (d.entangledLanes &= h),
      (h = d.entanglements);
    var E = d.eventTimes;
    for (d = d.expirationTimes; 0 < w; ) {
      var M = 31 - gn(w),
        L = 1 << M;
      (h[M] = 0), (E[M] = -1), (d[M] = -1), (w &= ~L);
    }
  }
  function D_(d, h) {
    var w = (d.entangledLanes |= h);
    for (d = d.entanglements; w; ) {
      var E = 31 - gn(w),
        M = 1 << E;
      (M & h) | (d[E] & h) && (d[E] |= h), (w &= ~M);
    }
  }
  var Yt = 0;
  function mA(d) {
    return (
      (d &= -d), 1 < d ? (4 < d ? (d & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var k_ = i.unstable_scheduleCallback,
    gA = i.unstable_cancelCallback,
    g5 = i.unstable_shouldYield,
    v5 = i.unstable_requestPaint,
    nr = i.unstable_now,
    U_ = i.unstable_ImmediatePriority,
    y5 = i.unstable_UserBlockingPriority,
    F_ = i.unstable_NormalPriority,
    x5 = i.unstable_IdlePriority,
    Vm = null,
    Hs = null;
  function _5(d) {
    if (Hs && typeof Hs.onCommitFiberRoot == "function")
      try {
        Hs.onCommitFiberRoot(Vm, d, void 0, (d.current.flags & 128) === 128);
      } catch {}
  }
  function w5(d, h) {
    return (d === h && (d !== 0 || 1 / d === 1 / h)) || (d !== d && h !== h);
  }
  var Ws = typeof Object.is == "function" ? Object.is : w5,
    Eo = null,
    jm = !1,
    B_ = !1;
  function vA(d) {
    Eo === null ? (Eo = [d]) : Eo.push(d);
  }
  function S5(d) {
    (jm = !0), vA(d);
  }
  function Gs() {
    if (!B_ && Eo !== null) {
      B_ = !0;
      var d = 0,
        h = Yt;
      try {
        var w = Eo;
        for (Yt = 1; d < w.length; d++) {
          var E = w[d];
          do E = E(!0);
          while (E !== null);
        }
        (Eo = null), (jm = !1);
      } catch (M) {
        throw (Eo !== null && (Eo = Eo.slice(d + 1)), k_(U_, Gs), M);
      } finally {
        (Yt = h), (B_ = !1);
      }
    }
    return null;
  }
  var b5 = a.ReactCurrentBatchConfig;
  function Hm(d, h) {
    if (Ws(d, h)) return !0;
    if (
      typeof d != "object" ||
      d === null ||
      typeof h != "object" ||
      h === null
    )
      return !1;
    var w = Object.keys(d),
      E = Object.keys(h);
    if (w.length !== E.length) return !1;
    for (E = 0; E < w.length; E++) {
      var M = w[E];
      if (!Ze.call(h, M) || !Ws(d[M], h[M])) return !1;
    }
    return !0;
  }
  function E5(d) {
    switch (d.tag) {
      case 5:
        return Ae(d.type);
      case 16:
        return Ae("Lazy");
      case 13:
        return Ae("Suspense");
      case 19:
        return Ae("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (d = nt(d.type, !1)), d;
      case 11:
        return (d = nt(d.type.render, !1)), d;
      case 1:
        return (d = nt(d.type, !0)), d;
      default:
        return "";
    }
  }
  function ds(d, h) {
    if (d && d.defaultProps) {
      (h = s({}, h)), (d = d.defaultProps);
      for (var w in d) h[w] === void 0 && (h[w] = d[w]);
      return h;
    }
    return h;
  }
  var Wm = at(null),
    Gm = null,
    su = null,
    z_ = null;
  function V_() {
    z_ = su = Gm = null;
  }
  function yA(d, h, w) {
    Fe
      ? (pt(Wm, h._currentValue), (h._currentValue = w))
      : (pt(Wm, h._currentValue2), (h._currentValue2 = w));
  }
  function j_(d) {
    var h = Wm.current;
    lt(Wm), Fe ? (d._currentValue = h) : (d._currentValue2 = h);
  }
  function H_(d, h, w) {
    for (; d !== null; ) {
      var E = d.alternate;
      if (
        ((d.childLanes & h) !== h
          ? ((d.childLanes |= h), E !== null && (E.childLanes |= h))
          : E !== null && (E.childLanes & h) !== h && (E.childLanes |= h),
        d === w)
      )
        break;
      d = d.return;
    }
  }
  function ou(d, h) {
    (Gm = d),
      (z_ = su = null),
      (d = d.dependencies),
      d !== null &&
        d.firstContext !== null &&
        (d.lanes & h && (wi = !0), (d.firstContext = null));
  }
  function zi(d) {
    var h = Fe ? d._currentValue : d._currentValue2;
    if (z_ !== d)
      if (((d = { context: d, memoizedValue: h, next: null }), su === null)) {
        if (Gm === null) throw Error(o(308));
        (su = d), (Gm.dependencies = { lanes: 0, firstContext: d });
      } else su = su.next = d;
    return h;
  }
  var $s = null,
    ua = !1;
  function W_(d) {
    d.updateQueue = {
      baseState: d.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function xA(d, h) {
    (d = d.updateQueue),
      h.updateQueue === d &&
        (h.updateQueue = {
          baseState: d.baseState,
          firstBaseUpdate: d.firstBaseUpdate,
          lastBaseUpdate: d.lastBaseUpdate,
          shared: d.shared,
          effects: d.effects,
        });
  }
  function To(d, h) {
    return {
      eventTime: d,
      lane: h,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function da(d, h) {
    var w = d.updateQueue;
    w !== null &&
      ((w = w.shared),
      zn !== null && d.mode & 1 && !(Vt & 2)
        ? ((d = w.interleaved),
          d === null
            ? ((h.next = h), $s === null ? ($s = [w]) : $s.push(w))
            : ((h.next = d.next), (d.next = h)),
          (w.interleaved = h))
        : ((d = w.pending),
          d === null ? (h.next = h) : ((h.next = d.next), (d.next = h)),
          (w.pending = h)));
  }
  function $m(d, h, w) {
    if (
      ((h = h.updateQueue), h !== null && ((h = h.shared), (w & 4194240) !== 0))
    ) {
      var E = h.lanes;
      (E &= d.pendingLanes), (w |= E), (h.lanes = w), D_(d, w);
    }
  }
  function _A(d, h) {
    var w = d.updateQueue,
      E = d.alternate;
    if (E !== null && ((E = E.updateQueue), w === E)) {
      var M = null,
        L = null;
      if (((w = w.firstBaseUpdate), w !== null)) {
        do {
          var V = {
            eventTime: w.eventTime,
            lane: w.lane,
            tag: w.tag,
            payload: w.payload,
            callback: w.callback,
            next: null,
          };
          L === null ? (M = L = V) : (L = L.next = V), (w = w.next);
        } while (w !== null);
        L === null ? (M = L = h) : (L = L.next = h);
      } else M = L = h;
      (w = {
        baseState: E.baseState,
        firstBaseUpdate: M,
        lastBaseUpdate: L,
        shared: E.shared,
        effects: E.effects,
      }),
        (d.updateQueue = w);
      return;
    }
    (d = w.lastBaseUpdate),
      d === null ? (w.firstBaseUpdate = h) : (d.next = h),
      (w.lastBaseUpdate = h);
  }
  function Xm(d, h, w, E) {
    var M = d.updateQueue;
    ua = !1;
    var L = M.firstBaseUpdate,
      V = M.lastBaseUpdate,
      J = M.shared.pending;
    if (J !== null) {
      M.shared.pending = null;
      var fe = J,
        ke = fe.next;
      (fe.next = null), V === null ? (L = ke) : (V.next = ke), (V = fe);
      var rt = d.alternate;
      rt !== null &&
        ((rt = rt.updateQueue),
        (J = rt.lastBaseUpdate),
        J !== V &&
          (J === null ? (rt.firstBaseUpdate = ke) : (J.next = ke),
          (rt.lastBaseUpdate = fe)));
    }
    if (L !== null) {
      var Rt = M.baseState;
      (V = 0), (rt = ke = fe = null), (J = L);
      do {
        var xt = J.lane,
          on = J.eventTime;
        if ((E & xt) === xt) {
          rt !== null &&
            (rt = rt.next =
              {
                eventTime: on,
                lane: 0,
                tag: J.tag,
                payload: J.payload,
                callback: J.callback,
                next: null,
              });
          e: {
            var ht = d,
              Er = J;
            switch (((xt = h), (on = w), Er.tag)) {
              case 1:
                if (((ht = Er.payload), typeof ht == "function")) {
                  Rt = ht.call(on, Rt, xt);
                  break e;
                }
                Rt = ht;
                break e;
              case 3:
                ht.flags = (ht.flags & -65537) | 128;
              case 0:
                if (
                  ((ht = Er.payload),
                  (xt = typeof ht == "function" ? ht.call(on, Rt, xt) : ht),
                  xt == null)
                )
                  break e;
                Rt = s({}, Rt, xt);
                break e;
              case 2:
                ua = !0;
            }
          }
          J.callback !== null &&
            J.lane !== 0 &&
            ((d.flags |= 64),
            (xt = M.effects),
            xt === null ? (M.effects = [J]) : xt.push(J));
        } else
          (on = {
            eventTime: on,
            lane: xt,
            tag: J.tag,
            payload: J.payload,
            callback: J.callback,
            next: null,
          }),
            rt === null ? ((ke = rt = on), (fe = Rt)) : (rt = rt.next = on),
            (V |= xt);
        if (((J = J.next), J === null)) {
          if (((J = M.shared.pending), J === null)) break;
          (xt = J),
            (J = xt.next),
            (xt.next = null),
            (M.lastBaseUpdate = xt),
            (M.shared.pending = null);
        }
      } while (!0);
      if (
        (rt === null && (fe = Rt),
        (M.baseState = fe),
        (M.firstBaseUpdate = ke),
        (M.lastBaseUpdate = rt),
        (h = M.shared.interleaved),
        h !== null)
      ) {
        M = h;
        do (V |= M.lane), (M = M.next);
        while (M !== h);
      } else L === null && (M.shared.lanes = 0);
      (mu |= V), (d.lanes = V), (d.memoizedState = Rt);
    }
  }
  function wA(d, h, w) {
    if (((d = h.effects), (h.effects = null), d !== null))
      for (h = 0; h < d.length; h++) {
        var E = d[h],
          M = E.callback;
        if (M !== null) {
          if (((E.callback = null), (E = w), typeof M != "function"))
            throw Error(o(191, M));
          M.call(E);
        }
      }
  }
  var SA = new r.Component().refs;
  function G_(d, h, w, E) {
    (h = d.memoizedState),
      (w = w(E, h)),
      (w = w == null ? h : s({}, h, w)),
      (d.memoizedState = w),
      d.lanes === 0 && (d.updateQueue.baseState = w);
  }
  var qm = {
    isMounted: function (d) {
      return (d = d._reactInternals) ? I(d) === d : !1;
    },
    enqueueSetState: function (d, h, w) {
      d = d._reactInternals;
      var E = zr(),
        M = pa(d),
        L = To(E, M);
      (L.payload = h),
        w != null && (L.callback = w),
        da(d, L),
        (h = Gi(d, M, E)),
        h !== null && $m(h, d, M);
    },
    enqueueReplaceState: function (d, h, w) {
      d = d._reactInternals;
      var E = zr(),
        M = pa(d),
        L = To(E, M);
      (L.tag = 1),
        (L.payload = h),
        w != null && (L.callback = w),
        da(d, L),
        (h = Gi(d, M, E)),
        h !== null && $m(h, d, M);
    },
    enqueueForceUpdate: function (d, h) {
      d = d._reactInternals;
      var w = zr(),
        E = pa(d),
        M = To(w, E);
      (M.tag = 2),
        h != null && (M.callback = h),
        da(d, M),
        (h = Gi(d, E, w)),
        h !== null && $m(h, d, E);
    },
  };
  function bA(d, h, w, E, M, L, V) {
    return (
      (d = d.stateNode),
      typeof d.shouldComponentUpdate == "function"
        ? d.shouldComponentUpdate(E, L, V)
        : h.prototype && h.prototype.isPureReactComponent
        ? !Hm(w, E) || !Hm(M, L)
        : !0
    );
  }
  function EA(d, h, w) {
    var E = !1,
      M = en,
      L = h.contextType;
    return (
      typeof L == "object" && L !== null
        ? (L = zi(L))
        : ((M = Mt(h) ? ut : Lt.current),
          (E = h.contextTypes),
          (L = (E = E != null) ? tn(d, M) : en)),
      (h = new h(w, L)),
      (d.memoizedState =
        h.state !== null && h.state !== void 0 ? h.state : null),
      (h.updater = qm),
      (d.stateNode = h),
      (h._reactInternals = d),
      E &&
        ((d = d.stateNode),
        (d.__reactInternalMemoizedUnmaskedChildContext = M),
        (d.__reactInternalMemoizedMaskedChildContext = L)),
      h
    );
  }
  function TA(d, h, w, E) {
    (d = h.state),
      typeof h.componentWillReceiveProps == "function" &&
        h.componentWillReceiveProps(w, E),
      typeof h.UNSAFE_componentWillReceiveProps == "function" &&
        h.UNSAFE_componentWillReceiveProps(w, E),
      h.state !== d && qm.enqueueReplaceState(h, h.state, null);
  }
  function $_(d, h, w, E) {
    var M = d.stateNode;
    (M.props = w), (M.state = d.memoizedState), (M.refs = SA), W_(d);
    var L = h.contextType;
    typeof L == "object" && L !== null
      ? (M.context = zi(L))
      : ((L = Mt(h) ? ut : Lt.current), (M.context = tn(d, L))),
      (M.state = d.memoizedState),
      (L = h.getDerivedStateFromProps),
      typeof L == "function" && (G_(d, h, L, w), (M.state = d.memoizedState)),
      typeof h.getDerivedStateFromProps == "function" ||
        typeof M.getSnapshotBeforeUpdate == "function" ||
        (typeof M.UNSAFE_componentWillMount != "function" &&
          typeof M.componentWillMount != "function") ||
        ((h = M.state),
        typeof M.componentWillMount == "function" && M.componentWillMount(),
        typeof M.UNSAFE_componentWillMount == "function" &&
          M.UNSAFE_componentWillMount(),
        h !== M.state && qm.enqueueReplaceState(M, M.state, null),
        Xm(d, w, M, E),
        (M.state = d.memoizedState)),
      typeof M.componentDidMount == "function" && (d.flags |= 4194308);
  }
  var au = [],
    lu = 0,
    Km = null,
    Ym = 0,
    Vi = [],
    ji = 0,
    Cl = null,
    Mo = 1,
    Co = "";
  function Al(d, h) {
    (au[lu++] = Ym), (au[lu++] = Km), (Km = d), (Ym = h);
  }
  function MA(d, h, w) {
    (Vi[ji++] = Mo), (Vi[ji++] = Co), (Vi[ji++] = Cl), (Cl = d);
    var E = Mo;
    d = Co;
    var M = 32 - gn(E) - 1;
    (E &= ~(1 << M)), (w += 1);
    var L = 32 - gn(h) + M;
    if (30 < L) {
      var V = M - (M % 5);
      (L = (E & ((1 << V) - 1)).toString(32)),
        (E >>= V),
        (M -= V),
        (Mo = (1 << (32 - gn(h) + M)) | (w << M) | E),
        (Co = L + d);
    } else (Mo = (1 << L) | (w << M) | E), (Co = d);
  }
  function X_(d) {
    d.return !== null && (Al(d, 1), MA(d, 1, 0));
  }
  function q_(d) {
    for (; d === Km; )
      (Km = au[--lu]), (au[lu] = null), (Ym = au[--lu]), (au[lu] = null);
    for (; d === Cl; )
      (Cl = Vi[--ji]),
        (Vi[ji] = null),
        (Co = Vi[--ji]),
        (Vi[ji] = null),
        (Mo = Vi[--ji]),
        (Vi[ji] = null);
  }
  var xi = null,
    _i = null,
    vn = !1,
    Bh = !1,
    hs = null;
  function CA(d, h) {
    var w = $i(5, null, null, 0);
    (w.elementType = "DELETED"),
      (w.stateNode = h),
      (w.return = d),
      (h = d.deletions),
      h === null ? ((d.deletions = [w]), (d.flags |= 16)) : h.push(w);
  }
  function AA(d, h) {
    switch (d.tag) {
      case 5:
        return (
          (h = On(h, d.type, d.pendingProps)),
          h !== null ? ((d.stateNode = h), (xi = d), (_i = km(h)), !0) : !1
        );
      case 6:
        return (
          (h = Fi(h, d.pendingProps)),
          h !== null ? ((d.stateNode = h), (xi = d), (_i = null), !0) : !1
        );
      case 13:
        if (((h = Dn(h)), h !== null)) {
          var w = Cl !== null ? { id: Mo, overflow: Co } : null;
          return (
            (d.memoizedState = {
              dehydrated: h,
              treeContext: w,
              retryLane: 1073741824,
            }),
            (w = $i(18, null, null, 0)),
            (w.stateNode = h),
            (w.return = d),
            (d.child = w),
            (xi = d),
            (_i = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function K_(d) {
    return (d.mode & 1) !== 0 && (d.flags & 128) === 0;
  }
  function Y_(d) {
    if (vn) {
      var h = _i;
      if (h) {
        var w = h;
        if (!AA(d, h)) {
          if (K_(d)) throw Error(o(418));
          h = Vs(w);
          var E = xi;
          h && AA(d, h)
            ? CA(E, w)
            : ((d.flags = (d.flags & -4097) | 2), (vn = !1), (xi = d));
        }
      } else {
        if (K_(d)) throw Error(o(418));
        (d.flags = (d.flags & -4097) | 2), (vn = !1), (xi = d);
      }
    }
  }
  function RA(d) {
    for (
      d = d.return;
      d !== null && d.tag !== 5 && d.tag !== 3 && d.tag !== 13;

    )
      d = d.return;
    xi = d;
  }
  function zh(d) {
    if (!W || d !== xi) return !1;
    if (!vn) return RA(d), (vn = !0), !1;
    if (
      d.tag !== 3 &&
      (d.tag !== 5 || (ee(d.type) && !se(d.type, d.memoizedProps)))
    ) {
      var h = _i;
      if (h) {
        if (K_(d)) {
          for (d = _i; d; ) d = Vs(d);
          throw Error(o(418));
        }
        for (; h; ) CA(d, h), (h = Vs(h));
      }
    }
    if ((RA(d), d.tag === 13)) {
      if (!W) throw Error(o(316));
      if (((d = d.memoizedState), (d = d !== null ? d.dehydrated : null), !d))
        throw Error(o(317));
      _i = P_(d);
    } else _i = xi ? Vs(d.stateNode) : null;
    return !0;
  }
  function cu() {
    W && ((_i = xi = null), (Bh = vn = !1));
  }
  function J_(d) {
    hs === null ? (hs = [d]) : hs.push(d);
  }
  function Vh(d, h, w) {
    if (
      ((d = w.ref),
      d !== null && typeof d != "function" && typeof d != "object")
    ) {
      if (w._owner) {
        if (((w = w._owner), w)) {
          if (w.tag !== 1) throw Error(o(309));
          var E = w.stateNode;
        }
        if (!E) throw Error(o(147, d));
        var M = E,
          L = "" + d;
        return h !== null &&
          h.ref !== null &&
          typeof h.ref == "function" &&
          h.ref._stringRef === L
          ? h.ref
          : ((h = function (V) {
              var J = M.refs;
              J === SA && (J = M.refs = {}),
                V === null ? delete J[L] : (J[L] = V);
            }),
            (h._stringRef = L),
            h);
      }
      if (typeof d != "string") throw Error(o(284));
      if (!w._owner) throw Error(o(290, d));
    }
    return d;
  }
  function Jm(d, h) {
    throw (
      ((d = Object.prototype.toString.call(h)),
      Error(
        o(
          31,
          d === "[object Object]"
            ? "object with keys {" + Object.keys(h).join(", ") + "}"
            : d
        )
      ))
    );
  }
  function PA(d) {
    var h = d._init;
    return h(d._payload);
  }
  function IA(d) {
    function h(oe, Q) {
      if (d) {
        var ue = oe.deletions;
        ue === null ? ((oe.deletions = [Q]), (oe.flags |= 16)) : ue.push(Q);
      }
    }
    function w(oe, Q) {
      if (!d) return null;
      for (; Q !== null; ) h(oe, Q), (Q = Q.sibling);
      return null;
    }
    function E(oe, Q) {
      for (oe = new Map(); Q !== null; )
        Q.key !== null ? oe.set(Q.key, Q) : oe.set(Q.index, Q), (Q = Q.sibling);
      return oe;
    }
    function M(oe, Q) {
      return (oe = ga(oe, Q)), (oe.index = 0), (oe.sibling = null), oe;
    }
    function L(oe, Q, ue) {
      return (
        (oe.index = ue),
        d
          ? ((ue = oe.alternate),
            ue !== null
              ? ((ue = ue.index), ue < Q ? ((oe.flags |= 2), Q) : ue)
              : ((oe.flags |= 2), Q))
          : ((oe.flags |= 1048576), Q)
      );
    }
    function V(oe) {
      return d && oe.alternate === null && (oe.flags |= 2), oe;
    }
    function J(oe, Q, ue, qe) {
      return Q === null || Q.tag !== 6
        ? ((Q = Ow(ue, oe.mode, qe)), (Q.return = oe), Q)
        : ((Q = M(Q, ue)), (Q.return = oe), Q);
    }
    function fe(oe, Q, ue, qe) {
      var dt = ue.type;
      return dt === u
        ? rt(oe, Q, ue.props.children, qe, ue.key)
        : Q !== null &&
          (Q.elementType === dt ||
            (typeof dt == "object" &&
              dt !== null &&
              dt.$$typeof === S &&
              PA(dt) === Q.type))
        ? ((qe = M(Q, ue.props)),
          (qe.ref = Vh(oe, Q, ue)),
          (qe.return = oe),
          qe)
        : ((qe = Ag(ue.type, ue.key, ue.props, null, oe.mode, qe)),
          (qe.ref = Vh(oe, Q, ue)),
          (qe.return = oe),
          qe);
    }
    function ke(oe, Q, ue, qe) {
      return Q === null ||
        Q.tag !== 4 ||
        Q.stateNode.containerInfo !== ue.containerInfo ||
        Q.stateNode.implementation !== ue.implementation
        ? ((Q = Dw(ue, oe.mode, qe)), (Q.return = oe), Q)
        : ((Q = M(Q, ue.children || [])), (Q.return = oe), Q);
    }
    function rt(oe, Q, ue, qe, dt) {
      return Q === null || Q.tag !== 7
        ? ((Q = Dl(ue, oe.mode, qe, dt)), (Q.return = oe), Q)
        : ((Q = M(Q, ue)), (Q.return = oe), Q);
    }
    function Rt(oe, Q, ue) {
      if ((typeof Q == "string" && Q !== "") || typeof Q == "number")
        return (Q = Ow("" + Q, oe.mode, ue)), (Q.return = oe), Q;
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case l:
            return (
              (ue = Ag(Q.type, Q.key, Q.props, null, oe.mode, ue)),
              (ue.ref = Vh(oe, null, Q)),
              (ue.return = oe),
              ue
            );
          case c:
            return (Q = Dw(Q, oe.mode, ue)), (Q.return = oe), Q;
          case S:
            var qe = Q._init;
            return Rt(oe, qe(Q._payload), ue);
        }
        if (Z(Q) || A(Q))
          return (Q = Dl(Q, oe.mode, ue, null)), (Q.return = oe), Q;
        Jm(oe, Q);
      }
      return null;
    }
    function xt(oe, Q, ue, qe) {
      var dt = Q !== null ? Q.key : null;
      if ((typeof ue == "string" && ue !== "") || typeof ue == "number")
        return dt !== null ? null : J(oe, Q, "" + ue, qe);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case l:
            return ue.key === dt ? fe(oe, Q, ue, qe) : null;
          case c:
            return ue.key === dt ? ke(oe, Q, ue, qe) : null;
          case S:
            return (dt = ue._init), xt(oe, Q, dt(ue._payload), qe);
        }
        if (Z(ue) || A(ue)) return dt !== null ? null : rt(oe, Q, ue, qe, null);
        Jm(oe, ue);
      }
      return null;
    }
    function on(oe, Q, ue, qe, dt) {
      if ((typeof qe == "string" && qe !== "") || typeof qe == "number")
        return (oe = oe.get(ue) || null), J(Q, oe, "" + qe, dt);
      if (typeof qe == "object" && qe !== null) {
        switch (qe.$$typeof) {
          case l:
            return (
              (oe = oe.get(qe.key === null ? ue : qe.key) || null),
              fe(Q, oe, qe, dt)
            );
          case c:
            return (
              (oe = oe.get(qe.key === null ? ue : qe.key) || null),
              ke(Q, oe, qe, dt)
            );
          case S:
            var zt = qe._init;
            return on(oe, Q, ue, zt(qe._payload), dt);
        }
        if (Z(qe) || A(qe))
          return (oe = oe.get(ue) || null), rt(Q, oe, qe, dt, null);
        Jm(Q, qe);
      }
      return null;
    }
    function ht(oe, Q, ue, qe) {
      for (
        var dt = null, zt = null, Pt = Q, Jt = (Q = 0), ir = null;
        Pt !== null && Jt < ue.length;
        Jt++
      ) {
        Pt.index > Jt ? ((ir = Pt), (Pt = null)) : (ir = Pt.sibling);
        var Zt = xt(oe, Pt, ue[Jt], qe);
        if (Zt === null) {
          Pt === null && (Pt = ir);
          break;
        }
        d && Pt && Zt.alternate === null && h(oe, Pt),
          (Q = L(Zt, Q, Jt)),
          zt === null ? (dt = Zt) : (zt.sibling = Zt),
          (zt = Zt),
          (Pt = ir);
      }
      if (Jt === ue.length) return w(oe, Pt), vn && Al(oe, Jt), dt;
      if (Pt === null) {
        for (; Jt < ue.length; Jt++)
          (Pt = Rt(oe, ue[Jt], qe)),
            Pt !== null &&
              ((Q = L(Pt, Q, Jt)),
              zt === null ? (dt = Pt) : (zt.sibling = Pt),
              (zt = Pt));
        return vn && Al(oe, Jt), dt;
      }
      for (Pt = E(oe, Pt); Jt < ue.length; Jt++)
        (ir = on(Pt, oe, Jt, ue[Jt], qe)),
          ir !== null &&
            (d &&
              ir.alternate !== null &&
              Pt.delete(ir.key === null ? Jt : ir.key),
            (Q = L(ir, Q, Jt)),
            zt === null ? (dt = ir) : (zt.sibling = ir),
            (zt = ir));
      return (
        d &&
          Pt.forEach(function (va) {
            return h(oe, va);
          }),
        vn && Al(oe, Jt),
        dt
      );
    }
    function Er(oe, Q, ue, qe) {
      var dt = A(ue);
      if (typeof dt != "function") throw Error(o(150));
      if (((ue = dt.call(ue)), ue == null)) throw Error(o(151));
      for (
        var zt = (dt = null), Pt = Q, Jt = (Q = 0), ir = null, Zt = ue.next();
        Pt !== null && !Zt.done;
        Jt++, Zt = ue.next()
      ) {
        Pt.index > Jt ? ((ir = Pt), (Pt = null)) : (ir = Pt.sibling);
        var va = xt(oe, Pt, Zt.value, qe);
        if (va === null) {
          Pt === null && (Pt = ir);
          break;
        }
        d && Pt && va.alternate === null && h(oe, Pt),
          (Q = L(va, Q, Jt)),
          zt === null ? (dt = va) : (zt.sibling = va),
          (zt = va),
          (Pt = ir);
      }
      if (Zt.done) return w(oe, Pt), vn && Al(oe, Jt), dt;
      if (Pt === null) {
        for (; !Zt.done; Jt++, Zt = ue.next())
          (Zt = Rt(oe, Zt.value, qe)),
            Zt !== null &&
              ((Q = L(Zt, Q, Jt)),
              zt === null ? (dt = Zt) : (zt.sibling = Zt),
              (zt = Zt));
        return vn && Al(oe, Jt), dt;
      }
      for (Pt = E(oe, Pt); !Zt.done; Jt++, Zt = ue.next())
        (Zt = on(Pt, oe, Jt, Zt.value, qe)),
          Zt !== null &&
            (d &&
              Zt.alternate !== null &&
              Pt.delete(Zt.key === null ? Jt : Zt.key),
            (Q = L(Zt, Q, Jt)),
            zt === null ? (dt = Zt) : (zt.sibling = Zt),
            (zt = Zt));
      return (
        d &&
          Pt.forEach(function (eH) {
            return h(oe, eH);
          }),
        vn && Al(oe, Jt),
        dt
      );
    }
    function Xi(oe, Q, ue, qe) {
      if (
        (typeof ue == "object" &&
          ue !== null &&
          ue.type === u &&
          ue.key === null &&
          (ue = ue.props.children),
        typeof ue == "object" && ue !== null)
      ) {
        switch (ue.$$typeof) {
          case l:
            e: {
              for (var dt = ue.key, zt = Q; zt !== null; ) {
                if (zt.key === dt) {
                  if (((dt = ue.type), dt === u)) {
                    if (zt.tag === 7) {
                      w(oe, zt.sibling),
                        (Q = M(zt, ue.props.children)),
                        (Q.return = oe),
                        (oe = Q);
                      break e;
                    }
                  } else if (
                    zt.elementType === dt ||
                    (typeof dt == "object" &&
                      dt !== null &&
                      dt.$$typeof === S &&
                      PA(dt) === zt.type)
                  ) {
                    w(oe, zt.sibling),
                      (Q = M(zt, ue.props)),
                      (Q.ref = Vh(oe, zt, ue)),
                      (Q.return = oe),
                      (oe = Q);
                    break e;
                  }
                  w(oe, zt);
                  break;
                } else h(oe, zt);
                zt = zt.sibling;
              }
              ue.type === u
                ? ((Q = Dl(ue.props.children, oe.mode, qe, ue.key)),
                  (Q.return = oe),
                  (oe = Q))
                : ((qe = Ag(ue.type, ue.key, ue.props, null, oe.mode, qe)),
                  (qe.ref = Vh(oe, Q, ue)),
                  (qe.return = oe),
                  (oe = qe));
            }
            return V(oe);
          case c:
            e: {
              for (zt = ue.key; Q !== null; ) {
                if (Q.key === zt)
                  if (
                    Q.tag === 4 &&
                    Q.stateNode.containerInfo === ue.containerInfo &&
                    Q.stateNode.implementation === ue.implementation
                  ) {
                    w(oe, Q.sibling),
                      (Q = M(Q, ue.children || [])),
                      (Q.return = oe),
                      (oe = Q);
                    break e;
                  } else {
                    w(oe, Q);
                    break;
                  }
                else h(oe, Q);
                Q = Q.sibling;
              }
              (Q = Dw(ue, oe.mode, qe)), (Q.return = oe), (oe = Q);
            }
            return V(oe);
          case S:
            return (zt = ue._init), Xi(oe, Q, zt(ue._payload), qe);
        }
        if (Z(ue)) return ht(oe, Q, ue, qe);
        if (A(ue)) return Er(oe, Q, ue, qe);
        Jm(oe, ue);
      }
      return (typeof ue == "string" && ue !== "") || typeof ue == "number"
        ? ((ue = "" + ue),
          Q !== null && Q.tag === 6
            ? (w(oe, Q.sibling), (Q = M(Q, ue)), (Q.return = oe), (oe = Q))
            : (w(oe, Q), (Q = Ow(ue, oe.mode, qe)), (Q.return = oe), (oe = Q)),
          V(oe))
        : w(oe, Q);
    }
    return Xi;
  }
  var uu = IA(!0),
    NA = IA(!1),
    jh = {},
    Hi = at(jh),
    Hh = at(jh),
    du = at(jh);
  function Xs(d) {
    if (d === jh) throw Error(o(174));
    return d;
  }
  function Z_(d, h) {
    pt(du, h), pt(Hh, d), pt(Hi, jh), (d = Y(h)), lt(Hi), pt(Hi, d);
  }
  function hu() {
    lt(Hi), lt(Hh), lt(du);
  }
  function LA(d) {
    var h = Xs(du.current),
      w = Xs(Hi.current);
    (h = U(w, d.type, h)), w !== h && (pt(Hh, d), pt(Hi, h));
  }
  function Q_(d) {
    Hh.current === d && (lt(Hi), lt(Hh));
  }
  var _n = at(0);
  function Zm(d) {
    for (var h = d; h !== null; ) {
      if (h.tag === 13) {
        var w = h.memoizedState;
        if (w !== null && ((w = w.dehydrated), w === null || Fr(w) || ru(w)))
          return h;
      } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
        if (h.flags & 128) return h;
      } else if (h.child !== null) {
        (h.child.return = h), (h = h.child);
        continue;
      }
      if (h === d) break;
      for (; h.sibling === null; ) {
        if (h.return === null || h.return === d) return null;
        h = h.return;
      }
      (h.sibling.return = h.return), (h = h.sibling);
    }
    return null;
  }
  var ew = [];
  function tw() {
    for (var d = 0; d < ew.length; d++) {
      var h = ew[d];
      Fe
        ? (h._workInProgressVersionPrimary = null)
        : (h._workInProgressVersionSecondary = null);
    }
    ew.length = 0;
  }
  var Qm = a.ReactCurrentDispatcher,
    Wi = a.ReactCurrentBatchConfig,
    fu = 0,
    Cn = null,
    wr = null,
    rr = null,
    eg = !1,
    Wh = !1,
    Gh = 0,
    T5 = 0;
  function Sr() {
    throw Error(o(321));
  }
  function nw(d, h) {
    if (h === null) return !1;
    for (var w = 0; w < h.length && w < d.length; w++)
      if (!Ws(d[w], h[w])) return !1;
    return !0;
  }
  function rw(d, h, w, E, M, L) {
    if (
      ((fu = L),
      (Cn = h),
      (h.memoizedState = null),
      (h.updateQueue = null),
      (h.lanes = 0),
      (Qm.current = d === null || d.memoizedState === null ? R5 : P5),
      (d = w(E, M)),
      Wh)
    ) {
      L = 0;
      do {
        if (((Wh = !1), (Gh = 0), 25 <= L)) throw Error(o(301));
        (L += 1),
          (rr = wr = null),
          (h.updateQueue = null),
          (Qm.current = I5),
          (d = w(E, M));
      } while (Wh);
    }
    if (
      ((Qm.current = sg),
      (h = wr !== null && wr.next !== null),
      (fu = 0),
      (rr = wr = Cn = null),
      (eg = !1),
      h)
    )
      throw Error(o(300));
    return d;
  }
  function iw() {
    var d = Gh !== 0;
    return (Gh = 0), d;
  }
  function Ao() {
    var d = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return rr === null ? (Cn.memoizedState = rr = d) : (rr = rr.next = d), rr;
  }
  function qs() {
    if (wr === null) {
      var d = Cn.alternate;
      d = d !== null ? d.memoizedState : null;
    } else d = wr.next;
    var h = rr === null ? Cn.memoizedState : rr.next;
    if (h !== null) (rr = h), (wr = d);
    else {
      if (d === null) throw Error(o(310));
      (wr = d),
        (d = {
          memoizedState: wr.memoizedState,
          baseState: wr.baseState,
          baseQueue: wr.baseQueue,
          queue: wr.queue,
          next: null,
        }),
        rr === null ? (Cn.memoizedState = rr = d) : (rr = rr.next = d);
    }
    return rr;
  }
  function Rl(d, h) {
    return typeof h == "function" ? h(d) : h;
  }
  function tg(d) {
    var h = qs(),
      w = h.queue;
    if (w === null) throw Error(o(311));
    w.lastRenderedReducer = d;
    var E = wr,
      M = E.baseQueue,
      L = w.pending;
    if (L !== null) {
      if (M !== null) {
        var V = M.next;
        (M.next = L.next), (L.next = V);
      }
      (E.baseQueue = M = L), (w.pending = null);
    }
    if (M !== null) {
      (L = M.next), (E = E.baseState);
      var J = (V = null),
        fe = null,
        ke = L;
      do {
        var rt = ke.lane;
        if ((fu & rt) === rt)
          fe !== null &&
            (fe = fe.next =
              {
                lane: 0,
                action: ke.action,
                hasEagerState: ke.hasEagerState,
                eagerState: ke.eagerState,
                next: null,
              }),
            (E = ke.hasEagerState ? ke.eagerState : d(E, ke.action));
        else {
          var Rt = {
            lane: rt,
            action: ke.action,
            hasEagerState: ke.hasEagerState,
            eagerState: ke.eagerState,
            next: null,
          };
          fe === null ? ((J = fe = Rt), (V = E)) : (fe = fe.next = Rt),
            (Cn.lanes |= rt),
            (mu |= rt);
        }
        ke = ke.next;
      } while (ke !== null && ke !== L);
      fe === null ? (V = E) : (fe.next = J),
        Ws(E, h.memoizedState) || (wi = !0),
        (h.memoizedState = E),
        (h.baseState = V),
        (h.baseQueue = fe),
        (w.lastRenderedState = E);
    }
    if (((d = w.interleaved), d !== null)) {
      M = d;
      do (L = M.lane), (Cn.lanes |= L), (mu |= L), (M = M.next);
      while (M !== d);
    } else M === null && (w.lanes = 0);
    return [h.memoizedState, w.dispatch];
  }
  function ng(d) {
    var h = qs(),
      w = h.queue;
    if (w === null) throw Error(o(311));
    w.lastRenderedReducer = d;
    var E = w.dispatch,
      M = w.pending,
      L = h.memoizedState;
    if (M !== null) {
      w.pending = null;
      var V = (M = M.next);
      do (L = d(L, V.action)), (V = V.next);
      while (V !== M);
      Ws(L, h.memoizedState) || (wi = !0),
        (h.memoizedState = L),
        h.baseQueue === null && (h.baseState = L),
        (w.lastRenderedState = L);
    }
    return [L, E];
  }
  function OA() {}
  function DA(d, h) {
    var w = Cn,
      E = qs(),
      M = h(),
      L = !Ws(E.memoizedState, M);
    if (
      (L && ((E.memoizedState = M), (wi = !0)),
      (E = E.queue),
      Xh(FA.bind(null, w, E, d), [d]),
      E.getSnapshot !== h || L || (rr !== null && rr.memoizedState.tag & 1))
    ) {
      if (
        ((w.flags |= 2048),
        $h(9, UA.bind(null, w, E, M, h), void 0, null),
        zn === null)
      )
        throw Error(o(349));
      fu & 30 || kA(w, h, M);
    }
    return M;
  }
  function kA(d, h, w) {
    (d.flags |= 16384),
      (d = { getSnapshot: h, value: w }),
      (h = Cn.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (Cn.updateQueue = h),
          (h.stores = [d]))
        : ((w = h.stores), w === null ? (h.stores = [d]) : w.push(d));
  }
  function UA(d, h, w, E) {
    (h.value = w), (h.getSnapshot = E), BA(h) && Gi(d, 1, -1);
  }
  function FA(d, h, w) {
    return w(function () {
      BA(h) && Gi(d, 1, -1);
    });
  }
  function BA(d) {
    var h = d.getSnapshot;
    d = d.value;
    try {
      var w = h();
      return !Ws(d, w);
    } catch {
      return !0;
    }
  }
  function sw(d) {
    var h = Ao();
    return (
      typeof d == "function" && (d = d()),
      (h.memoizedState = h.baseState = d),
      (d = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Rl,
        lastRenderedState: d,
      }),
      (h.queue = d),
      (d = d.dispatch = A5.bind(null, Cn, d)),
      [h.memoizedState, d]
    );
  }
  function $h(d, h, w, E) {
    return (
      (d = { tag: d, create: h, destroy: w, deps: E, next: null }),
      (h = Cn.updateQueue),
      h === null
        ? ((h = { lastEffect: null, stores: null }),
          (Cn.updateQueue = h),
          (h.lastEffect = d.next = d))
        : ((w = h.lastEffect),
          w === null
            ? (h.lastEffect = d.next = d)
            : ((E = w.next), (w.next = d), (d.next = E), (h.lastEffect = d))),
      d
    );
  }
  function zA() {
    return qs().memoizedState;
  }
  function rg(d, h, w, E) {
    var M = Ao();
    (Cn.flags |= d),
      (M.memoizedState = $h(1 | h, w, void 0, E === void 0 ? null : E));
  }
  function ig(d, h, w, E) {
    var M = qs();
    E = E === void 0 ? null : E;
    var L = void 0;
    if (wr !== null) {
      var V = wr.memoizedState;
      if (((L = V.destroy), E !== null && nw(E, V.deps))) {
        M.memoizedState = $h(h, w, L, E);
        return;
      }
    }
    (Cn.flags |= d), (M.memoizedState = $h(1 | h, w, L, E));
  }
  function ow(d, h) {
    return rg(8390656, 8, d, h);
  }
  function Xh(d, h) {
    return ig(2048, 8, d, h);
  }
  function VA(d, h) {
    return ig(4, 2, d, h);
  }
  function jA(d, h) {
    return ig(4, 4, d, h);
  }
  function HA(d, h) {
    if (typeof h == "function")
      return (
        (d = d()),
        h(d),
        function () {
          h(null);
        }
      );
    if (h != null)
      return (
        (d = d()),
        (h.current = d),
        function () {
          h.current = null;
        }
      );
  }
  function WA(d, h, w) {
    return (
      (w = w != null ? w.concat([d]) : null), ig(4, 4, HA.bind(null, h, d), w)
    );
  }
  function aw() {}
  function GA(d, h) {
    var w = qs();
    h = h === void 0 ? null : h;
    var E = w.memoizedState;
    return E !== null && h !== null && nw(h, E[1])
      ? E[0]
      : ((w.memoizedState = [d, h]), d);
  }
  function $A(d, h) {
    var w = qs();
    h = h === void 0 ? null : h;
    var E = w.memoizedState;
    return E !== null && h !== null && nw(h, E[1])
      ? E[0]
      : ((d = d()), (w.memoizedState = [d, h]), d);
  }
  function M5(d, h) {
    var w = Yt;
    (Yt = w !== 0 && 4 > w ? w : 4), d(!0);
    var E = Wi.transition;
    Wi.transition = {};
    try {
      d(!1), h();
    } finally {
      (Yt = w), (Wi.transition = E);
    }
  }
  function XA() {
    return qs().memoizedState;
  }
  function C5(d, h, w) {
    var E = pa(d);
    (w = {
      lane: E,
      action: w,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      qA(d)
        ? KA(h, w)
        : (YA(d, h, w),
          (w = zr()),
          (d = Gi(d, E, w)),
          d !== null && JA(d, h, E));
  }
  function A5(d, h, w) {
    var E = pa(d),
      M = {
        lane: E,
        action: w,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (qA(d)) KA(h, M);
    else {
      YA(d, h, M);
      var L = d.alternate;
      if (
        d.lanes === 0 &&
        (L === null || L.lanes === 0) &&
        ((L = h.lastRenderedReducer), L !== null)
      )
        try {
          var V = h.lastRenderedState,
            J = L(V, w);
          if (((M.hasEagerState = !0), (M.eagerState = J), Ws(J, V))) return;
        } catch {
        } finally {
        }
      (w = zr()), (d = Gi(d, E, w)), d !== null && JA(d, h, E);
    }
  }
  function qA(d) {
    var h = d.alternate;
    return d === Cn || (h !== null && h === Cn);
  }
  function KA(d, h) {
    Wh = eg = !0;
    var w = d.pending;
    w === null ? (h.next = h) : ((h.next = w.next), (w.next = h)),
      (d.pending = h);
  }
  function YA(d, h, w) {
    zn !== null && d.mode & 1 && !(Vt & 2)
      ? ((d = h.interleaved),
        d === null
          ? ((w.next = w), $s === null ? ($s = [h]) : $s.push(h))
          : ((w.next = d.next), (d.next = w)),
        (h.interleaved = w))
      : ((d = h.pending),
        d === null ? (w.next = w) : ((w.next = d.next), (d.next = w)),
        (h.pending = w));
  }
  function JA(d, h, w) {
    if (w & 4194240) {
      var E = h.lanes;
      (E &= d.pendingLanes), (w |= E), (h.lanes = w), D_(d, w);
    }
  }
  var sg = {
      readContext: zi,
      useCallback: Sr,
      useContext: Sr,
      useEffect: Sr,
      useImperativeHandle: Sr,
      useInsertionEffect: Sr,
      useLayoutEffect: Sr,
      useMemo: Sr,
      useReducer: Sr,
      useRef: Sr,
      useState: Sr,
      useDebugValue: Sr,
      useDeferredValue: Sr,
      useTransition: Sr,
      useMutableSource: Sr,
      useSyncExternalStore: Sr,
      useId: Sr,
      unstable_isNewReconciler: !1,
    },
    R5 = {
      readContext: zi,
      useCallback: function (d, h) {
        return (Ao().memoizedState = [d, h === void 0 ? null : h]), d;
      },
      useContext: zi,
      useEffect: ow,
      useImperativeHandle: function (d, h, w) {
        return (
          (w = w != null ? w.concat([d]) : null),
          rg(4194308, 4, HA.bind(null, h, d), w)
        );
      },
      useLayoutEffect: function (d, h) {
        return rg(4194308, 4, d, h);
      },
      useInsertionEffect: function (d, h) {
        return rg(4, 2, d, h);
      },
      useMemo: function (d, h) {
        var w = Ao();
        return (
          (h = h === void 0 ? null : h),
          (d = d()),
          (w.memoizedState = [d, h]),
          d
        );
      },
      useReducer: function (d, h, w) {
        var E = Ao();
        return (
          (h = w !== void 0 ? w(h) : h),
          (E.memoizedState = E.baseState = h),
          (d = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: d,
            lastRenderedState: h,
          }),
          (E.queue = d),
          (d = d.dispatch = C5.bind(null, Cn, d)),
          [E.memoizedState, d]
        );
      },
      useRef: function (d) {
        var h = Ao();
        return (d = { current: d }), (h.memoizedState = d);
      },
      useState: sw,
      useDebugValue: aw,
      useDeferredValue: function (d) {
        var h = sw(d),
          w = h[0],
          E = h[1];
        return (
          ow(
            function () {
              var M = Wi.transition;
              Wi.transition = {};
              try {
                E(d);
              } finally {
                Wi.transition = M;
              }
            },
            [d]
          ),
          w
        );
      },
      useTransition: function () {
        var d = sw(!1),
          h = d[0];
        return (d = M5.bind(null, d[1])), (Ao().memoizedState = d), [h, d];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (d, h, w) {
        var E = Cn,
          M = Ao();
        if (vn) {
          if (w === void 0) throw Error(o(407));
          w = w();
        } else {
          if (((w = h()), zn === null)) throw Error(o(349));
          fu & 30 || kA(E, h, w);
        }
        M.memoizedState = w;
        var L = { value: w, getSnapshot: h };
        return (
          (M.queue = L),
          ow(FA.bind(null, E, L, d), [d]),
          (E.flags |= 2048),
          $h(9, UA.bind(null, E, L, w, h), void 0, null),
          w
        );
      },
      useId: function () {
        var d = Ao(),
          h = zn.identifierPrefix;
        if (vn) {
          var w = Co,
            E = Mo;
          (w = (E & ~(1 << (32 - gn(E) - 1))).toString(32) + w),
            (h = ":" + h + "R" + w),
            (w = Gh++),
            0 < w && (h += "H" + w.toString(32)),
            (h += ":");
        } else (w = T5++), (h = ":" + h + "r" + w.toString(32) + ":");
        return (d.memoizedState = h);
      },
      unstable_isNewReconciler: !1,
    },
    P5 = {
      readContext: zi,
      useCallback: GA,
      useContext: zi,
      useEffect: Xh,
      useImperativeHandle: WA,
      useInsertionEffect: VA,
      useLayoutEffect: jA,
      useMemo: $A,
      useReducer: tg,
      useRef: zA,
      useState: function () {
        return tg(Rl);
      },
      useDebugValue: aw,
      useDeferredValue: function (d) {
        var h = tg(Rl),
          w = h[0],
          E = h[1];
        return (
          Xh(
            function () {
              var M = Wi.transition;
              Wi.transition = {};
              try {
                E(d);
              } finally {
                Wi.transition = M;
              }
            },
            [d]
          ),
          w
        );
      },
      useTransition: function () {
        var d = tg(Rl)[0],
          h = qs().memoizedState;
        return [d, h];
      },
      useMutableSource: OA,
      useSyncExternalStore: DA,
      useId: XA,
      unstable_isNewReconciler: !1,
    },
    I5 = {
      readContext: zi,
      useCallback: GA,
      useContext: zi,
      useEffect: Xh,
      useImperativeHandle: WA,
      useInsertionEffect: VA,
      useLayoutEffect: jA,
      useMemo: $A,
      useReducer: ng,
      useRef: zA,
      useState: function () {
        return ng(Rl);
      },
      useDebugValue: aw,
      useDeferredValue: function (d) {
        var h = ng(Rl),
          w = h[0],
          E = h[1];
        return (
          Xh(
            function () {
              var M = Wi.transition;
              Wi.transition = {};
              try {
                E(d);
              } finally {
                Wi.transition = M;
              }
            },
            [d]
          ),
          w
        );
      },
      useTransition: function () {
        var d = ng(Rl)[0],
          h = qs().memoizedState;
        return [d, h];
      },
      useMutableSource: OA,
      useSyncExternalStore: DA,
      useId: XA,
      unstable_isNewReconciler: !1,
    };
  function lw(d, h) {
    try {
      var w = "",
        E = h;
      do (w += E5(E)), (E = E.return);
      while (E);
      var M = w;
    } catch (L) {
      M =
        `
Error generating stack: ` +
        L.message +
        `
` +
        L.stack;
    }
    return { value: d, source: h, stack: M };
  }
  function cw(d, h) {
    try {
      console.error(h.value);
    } catch (w) {
      setTimeout(function () {
        throw w;
      });
    }
  }
  var N5 = typeof WeakMap == "function" ? WeakMap : Map;
  function ZA(d, h, w) {
    (w = To(-1, w)), (w.tag = 3), (w.payload = { element: null });
    var E = h.value;
    return (
      (w.callback = function () {
        wg || ((wg = !0), (Cw = E)), cw(d, h);
      }),
      w
    );
  }
  function QA(d, h, w) {
    (w = To(-1, w)), (w.tag = 3);
    var E = d.type.getDerivedStateFromError;
    if (typeof E == "function") {
      var M = h.value;
      (w.payload = function () {
        return E(M);
      }),
        (w.callback = function () {
          cw(d, h);
        });
    }
    var L = d.stateNode;
    return (
      L !== null &&
        typeof L.componentDidCatch == "function" &&
        (w.callback = function () {
          cw(d, h),
            typeof E != "function" &&
              (ha === null ? (ha = new Set([this])) : ha.add(this));
          var V = h.stack;
          this.componentDidCatch(h.value, {
            componentStack: V !== null ? V : "",
          });
        }),
      w
    );
  }
  function eR(d, h, w) {
    var E = d.pingCache;
    if (E === null) {
      E = d.pingCache = new N5();
      var M = new Set();
      E.set(h, M);
    } else (M = E.get(h)), M === void 0 && ((M = new Set()), E.set(h, M));
    M.has(w) || (M.add(w), (d = $5.bind(null, d, h, w)), h.then(d, d));
  }
  function tR(d) {
    do {
      var h;
      if (
        ((h = d.tag === 13) &&
          ((h = d.memoizedState),
          (h = h !== null ? h.dehydrated !== null : !0)),
        h)
      )
        return d;
      d = d.return;
    } while (d !== null);
    return null;
  }
  function nR(d, h, w, E, M) {
    return d.mode & 1
      ? ((d.flags |= 65536), (d.lanes = M), d)
      : (d === h
          ? (d.flags |= 65536)
          : ((d.flags |= 128),
            (w.flags |= 131072),
            (w.flags &= -52805),
            w.tag === 1 &&
              (w.alternate === null
                ? (w.tag = 17)
                : ((h = To(-1, 1)), (h.tag = 2), da(w, h))),
            (w.lanes |= 1)),
        d);
  }
  function Ks(d) {
    d.flags |= 4;
  }
  function rR(d, h) {
    if (d !== null && d.child === h.child) return !0;
    if (h.flags & 16) return !1;
    for (d = h.child; d !== null; ) {
      if (d.flags & 12854 || d.subtreeFlags & 12854) return !1;
      d = d.sibling;
    }
    return !0;
  }
  var qh, Kh, og, ag;
  if (Ke)
    (qh = function (d, h) {
      for (var w = h.child; w !== null; ) {
        if (w.tag === 5 || w.tag === 6) de(d, w.stateNode);
        else if (w.tag !== 4 && w.child !== null) {
          (w.child.return = w), (w = w.child);
          continue;
        }
        if (w === h) break;
        for (; w.sibling === null; ) {
          if (w.return === null || w.return === h) return;
          w = w.return;
        }
        (w.sibling.return = w.return), (w = w.sibling);
      }
    }),
      (Kh = function () {}),
      (og = function (d, h, w, E, M) {
        if (((d = d.memoizedProps), d !== E)) {
          var L = h.stateNode,
            V = Xs(Hi.current);
          (w = Ie(L, w, d, E, M, V)), (h.updateQueue = w) && Ks(h);
        }
      }),
      (ag = function (d, h, w, E) {
        w !== E && Ks(h);
      });
  else if (Ve) {
    qh = function (d, h, w, E) {
      for (var M = h.child; M !== null; ) {
        if (M.tag === 5) {
          var L = M.stateNode;
          w && E && (L = At(L, M.type, M.memoizedProps, M)), de(d, L);
        } else if (M.tag === 6)
          (L = M.stateNode),
            w && E && (L = mn(L, M.memoizedProps, M)),
            de(d, L);
        else if (M.tag !== 4) {
          if (M.tag === 22 && M.memoizedState !== null)
            (L = M.child), L !== null && (L.return = M), qh(d, M, !0, !0);
          else if (M.child !== null) {
            (M.child.return = M), (M = M.child);
            continue;
          }
        }
        if (M === h) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === h) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      }
    };
    var iR = function (d, h, w, E) {
      for (var M = h.child; M !== null; ) {
        if (M.tag === 5) {
          var L = M.stateNode;
          w && E && (L = At(L, M.type, M.memoizedProps, M)), be(d, L);
        } else if (M.tag === 6)
          (L = M.stateNode),
            w && E && (L = mn(L, M.memoizedProps, M)),
            be(d, L);
        else if (M.tag !== 4) {
          if (M.tag === 22 && M.memoizedState !== null)
            (L = M.child), L !== null && (L.return = M), iR(d, M, !0, !0);
          else if (M.child !== null) {
            (M.child.return = M), (M = M.child);
            continue;
          }
        }
        if (M === h) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === h) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      }
    };
    (Kh = function (d, h) {
      var w = h.stateNode;
      if (!rR(d, h)) {
        d = w.containerInfo;
        var E = ye(d);
        iR(E, h, !1, !1), (w.pendingChildren = E), Ks(h), $e(d, E);
      }
    }),
      (og = function (d, h, w, E, M) {
        var L = d.stateNode,
          V = d.memoizedProps;
        if ((d = rR(d, h)) && V === E) h.stateNode = L;
        else {
          var J = h.stateNode,
            fe = Xs(Hi.current),
            ke = null;
          V !== E && (ke = Ie(J, w, V, E, M, fe)),
            d && ke === null
              ? (h.stateNode = L)
              : ((L = Me(L, ke, w, V, E, h, d, J)),
                Ee(L, w, E, M, fe) && Ks(h),
                (h.stateNode = L),
                d ? Ks(h) : qh(L, h, !1, !1));
        }
      }),
      (ag = function (d, h, w, E) {
        w !== E
          ? ((d = Xs(du.current)),
            (w = Xs(Hi.current)),
            (h.stateNode = _e(E, d, w, h)),
            Ks(h))
          : (h.stateNode = d.stateNode);
      });
  } else (Kh = function () {}), (og = function () {}), (ag = function () {});
  function Yh(d, h) {
    if (!vn)
      switch (d.tailMode) {
        case "hidden":
          h = d.tail;
          for (var w = null; h !== null; )
            h.alternate !== null && (w = h), (h = h.sibling);
          w === null ? (d.tail = null) : (w.sibling = null);
          break;
        case "collapsed":
          w = d.tail;
          for (var E = null; w !== null; )
            w.alternate !== null && (E = w), (w = w.sibling);
          E === null
            ? h || d.tail === null
              ? (d.tail = null)
              : (d.tail.sibling = null)
            : (E.sibling = null);
      }
  }
  function br(d) {
    var h = d.alternate !== null && d.alternate.child === d.child,
      w = 0,
      E = 0;
    if (h)
      for (var M = d.child; M !== null; )
        (w |= M.lanes | M.childLanes),
          (E |= M.subtreeFlags & 14680064),
          (E |= M.flags & 14680064),
          (M.return = d),
          (M = M.sibling);
    else
      for (M = d.child; M !== null; )
        (w |= M.lanes | M.childLanes),
          (E |= M.subtreeFlags),
          (E |= M.flags),
          (M.return = d),
          (M = M.sibling);
    return (d.subtreeFlags |= E), (d.childLanes = w), h;
  }
  function L5(d, h, w) {
    var E = h.pendingProps;
    switch ((q_(h), h.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return br(h), null;
      case 1:
        return Mt(h.type) && tr(), br(h), null;
      case 3:
        return (
          (E = h.stateNode),
          hu(),
          lt(Ot),
          lt(Lt),
          tw(),
          E.pendingContext &&
            ((E.context = E.pendingContext), (E.pendingContext = null)),
          (d === null || d.child === null) &&
            (zh(h)
              ? Ks(h)
              : d === null ||
                (d.memoizedState.isDehydrated && !(h.flags & 256)) ||
                ((h.flags |= 1024), hs !== null && (Pw(hs), (hs = null)))),
          Kh(d, h),
          br(h),
          null
        );
      case 5:
        Q_(h), (w = Xs(du.current));
        var M = h.type;
        if (d !== null && h.stateNode != null)
          og(d, h, M, E, w),
            d.ref !== h.ref && ((h.flags |= 512), (h.flags |= 2097152));
        else {
          if (!E) {
            if (h.stateNode === null) throw Error(o(166));
            return br(h), null;
          }
          if (((d = Xs(Hi.current)), zh(h))) {
            if (!W) throw Error(o(175));
            (d = Fm(h.stateNode, h.type, h.memoizedProps, w, d, h, !Bh)),
              (h.updateQueue = d),
              d !== null && Ks(h);
          } else {
            var L = ie(M, E, w, d, h);
            qh(L, h, !1, !1), (h.stateNode = L), Ee(L, M, E, w, d) && Ks(h);
          }
          h.ref !== null && ((h.flags |= 512), (h.flags |= 2097152));
        }
        return br(h), null;
      case 6:
        if (d && h.stateNode != null) ag(d, h, d.memoizedProps, E);
        else {
          if (typeof E != "string" && h.stateNode === null) throw Error(o(166));
          if (((d = Xs(du.current)), (w = Xs(Hi.current)), zh(h))) {
            if (!W) throw Error(o(176));
            if (
              ((d = h.stateNode),
              (E = h.memoizedProps),
              (w = A_(d, E, h, !Bh)) && ((M = xi), M !== null))
            )
              switch (((L = (M.mode & 1) !== 0), M.tag)) {
                case 3:
                  le(M.stateNode.containerInfo, d, E, L);
                  break;
                case 5:
                  ce(M.type, M.memoizedProps, M.stateNode, d, E, L);
              }
            w && Ks(h);
          } else h.stateNode = _e(E, d, w, h);
        }
        return br(h), null;
      case 13:
        if (
          (lt(_n),
          (E = h.memoizedState),
          vn && _i !== null && h.mode & 1 && !(h.flags & 128))
        ) {
          for (d = _i; d; ) d = Vs(d);
          return cu(), (h.flags |= 98560), h;
        }
        if (E !== null && E.dehydrated !== null) {
          if (((E = zh(h)), d === null)) {
            if (!E) throw Error(o(318));
            if (!W) throw Error(o(344));
            if (
              ((d = h.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(o(317));
            R_(d, h);
          } else
            cu(), !(h.flags & 128) && (h.memoizedState = null), (h.flags |= 4);
          return br(h), null;
        }
        return (
          hs !== null && (Pw(hs), (hs = null)),
          h.flags & 128
            ? ((h.lanes = w), h)
            : ((E = E !== null),
              (w = !1),
              d === null ? zh(h) : (w = d.memoizedState !== null),
              E &&
                !w &&
                ((h.child.flags |= 8192),
                h.mode & 1 &&
                  (d === null || _n.current & 1 ? qn === 0 && (qn = 3) : Nw())),
              h.updateQueue !== null && (h.flags |= 4),
              br(h),
              null)
        );
      case 4:
        return (
          hu(),
          Kh(d, h),
          d === null && pe(h.stateNode.containerInfo),
          br(h),
          null
        );
      case 10:
        return j_(h.type._context), br(h), null;
      case 17:
        return Mt(h.type) && tr(), br(h), null;
      case 19:
        if ((lt(_n), (M = h.memoizedState), M === null)) return br(h), null;
        if (((E = (h.flags & 128) !== 0), (L = M.rendering), L === null))
          if (E) Yh(M, !1);
          else {
            if (qn !== 0 || (d !== null && d.flags & 128))
              for (d = h.child; d !== null; ) {
                if (((L = Zm(d)), L !== null)) {
                  for (
                    h.flags |= 128,
                      Yh(M, !1),
                      d = L.updateQueue,
                      d !== null && ((h.updateQueue = d), (h.flags |= 4)),
                      h.subtreeFlags = 0,
                      d = w,
                      E = h.child;
                    E !== null;

                  )
                    (w = E),
                      (M = d),
                      (w.flags &= 14680066),
                      (L = w.alternate),
                      L === null
                        ? ((w.childLanes = 0),
                          (w.lanes = M),
                          (w.child = null),
                          (w.subtreeFlags = 0),
                          (w.memoizedProps = null),
                          (w.memoizedState = null),
                          (w.updateQueue = null),
                          (w.dependencies = null),
                          (w.stateNode = null))
                        : ((w.childLanes = L.childLanes),
                          (w.lanes = L.lanes),
                          (w.child = L.child),
                          (w.subtreeFlags = 0),
                          (w.deletions = null),
                          (w.memoizedProps = L.memoizedProps),
                          (w.memoizedState = L.memoizedState),
                          (w.updateQueue = L.updateQueue),
                          (w.type = L.type),
                          (M = L.dependencies),
                          (w.dependencies =
                            M === null
                              ? null
                              : {
                                  lanes: M.lanes,
                                  firstContext: M.firstContext,
                                })),
                      (E = E.sibling);
                  return pt(_n, (_n.current & 1) | 2), h.child;
                }
                d = d.sibling;
              }
            M.tail !== null &&
              nr() > Mw &&
              ((h.flags |= 128), (E = !0), Yh(M, !1), (h.lanes = 4194304));
          }
        else {
          if (!E)
            if (((d = Zm(L)), d !== null)) {
              if (
                ((h.flags |= 128),
                (E = !0),
                (d = d.updateQueue),
                d !== null && ((h.updateQueue = d), (h.flags |= 4)),
                Yh(M, !0),
                M.tail === null &&
                  M.tailMode === "hidden" &&
                  !L.alternate &&
                  !vn)
              )
                return br(h), null;
            } else
              2 * nr() - M.renderingStartTime > Mw &&
                w !== 1073741824 &&
                ((h.flags |= 128), (E = !0), Yh(M, !1), (h.lanes = 4194304));
          M.isBackwards
            ? ((L.sibling = h.child), (h.child = L))
            : ((d = M.last),
              d !== null ? (d.sibling = L) : (h.child = L),
              (M.last = L));
        }
        return M.tail !== null
          ? ((h = M.tail),
            (M.rendering = h),
            (M.tail = h.sibling),
            (M.renderingStartTime = nr()),
            (h.sibling = null),
            (d = _n.current),
            pt(_n, E ? (d & 1) | 2 : d & 1),
            h)
          : (br(h), null);
      case 22:
      case 23:
        return (
          Iw(),
          (E = h.memoizedState !== null),
          d !== null && (d.memoizedState !== null) !== E && (h.flags |= 8192),
          E && h.mode & 1
            ? Si & 1073741824 &&
              (br(h), Ke && h.subtreeFlags & 6 && (h.flags |= 8192))
            : br(h),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, h.tag));
  }
  var O5 = a.ReactCurrentOwner,
    wi = !1;
  function Br(d, h, w, E) {
    h.child = d === null ? NA(h, null, w, E) : uu(h, d.child, w, E);
  }
  function sR(d, h, w, E, M) {
    w = w.render;
    var L = h.ref;
    return (
      ou(h, M),
      (E = rw(d, h, w, E, L, M)),
      (w = iw()),
      d !== null && !wi
        ? ((h.updateQueue = d.updateQueue),
          (h.flags &= -2053),
          (d.lanes &= ~M),
          Ro(d, h, M))
        : (vn && w && X_(h), (h.flags |= 1), Br(d, h, E, M), h.child)
    );
  }
  function oR(d, h, w, E, M) {
    if (d === null) {
      var L = w.type;
      return typeof L == "function" &&
        !Lw(L) &&
        L.defaultProps === void 0 &&
        w.compare === null &&
        w.defaultProps === void 0
        ? ((h.tag = 15), (h.type = L), aR(d, h, L, E, M))
        : ((d = Ag(w.type, null, E, h, h.mode, M)),
          (d.ref = h.ref),
          (d.return = h),
          (h.child = d));
    }
    if (((L = d.child), !(d.lanes & M))) {
      var V = L.memoizedProps;
      if (
        ((w = w.compare), (w = w !== null ? w : Hm), w(V, E) && d.ref === h.ref)
      )
        return Ro(d, h, M);
    }
    return (
      (h.flags |= 1),
      (d = ga(L, E)),
      (d.ref = h.ref),
      (d.return = h),
      (h.child = d)
    );
  }
  function aR(d, h, w, E, M) {
    if (d !== null && Hm(d.memoizedProps, E) && d.ref === h.ref)
      if (((wi = !1), (d.lanes & M) !== 0)) d.flags & 131072 && (wi = !0);
      else return (h.lanes = d.lanes), Ro(d, h, M);
    return uw(d, h, w, E, M);
  }
  function lR(d, h, w) {
    var E = h.pendingProps,
      M = E.children,
      L = d !== null ? d.memoizedState : null;
    if (E.mode === "hidden")
      if (!(h.mode & 1))
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          pt(pu, Si),
          (Si |= w);
      else if (w & 1073741824)
        (h.memoizedState = { baseLanes: 0, cachePool: null }),
          (E = L !== null ? L.baseLanes : w),
          pt(pu, Si),
          (Si |= E);
      else
        return (
          (d = L !== null ? L.baseLanes | w : w),
          (h.lanes = h.childLanes = 1073741824),
          (h.memoizedState = { baseLanes: d, cachePool: null }),
          (h.updateQueue = null),
          pt(pu, Si),
          (Si |= d),
          null
        );
    else
      L !== null ? ((E = L.baseLanes | w), (h.memoizedState = null)) : (E = w),
        pt(pu, Si),
        (Si |= E);
    return Br(d, h, M, w), h.child;
  }
  function cR(d, h) {
    var w = h.ref;
    ((d === null && w !== null) || (d !== null && d.ref !== w)) &&
      ((h.flags |= 512), (h.flags |= 2097152));
  }
  function uw(d, h, w, E, M) {
    var L = Mt(w) ? ut : Lt.current;
    return (
      (L = tn(h, L)),
      ou(h, M),
      (w = rw(d, h, w, E, L, M)),
      (E = iw()),
      d !== null && !wi
        ? ((h.updateQueue = d.updateQueue),
          (h.flags &= -2053),
          (d.lanes &= ~M),
          Ro(d, h, M))
        : (vn && E && X_(h), (h.flags |= 1), Br(d, h, w, M), h.child)
    );
  }
  function uR(d, h, w, E, M) {
    if (Mt(w)) {
      var L = !0;
      js(h);
    } else L = !1;
    if ((ou(h, M), h.stateNode === null))
      d !== null &&
        ((d.alternate = null), (h.alternate = null), (h.flags |= 2)),
        EA(h, w, E),
        $_(h, w, E, M),
        (E = !0);
    else if (d === null) {
      var V = h.stateNode,
        J = h.memoizedProps;
      V.props = J;
      var fe = V.context,
        ke = w.contextType;
      typeof ke == "object" && ke !== null
        ? (ke = zi(ke))
        : ((ke = Mt(w) ? ut : Lt.current), (ke = tn(h, ke)));
      var rt = w.getDerivedStateFromProps,
        Rt =
          typeof rt == "function" ||
          typeof V.getSnapshotBeforeUpdate == "function";
      Rt ||
        (typeof V.UNSAFE_componentWillReceiveProps != "function" &&
          typeof V.componentWillReceiveProps != "function") ||
        ((J !== E || fe !== ke) && TA(h, V, E, ke)),
        (ua = !1);
      var xt = h.memoizedState;
      (V.state = xt),
        Xm(h, E, V, M),
        (fe = h.memoizedState),
        J !== E || xt !== fe || Ot.current || ua
          ? (typeof rt == "function" &&
              (G_(h, w, rt, E), (fe = h.memoizedState)),
            (J = ua || bA(h, w, J, E, xt, fe, ke))
              ? (Rt ||
                  (typeof V.UNSAFE_componentWillMount != "function" &&
                    typeof V.componentWillMount != "function") ||
                  (typeof V.componentWillMount == "function" &&
                    V.componentWillMount(),
                  typeof V.UNSAFE_componentWillMount == "function" &&
                    V.UNSAFE_componentWillMount()),
                typeof V.componentDidMount == "function" &&
                  (h.flags |= 4194308))
              : (typeof V.componentDidMount == "function" &&
                  (h.flags |= 4194308),
                (h.memoizedProps = E),
                (h.memoizedState = fe)),
            (V.props = E),
            (V.state = fe),
            (V.context = ke),
            (E = J))
          : (typeof V.componentDidMount == "function" && (h.flags |= 4194308),
            (E = !1));
    } else {
      (V = h.stateNode),
        xA(d, h),
        (J = h.memoizedProps),
        (ke = h.type === h.elementType ? J : ds(h.type, J)),
        (V.props = ke),
        (Rt = h.pendingProps),
        (xt = V.context),
        (fe = w.contextType),
        typeof fe == "object" && fe !== null
          ? (fe = zi(fe))
          : ((fe = Mt(w) ? ut : Lt.current), (fe = tn(h, fe)));
      var on = w.getDerivedStateFromProps;
      (rt =
        typeof on == "function" ||
        typeof V.getSnapshotBeforeUpdate == "function") ||
        (typeof V.UNSAFE_componentWillReceiveProps != "function" &&
          typeof V.componentWillReceiveProps != "function") ||
        ((J !== Rt || xt !== fe) && TA(h, V, E, fe)),
        (ua = !1),
        (xt = h.memoizedState),
        (V.state = xt),
        Xm(h, E, V, M);
      var ht = h.memoizedState;
      J !== Rt || xt !== ht || Ot.current || ua
        ? (typeof on == "function" && (G_(h, w, on, E), (ht = h.memoizedState)),
          (ke = ua || bA(h, w, ke, E, xt, ht, fe) || !1)
            ? (rt ||
                (typeof V.UNSAFE_componentWillUpdate != "function" &&
                  typeof V.componentWillUpdate != "function") ||
                (typeof V.componentWillUpdate == "function" &&
                  V.componentWillUpdate(E, ht, fe),
                typeof V.UNSAFE_componentWillUpdate == "function" &&
                  V.UNSAFE_componentWillUpdate(E, ht, fe)),
              typeof V.componentDidUpdate == "function" && (h.flags |= 4),
              typeof V.getSnapshotBeforeUpdate == "function" &&
                (h.flags |= 1024))
            : (typeof V.componentDidUpdate != "function" ||
                (J === d.memoizedProps && xt === d.memoizedState) ||
                (h.flags |= 4),
              typeof V.getSnapshotBeforeUpdate != "function" ||
                (J === d.memoizedProps && xt === d.memoizedState) ||
                (h.flags |= 1024),
              (h.memoizedProps = E),
              (h.memoizedState = ht)),
          (V.props = E),
          (V.state = ht),
          (V.context = fe),
          (E = ke))
        : (typeof V.componentDidUpdate != "function" ||
            (J === d.memoizedProps && xt === d.memoizedState) ||
            (h.flags |= 4),
          typeof V.getSnapshotBeforeUpdate != "function" ||
            (J === d.memoizedProps && xt === d.memoizedState) ||
            (h.flags |= 1024),
          (E = !1));
    }
    return dw(d, h, w, E, L, M);
  }
  function dw(d, h, w, E, M, L) {
    cR(d, h);
    var V = (h.flags & 128) !== 0;
    if (!E && !V) return M && an(h, w, !1), Ro(d, h, L);
    (E = h.stateNode), (O5.current = h);
    var J =
      V && typeof w.getDerivedStateFromError != "function" ? null : E.render();
    return (
      (h.flags |= 1),
      d !== null && V
        ? ((h.child = uu(h, d.child, null, L)), (h.child = uu(h, null, J, L)))
        : Br(d, h, J, L),
      (h.memoizedState = E.state),
      M && an(h, w, !0),
      h.child
    );
  }
  function dR(d) {
    var h = d.stateNode;
    h.pendingContext
      ? bo(d, h.pendingContext, h.pendingContext !== h.context)
      : h.context && bo(d, h.context, !1),
      Z_(d, h.containerInfo);
  }
  function hR(d, h, w, E, M) {
    return cu(), J_(M), (h.flags |= 256), Br(d, h, w, E), h.child;
  }
  var lg = { dehydrated: null, treeContext: null, retryLane: 0 };
  function cg(d) {
    return { baseLanes: d, cachePool: null };
  }
  function fR(d, h, w) {
    var E = h.pendingProps,
      M = _n.current,
      L = !1,
      V = (h.flags & 128) !== 0,
      J;
    if (
      ((J = V) ||
        (J = d !== null && d.memoizedState === null ? !1 : (M & 2) !== 0),
      J
        ? ((L = !0), (h.flags &= -129))
        : (d === null || d.memoizedState !== null) && (M |= 1),
      pt(_n, M & 1),
      d === null)
    )
      return (
        Y_(h),
        (d = h.memoizedState),
        d !== null && ((d = d.dehydrated), d !== null)
          ? (h.mode & 1
              ? ru(d)
                ? (h.lanes = 8)
                : (h.lanes = 1073741824)
              : (h.lanes = 1),
            null)
          : ((M = E.children),
            (d = E.fallback),
            L
              ? ((E = h.mode),
                (L = h.child),
                (M = { mode: "hidden", children: M }),
                !(E & 1) && L !== null
                  ? ((L.childLanes = 0), (L.pendingProps = M))
                  : (L = Rg(M, E, 0, null)),
                (d = Dl(d, E, w, null)),
                (L.return = h),
                (d.return = h),
                (L.sibling = d),
                (h.child = L),
                (h.child.memoizedState = cg(w)),
                (h.memoizedState = lg),
                d)
              : hw(h, M))
      );
    if (((M = d.memoizedState), M !== null)) {
      if (((J = M.dehydrated), J !== null)) {
        if (V)
          return h.flags & 256
            ? ((h.flags &= -257), ug(d, h, w, Error(o(422))))
            : h.memoizedState !== null
            ? ((h.child = d.child), (h.flags |= 128), null)
            : ((L = E.fallback),
              (M = h.mode),
              (E = Rg({ mode: "visible", children: E.children }, M, 0, null)),
              (L = Dl(L, M, w, null)),
              (L.flags |= 2),
              (E.return = h),
              (L.return = h),
              (E.sibling = L),
              (h.child = E),
              h.mode & 1 && uu(h, d.child, null, w),
              (h.child.memoizedState = cg(w)),
              (h.memoizedState = lg),
              L);
        if (!(h.mode & 1)) h = ug(d, h, w, null);
        else if (ru(J)) h = ug(d, h, w, Error(o(419)));
        else if (((E = (w & d.childLanes) !== 0), wi || E)) {
          if (((E = zn), E !== null)) {
            switch (w & -w) {
              case 4:
                L = 2;
                break;
              case 16:
                L = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                L = 32;
                break;
              case 536870912:
                L = 268435456;
                break;
              default:
                L = 0;
            }
            (E = L & (E.suspendedLanes | w) ? 0 : L),
              E !== 0 && E !== M.retryLane && ((M.retryLane = E), Gi(d, E, -1));
          }
          Nw(), (h = ug(d, h, w, Error(o(421))));
        } else
          Fr(J)
            ? ((h.flags |= 128),
              (h.child = d.child),
              (h = X5.bind(null, d)),
              Dm(J, h),
              (h = null))
            : ((w = M.treeContext),
              W &&
                ((_i = Um(J)),
                (xi = h),
                (vn = !0),
                (hs = null),
                (Bh = !1),
                w !== null &&
                  ((Vi[ji++] = Mo),
                  (Vi[ji++] = Co),
                  (Vi[ji++] = Cl),
                  (Mo = w.id),
                  (Co = w.overflow),
                  (Cl = h))),
              (h = hw(h, h.pendingProps.children)),
              (h.flags |= 4096));
        return h;
      }
      return L
        ? ((E = mR(d, h, E.children, E.fallback, w)),
          (L = h.child),
          (M = d.child.memoizedState),
          (L.memoizedState =
            M === null
              ? cg(w)
              : { baseLanes: M.baseLanes | w, cachePool: null }),
          (L.childLanes = d.childLanes & ~w),
          (h.memoizedState = lg),
          E)
        : ((w = pR(d, h, E.children, w)), (h.memoizedState = null), w);
    }
    return L
      ? ((E = mR(d, h, E.children, E.fallback, w)),
        (L = h.child),
        (M = d.child.memoizedState),
        (L.memoizedState =
          M === null ? cg(w) : { baseLanes: M.baseLanes | w, cachePool: null }),
        (L.childLanes = d.childLanes & ~w),
        (h.memoizedState = lg),
        E)
      : ((w = pR(d, h, E.children, w)), (h.memoizedState = null), w);
  }
  function hw(d, h) {
    return (
      (h = Rg({ mode: "visible", children: h }, d.mode, 0, null)),
      (h.return = d),
      (d.child = h)
    );
  }
  function pR(d, h, w, E) {
    var M = d.child;
    return (
      (d = M.sibling),
      (w = ga(M, { mode: "visible", children: w })),
      !(h.mode & 1) && (w.lanes = E),
      (w.return = h),
      (w.sibling = null),
      d !== null &&
        ((E = h.deletions),
        E === null ? ((h.deletions = [d]), (h.flags |= 16)) : E.push(d)),
      (h.child = w)
    );
  }
  function mR(d, h, w, E, M) {
    var L = h.mode;
    d = d.child;
    var V = d.sibling,
      J = { mode: "hidden", children: w };
    return (
      !(L & 1) && h.child !== d
        ? ((w = h.child),
          (w.childLanes = 0),
          (w.pendingProps = J),
          (h.deletions = null))
        : ((w = ga(d, J)), (w.subtreeFlags = d.subtreeFlags & 14680064)),
      V !== null ? (E = ga(V, E)) : ((E = Dl(E, L, M, null)), (E.flags |= 2)),
      (E.return = h),
      (w.return = h),
      (w.sibling = E),
      (h.child = w),
      E
    );
  }
  function ug(d, h, w, E) {
    return (
      E !== null && J_(E),
      uu(h, d.child, null, w),
      (d = hw(h, h.pendingProps.children)),
      (d.flags |= 2),
      (h.memoizedState = null),
      d
    );
  }
  function gR(d, h, w) {
    d.lanes |= h;
    var E = d.alternate;
    E !== null && (E.lanes |= h), H_(d.return, h, w);
  }
  function fw(d, h, w, E, M) {
    var L = d.memoizedState;
    L === null
      ? (d.memoizedState = {
          isBackwards: h,
          rendering: null,
          renderingStartTime: 0,
          last: E,
          tail: w,
          tailMode: M,
        })
      : ((L.isBackwards = h),
        (L.rendering = null),
        (L.renderingStartTime = 0),
        (L.last = E),
        (L.tail = w),
        (L.tailMode = M));
  }
  function vR(d, h, w) {
    var E = h.pendingProps,
      M = E.revealOrder,
      L = E.tail;
    if ((Br(d, h, E.children, w), (E = _n.current), E & 2))
      (E = (E & 1) | 2), (h.flags |= 128);
    else {
      if (d !== null && d.flags & 128)
        e: for (d = h.child; d !== null; ) {
          if (d.tag === 13) d.memoizedState !== null && gR(d, w, h);
          else if (d.tag === 19) gR(d, w, h);
          else if (d.child !== null) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === h) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === h) break e;
            d = d.return;
          }
          (d.sibling.return = d.return), (d = d.sibling);
        }
      E &= 1;
    }
    if ((pt(_n, E), !(h.mode & 1))) h.memoizedState = null;
    else
      switch (M) {
        case "forwards":
          for (w = h.child, M = null; w !== null; )
            (d = w.alternate),
              d !== null && Zm(d) === null && (M = w),
              (w = w.sibling);
          (w = M),
            w === null
              ? ((M = h.child), (h.child = null))
              : ((M = w.sibling), (w.sibling = null)),
            fw(h, !1, M, w, L);
          break;
        case "backwards":
          for (w = null, M = h.child, h.child = null; M !== null; ) {
            if (((d = M.alternate), d !== null && Zm(d) === null)) {
              h.child = M;
              break;
            }
            (d = M.sibling), (M.sibling = w), (w = M), (M = d);
          }
          fw(h, !0, w, null, L);
          break;
        case "together":
          fw(h, !1, null, null, void 0);
          break;
        default:
          h.memoizedState = null;
      }
    return h.child;
  }
  function Ro(d, h, w) {
    if (
      (d !== null && (h.dependencies = d.dependencies),
      (mu |= h.lanes),
      !(w & h.childLanes))
    )
      return null;
    if (d !== null && h.child !== d.child) throw Error(o(153));
    if (h.child !== null) {
      for (
        d = h.child, w = ga(d, d.pendingProps), h.child = w, w.return = h;
        d.sibling !== null;

      )
        (d = d.sibling),
          (w = w.sibling = ga(d, d.pendingProps)),
          (w.return = h);
      w.sibling = null;
    }
    return h.child;
  }
  function D5(d, h, w) {
    switch (h.tag) {
      case 3:
        dR(h), cu();
        break;
      case 5:
        LA(h);
        break;
      case 1:
        Mt(h.type) && js(h);
        break;
      case 4:
        Z_(h, h.stateNode.containerInfo);
        break;
      case 10:
        yA(h, h.type._context, h.memoizedProps.value);
        break;
      case 13:
        var E = h.memoizedState;
        if (E !== null)
          return E.dehydrated !== null
            ? (pt(_n, _n.current & 1), (h.flags |= 128), null)
            : w & h.child.childLanes
            ? fR(d, h, w)
            : (pt(_n, _n.current & 1),
              (d = Ro(d, h, w)),
              d !== null ? d.sibling : null);
        pt(_n, _n.current & 1);
        break;
      case 19:
        if (((E = (w & h.childLanes) !== 0), d.flags & 128)) {
          if (E) return vR(d, h, w);
          h.flags |= 128;
        }
        var M = h.memoizedState;
        if (
          (M !== null &&
            ((M.rendering = null), (M.tail = null), (M.lastEffect = null)),
          pt(_n, _n.current),
          E)
        )
          break;
        return null;
      case 22:
      case 23:
        return (h.lanes = 0), lR(d, h, w);
    }
    return Ro(d, h, w);
  }
  function k5(d, h) {
    switch ((q_(h), h.tag)) {
      case 1:
        return (
          Mt(h.type) && tr(),
          (d = h.flags),
          d & 65536 ? ((h.flags = (d & -65537) | 128), h) : null
        );
      case 3:
        return (
          hu(),
          lt(Ot),
          lt(Lt),
          tw(),
          (d = h.flags),
          d & 65536 && !(d & 128) ? ((h.flags = (d & -65537) | 128), h) : null
        );
      case 5:
        return Q_(h), null;
      case 13:
        if (
          (lt(_n), (d = h.memoizedState), d !== null && d.dehydrated !== null)
        ) {
          if (h.alternate === null) throw Error(o(340));
          cu();
        }
        return (
          (d = h.flags), d & 65536 ? ((h.flags = (d & -65537) | 128), h) : null
        );
      case 19:
        return lt(_n), null;
      case 4:
        return hu(), null;
      case 10:
        return j_(h.type._context), null;
      case 22:
      case 23:
        return Iw(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var dg = !1,
    Pl = !1,
    U5 = typeof WeakSet == "function" ? WeakSet : Set,
    Xe = null;
  function hg(d, h) {
    var w = d.ref;
    if (w !== null)
      if (typeof w == "function")
        try {
          w(null);
        } catch (E) {
          ii(d, h, E);
        }
      else w.current = null;
  }
  function pw(d, h, w) {
    try {
      w();
    } catch (E) {
      ii(d, h, E);
    }
  }
  var yR = !1;
  function F5(d, h) {
    for (H(d.containerInfo), Xe = h; Xe !== null; )
      if (
        ((d = Xe), (h = d.child), (d.subtreeFlags & 1028) !== 0 && h !== null)
      )
        (h.return = d), (Xe = h);
      else
        for (; Xe !== null; ) {
          d = Xe;
          try {
            var w = d.alternate;
            if (d.flags & 1024)
              switch (d.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (w !== null) {
                    var E = w.memoizedProps,
                      M = w.memoizedState,
                      L = d.stateNode,
                      V = L.getSnapshotBeforeUpdate(
                        d.elementType === d.type ? E : ds(d.type, E),
                        M
                      );
                    L.__reactInternalSnapshotBeforeUpdate = V;
                  }
                  break;
                case 3:
                  Ke && Ye(d.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (J) {
            ii(d, d.return, J);
          }
          if (((h = d.sibling), h !== null)) {
            (h.return = d.return), (Xe = h);
            break;
          }
          Xe = d.return;
        }
    return (w = yR), (yR = !1), w;
  }
  function Il(d, h, w) {
    var E = h.updateQueue;
    if (((E = E !== null ? E.lastEffect : null), E !== null)) {
      var M = (E = E.next);
      do {
        if ((M.tag & d) === d) {
          var L = M.destroy;
          (M.destroy = void 0), L !== void 0 && pw(h, w, L);
        }
        M = M.next;
      } while (M !== E);
    }
  }
  function Jh(d, h) {
    if (
      ((h = h.updateQueue), (h = h !== null ? h.lastEffect : null), h !== null)
    ) {
      var w = (h = h.next);
      do {
        if ((w.tag & d) === d) {
          var E = w.create;
          w.destroy = E();
        }
        w = w.next;
      } while (w !== h);
    }
  }
  function mw(d) {
    var h = d.ref;
    if (h !== null) {
      var w = d.stateNode;
      switch (d.tag) {
        case 5:
          d = q(w);
          break;
        default:
          d = w;
      }
      typeof h == "function" ? h(d) : (h.current = d);
    }
  }
  function xR(d, h, w) {
    if (Hs && typeof Hs.onCommitFiberUnmount == "function")
      try {
        Hs.onCommitFiberUnmount(Vm, h);
      } catch {}
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((d = h.updateQueue), d !== null && ((d = d.lastEffect), d !== null))
        ) {
          var E = (d = d.next);
          do {
            var M = E,
              L = M.destroy;
            (M = M.tag),
              L !== void 0 && (M & 2 || M & 4) && pw(h, w, L),
              (E = E.next);
          } while (E !== d);
        }
        break;
      case 1:
        if (
          (hg(h, w),
          (d = h.stateNode),
          typeof d.componentWillUnmount == "function")
        )
          try {
            (d.props = h.memoizedProps),
              (d.state = h.memoizedState),
              d.componentWillUnmount();
          } catch (V) {
            ii(h, w, V);
          }
        break;
      case 5:
        hg(h, w);
        break;
      case 4:
        Ke
          ? TR(d, h, w)
          : Ve &&
            Ve &&
            ((h = h.stateNode.containerInfo), (w = ye(h)), mt(h, w));
    }
  }
  function _R(d, h, w) {
    for (var E = h; ; )
      if ((xR(d, E, w), E.child === null || (Ke && E.tag === 4))) {
        if (E === h) break;
        for (; E.sibling === null; ) {
          if (E.return === null || E.return === h) return;
          E = E.return;
        }
        (E.sibling.return = E.return), (E = E.sibling);
      } else (E.child.return = E), (E = E.child);
  }
  function wR(d) {
    var h = d.alternate;
    h !== null && ((d.alternate = null), wR(h)),
      (d.child = null),
      (d.deletions = null),
      (d.sibling = null),
      d.tag === 5 && ((h = d.stateNode), h !== null && me(h)),
      (d.stateNode = null),
      (d.return = null),
      (d.dependencies = null),
      (d.memoizedProps = null),
      (d.memoizedState = null),
      (d.pendingProps = null),
      (d.stateNode = null),
      (d.updateQueue = null);
  }
  function SR(d) {
    return d.tag === 5 || d.tag === 3 || d.tag === 4;
  }
  function bR(d) {
    e: for (;;) {
      for (; d.sibling === null; ) {
        if (d.return === null || SR(d.return)) return null;
        d = d.return;
      }
      for (
        d.sibling.return = d.return, d = d.sibling;
        d.tag !== 5 && d.tag !== 6 && d.tag !== 18;

      ) {
        if (d.flags & 2 || d.child === null || d.tag === 4) continue e;
        (d.child.return = d), (d = d.child);
      }
      if (!(d.flags & 2)) return d.stateNode;
    }
  }
  function ER(d) {
    if (Ke) {
      e: {
        for (var h = d.return; h !== null; ) {
          if (SR(h)) break e;
          h = h.return;
        }
        throw Error(o(160));
      }
      var w = h;
      switch (w.tag) {
        case 5:
          (h = w.stateNode),
            w.flags & 32 && (He(h), (w.flags &= -33)),
            (w = bR(d)),
            vw(d, w, h);
          break;
        case 3:
        case 4:
          (h = w.stateNode.containerInfo), (w = bR(d)), gw(d, w, h);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function gw(d, h, w) {
    var E = d.tag;
    if (E === 5 || E === 6) (d = d.stateNode), h ? je(w, d, h) : ot(w, d);
    else if (E !== 4 && ((d = d.child), d !== null))
      for (gw(d, h, w), d = d.sibling; d !== null; )
        gw(d, h, w), (d = d.sibling);
  }
  function vw(d, h, w) {
    var E = d.tag;
    if (E === 5 || E === 6) (d = d.stateNode), h ? Ce(w, d, h) : he(w, d);
    else if (E !== 4 && ((d = d.child), d !== null))
      for (vw(d, h, w), d = d.sibling; d !== null; )
        vw(d, h, w), (d = d.sibling);
  }
  function TR(d, h, w) {
    for (var E = h, M = !1, L, V; ; ) {
      if (!M) {
        M = E.return;
        e: for (;;) {
          if (M === null) throw Error(o(160));
          switch (((L = M.stateNode), M.tag)) {
            case 5:
              V = !1;
              break e;
            case 3:
              (L = L.containerInfo), (V = !0);
              break e;
            case 4:
              (L = L.containerInfo), (V = !0);
              break e;
          }
          M = M.return;
        }
        M = !0;
      }
      if (E.tag === 5 || E.tag === 6)
        _R(d, E, w), V ? Qe(L, E.stateNode) : vt(L, E.stateNode);
      else if (E.tag === 18) V ? F(L, E.stateNode) : N_(L, E.stateNode);
      else if (E.tag === 4) {
        if (E.child !== null) {
          (L = E.stateNode.containerInfo),
            (V = !0),
            (E.child.return = E),
            (E = E.child);
          continue;
        }
      } else if ((xR(d, E, w), E.child !== null)) {
        (E.child.return = E), (E = E.child);
        continue;
      }
      if (E === h) break;
      for (; E.sibling === null; ) {
        if (E.return === null || E.return === h) return;
        (E = E.return), E.tag === 4 && (M = !1);
      }
      (E.sibling.return = E.return), (E = E.sibling);
    }
  }
  function yw(d, h) {
    if (Ke) {
      switch (h.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Il(3, h, h.return), Jh(3, h), Il(5, h, h.return);
          return;
        case 1:
          return;
        case 5:
          var w = h.stateNode;
          if (w != null) {
            var E = h.memoizedProps;
            d = d !== null ? d.memoizedProps : E;
            var M = h.type,
              L = h.updateQueue;
            (h.updateQueue = null), L !== null && tt(w, L, M, d, E, h);
          }
          return;
        case 6:
          if (h.stateNode === null) throw Error(o(162));
          (w = h.memoizedProps),
            Ne(h.stateNode, d !== null ? d.memoizedProps : w, w);
          return;
        case 3:
          W &&
            d !== null &&
            d.memoizedState.isDehydrated &&
            Bm(h.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          fg(h);
          return;
        case 19:
          fg(h);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (h.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Il(3, h, h.return), Jh(3, h), Il(5, h, h.return);
        return;
      case 12:
        return;
      case 13:
        fg(h);
        return;
      case 19:
        fg(h);
        return;
      case 3:
        W &&
          d !== null &&
          d.memoizedState.isDehydrated &&
          Bm(h.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (Ve) {
      switch (h.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (h = h.stateNode), mt(h.containerInfo, h.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function fg(d) {
    var h = d.updateQueue;
    if (h !== null) {
      d.updateQueue = null;
      var w = d.stateNode;
      w === null && (w = d.stateNode = new U5()),
        h.forEach(function (E) {
          var M = q5.bind(null, d, E);
          w.has(E) || (w.add(E), E.then(M, M));
        });
    }
  }
  function B5(d, h) {
    for (Xe = h; Xe !== null; ) {
      h = Xe;
      var w = h.deletions;
      if (w !== null)
        for (var E = 0; E < w.length; E++) {
          var M = w[E];
          try {
            var L = d;
            Ke ? TR(L, M, h) : _R(L, M, h);
            var V = M.alternate;
            V !== null && (V.return = null), (M.return = null);
          } catch (dt) {
            ii(M, h, dt);
          }
        }
      if (((w = h.child), h.subtreeFlags & 12854 && w !== null))
        (w.return = h), (Xe = w);
      else
        for (; Xe !== null; ) {
          h = Xe;
          try {
            var J = h.flags;
            if ((J & 32 && Ke && He(h.stateNode), J & 512)) {
              var fe = h.alternate;
              if (fe !== null) {
                var ke = fe.ref;
                ke !== null &&
                  (typeof ke == "function" ? ke(null) : (ke.current = null));
              }
            }
            if (J & 8192)
              switch (h.tag) {
                case 13:
                  if (h.memoizedState !== null) {
                    var rt = h.alternate;
                    (rt === null || rt.memoizedState === null) && (Tw = nr());
                  }
                  break;
                case 22:
                  var Rt = h.memoizedState !== null,
                    xt = h.alternate,
                    on = xt !== null && xt.memoizedState !== null;
                  if (((w = h), Ke)) {
                    e: if (((E = w), (M = Rt), (L = null), Ke))
                      for (var ht = E; ; ) {
                        if (ht.tag === 5) {
                          if (L === null) {
                            L = ht;
                            var Er = ht.stateNode;
                            M ? Ct(Er) : Re(ht.stateNode, ht.memoizedProps);
                          }
                        } else if (ht.tag === 6) {
                          if (L === null) {
                            var Xi = ht.stateNode;
                            M ? K(Xi) : ze(Xi, ht.memoizedProps);
                          }
                        } else if (
                          ((ht.tag !== 22 && ht.tag !== 23) ||
                            ht.memoizedState === null ||
                            ht === E) &&
                          ht.child !== null
                        ) {
                          (ht.child.return = ht), (ht = ht.child);
                          continue;
                        }
                        if (ht === E) break;
                        for (; ht.sibling === null; ) {
                          if (ht.return === null || ht.return === E) break e;
                          L === ht && (L = null), (ht = ht.return);
                        }
                        L === ht && (L = null),
                          (ht.sibling.return = ht.return),
                          (ht = ht.sibling);
                      }
                  }
                  if (Rt && !on && w.mode & 1) {
                    Xe = w;
                    for (var oe = w.child; oe !== null; ) {
                      for (w = Xe = oe; Xe !== null; ) {
                        E = Xe;
                        var Q = E.child;
                        switch (E.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Il(4, E, E.return);
                            break;
                          case 1:
                            hg(E, E.return);
                            var ue = E.stateNode;
                            if (typeof ue.componentWillUnmount == "function") {
                              var qe = E.return;
                              try {
                                (ue.props = E.memoizedProps),
                                  (ue.state = E.memoizedState),
                                  ue.componentWillUnmount();
                              } catch (dt) {
                                ii(E, qe, dt);
                              }
                            }
                            break;
                          case 5:
                            hg(E, E.return);
                            break;
                          case 22:
                            if (E.memoizedState !== null) {
                              AR(w);
                              continue;
                            }
                        }
                        Q !== null ? ((Q.return = E), (Xe = Q)) : AR(w);
                      }
                      oe = oe.sibling;
                    }
                  }
              }
            switch (J & 4102) {
              case 2:
                ER(h), (h.flags &= -3);
                break;
              case 6:
                ER(h), (h.flags &= -3), yw(h.alternate, h);
                break;
              case 4096:
                h.flags &= -4097;
                break;
              case 4100:
                (h.flags &= -4097), yw(h.alternate, h);
                break;
              case 4:
                yw(h.alternate, h);
            }
          } catch (dt) {
            ii(h, h.return, dt);
          }
          if (((w = h.sibling), w !== null)) {
            (w.return = h.return), (Xe = w);
            break;
          }
          Xe = h.return;
        }
    }
  }
  function z5(d, h, w) {
    (Xe = d), MR(d);
  }
  function MR(d, h, w) {
    for (var E = (d.mode & 1) !== 0; Xe !== null; ) {
      var M = Xe,
        L = M.child;
      if (M.tag === 22 && E) {
        var V = M.memoizedState !== null || dg;
        if (!V) {
          var J = M.alternate,
            fe = (J !== null && J.memoizedState !== null) || Pl;
          J = dg;
          var ke = Pl;
          if (((dg = V), (Pl = fe) && !ke))
            for (Xe = M; Xe !== null; )
              (V = Xe),
                (fe = V.child),
                V.tag === 22 && V.memoizedState !== null
                  ? RR(M)
                  : fe !== null
                  ? ((fe.return = V), (Xe = fe))
                  : RR(M);
          for (; L !== null; ) (Xe = L), MR(L), (L = L.sibling);
          (Xe = M), (dg = J), (Pl = ke);
        }
        CR(d);
      } else
        M.subtreeFlags & 8772 && L !== null
          ? ((L.return = M), (Xe = L))
          : CR(d);
    }
  }
  function CR(d) {
    for (; Xe !== null; ) {
      var h = Xe;
      if (h.flags & 8772) {
        var w = h.alternate;
        try {
          if (h.flags & 8772)
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                Pl || Jh(5, h);
                break;
              case 1:
                var E = h.stateNode;
                if (h.flags & 4 && !Pl)
                  if (w === null) E.componentDidMount();
                  else {
                    var M =
                      h.elementType === h.type
                        ? w.memoizedProps
                        : ds(h.type, w.memoizedProps);
                    E.componentDidUpdate(
                      M,
                      w.memoizedState,
                      E.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var L = h.updateQueue;
                L !== null && wA(h, L, E);
                break;
              case 3:
                var V = h.updateQueue;
                if (V !== null) {
                  if (((w = null), h.child !== null))
                    switch (h.child.tag) {
                      case 5:
                        w = q(h.child.stateNode);
                        break;
                      case 1:
                        w = h.child.stateNode;
                    }
                  wA(h, V, w);
                }
                break;
              case 5:
                var J = h.stateNode;
                w === null && h.flags & 4 && it(J, h.type, h.memoizedProps, h);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (W && h.memoizedState === null) {
                  var fe = h.alternate;
                  if (fe !== null) {
                    var ke = fe.memoizedState;
                    if (ke !== null) {
                      var rt = ke.dehydrated;
                      rt !== null && I_(rt);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          Pl || (h.flags & 512 && mw(h));
        } catch (Rt) {
          ii(h, h.return, Rt);
        }
      }
      if (h === d) {
        Xe = null;
        break;
      }
      if (((w = h.sibling), w !== null)) {
        (w.return = h.return), (Xe = w);
        break;
      }
      Xe = h.return;
    }
  }
  function AR(d) {
    for (; Xe !== null; ) {
      var h = Xe;
      if (h === d) {
        Xe = null;
        break;
      }
      var w = h.sibling;
      if (w !== null) {
        (w.return = h.return), (Xe = w);
        break;
      }
      Xe = h.return;
    }
  }
  function RR(d) {
    for (; Xe !== null; ) {
      var h = Xe;
      try {
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            var w = h.return;
            try {
              Jh(4, h);
            } catch (fe) {
              ii(h, w, fe);
            }
            break;
          case 1:
            var E = h.stateNode;
            if (typeof E.componentDidMount == "function") {
              var M = h.return;
              try {
                E.componentDidMount();
              } catch (fe) {
                ii(h, M, fe);
              }
            }
            var L = h.return;
            try {
              mw(h);
            } catch (fe) {
              ii(h, L, fe);
            }
            break;
          case 5:
            var V = h.return;
            try {
              mw(h);
            } catch (fe) {
              ii(h, V, fe);
            }
        }
      } catch (fe) {
        ii(h, h.return, fe);
      }
      if (h === d) {
        Xe = null;
        break;
      }
      var J = h.sibling;
      if (J !== null) {
        (J.return = h.return), (Xe = J);
        break;
      }
      Xe = h.return;
    }
  }
  var pg = 0,
    mg = 1,
    gg = 2,
    vg = 3,
    yg = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Zh = Symbol.for;
    (pg = Zh("selector.component")),
      (mg = Zh("selector.has_pseudo_class")),
      (gg = Zh("selector.role")),
      (vg = Zh("selector.test_id")),
      (yg = Zh("selector.text"));
  }
  function xw(d) {
    var h = ge(d);
    if (h != null) {
      if (typeof h.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return h;
    }
    if (((d = _t(d)), d === null)) throw Error(o(362));
    return d.stateNode.current;
  }
  function _w(d, h) {
    switch (h.$$typeof) {
      case pg:
        if (d.type === h.value) return !0;
        break;
      case mg:
        e: {
          (h = h.value), (d = [d, 0]);
          for (var w = 0; w < d.length; ) {
            var E = d[w++],
              M = d[w++],
              L = h[M];
            if (E.tag !== 5 || !k(E)) {
              for (; L != null && _w(E, L); ) M++, (L = h[M]);
              if (M === h.length) {
                h = !0;
                break e;
              } else
                for (E = E.child; E !== null; ) d.push(E, M), (E = E.sibling);
            }
          }
          h = !1;
        }
        return h;
      case gg:
        if (d.tag === 5 && ne(d.stateNode, h.value)) return !0;
        break;
      case yg:
        if (
          (d.tag === 5 || d.tag === 6) &&
          ((d = B(d)), d !== null && 0 <= d.indexOf(h.value))
        )
          return !0;
        break;
      case vg:
        if (
          d.tag === 5 &&
          ((d = d.memoizedProps["data-testname"]),
          typeof d == "string" && d.toLowerCase() === h.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function ww(d) {
    switch (d.$$typeof) {
      case pg:
        return "<" + (R(d.value) || "Unknown") + ">";
      case mg:
        return ":has(" + (ww(d) || "") + ")";
      case gg:
        return '[role="' + d.value + '"]';
      case yg:
        return '"' + d.value + '"';
      case vg:
        return '[data-testname="' + d.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function PR(d, h) {
    var w = [];
    d = [d, 0];
    for (var E = 0; E < d.length; ) {
      var M = d[E++],
        L = d[E++],
        V = h[L];
      if (M.tag !== 5 || !k(M)) {
        for (; V != null && _w(M, V); ) L++, (V = h[L]);
        if (L === h.length) w.push(M);
        else for (M = M.child; M !== null; ) d.push(M, L), (M = M.sibling);
      }
    }
    return w;
  }
  function Sw(d, h) {
    if (!De) throw Error(o(363));
    (d = xw(d)), (d = PR(d, h)), (h = []), (d = Array.from(d));
    for (var w = 0; w < d.length; ) {
      var E = d[w++];
      if (E.tag === 5) k(E) || h.push(E.stateNode);
      else for (E = E.child; E !== null; ) d.push(E), (E = E.sibling);
    }
    return h;
  }
  var V5 = Math.ceil,
    xg = a.ReactCurrentDispatcher,
    bw = a.ReactCurrentOwner,
    kn = a.ReactCurrentBatchConfig,
    Vt = 0,
    zn = null,
    Vn = null,
    dr = 0,
    Si = 0,
    pu = at(0),
    qn = 0,
    Qh = null,
    mu = 0,
    _g = 0,
    Ew = 0,
    ef = null,
    ni = null,
    Tw = 0,
    Mw = 1 / 0;
  function gu() {
    Mw = nr() + 500;
  }
  var wg = !1,
    Cw = null,
    ha = null,
    Sg = !1,
    fa = null,
    bg = 0,
    tf = 0,
    Aw = null,
    Eg = -1,
    Tg = 0;
  function zr() {
    return Vt & 6 ? nr() : Eg !== -1 ? Eg : (Eg = nr());
  }
  function pa(d) {
    return d.mode & 1
      ? Vt & 2 && dr !== 0
        ? dr & -dr
        : b5.transition !== null
        ? (Tg === 0 &&
            ((d = ca), (ca <<= 1), !(ca & 4194240) && (ca = 64), (Tg = d)),
          Tg)
        : ((d = Yt), d !== 0 ? d : Se())
      : 1;
  }
  function Gi(d, h, w) {
    if (50 < tf) throw ((tf = 0), (Aw = null), Error(o(185)));
    var E = Mg(d, h);
    return E === null
      ? null
      : (Fh(E, h, w),
        (!(Vt & 2) || E !== zn) &&
          (E === zn && (!(Vt & 2) && (_g |= h), qn === 4 && ma(E, dr)),
          ri(E, w),
          h === 1 && Vt === 0 && !(d.mode & 1) && (gu(), jm && Gs())),
        E);
  }
  function Mg(d, h) {
    d.lanes |= h;
    var w = d.alternate;
    for (w !== null && (w.lanes |= h), w = d, d = d.return; d !== null; )
      (d.childLanes |= h),
        (w = d.alternate),
        w !== null && (w.childLanes |= h),
        (w = d),
        (d = d.return);
    return w.tag === 3 ? w.stateNode : null;
  }
  function ri(d, h) {
    var w = d.callbackNode;
    p5(d, h);
    var E = zm(d, d === zn ? dr : 0);
    if (E === 0)
      w !== null && gA(w), (d.callbackNode = null), (d.callbackPriority = 0);
    else if (((h = E & -E), d.callbackPriority !== h)) {
      if ((w != null && gA(w), h === 1))
        d.tag === 0 ? S5(NR.bind(null, d)) : vA(NR.bind(null, d)),
          Oe
            ? Te(function () {
                Vt === 0 && Gs();
              })
            : k_(U_, Gs),
          (w = null);
      else {
        switch (mA(E)) {
          case 1:
            w = U_;
            break;
          case 4:
            w = y5;
            break;
          case 16:
            w = F_;
            break;
          case 536870912:
            w = x5;
            break;
          default:
            w = F_;
        }
        w = VR(w, IR.bind(null, d));
      }
      (d.callbackPriority = h), (d.callbackNode = w);
    }
  }
  function IR(d, h) {
    if (((Eg = -1), (Tg = 0), Vt & 6)) throw Error(o(327));
    var w = d.callbackNode;
    if (Ol() && d.callbackNode !== w) return null;
    var E = zm(d, d === zn ? dr : 0);
    if (E === 0) return null;
    if (E & 30 || E & d.expiredLanes || h) h = Cg(d, E);
    else {
      h = E;
      var M = Vt;
      Vt |= 2;
      var L = DR();
      (zn !== d || dr !== h) && (gu(), Nl(d, h));
      do
        try {
          W5();
          break;
        } catch (J) {
          OR(d, J);
        }
      while (!0);
      V_(),
        (xg.current = L),
        (Vt = M),
        Vn !== null ? (h = 0) : ((zn = null), (dr = 0), (h = qn));
    }
    if (h !== 0) {
      if (
        (h === 2 && ((M = L_(d)), M !== 0 && ((E = M), (h = Rw(d, M)))),
        h === 1)
      )
        throw ((w = Qh), Nl(d, 0), ma(d, E), ri(d, nr()), w);
      if (h === 6) ma(d, E);
      else {
        if (
          ((M = d.current.alternate),
          !(E & 30) &&
            !j5(M) &&
            ((h = Cg(d, E)),
            h === 2 && ((L = L_(d)), L !== 0 && ((E = L), (h = Rw(d, L)))),
            h === 1))
        )
          throw ((w = Qh), Nl(d, 0), ma(d, E), ri(d, nr()), w);
        switch (((d.finishedWork = M), (d.finishedLanes = E), h)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            Ll(d, ni);
            break;
          case 3:
            if (
              (ma(d, E),
              (E & 130023424) === E && ((h = Tw + 500 - nr()), 10 < h))
            ) {
              if (zm(d, 0) !== 0) break;
              if (((M = d.suspendedLanes), (M & E) !== E)) {
                zr(), (d.pingedLanes |= d.suspendedLanes & M);
                break;
              }
              d.timeoutHandle = re(Ll.bind(null, d, ni), h);
              break;
            }
            Ll(d, ni);
            break;
          case 4:
            if ((ma(d, E), (E & 4194240) === E)) break;
            for (h = d.eventTimes, M = -1; 0 < E; ) {
              var V = 31 - gn(E);
              (L = 1 << V), (V = h[V]), V > M && (M = V), (E &= ~L);
            }
            if (
              ((E = M),
              (E = nr() - E),
              (E =
                (120 > E
                  ? 120
                  : 480 > E
                  ? 480
                  : 1080 > E
                  ? 1080
                  : 1920 > E
                  ? 1920
                  : 3e3 > E
                  ? 3e3
                  : 4320 > E
                  ? 4320
                  : 1960 * V5(E / 1960)) - E),
              10 < E)
            ) {
              d.timeoutHandle = re(Ll.bind(null, d, ni), E);
              break;
            }
            Ll(d, ni);
            break;
          case 5:
            Ll(d, ni);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return ri(d, nr()), d.callbackNode === w ? IR.bind(null, d) : null;
  }
  function Rw(d, h) {
    var w = ef;
    return (
      d.current.memoizedState.isDehydrated && (Nl(d, h).flags |= 256),
      (d = Cg(d, h)),
      d !== 2 && ((h = ni), (ni = w), h !== null && Pw(h)),
      d
    );
  }
  function Pw(d) {
    ni === null ? (ni = d) : ni.push.apply(ni, d);
  }
  function j5(d) {
    for (var h = d; ; ) {
      if (h.flags & 16384) {
        var w = h.updateQueue;
        if (w !== null && ((w = w.stores), w !== null))
          for (var E = 0; E < w.length; E++) {
            var M = w[E],
              L = M.getSnapshot;
            M = M.value;
            try {
              if (!Ws(L(), M)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((w = h.child), h.subtreeFlags & 16384 && w !== null))
        (w.return = h), (h = w);
      else {
        if (h === d) break;
        for (; h.sibling === null; ) {
          if (h.return === null || h.return === d) return !0;
          h = h.return;
        }
        (h.sibling.return = h.return), (h = h.sibling);
      }
    }
    return !0;
  }
  function ma(d, h) {
    for (
      h &= ~Ew,
        h &= ~_g,
        d.suspendedLanes |= h,
        d.pingedLanes &= ~h,
        d = d.expirationTimes;
      0 < h;

    ) {
      var w = 31 - gn(h),
        E = 1 << w;
      (d[w] = -1), (h &= ~E);
    }
  }
  function NR(d) {
    if (Vt & 6) throw Error(o(327));
    Ol();
    var h = zm(d, 0);
    if (!(h & 1)) return ri(d, nr()), null;
    var w = Cg(d, h);
    if (d.tag !== 0 && w === 2) {
      var E = L_(d);
      E !== 0 && ((h = E), (w = Rw(d, E)));
    }
    if (w === 1) throw ((w = Qh), Nl(d, 0), ma(d, h), ri(d, nr()), w);
    if (w === 6) throw Error(o(345));
    return (
      (d.finishedWork = d.current.alternate),
      (d.finishedLanes = h),
      Ll(d, ni),
      ri(d, nr()),
      null
    );
  }
  function LR(d) {
    fa !== null && fa.tag === 0 && !(Vt & 6) && Ol();
    var h = Vt;
    Vt |= 1;
    var w = kn.transition,
      E = Yt;
    try {
      if (((kn.transition = null), (Yt = 1), d)) return d();
    } finally {
      (Yt = E), (kn.transition = w), (Vt = h), !(Vt & 6) && Gs();
    }
  }
  function Iw() {
    (Si = pu.current), lt(pu);
  }
  function Nl(d, h) {
    (d.finishedWork = null), (d.finishedLanes = 0);
    var w = d.timeoutHandle;
    if ((w !== Ue && ((d.timeoutHandle = Ue), Be(w)), Vn !== null))
      for (w = Vn.return; w !== null; ) {
        var E = w;
        switch ((q_(E), E.tag)) {
          case 1:
            (E = E.type.childContextTypes), E != null && tr();
            break;
          case 3:
            hu(), lt(Ot), lt(Lt), tw();
            break;
          case 5:
            Q_(E);
            break;
          case 4:
            hu();
            break;
          case 13:
            lt(_n);
            break;
          case 19:
            lt(_n);
            break;
          case 10:
            j_(E.type._context);
            break;
          case 22:
          case 23:
            Iw();
        }
        w = w.return;
      }
    if (
      ((zn = d),
      (Vn = d = ga(d.current, null)),
      (dr = Si = h),
      (qn = 0),
      (Qh = null),
      (Ew = _g = mu = 0),
      (ni = ef = null),
      $s !== null)
    ) {
      for (h = 0; h < $s.length; h++)
        if (((w = $s[h]), (E = w.interleaved), E !== null)) {
          w.interleaved = null;
          var M = E.next,
            L = w.pending;
          if (L !== null) {
            var V = L.next;
            (L.next = M), (E.next = V);
          }
          w.pending = E;
        }
      $s = null;
    }
    return d;
  }
  function OR(d, h) {
    do {
      var w = Vn;
      try {
        if ((V_(), (Qm.current = sg), eg)) {
          for (var E = Cn.memoizedState; E !== null; ) {
            var M = E.queue;
            M !== null && (M.pending = null), (E = E.next);
          }
          eg = !1;
        }
        if (
          ((fu = 0),
          (rr = wr = Cn = null),
          (Wh = !1),
          (Gh = 0),
          (bw.current = null),
          w === null || w.return === null)
        ) {
          (qn = 1), (Qh = h), (Vn = null);
          break;
        }
        e: {
          var L = d,
            V = w.return,
            J = w,
            fe = h;
          if (
            ((h = dr),
            (J.flags |= 32768),
            fe !== null &&
              typeof fe == "object" &&
              typeof fe.then == "function")
          ) {
            var ke = fe,
              rt = J,
              Rt = rt.tag;
            if (!(rt.mode & 1) && (Rt === 0 || Rt === 11 || Rt === 15)) {
              var xt = rt.alternate;
              xt
                ? ((rt.updateQueue = xt.updateQueue),
                  (rt.memoizedState = xt.memoizedState),
                  (rt.lanes = xt.lanes))
                : ((rt.updateQueue = null), (rt.memoizedState = null));
            }
            var on = tR(V);
            if (on !== null) {
              (on.flags &= -257),
                nR(on, V, J, L, h),
                on.mode & 1 && eR(L, ke, h),
                (h = on),
                (fe = ke);
              var ht = h.updateQueue;
              if (ht === null) {
                var Er = new Set();
                Er.add(fe), (h.updateQueue = Er);
              } else ht.add(fe);
              break e;
            } else {
              if (!(h & 1)) {
                eR(L, ke, h), Nw();
                break e;
              }
              fe = Error(o(426));
            }
          } else if (vn && J.mode & 1) {
            var Xi = tR(V);
            if (Xi !== null) {
              !(Xi.flags & 65536) && (Xi.flags |= 256),
                nR(Xi, V, J, L, h),
                J_(fe);
              break e;
            }
          }
          (L = fe),
            qn !== 4 && (qn = 2),
            ef === null ? (ef = [L]) : ef.push(L),
            (fe = lw(fe, J)),
            (J = V);
          do {
            switch (J.tag) {
              case 3:
                (J.flags |= 65536), (h &= -h), (J.lanes |= h);
                var oe = ZA(J, fe, h);
                _A(J, oe);
                break e;
              case 1:
                L = fe;
                var Q = J.type,
                  ue = J.stateNode;
                if (
                  !(J.flags & 128) &&
                  (typeof Q.getDerivedStateFromError == "function" ||
                    (ue !== null &&
                      typeof ue.componentDidCatch == "function" &&
                      (ha === null || !ha.has(ue))))
                ) {
                  (J.flags |= 65536), (h &= -h), (J.lanes |= h);
                  var qe = QA(J, L, h);
                  _A(J, qe);
                  break e;
                }
            }
            J = J.return;
          } while (J !== null);
        }
        UR(w);
      } catch (dt) {
        (h = dt), Vn === w && w !== null && (Vn = w = w.return);
        continue;
      }
      break;
    } while (!0);
  }
  function DR() {
    var d = xg.current;
    return (xg.current = sg), d === null ? sg : d;
  }
  function Nw() {
    (qn === 0 || qn === 3 || qn === 2) && (qn = 4),
      zn === null || (!(mu & 268435455) && !(_g & 268435455)) || ma(zn, dr);
  }
  function Cg(d, h) {
    var w = Vt;
    Vt |= 2;
    var E = DR();
    (zn === d && dr === h) || Nl(d, h);
    do
      try {
        H5();
        break;
      } catch (M) {
        OR(d, M);
      }
    while (!0);
    if ((V_(), (Vt = w), (xg.current = E), Vn !== null)) throw Error(o(261));
    return (zn = null), (dr = 0), qn;
  }
  function H5() {
    for (; Vn !== null; ) kR(Vn);
  }
  function W5() {
    for (; Vn !== null && !g5(); ) kR(Vn);
  }
  function kR(d) {
    var h = zR(d.alternate, d, Si);
    (d.memoizedProps = d.pendingProps),
      h === null ? UR(d) : (Vn = h),
      (bw.current = null);
  }
  function UR(d) {
    var h = d;
    do {
      var w = h.alternate;
      if (((d = h.return), h.flags & 32768)) {
        if (((w = k5(w, h)), w !== null)) {
          (w.flags &= 32767), (Vn = w);
          return;
        }
        if (d !== null)
          (d.flags |= 32768), (d.subtreeFlags = 0), (d.deletions = null);
        else {
          (qn = 6), (Vn = null);
          return;
        }
      } else if (((w = L5(w, h, Si)), w !== null)) {
        Vn = w;
        return;
      }
      if (((h = h.sibling), h !== null)) {
        Vn = h;
        return;
      }
      Vn = h = d;
    } while (h !== null);
    qn === 0 && (qn = 5);
  }
  function Ll(d, h) {
    var w = Yt,
      E = kn.transition;
    try {
      (kn.transition = null), (Yt = 1), G5(d, h, w);
    } finally {
      (kn.transition = E), (Yt = w);
    }
    return null;
  }
  function G5(d, h, w) {
    do Ol();
    while (fa !== null);
    if (Vt & 6) throw Error(o(327));
    var E = d.finishedWork,
      M = d.finishedLanes;
    if (E === null) return null;
    if (((d.finishedWork = null), (d.finishedLanes = 0), E === d.current))
      throw Error(o(177));
    (d.callbackNode = null), (d.callbackPriority = 0);
    var L = E.lanes | E.childLanes;
    if (
      (m5(d, L),
      d === zn && ((Vn = zn = null), (dr = 0)),
      (!(E.subtreeFlags & 2064) && !(E.flags & 2064)) ||
        Sg ||
        ((Sg = !0),
        VR(F_, function () {
          return Ol(), null;
        })),
      (L = (E.flags & 15990) !== 0),
      E.subtreeFlags & 15990 || L)
    ) {
      (L = kn.transition), (kn.transition = null);
      var V = Yt;
      Yt = 1;
      var J = Vt;
      (Vt |= 4),
        (bw.current = null),
        F5(d, E),
        B5(d, E),
        X(d.containerInfo),
        (d.current = E),
        z5(E),
        v5(),
        (Vt = J),
        (Yt = V),
        (kn.transition = L);
    } else d.current = E;
    if (
      (Sg && ((Sg = !1), (fa = d), (bg = M)),
      (L = d.pendingLanes),
      L === 0 && (ha = null),
      _5(E.stateNode),
      ri(d, nr()),
      h !== null)
    )
      for (w = d.onRecoverableError, E = 0; E < h.length; E++) w(h[E]);
    if (wg) throw ((wg = !1), (d = Cw), (Cw = null), d);
    return (
      bg & 1 && d.tag !== 0 && Ol(),
      (L = d.pendingLanes),
      L & 1 ? (d === Aw ? tf++ : ((tf = 0), (Aw = d))) : (tf = 0),
      Gs(),
      null
    );
  }
  function Ol() {
    if (fa !== null) {
      var d = mA(bg),
        h = kn.transition,
        w = Yt;
      try {
        if (((kn.transition = null), (Yt = 16 > d ? 16 : d), fa === null))
          var E = !1;
        else {
          if (((d = fa), (fa = null), (bg = 0), Vt & 6)) throw Error(o(331));
          var M = Vt;
          for (Vt |= 4, Xe = d.current; Xe !== null; ) {
            var L = Xe,
              V = L.child;
            if (Xe.flags & 16) {
              var J = L.deletions;
              if (J !== null) {
                for (var fe = 0; fe < J.length; fe++) {
                  var ke = J[fe];
                  for (Xe = ke; Xe !== null; ) {
                    var rt = Xe;
                    switch (rt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Il(8, rt, L);
                    }
                    var Rt = rt.child;
                    if (Rt !== null) (Rt.return = rt), (Xe = Rt);
                    else
                      for (; Xe !== null; ) {
                        rt = Xe;
                        var xt = rt.sibling,
                          on = rt.return;
                        if ((wR(rt), rt === ke)) {
                          Xe = null;
                          break;
                        }
                        if (xt !== null) {
                          (xt.return = on), (Xe = xt);
                          break;
                        }
                        Xe = on;
                      }
                  }
                }
                var ht = L.alternate;
                if (ht !== null) {
                  var Er = ht.child;
                  if (Er !== null) {
                    ht.child = null;
                    do {
                      var Xi = Er.sibling;
                      (Er.sibling = null), (Er = Xi);
                    } while (Er !== null);
                  }
                }
                Xe = L;
              }
            }
            if (L.subtreeFlags & 2064 && V !== null) (V.return = L), (Xe = V);
            else
              e: for (; Xe !== null; ) {
                if (((L = Xe), L.flags & 2048))
                  switch (L.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Il(9, L, L.return);
                  }
                var oe = L.sibling;
                if (oe !== null) {
                  (oe.return = L.return), (Xe = oe);
                  break e;
                }
                Xe = L.return;
              }
          }
          var Q = d.current;
          for (Xe = Q; Xe !== null; ) {
            V = Xe;
            var ue = V.child;
            if (V.subtreeFlags & 2064 && ue !== null)
              (ue.return = V), (Xe = ue);
            else
              e: for (V = Q; Xe !== null; ) {
                if (((J = Xe), J.flags & 2048))
                  try {
                    switch (J.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Jh(9, J);
                    }
                  } catch (dt) {
                    ii(J, J.return, dt);
                  }
                if (J === V) {
                  Xe = null;
                  break e;
                }
                var qe = J.sibling;
                if (qe !== null) {
                  (qe.return = J.return), (Xe = qe);
                  break e;
                }
                Xe = J.return;
              }
          }
          if (
            ((Vt = M),
            Gs(),
            Hs && typeof Hs.onPostCommitFiberRoot == "function")
          )
            try {
              Hs.onPostCommitFiberRoot(Vm, d);
            } catch {}
          E = !0;
        }
        return E;
      } finally {
        (Yt = w), (kn.transition = h);
      }
    }
    return !1;
  }
  function FR(d, h, w) {
    (h = lw(w, h)),
      (h = ZA(d, h, 1)),
      da(d, h),
      (h = zr()),
      (d = Mg(d, 1)),
      d !== null && (Fh(d, 1, h), ri(d, h));
  }
  function ii(d, h, w) {
    if (d.tag === 3) FR(d, d, w);
    else
      for (; h !== null; ) {
        if (h.tag === 3) {
          FR(h, d, w);
          break;
        } else if (h.tag === 1) {
          var E = h.stateNode;
          if (
            typeof h.type.getDerivedStateFromError == "function" ||
            (typeof E.componentDidCatch == "function" &&
              (ha === null || !ha.has(E)))
          ) {
            (d = lw(w, d)),
              (d = QA(h, d, 1)),
              da(h, d),
              (d = zr()),
              (h = Mg(h, 1)),
              h !== null && (Fh(h, 1, d), ri(h, d));
            break;
          }
        }
        h = h.return;
      }
  }
  function $5(d, h, w) {
    var E = d.pingCache;
    E !== null && E.delete(h),
      (h = zr()),
      (d.pingedLanes |= d.suspendedLanes & w),
      zn === d &&
        (dr & w) === w &&
        (qn === 4 || (qn === 3 && (dr & 130023424) === dr && 500 > nr() - Tw)
          ? Nl(d, 0)
          : (Ew |= w)),
      ri(d, h);
  }
  function BR(d, h) {
    h === 0 &&
      (d.mode & 1
        ? ((h = Bi), (Bi <<= 1), !(Bi & 130023424) && (Bi = 4194304))
        : (h = 1));
    var w = zr();
    (d = Mg(d, h)), d !== null && (Fh(d, h, w), ri(d, w));
  }
  function X5(d) {
    var h = d.memoizedState,
      w = 0;
    h !== null && (w = h.retryLane), BR(d, w);
  }
  function q5(d, h) {
    var w = 0;
    switch (d.tag) {
      case 13:
        var E = d.stateNode,
          M = d.memoizedState;
        M !== null && (w = M.retryLane);
        break;
      case 19:
        E = d.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    E !== null && E.delete(h), BR(d, w);
  }
  var zR;
  zR = function (d, h, w) {
    if (d !== null)
      if (d.memoizedProps !== h.pendingProps || Ot.current) wi = !0;
      else {
        if (!(d.lanes & w) && !(h.flags & 128)) return (wi = !1), D5(d, h, w);
        wi = !!(d.flags & 131072);
      }
    else (wi = !1), vn && h.flags & 1048576 && MA(h, Ym, h.index);
    switch (((h.lanes = 0), h.tag)) {
      case 2:
        var E = h.type;
        d !== null &&
          ((d.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (d = h.pendingProps);
        var M = tn(h, Lt.current);
        ou(h, w), (M = rw(null, h, E, d, M, w));
        var L = iw();
        return (
          (h.flags |= 1),
          typeof M == "object" &&
          M !== null &&
          typeof M.render == "function" &&
          M.$$typeof === void 0
            ? ((h.tag = 1),
              (h.memoizedState = null),
              (h.updateQueue = null),
              Mt(E) ? ((L = !0), js(h)) : (L = !1),
              (h.memoizedState =
                M.state !== null && M.state !== void 0 ? M.state : null),
              W_(h),
              (M.updater = qm),
              (h.stateNode = M),
              (M._reactInternals = h),
              $_(h, E, d, w),
              (h = dw(null, h, E, !0, L, w)))
            : ((h.tag = 0), vn && L && X_(h), Br(null, h, M, w), (h = h.child)),
          h
        );
      case 16:
        E = h.elementType;
        e: {
          switch (
            (d !== null &&
              ((d.alternate = null), (h.alternate = null), (h.flags |= 2)),
            (d = h.pendingProps),
            (M = E._init),
            (E = M(E._payload)),
            (h.type = E),
            (M = h.tag = Y5(E)),
            (d = ds(E, d)),
            M)
          ) {
            case 0:
              h = uw(null, h, E, d, w);
              break e;
            case 1:
              h = uR(null, h, E, d, w);
              break e;
            case 11:
              h = sR(null, h, E, d, w);
              break e;
            case 14:
              h = oR(null, h, E, ds(E.type, d), w);
              break e;
          }
          throw Error(o(306, E, ""));
        }
        return h;
      case 0:
        return (
          (E = h.type),
          (M = h.pendingProps),
          (M = h.elementType === E ? M : ds(E, M)),
          uw(d, h, E, M, w)
        );
      case 1:
        return (
          (E = h.type),
          (M = h.pendingProps),
          (M = h.elementType === E ? M : ds(E, M)),
          uR(d, h, E, M, w)
        );
      case 3:
        e: {
          if ((dR(h), d === null)) throw Error(o(387));
          (E = h.pendingProps),
            (L = h.memoizedState),
            (M = L.element),
            xA(d, h),
            Xm(h, E, null, w);
          var V = h.memoizedState;
          if (((E = V.element), W && L.isDehydrated))
            if (
              ((L = {
                element: E,
                isDehydrated: !1,
                cache: V.cache,
                transitions: V.transitions,
              }),
              (h.updateQueue.baseState = L),
              (h.memoizedState = L),
              h.flags & 256)
            ) {
              (M = Error(o(423))), (h = hR(d, h, E, w, M));
              break e;
            } else if (E !== M) {
              (M = Error(o(424))), (h = hR(d, h, E, w, M));
              break e;
            } else
              for (
                W &&
                  ((_i = iu(h.stateNode.containerInfo)),
                  (xi = h),
                  (vn = !0),
                  (hs = null),
                  (Bh = !1)),
                  w = NA(h, null, E, w),
                  h.child = w;
                w;

              )
                (w.flags = (w.flags & -3) | 4096), (w = w.sibling);
          else {
            if ((cu(), E === M)) {
              h = Ro(d, h, w);
              break e;
            }
            Br(d, h, E, w);
          }
          h = h.child;
        }
        return h;
      case 5:
        return (
          LA(h),
          d === null && Y_(h),
          (E = h.type),
          (M = h.pendingProps),
          (L = d !== null ? d.memoizedProps : null),
          (V = M.children),
          se(E, M) ? (V = null) : L !== null && se(E, L) && (h.flags |= 32),
          cR(d, h),
          Br(d, h, V, w),
          h.child
        );
      case 6:
        return d === null && Y_(h), null;
      case 13:
        return fR(d, h, w);
      case 4:
        return (
          Z_(h, h.stateNode.containerInfo),
          (E = h.pendingProps),
          d === null ? (h.child = uu(h, null, E, w)) : Br(d, h, E, w),
          h.child
        );
      case 11:
        return (
          (E = h.type),
          (M = h.pendingProps),
          (M = h.elementType === E ? M : ds(E, M)),
          sR(d, h, E, M, w)
        );
      case 7:
        return Br(d, h, h.pendingProps, w), h.child;
      case 8:
        return Br(d, h, h.pendingProps.children, w), h.child;
      case 12:
        return Br(d, h, h.pendingProps.children, w), h.child;
      case 10:
        e: {
          if (
            ((E = h.type._context),
            (M = h.pendingProps),
            (L = h.memoizedProps),
            (V = M.value),
            yA(h, E, V),
            L !== null)
          )
            if (Ws(L.value, V)) {
              if (L.children === M.children && !Ot.current) {
                h = Ro(d, h, w);
                break e;
              }
            } else
              for (L = h.child, L !== null && (L.return = h); L !== null; ) {
                var J = L.dependencies;
                if (J !== null) {
                  V = L.child;
                  for (var fe = J.firstContext; fe !== null; ) {
                    if (fe.context === E) {
                      if (L.tag === 1) {
                        (fe = To(-1, w & -w)), (fe.tag = 2);
                        var ke = L.updateQueue;
                        if (ke !== null) {
                          ke = ke.shared;
                          var rt = ke.pending;
                          rt === null
                            ? (fe.next = fe)
                            : ((fe.next = rt.next), (rt.next = fe)),
                            (ke.pending = fe);
                        }
                      }
                      (L.lanes |= w),
                        (fe = L.alternate),
                        fe !== null && (fe.lanes |= w),
                        H_(L.return, w, h),
                        (J.lanes |= w);
                      break;
                    }
                    fe = fe.next;
                  }
                } else if (L.tag === 10) V = L.type === h.type ? null : L.child;
                else if (L.tag === 18) {
                  if (((V = L.return), V === null)) throw Error(o(341));
                  (V.lanes |= w),
                    (J = V.alternate),
                    J !== null && (J.lanes |= w),
                    H_(V, w, h),
                    (V = L.sibling);
                } else V = L.child;
                if (V !== null) V.return = L;
                else
                  for (V = L; V !== null; ) {
                    if (V === h) {
                      V = null;
                      break;
                    }
                    if (((L = V.sibling), L !== null)) {
                      (L.return = V.return), (V = L);
                      break;
                    }
                    V = V.return;
                  }
                L = V;
              }
          Br(d, h, M.children, w), (h = h.child);
        }
        return h;
      case 9:
        return (
          (M = h.type),
          (E = h.pendingProps.children),
          ou(h, w),
          (M = zi(M)),
          (E = E(M)),
          (h.flags |= 1),
          Br(d, h, E, w),
          h.child
        );
      case 14:
        return (
          (E = h.type),
          (M = ds(E, h.pendingProps)),
          (M = ds(E.type, M)),
          oR(d, h, E, M, w)
        );
      case 15:
        return aR(d, h, h.type, h.pendingProps, w);
      case 17:
        return (
          (E = h.type),
          (M = h.pendingProps),
          (M = h.elementType === E ? M : ds(E, M)),
          d !== null &&
            ((d.alternate = null), (h.alternate = null), (h.flags |= 2)),
          (h.tag = 1),
          Mt(E) ? ((d = !0), js(h)) : (d = !1),
          ou(h, w),
          EA(h, E, M),
          $_(h, E, M, w),
          dw(null, h, E, !0, d, w)
        );
      case 19:
        return vR(d, h, w);
      case 22:
        return lR(d, h, w);
    }
    throw Error(o(156, h.tag));
  };
  function VR(d, h) {
    return k_(d, h);
  }
  function K5(d, h, w, E) {
    (this.tag = d),
      (this.key = w),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = h),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = E),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function $i(d, h, w, E) {
    return new K5(d, h, w, E);
  }
  function Lw(d) {
    return (d = d.prototype), !(!d || !d.isReactComponent);
  }
  function Y5(d) {
    if (typeof d == "function") return Lw(d) ? 1 : 0;
    if (d != null) {
      if (((d = d.$$typeof), d === y)) return 11;
      if (d === _) return 14;
    }
    return 2;
  }
  function ga(d, h) {
    var w = d.alternate;
    return (
      w === null
        ? ((w = $i(d.tag, h, d.key, d.mode)),
          (w.elementType = d.elementType),
          (w.type = d.type),
          (w.stateNode = d.stateNode),
          (w.alternate = d),
          (d.alternate = w))
        : ((w.pendingProps = h),
          (w.type = d.type),
          (w.flags = 0),
          (w.subtreeFlags = 0),
          (w.deletions = null)),
      (w.flags = d.flags & 14680064),
      (w.childLanes = d.childLanes),
      (w.lanes = d.lanes),
      (w.child = d.child),
      (w.memoizedProps = d.memoizedProps),
      (w.memoizedState = d.memoizedState),
      (w.updateQueue = d.updateQueue),
      (h = d.dependencies),
      (w.dependencies =
        h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }),
      (w.sibling = d.sibling),
      (w.index = d.index),
      (w.ref = d.ref),
      w
    );
  }
  function Ag(d, h, w, E, M, L) {
    var V = 2;
    if (((E = d), typeof d == "function")) Lw(d) && (V = 1);
    else if (typeof d == "string") V = 5;
    else
      e: switch (d) {
        case u:
          return Dl(w.children, M, L, h);
        case f:
          (V = 8), (M |= 8);
          break;
        case p:
          return (
            (d = $i(12, w, h, M | 2)), (d.elementType = p), (d.lanes = L), d
          );
        case x:
          return (d = $i(13, w, h, M)), (d.elementType = x), (d.lanes = L), d;
        case g:
          return (d = $i(19, w, h, M)), (d.elementType = g), (d.lanes = L), d;
        case b:
          return Rg(w, M, L, h);
        default:
          if (typeof d == "object" && d !== null)
            switch (d.$$typeof) {
              case m:
                V = 10;
                break e;
              case v:
                V = 9;
                break e;
              case y:
                V = 11;
                break e;
              case _:
                V = 14;
                break e;
              case S:
                (V = 16), (E = null);
                break e;
            }
          throw Error(o(130, d == null ? d : typeof d, ""));
      }
    return (
      (h = $i(V, w, h, M)), (h.elementType = d), (h.type = E), (h.lanes = L), h
    );
  }
  function Dl(d, h, w, E) {
    return (d = $i(7, d, E, h)), (d.lanes = w), d;
  }
  function Rg(d, h, w, E) {
    return (
      (d = $i(22, d, E, h)),
      (d.elementType = b),
      (d.lanes = w),
      (d.stateNode = {}),
      d
    );
  }
  function Ow(d, h, w) {
    return (d = $i(6, d, null, h)), (d.lanes = w), d;
  }
  function Dw(d, h, w) {
    return (
      (h = $i(4, d.children !== null ? d.children : [], d.key, h)),
      (h.lanes = w),
      (h.stateNode = {
        containerInfo: d.containerInfo,
        pendingChildren: null,
        implementation: d.implementation,
      }),
      h
    );
  }
  function J5(d, h, w, E, M) {
    (this.tag = h),
      (this.containerInfo = d),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Ue),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = O_(0)),
      (this.expirationTimes = O_(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = O_(0)),
      (this.identifierPrefix = E),
      (this.onRecoverableError = M),
      W && (this.mutableSourceEagerHydrationData = null);
  }
  function jR(d, h, w, E, M, L, V, J, fe) {
    return (
      (d = new J5(d, h, w, J, fe)),
      h === 1 ? ((h = 1), L === !0 && (h |= 8)) : (h = 0),
      (L = $i(3, null, null, h)),
      (d.current = L),
      (L.stateNode = d),
      (L.memoizedState = {
        element: E,
        isDehydrated: w,
        cache: null,
        transitions: null,
      }),
      W_(L),
      d
    );
  }
  function HR(d) {
    if (!d) return en;
    d = d._reactInternals;
    e: {
      if (I(d) !== d || d.tag !== 1) throw Error(o(170));
      var h = d;
      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break e;
          case 1:
            if (Mt(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        h = h.return;
      } while (h !== null);
      throw Error(o(171));
    }
    if (d.tag === 1) {
      var w = d.type;
      if (Mt(w)) return xr(d, w, h);
    }
    return h;
  }
  function WR(d) {
    var h = d._reactInternals;
    if (h === void 0)
      throw typeof d.render == "function"
        ? Error(o(188))
        : ((d = Object.keys(d).join(",")), Error(o(268, d)));
    return (d = j(h)), d === null ? null : d.stateNode;
  }
  function GR(d, h) {
    if (((d = d.memoizedState), d !== null && d.dehydrated !== null)) {
      var w = d.retryLane;
      d.retryLane = w !== 0 && w < h ? w : h;
    }
  }
  function kw(d, h) {
    GR(d, h), (d = d.alternate) && GR(d, h);
  }
  function Z5(d) {
    return (d = j(d)), d === null ? null : d.stateNode;
  }
  function Q5() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (d) {
      if (d.tag === 13) {
        var h = zr();
        Gi(d, 134217728, h), kw(d, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (d) {
      if (d.tag === 13) {
        var h = zr(),
          w = pa(d);
        Gi(d, w, h), kw(d, w);
      }
    }),
    (t.attemptSynchronousHydration = function (d) {
      switch (d.tag) {
        case 3:
          var h = d.stateNode;
          if (h.current.memoizedState.isDehydrated) {
            var w = Uh(h.pendingLanes);
            w !== 0 && (D_(h, w | 1), ri(h, nr()), !(Vt & 6) && (gu(), Gs()));
          }
          break;
        case 13:
          var E = zr();
          LR(function () {
            return Gi(d, 1, E);
          }),
            kw(d, 1);
      }
    }),
    (t.batchedUpdates = function (d, h) {
      var w = Vt;
      Vt |= 1;
      try {
        return d(h);
      } finally {
        (Vt = w), Vt === 0 && (gu(), jm && Gs());
      }
    }),
    (t.createComponentSelector = function (d) {
      return { $$typeof: pg, value: d };
    }),
    (t.createContainer = function (d, h, w, E, M, L, V) {
      return jR(d, h, !1, null, w, E, M, L, V);
    }),
    (t.createHasPseudoClassSelector = function (d) {
      return { $$typeof: mg, value: d };
    }),
    (t.createHydrationContainer = function (d, h, w, E, M, L, V, J, fe) {
      return (
        (d = jR(w, E, !0, d, M, L, V, J, fe)),
        (d.context = HR(null)),
        (w = d.current),
        (E = zr()),
        (M = pa(w)),
        (L = To(E, M)),
        (L.callback = h ?? null),
        da(w, L),
        (d.current.lanes = M),
        Fh(d, M, E),
        ri(d, E),
        d
      );
    }),
    (t.createPortal = function (d, h, w) {
      var E =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: c,
        key: E == null ? null : "" + E,
        children: d,
        containerInfo: h,
        implementation: w,
      };
    }),
    (t.createRoleSelector = function (d) {
      return { $$typeof: gg, value: d };
    }),
    (t.createTestNameSelector = function (d) {
      return { $$typeof: vg, value: d };
    }),
    (t.createTextSelector = function (d) {
      return { $$typeof: yg, value: d };
    }),
    (t.deferredUpdates = function (d) {
      var h = Yt,
        w = kn.transition;
      try {
        return (kn.transition = null), (Yt = 16), d();
      } finally {
        (Yt = h), (kn.transition = w);
      }
    }),
    (t.discreteUpdates = function (d, h, w, E, M) {
      var L = Yt,
        V = kn.transition;
      try {
        return (kn.transition = null), (Yt = 1), d(h, w, E, M);
      } finally {
        (Yt = L), (kn.transition = V), Vt === 0 && gu();
      }
    }),
    (t.findAllNodes = Sw),
    (t.findBoundingRects = function (d, h) {
      if (!De) throw Error(o(363));
      (h = Sw(d, h)), (d = []);
      for (var w = 0; w < h.length; w++) d.push(wt(h[w]));
      for (h = d.length - 1; 0 < h; h--) {
        w = d[h];
        for (
          var E = w.x, M = E + w.width, L = w.y, V = L + w.height, J = h - 1;
          0 <= J;
          J--
        )
          if (h !== J) {
            var fe = d[J],
              ke = fe.x,
              rt = ke + fe.width,
              Rt = fe.y,
              xt = Rt + fe.height;
            if (E >= ke && L >= Rt && M <= rt && V <= xt) {
              d.splice(h, 1);
              break;
            } else if (E !== ke || w.width !== fe.width || xt < L || Rt > V) {
              if (!(L !== Rt || w.height !== fe.height || rt < E || ke > M)) {
                ke > E && ((fe.width += ke - E), (fe.x = E)),
                  rt < M && (fe.width = M - ke),
                  d.splice(h, 1);
                break;
              }
            } else {
              Rt > L && ((fe.height += Rt - L), (fe.y = L)),
                xt < V && (fe.height = V - Rt),
                d.splice(h, 1);
              break;
            }
          }
      }
      return d;
    }),
    (t.findHostInstance = WR),
    (t.findHostInstanceWithNoPortals = function (d) {
      return (
        (d = D(d)),
        (d = d !== null ? G(d) : null),
        d === null ? null : d.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (d) {
      return WR(d);
    }),
    (t.flushControlled = function (d) {
      var h = Vt;
      Vt |= 1;
      var w = kn.transition,
        E = Yt;
      try {
        (kn.transition = null), (Yt = 1), d();
      } finally {
        (Yt = E), (kn.transition = w), (Vt = h), Vt === 0 && (gu(), Gs());
      }
    }),
    (t.flushPassiveEffects = Ol),
    (t.flushSync = LR),
    (t.focusWithin = function (d, h) {
      if (!De) throw Error(o(363));
      for (d = xw(d), h = PR(d, h), h = Array.from(h), d = 0; d < h.length; ) {
        var w = h[d++];
        if (!k(w)) {
          if (w.tag === 5 && ae(w.stateNode)) return !0;
          for (w = w.child; w !== null; ) h.push(w), (w = w.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Yt;
    }),
    (t.getFindAllNodesFailureDescription = function (d, h) {
      if (!De) throw Error(o(363));
      var w = 0,
        E = [];
      d = [xw(d), 0];
      for (var M = 0; M < d.length; ) {
        var L = d[M++],
          V = d[M++],
          J = h[V];
        if (
          (L.tag !== 5 || !k(L)) &&
          (_w(L, J) && (E.push(ww(J)), V++, V > w && (w = V)), V < h.length)
        )
          for (L = L.child; L !== null; ) d.push(L, V), (L = L.sibling);
      }
      if (w < h.length) {
        for (d = []; w < h.length; w++) d.push(ww(h[w]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (E.join(" > ") +
            `

No matching component was found for:
  `) +
          d.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (d) {
      if (((d = d.current), !d.child)) return null;
      switch (d.child.tag) {
        case 5:
          return q(d.child.stateNode);
        default:
          return d.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (d) {
      if (
        ((d = {
          bundleType: d.bundleType,
          version: d.version,
          rendererPackageName: d.rendererPackageName,
          rendererConfig: d.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: Z5,
          findFiberByHostInstance: d.findFiberByHostInstance || Q5,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        d = !1;
      else {
        var h = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (h.isDisabled || !h.supportsFiber) d = !0;
        else {
          try {
            (Vm = h.inject(d)), (Hs = h);
          } catch {}
          d = !!h.checkDCE;
        }
      }
      return d;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (d, h, w, E) {
      if (!De) throw Error(o(363));
      d = Sw(d, h);
      var M = we(d, w, E).disconnect;
      return {
        disconnect: function () {
          M();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (d, h) {
      var w = h._getVersion;
      (w = w(h._source)),
        d.mutableSourceEagerHydrationData == null
          ? (d.mutableSourceEagerHydrationData = [h, w])
          : d.mutableSourceEagerHydrationData.push(h, w);
    }),
    (t.runWithPriority = function (d, h) {
      var w = Yt;
      try {
        return (Yt = d), h();
      } finally {
        Yt = w;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (d, h, w, E) {
      var M = h.current,
        L = zr(),
        V = pa(M);
      return (
        (w = HR(w)),
        h.context === null ? (h.context = w) : (h.pendingContext = w),
        (h = To(L, V)),
        (h.payload = { element: d }),
        (E = E === void 0 ? null : E),
        E !== null && (h.callback = E),
        da(M, h),
        (d = Gi(M, V, L)),
        d !== null && $m(d, M, V),
        V
      );
    }),
    t
  );
};
dj.exports = cue;
var uue = dj.exports;
const due = cT(uue),
  dA = {},
  hue = (n) => void Object.assign(dA, n);
function fue(n, e) {
  function t(u, { args: f = [], attach: p, ...m }, v) {
    let y = `${u[0].toUpperCase()}${u.slice(1)}`,
      x;
    if (u === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      x = Qu(g, { type: u, root: v, attach: p, primitive: !0 });
    } else {
      const g = dA[y];
      if (!g)
        throw new Error(
          `R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(f))
        throw new Error("R3F: The args prop must be an array!");
      x = Qu(new g(...f), {
        type: u,
        root: v,
        attach: p,
        memoizedProps: { args: f },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x.isBufferGeometry
          ? (x.__r3f.attach = "geometry")
          : x.isMaterial && (x.__r3f.attach = "material")),
      y !== "inject" && j1(x, m),
      x
    );
  }
  function r(u, f) {
    let p = !1;
    if (f) {
      var m, v;
      (m = f.__r3f) != null && m.attach
        ? V1(u, f, f.__r3f.attach)
        : f.isObject3D && u.isObject3D && (u.add(f), (p = !0)),
        p || (v = u.__r3f) == null || v.objects.push(f),
        f.__r3f || Qu(f, {}),
        (f.__r3f.parent = u),
        tT(f),
        ed(f);
    }
  }
  function i(u, f, p) {
    let m = !1;
    if (f) {
      var v, y;
      if ((v = f.__r3f) != null && v.attach) V1(u, f, f.__r3f.attach);
      else if (f.isObject3D && u.isObject3D) {
        (f.parent = u),
          f.dispatchEvent({ type: "added" }),
          u.dispatchEvent({ type: "childadded", child: f });
        const x = u.children.filter((_) => _ !== f),
          g = x.indexOf(p);
        (u.children = [...x.slice(0, g), f, ...x.slice(g)]), (m = !0);
      }
      m || (y = u.__r3f) == null || y.objects.push(f),
        f.__r3f || Qu(f, {}),
        (f.__r3f.parent = u),
        tT(f),
        ed(f);
    }
  }
  function s(u, f, p = !1) {
    u && [...u].forEach((m) => o(f, m, p));
  }
  function o(u, f, p) {
    if (f) {
      var m, v, y;
      if (
        (f.__r3f && (f.__r3f.parent = null),
        (m = u.__r3f) != null &&
          m.objects &&
          (u.__r3f.objects = u.__r3f.objects.filter((b) => b !== f)),
        (v = f.__r3f) != null && v.attach)
      )
        wO(u, f, f.__r3f.attach);
      else if (f.isObject3D && u.isObject3D) {
        var x;
        u.remove(f), (x = f.__r3f) != null && x.root && wue(Ly(f), f);
      }
      const _ = (y = f.__r3f) == null ? void 0 : y.primitive,
        S = !_ && (p === void 0 ? f.dispose !== null : p);
      if (!_) {
        var g;
        s((g = f.__r3f) == null ? void 0 : g.objects, f, S),
          s(f.children, f, S);
      }
      if ((delete f.__r3f, S && f.dispose && f.type !== "Scene")) {
        const b = () => {
          try {
            f.dispose();
          } catch {}
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u"
          ? QE.unstable_scheduleCallback(QE.unstable_IdlePriority, b)
          : b();
      }
      ed(u);
    }
  }
  function a(u, f, p, m) {
    var v;
    const y = (v = u.__r3f) == null ? void 0 : v.parent;
    if (!y) return;
    const x = t(f, p, u.__r3f.root);
    if (u.children) {
      for (const g of u.children) g.__r3f && r(x, g);
      u.children = u.children.filter((g) => !g.__r3f);
    }
    u.__r3f.objects.forEach((g) => r(x, g)),
      (u.__r3f.objects = []),
      u.__r3f.autoRemovedBeforeAppend || o(y, u),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      r(y, x),
      x.raycast &&
        x.__r3f.eventCount &&
        Ly(x).getState().internal.interaction.push(x),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = x),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(x) : (g.ref.current = x)));
      });
  }
  const l = () => {};
  return {
    reconciler: due({
      createInstance: t,
      removeChild: o,
      appendChild: r,
      appendInitialChild: r,
      insertBefore: i,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (u, f) => {
        if (!f) return;
        const p = u.getState().scene;
        p.__r3f && ((p.__r3f.root = u), r(p, f));
      },
      removeChildFromContainer: (u, f) => {
        f && o(u.getState().scene, f);
      },
      insertInContainerBefore: (u, f, p) => {
        if (!f || !p) return;
        const m = u.getState().scene;
        m.__r3f && i(m, f, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (u) => u,
      finalizeInitialChildren(u) {
        var f;
        return !!((f = u == null ? void 0 : u.__r3f) != null ? f : {}).handlers;
      },
      prepareUpdate(u, f, p, m) {
        var v;
        if (
          ((v = u == null ? void 0 : u.__r3f) != null ? v : {}).primitive &&
          m.object &&
          m.object !== u
        )
          return [!0];
        {
          const { args: x = [], children: g, ..._ } = m,
            { args: S = [], children: b, ...C } = p;
          if (!Array.isArray(x))
            throw new Error("R3F: the args prop must be an array!");
          if (x.some((R, O) => R !== S[O])) return [!0];
          const A = _j(u, _, C, !0);
          return A.changes.length ? [!1, A] : null;
        }
      },
      commitUpdate(u, [f, p], m, v, y, x) {
        f ? a(u, m, y, x) : j1(u, p);
      },
      commitMount(u, f, p, m) {
        var v;
        const y = (v = u.__r3f) != null ? v : {};
        u.raycast &&
          y.handlers &&
          y.eventCount &&
          Ly(u).getState().internal.interaction.push(u);
      },
      getPublicInstance: (u) => u,
      prepareForCommit: () => null,
      preparePortalMount: (u) => Qu(u.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(u) {
        var f;
        const { attach: p, parent: m } = (f = u.__r3f) != null ? f : {};
        p && m && wO(m, u, p), u.isObject3D && (u.visible = !1), ed(u);
      },
      unhideInstance(u, f) {
        var p;
        const { attach: m, parent: v } = (p = u.__r3f) != null ? p : {};
        m && v && V1(v, u, m),
          ((u.isObject3D && f.visible == null) || f.visible) &&
            (u.visible = !0),
          ed(u);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Sd.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && hn.fun(performance.now)
          ? performance.now
          : hn.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: hn.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: hn.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: j1,
  };
}
var vO, yO;
const z1 = (n) => "colorSpace" in n || "outputColorSpace" in n,
  pj = () => {
    var n;
    return (n = dA.ColorManagement) != null ? n : null;
  },
  mj = (n) => n && n.isOrthographicCamera,
  pue = (n) => n && n.hasOwnProperty("current"),
  Om =
    typeof window < "u" &&
    (((vO = window.document) != null && vO.createElement) ||
      ((yO = window.navigator) == null ? void 0 : yO.product) === "ReactNative")
      ? P.useLayoutEffect
      : P.useEffect;
function gj(n) {
  const e = P.useRef(n);
  return Om(() => void (e.current = n), [n]), e;
}
function mue({ set: n }) {
  return Om(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class vj extends P.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
vj.getDerivedStateFromError = () => ({ error: !0 });
const yj = "__default",
  xO = new Map(),
  gue = (n) => n && !!n.memoized && !!n.changes;
function xj(n) {
  var e;
  const t =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n;
}
const Mf = (n) => {
  var e;
  return (e = n.__r3f) == null ? void 0 : e.root.getState();
};
function Ly(n) {
  let e = n.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const hn = {
  obj: (n) => n === Object(n) && !hn.arr(n) && typeof n != "function",
  fun: (n) => typeof n == "function",
  str: (n) => typeof n == "string",
  num: (n) => typeof n == "number",
  boo: (n) => typeof n == "boolean",
  und: (n) => n === void 0,
  arr: (n) => Array.isArray(n),
  equ(
    n,
    e,
    { arrays: t = "shallow", objects: r = "reference", strict: i = !0 } = {}
  ) {
    if (typeof n != typeof e || !!n != !!e) return !1;
    if (hn.str(n) || hn.num(n) || hn.boo(n)) return n === e;
    const s = hn.obj(n);
    if (s && r === "reference") return n === e;
    const o = hn.arr(n);
    if (o && t === "reference") return n === e;
    if ((o || s) && n === e) return !0;
    let a;
    for (a in n) if (!(a in e)) return !1;
    if (s && t === "shallow" && r === "shallow") {
      for (a in i ? e : n)
        if (!hn.equ(n[a], e[a], { strict: i, objects: "reference" })) return !1;
    } else for (a in i ? e : n) if (n[a] !== e[a]) return !1;
    if (hn.und(a)) {
      if (
        (o && n.length === 0 && e.length === 0) ||
        (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
      )
        return !0;
      if (n !== e) return !1;
    }
    return !0;
  },
};
function vue(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function Qu(n, e) {
  const t = n;
  return (
    (t.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    n
  );
}
function eT(n, e) {
  let t = n;
  if (e.includes("-")) {
    const r = e.split("-"),
      i = r.pop();
    return (t = r.reduce((s, o) => s[o], n)), { target: t, key: i };
  } else return { target: t, key: e };
}
const _O = /-\d+$/;
function V1(n, e, t) {
  if (hn.str(t)) {
    if (_O.test(t)) {
      const s = t.replace(_O, ""),
        { target: o, key: a } = eT(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: r, key: i } = eT(n, t);
    (e.__r3f.previousAttach = r[i]), (r[i] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function wO(n, e, t) {
  var r, i;
  if (hn.str(t)) {
    const { target: s, key: o } = eT(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (r = e.__r3f) == null || r.previousAttach == null || r.previousAttach(n, e);
  (i = e.__r3f) == null || delete i.previousAttach;
}
function _j(
  n,
  { children: e, key: t, ref: r, ...i },
  { children: s, key: o, ref: a, ...l } = {},
  c = !1
) {
  const u = n.__r3f,
    f = Object.entries(i),
    p = [];
  if (c) {
    const v = Object.keys(l);
    for (let y = 0; y < v.length; y++)
      i.hasOwnProperty(v[y]) || f.unshift([v[y], yj + "remove"]);
  }
  f.forEach(([v, y]) => {
    var x;
    if (
      ((x = n.__r3f) != null && x.primitive && v === "object") ||
      hn.equ(y, l[v])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v))
      return p.push([v, y, !0, []]);
    let g = [];
    v.includes("-") && (g = v.split("-")), p.push([v, y, !1, g]);
    for (const _ in i) {
      const S = i[_];
      _.startsWith(`${v}-`) && p.push([_, S, !1, _.split("-")]);
    }
  });
  const m = { ...i };
  return (
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.args &&
      (m.args = u.memoizedProps.args),
    u != null &&
      u.memoizedProps &&
      u != null &&
      u.memoizedProps.attach &&
      (m.attach = u.memoizedProps.attach),
    { memoized: m, changes: p }
  );
}
const yue = typeof process < "u" && !1;
function j1(n, e) {
  var t;
  const r = n.__r3f,
    i = r == null ? void 0 : r.root,
    s = i == null || i.getState == null ? void 0 : i.getState(),
    { memoized: o, changes: a } = gue(e) ? e : _j(n, e),
    l = r == null ? void 0 : r.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [m, v, y, x] = a[p];
    if (z1(n)) {
      const b = "srgb",
        C = "srgb-linear";
      m === "encoding"
        ? ((m = "colorSpace"), (v = v === 3001 ? b : C))
        : m === "outputEncoding" &&
          ((m = "outputColorSpace"), (v = v === 3001 ? b : C));
    }
    let g = n,
      _ = g[m];
    if (x.length && ((_ = x.reduce((S, b) => S[b], n)), !(_ && _.set))) {
      const [S, ...b] = x.reverse();
      (g = b.reverse().reduce((C, A) => C[A], n)), (m = S);
    }
    if (v === yj + "remove")
      if (g.constructor) {
        let S = xO.get(g.constructor);
        S || ((S = new g.constructor()), xO.set(g.constructor, S)), (v = S[m]);
      } else v = 0;
    if (y && r)
      v ? (r.handlers[m] = v) : delete r.handlers[m],
        (r.eventCount = Object.keys(r.handlers).length);
    else if (_ && _.set && (_.copy || _ instanceof Ic)) {
      if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v);
      else if (
        _.copy &&
        v &&
        v.constructor &&
        (yue
          ? _.constructor.name === v.constructor.name
          : _.constructor === v.constructor)
      )
        _.copy(v);
      else if (v !== void 0) {
        var c;
        const S = (c = _) == null ? void 0 : c.isColor;
        !S && _.setScalar
          ? _.setScalar(v)
          : _ instanceof Ic && v instanceof Ic
          ? (_.mask = v.mask)
          : _.set(v),
          !pj() && s && !s.linear && S && _.convertSRGBToLinear();
      }
    } else {
      var u;
      if (
        ((g[m] = v),
        (u = g[m]) != null &&
          u.isTexture &&
          g[m].format === Or &&
          g[m].type === ls &&
          s)
      ) {
        const S = g[m];
        z1(S) && z1(s.gl)
          ? (S.colorSpace = s.gl.outputColorSpace)
          : (S.encoding = s.gl.outputEncoding);
      }
    }
    ed(n);
  }
  if (r && r.parent && n.raycast && l !== r.eventCount) {
    const p = Ly(n).getState().internal,
      m = p.interaction.indexOf(n);
    m > -1 && p.interaction.splice(m, 1), r.eventCount && p.interaction.push(n);
  }
  return (
    !(a.length === 1 && a[0][0] === "onUpdate") &&
      a.length &&
      (t = n.__r3f) != null &&
      t.parent &&
      tT(n),
    n
  );
}
function ed(n) {
  var e, t;
  const r =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  r && r.internal.frames === 0 && r.invalidate();
}
function tT(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function xue(n, e) {
  n.manual ||
    (mj(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function oy(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function _ue() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Sd.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Sd.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Sd.ContinuousEventPriority;
    default:
      return Sd.DefaultEventPriority;
  }
}
function wj(n, e, t, r) {
  const i = t.get(e);
  i &&
    (t.delete(e),
    t.size === 0 && (n.delete(r), i.target.releasePointerCapture(r)));
}
function wue(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((r) => r !== e)),
    (t.initialHits = t.initialHits.filter((r) => r !== e)),
    t.hovered.forEach((r, i) => {
      (r.eventObject === e || r.object === e) && t.hovered.delete(i);
    }),
    t.capturedMap.forEach((r, i) => {
      wj(t.capturedMap, e, r, i);
    });
}
function Sue(n) {
  function e(l) {
    const { internal: c } = n.getState(),
      u = l.offsetX - c.initialClick[0],
      f = l.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(u * u + f * f));
  }
  function t(l) {
    return l.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((u) => {
        var f;
        return (f = c.__r3f) == null ? void 0 : f.handlers["onPointer" + u];
      })
    );
  }
  function r(l, c) {
    const u = n.getState(),
      f = new Set(),
      p = [],
      m = c ? c(u.internal.interaction) : u.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const _ = Mf(m[g]);
      _ && (_.raycaster.camera = void 0);
    }
    u.previousRoot || u.events.compute == null || u.events.compute(l, u);
    function v(g) {
      const _ = Mf(g);
      if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
      if (_.raycaster.camera === void 0) {
        var S;
        _.events.compute == null ||
          _.events.compute(
            l,
            _,
            (S = _.previousRoot) == null ? void 0 : S.getState()
          ),
          _.raycaster.camera === void 0 && (_.raycaster.camera = null);
      }
      return _.raycaster.camera ? _.raycaster.intersectObject(g, !0) : [];
    }
    let y = m
      .flatMap(v)
      .sort((g, _) => {
        const S = Mf(g.object),
          b = Mf(_.object);
        return !S || !b
          ? g.distance - _.distance
          : b.events.priority - S.events.priority || g.distance - _.distance;
      })
      .filter((g) => {
        const _ = oy(g);
        return f.has(_) ? !1 : (f.add(_), !0);
      });
    u.events.filter && (y = u.events.filter(y, u));
    for (const g of y) {
      let _ = g.object;
      for (; _; ) {
        var x;
        (x = _.__r3f) != null &&
          x.eventCount &&
          p.push({ ...g, eventObject: _ }),
          (_ = _.parent);
      }
    }
    if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId))
      for (let g of u.internal.capturedMap.get(l.pointerId).values())
        f.has(oy(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function i(l, c, u, f) {
    const p = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const v of l) {
        const y = Mf(v.object) || p,
          { raycaster: x, pointer: g, camera: _, internal: S } = y,
          b = new z(g.x, g.y, 0).unproject(_),
          C = (N) => {
            var D, j;
            return (D =
              (j = S.capturedMap.get(N)) == null
                ? void 0
                : j.has(v.eventObject)) != null
              ? D
              : !1;
          },
          A = (N) => {
            const D = { intersection: v, target: c.target };
            S.capturedMap.has(N)
              ? S.capturedMap.get(N).set(v.eventObject, D)
              : S.capturedMap.set(N, new Map([[v.eventObject, D]])),
              c.target.setPointerCapture(N);
          },
          R = (N) => {
            const D = S.capturedMap.get(N);
            D && wj(S.capturedMap, v.eventObject, D, N);
          };
        let O = {};
        for (let N in c) {
          let D = c[N];
          typeof D != "function" && (O[N] = D);
        }
        let I = {
          ...v,
          ...O,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: u,
          unprojectedPoint: b,
          ray: x.ray,
          camera: _,
          stopPropagation() {
            const N = "pointerId" in c && S.capturedMap.get(c.pointerId);
            if (
              (!N || N.has(v.eventObject)) &&
              ((I.stopped = m.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (D) => D.eventObject === v.eventObject
                ))
            ) {
              const D = l.slice(0, l.indexOf(v));
              s([...D, v]);
            }
          },
          target: {
            hasPointerCapture: C,
            setPointerCapture: A,
            releasePointerCapture: R,
          },
          currentTarget: {
            hasPointerCapture: C,
            setPointerCapture: A,
            releasePointerCapture: R,
          },
          nativeEvent: c,
        };
        if ((f(I), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: c } = n.getState();
    for (const u of c.hovered.values())
      if (
        !l.length ||
        !l.find(
          (f) =>
            f.object === u.object &&
            f.index === u.index &&
            f.instanceId === u.instanceId
        )
      ) {
        const p = u.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((c.hovered.delete(oy(u)), p != null && p.eventCount)) {
          const v = { ...u, intersections: l };
          m.onPointerOut == null || m.onPointerOut(v),
            m.onPointerLeave == null || m.onPointerLeave(v);
        }
      }
  }
  function o(l, c) {
    for (let u = 0; u < c.length; u++) {
      const f = c[u].__r3f;
      f == null ||
        f.handlers.onPointerMissed == null ||
        f.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: u } = n.getState();
          "pointerId" in c &&
            u.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              u.capturedMap.has(c.pointerId) &&
                (u.capturedMap.delete(c.pointerId), s([]));
            });
        };
    }
    return function (u) {
      const { onPointerMissed: f, internal: p } = n.getState();
      p.lastEvent.current = u;
      const m = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = r(u, m ? t : void 0),
        g = v ? e(u) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [u.offsetX, u.offsetY]),
        (p.initialHits = x.map((S) => S.eventObject))),
        v && !x.length && g <= 2 && (o(u, p.interaction), f && f(u)),
        m && s(x);
      function _(S) {
        const b = S.eventObject,
          C = b.__r3f,
          A = C == null ? void 0 : C.handlers;
        if (C != null && C.eventCount)
          if (m) {
            if (
              A.onPointerOver ||
              A.onPointerEnter ||
              A.onPointerOut ||
              A.onPointerLeave
            ) {
              const R = oy(S),
                O = p.hovered.get(R);
              O
                ? O.stopped && S.stopPropagation()
                : (p.hovered.set(R, S),
                  A.onPointerOver == null || A.onPointerOver(S),
                  A.onPointerEnter == null || A.onPointerEnter(S));
            }
            A.onPointerMove == null || A.onPointerMove(S);
          } else {
            const R = A[l];
            R
              ? (!v || p.initialHits.includes(b)) &&
                (o(
                  u,
                  p.interaction.filter((O) => !p.initialHits.includes(O))
                ),
                R(S))
              : v &&
                p.initialHits.includes(b) &&
                o(
                  u,
                  p.interaction.filter((O) => !p.initialHits.includes(O))
                );
          }
      }
      i(x, u, g, _);
    };
  }
  return { handlePointer: a };
}
const Sj = (n) => !!(n != null && n.render),
  bj = P.createContext(null),
  bue = (n, e) => {
    const t = lue((a, l) => {
        const c = new z(),
          u = new z(),
          f = new z();
        function p(g = l().camera, _ = u, S = l().size) {
          const { width: b, height: C, top: A, left: R } = S,
            O = b / C;
          _.isVector3 ? f.copy(_) : f.set(..._);
          const I = g.getWorldPosition(c).distanceTo(f);
          if (mj(g))
            return {
              width: b / g.zoom,
              height: C / g.zoom,
              top: A,
              left: R,
              factor: 1,
              distance: I,
              aspect: O,
            };
          {
            const N = (g.fov * Math.PI) / 180,
              D = 2 * Math.tan(N / 2) * I,
              j = D * (b / C);
            return {
              width: j,
              height: D,
              top: A,
              left: R,
              factor: b / j,
              distance: I,
              aspect: O,
            };
          }
        }
        let m;
        const v = (g) =>
            a((_) => ({ performance: { ..._.performance, current: g } })),
          y = new xe();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => n(l(), g),
          advance: (g, _) => e(g, _, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new sA(),
          pointer: y,
          mouse: y,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  v(g.performance.min),
                (m = setTimeout(
                  () => v(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((_) => ({ ..._, events: { ..._.events, ...g } })),
          setSize: (g, _, S, b, C) => {
            const A = l().camera,
              R = {
                width: g,
                height: _,
                top: b || 0,
                left: C || 0,
                updateStyle: S,
              };
            a((O) => ({ size: R, viewport: { ...O.viewport, ...p(A, u, R) } }));
          },
          setDpr: (g) =>
            a((_) => {
              const S = xj(g);
              return {
                viewport: {
                  ..._.viewport,
                  dpr: S,
                  initialDpr: _.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const _ = l().clock;
            _.stop(),
              (_.elapsedTime = 0),
              g !== "never" && (_.start(), (_.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: P.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, _, S) => {
              const b = l().internal;
              return (
                (b.priority = b.priority + (_ > 0 ? 1 : 0)),
                b.subscribers.push({ ref: g, priority: _, store: S }),
                (b.subscribers = b.subscribers.sort(
                  (C, A) => C.priority - A.priority
                )),
                () => {
                  const C = l().internal;
                  C != null &&
                    C.subscribers &&
                    ((C.priority = C.priority - (_ > 0 ? 1 : 0)),
                    (C.subscribers = C.subscribers.filter((A) => A.ref !== g)));
                }
              );
            },
          },
        };
      }),
      r = t.getState();
    let i = r.size,
      s = r.viewport.dpr,
      o = r.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: c, gl: u, set: f } = t.getState();
        if (l.width !== i.width || l.height !== i.height || c.dpr !== s) {
          var p;
          (i = l), (s = c.dpr), xue(a, l), u.setPixelRatio(c.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                u.domElement instanceof HTMLCanvasElement;
          u.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          f((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let ay,
  Eue = new Set(),
  Tue = new Set(),
  Mue = new Set();
function H1(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Cf(n, e) {
  switch (n) {
    case "before":
      return H1(Eue, e);
    case "after":
      return H1(Tue, e);
    case "tail":
      return H1(Mue, e);
  }
}
let W1, G1;
function $1(n, e, t) {
  let r = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((r = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      W1 = e.internal.subscribers,
      ay = 0;
    ay < W1.length;
    ay++
  )
    (G1 = W1[ay]), G1.ref.current(G1.store.getState(), r, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function Cue(n) {
  let e = !1,
    t = !1,
    r,
    i,
    s;
  function o(c) {
    (i = requestAnimationFrame(o)),
      (e = !0),
      (r = 0),
      Cf("before", c),
      (t = !0);
    for (const f of n.values()) {
      var u;
      (s = f.store.getState()),
        s.internal.active &&
          (s.frameloop === "always" || s.internal.frames > 0) &&
          !((u = s.gl.xr) != null && u.isPresenting) &&
          (r += $1(c, s));
    }
    if (((t = !1), Cf("after", c), r === 0))
      return Cf("tail", c), (e = !1), cancelAnimationFrame(i);
  }
  function a(c, u = 1) {
    var f;
    if (!c) return n.forEach((p) => a(p.store.getState(), u));
    ((f = c.gl.xr) != null && f.isPresenting) ||
      !c.internal.active ||
      c.frameloop === "never" ||
      (u > 1
        ? (c.internal.frames = Math.min(60, c.internal.frames + u))
        : t
        ? (c.internal.frames = 2)
        : (c.internal.frames = 1),
      e || ((e = !0), requestAnimationFrame(o)));
  }
  function l(c, u = !0, f, p) {
    if ((u && Cf("before", c), f)) $1(c, f, p);
    else for (const m of n.values()) $1(c, m.store.getState());
    u && Cf("after", c);
  }
  return { loop: o, invalidate: a, advance: l };
}
function Ej() {
  const n = P.useContext(bj);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Aue(n = (t) => t, e) {
  return Ej()(n, e);
}
function Rue(n, e = 0) {
  const t = Ej(),
    r = t.getState().internal.subscribe,
    i = gj(n);
  return Om(() => r(i, e, t), [e, r, t]), null;
}
const ph = new Map(),
  { invalidate: SO, advance: bO } = Cue(ph),
  { reconciler: cx, applyProps: Xu } = fue(ph, _ue),
  qu = { objects: "shallow", strict: !1 },
  Pue = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return Sj(t)
      ? t
      : new cj({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function Iue(n, e) {
  const t = typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement;
  if (e) {
    const { width: r, height: i, top: s, left: o, updateStyle: a = t } = e;
    return { width: r, height: i, top: s, left: o, updateStyle: a };
  } else if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: r,
      height: i,
      top: s,
      left: o,
    } = n.parentElement.getBoundingClientRect();
    return { width: r, height: i, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0,
      updateStyle: t,
    };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function Nue(n) {
  const e = ph.get(n),
    t = e == null ? void 0 : e.fiber,
    r = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const i = typeof reportError == "function" ? reportError : console.error,
    s = r || bue(SO, bO),
    o =
      t ||
      cx.createContainer(s, Sd.ConcurrentRoot, null, !1, null, "", i, null);
  e || ph.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    c;
  return {
    configure(u = {}) {
      let {
          gl: f,
          size: p,
          scene: m,
          events: v,
          onCreated: y,
          shadows: x = !1,
          linear: g = !1,
          flat: _ = !1,
          legacy: S = !1,
          orthographic: b = !1,
          frameloop: C = "always",
          dpr: A = [1, 2],
          performance: R,
          raycaster: O,
          camera: I,
          onPointerMissed: N,
        } = u,
        D = s.getState(),
        j = D.gl;
      D.gl || D.set({ gl: (j = Pue(f, n)) });
      let $ = D.raycaster;
      $ || D.set({ raycaster: ($ = new ej()) });
      const { params: G, ...Z } = O || {};
      if (
        (hn.equ(Z, $, qu) || Xu($, { ...Z }),
        hn.equ(G, $.params, qu) || Xu($, { params: { ...$.params, ...G } }),
        !D.camera || (D.camera === c && !hn.equ(c, I, qu)))
      ) {
        c = I;
        const X = I instanceof Tm,
          ie = X
            ? I
            : b
            ? new Lm(0, 0, 0, 0, 0.1, 1e3)
            : new lr(75, 0, 0.1, 1e3);
        X ||
          ((ie.position.z = 5),
          I &&
            (Xu(ie, I),
            ("aspect" in I ||
              "left" in I ||
              "right" in I ||
              "bottom" in I ||
              "top" in I) &&
              ((ie.manual = !0), ie.updateProjectionMatrix())),
          !D.camera && !(I != null && I.rotation) && ie.lookAt(0, 0, 0)),
          D.set({ camera: ie }),
          ($.camera = ie);
      }
      if (!D.scene) {
        let X;
        m != null && m.isScene ? (X = m) : ((X = new BC()), m && Xu(X, m)),
          D.set({ scene: Qu(X) });
      }
      if (!D.xr) {
        var q;
        const X = (Ee, Ie) => {
            const se = s.getState();
            se.frameloop !== "never" && bO(Ee, !0, se, Ie);
          },
          ie = () => {
            const Ee = s.getState();
            (Ee.gl.xr.enabled = Ee.gl.xr.isPresenting),
              Ee.gl.xr.setAnimationLoop(Ee.gl.xr.isPresenting ? X : null),
              Ee.gl.xr.isPresenting || SO(Ee);
          },
          de = {
            connect() {
              const Ee = s.getState().gl;
              Ee.xr.addEventListener("sessionstart", ie),
                Ee.xr.addEventListener("sessionend", ie);
            },
            disconnect() {
              const Ee = s.getState().gl;
              Ee.xr.removeEventListener("sessionstart", ie),
                Ee.xr.removeEventListener("sessionend", ie);
            },
          };
        typeof ((q = j.xr) == null ? void 0 : q.addEventListener) ==
          "function" && de.connect(),
          D.set({ xr: de });
      }
      if (j.shadowMap) {
        const X = j.shadowMap.enabled,
          ie = j.shadowMap.type;
        if (((j.shadowMap.enabled = !!x), hn.boo(x))) j.shadowMap.type = np;
        else if (hn.str(x)) {
          var Y;
          const de = { basic: h4, percentage: Xx, soft: np, variance: Ts };
          j.shadowMap.type = (Y = de[x]) != null ? Y : np;
        } else hn.obj(x) && Object.assign(j.shadowMap, x);
        (X !== j.shadowMap.enabled || ie !== j.shadowMap.type) &&
          (j.shadowMap.needsUpdate = !0);
      }
      const U = pj();
      U &&
        ("enabled" in U
          ? (U.enabled = !S)
          : "legacyMode" in U && (U.legacyMode = S)),
        l ||
          Xu(j, { outputEncoding: g ? 3e3 : 3001, toneMapping: _ ? go : EC }),
        D.legacy !== S && D.set(() => ({ legacy: S })),
        D.linear !== g && D.set(() => ({ linear: g })),
        D.flat !== _ && D.set(() => ({ flat: _ })),
        f && !hn.fun(f) && !Sj(f) && !hn.equ(f, j, qu) && Xu(j, f),
        v && !D.events.handlers && D.set({ events: v(s) });
      const H = Iue(n, p);
      return (
        hn.equ(H, D.size, qu) ||
          D.setSize(H.width, H.height, H.updateStyle, H.top, H.left),
        A && D.viewport.dpr !== xj(A) && D.setDpr(A),
        D.frameloop !== C && D.setFrameloop(C),
        D.onPointerMissed || D.set({ onPointerMissed: N }),
        R &&
          !hn.equ(R, D.performance, qu) &&
          D.set((X) => ({ performance: { ...X.performance, ...R } })),
        (a = y),
        (l = !0),
        this
      );
    },
    render(u) {
      return (
        l || this.configure(),
        cx.updateContainer(
          T.jsx(Lue, { store: s, children: u, onCreated: a, rootElement: n }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      Tj(n);
    },
  };
}
function Lue({ store: n, children: e, onCreated: t, rootElement: r }) {
  return (
    Om(() => {
      const i = n.getState();
      i.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(i),
        n.getState().events.connected ||
          i.events.connect == null ||
          i.events.connect(r);
    }, []),
    T.jsx(bj.Provider, { value: n, children: e })
  );
}
function Tj(n, e) {
  const t = ph.get(n),
    r = t == null ? void 0 : t.fiber;
  if (r) {
    const i = t == null ? void 0 : t.store.getState();
    i && (i.internal.active = !1),
      cx.updateContainer(null, r, null, () => {
        i &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              i.events.disconnect == null || i.events.disconnect(),
                (s = i.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = i.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = i.gl) != null && l.xr && i.xr.disconnect(),
                vue(i),
                ph.delete(n);
            } catch {}
          }, 500);
      });
  }
}
cx.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: P.version,
});
const X1 = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function Oue(n) {
  const { handlePointer: e } = Sue(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, r, i) {
      r.pointer.set(
        (t.offsetX / r.size.width) * 2 - 1,
        -(t.offsetY / r.size.height) * 2 + 1
      ),
        r.raycaster.setFromCamera(r.pointer, r.camera);
    },
    connected: void 0,
    handlers: Object.keys(X1).reduce((t, r) => ({ ...t, [r]: e(r) }), {}),
    update: () => {
      var t;
      const { events: r, internal: i } = n.getState();
      (t = i.lastEvent) != null &&
        t.current &&
        r.handlers &&
        r.handlers.onPointerMove(i.lastEvent.current);
    },
    connect: (t) => {
      var r;
      const { set: i, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        i((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((r = s.handlers) != null ? r : []).forEach(([o, a]) => {
          const [l, c] = X1[o];
          t.addEventListener(l, a, { passive: c });
        });
    },
    disconnect: () => {
      const { set: t, events: r } = n.getState();
      if (r.connected) {
        var i;
        Object.entries((i = r.handlers) != null ? i : []).forEach(([s, o]) => {
          if (r && r.connected instanceof HTMLElement) {
            const [a] = X1[s];
            r.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
function EO(n, e) {
  let t;
  return (...r) => {
    window.clearTimeout(t), (t = window.setTimeout(() => n(...r), e));
  };
}
function Due(
  { debounce: n, scroll: e, polyfill: t, offsetSize: r } = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1,
  }
) {
  const i = t || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!i)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [s, o] = P.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    a = P.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: s,
      orientationHandler: null,
    }),
    l = n ? (typeof n == "number" ? n : n.scroll) : null,
    c = n ? (typeof n == "number" ? n : n.resize) : null,
    u = P.useRef(!1);
  P.useEffect(() => ((u.current = !0), () => void (u.current = !1)));
  const [f, p, m] = P.useMemo(() => {
    const g = () => {
      if (!a.current.element) return;
      const {
          left: _,
          top: S,
          width: b,
          height: C,
          bottom: A,
          right: R,
          x: O,
          y: I,
        } = a.current.element.getBoundingClientRect(),
        N = {
          left: _,
          top: S,
          width: b,
          height: C,
          bottom: A,
          right: R,
          x: O,
          y: I,
        };
      a.current.element instanceof HTMLElement &&
        r &&
        ((N.height = a.current.element.offsetHeight),
        (N.width = a.current.element.offsetWidth)),
        Object.freeze(N),
        u.current &&
          !Bue(a.current.lastBounds, N) &&
          o((a.current.lastBounds = N));
    };
    return [g, c ? EO(g, c) : g, l ? EO(g, l) : g];
  }, [o, r, l, c]);
  function v() {
    a.current.scrollContainers &&
      (a.current.scrollContainers.forEach((g) =>
        g.removeEventListener("scroll", m, !0)
      ),
      (a.current.scrollContainers = null)),
      a.current.resizeObserver &&
        (a.current.resizeObserver.disconnect(),
        (a.current.resizeObserver = null)),
      a.current.orientationHandler &&
        ("orientation" in screen && "removeEventListener" in screen.orientation
          ? screen.orientation.removeEventListener(
              "change",
              a.current.orientationHandler
            )
          : "onorientationchange" in window &&
            window.removeEventListener(
              "orientationchange",
              a.current.orientationHandler
            ));
  }
  function y() {
    a.current.element &&
      ((a.current.resizeObserver = new i(m)),
      a.current.resizeObserver.observe(a.current.element),
      e &&
        a.current.scrollContainers &&
        a.current.scrollContainers.forEach((g) =>
          g.addEventListener("scroll", m, { capture: !0, passive: !0 })
        ),
      (a.current.orientationHandler = () => {
        m();
      }),
      "orientation" in screen && "addEventListener" in screen.orientation
        ? screen.orientation.addEventListener(
            "change",
            a.current.orientationHandler
          )
        : "onorientationchange" in window &&
          window.addEventListener(
            "orientationchange",
            a.current.orientationHandler
          ));
  }
  const x = (g) => {
    !g ||
      g === a.current.element ||
      (v(), (a.current.element = g), (a.current.scrollContainers = Mj(g)), y());
  };
  return (
    Uue(m, !!e),
    kue(p),
    P.useEffect(() => {
      v(), y();
    }, [e, m, p]),
    P.useEffect(() => v, []),
    [x, s, f]
  );
}
function kue(n) {
  P.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function Uue(n, e) {
  P.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function Mj(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: r,
    overflowY: i,
  } = window.getComputedStyle(n);
  return (
    [t, r, i].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...Mj(n.parentElement)]
  );
}
const Fue = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  Bue = (n, e) => Fue.every((t) => n[t] === e[t]);
var zue = Object.defineProperty,
  Vue = Object.defineProperties,
  jue = Object.getOwnPropertyDescriptors,
  TO = Object.getOwnPropertySymbols,
  Hue = Object.prototype.hasOwnProperty,
  Wue = Object.prototype.propertyIsEnumerable,
  MO = (n, e, t) =>
    e in n
      ? zue(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  CO = (n, e) => {
    for (var t in e || (e = {})) Hue.call(e, t) && MO(n, t, e[t]);
    if (TO) for (var t of TO(e)) Wue.call(e, t) && MO(n, t, e[t]);
    return n;
  },
  Gue = (n, e) => Vue(n, jue(e)),
  AO,
  RO;
typeof window < "u" &&
(((AO = window.document) != null && AO.createElement) ||
  ((RO = window.navigator) == null ? void 0 : RO.product) === "ReactNative")
  ? P.useLayoutEffect
  : P.useEffect;
function Cj(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let r = n.child;
  for (; r; ) {
    const i = Cj(r, e, t);
    if (i) return i;
    r = r.sibling;
  }
}
function Aj(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const PO = console.error;
console.error = function () {
  const n = [...arguments].join("");
  if (n != null && n.startsWith("Warning:") && n.includes("useContext")) {
    console.error = PO;
    return;
  }
  return PO.apply(this, arguments);
};
const hA = Aj(P.createContext(null));
class Rj extends P.Component {
  render() {
    return P.createElement(
      hA.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
function $ue() {
  const n = P.useContext(hA);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = P.useId();
  return P.useMemo(() => {
    for (const r of [n, n == null ? void 0 : n.alternate]) {
      if (!r) continue;
      const i = Cj(r, !1, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return !0;
          o = o.next;
        }
      });
      if (i) return i;
    }
  }, [n, e]);
}
function Xue() {
  const n = $ue(),
    [e] = P.useState(() => new Map());
  e.clear();
  let t = n;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const i =
        t.type._context === void 0 && t.type.Provider === t.type
          ? t.type
          : t.type._context;
      i && i !== hA && !e.has(i) && e.set(i, P.useContext(Aj(i)));
    }
    t = t.return;
  }
  return e;
}
function que() {
  const n = Xue();
  return P.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (r) =>
          P.createElement(
            e,
            null,
            P.createElement(t.Provider, Gue(CO({}, r), { value: n.get(t) }))
          ),
        (e) => P.createElement(Rj, CO({}, e))
      ),
    [n]
  );
}
const Kue = P.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: r,
      style: i,
      gl: s,
      events: o = Oue,
      eventSource: a,
      eventPrefix: l,
      shadows: c,
      linear: u,
      flat: f,
      legacy: p,
      orthographic: m,
      frameloop: v,
      dpr: y,
      performance: x,
      raycaster: g,
      camera: _,
      scene: S,
      onPointerMissed: b,
      onCreated: C,
      ...A
    },
    R
  ) {
    P.useMemo(() => hue(sue), []);
    const O = que(),
      [I, N] = Due({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...r }),
      D = P.useRef(null),
      j = P.useRef(null);
    P.useImperativeHandle(R, () => D.current);
    const $ = gj(b),
      [G, Z] = P.useState(!1),
      [q, Y] = P.useState(!1);
    if (G) throw G;
    if (q) throw q;
    const U = P.useRef(null);
    Om(() => {
      const X = D.current;
      N.width > 0 &&
        N.height > 0 &&
        X &&
        (U.current || (U.current = Nue(X)),
        U.current.configure({
          gl: s,
          events: o,
          shadows: c,
          linear: u,
          flat: f,
          legacy: p,
          orthographic: m,
          frameloop: v,
          dpr: y,
          performance: x,
          raycaster: g,
          camera: _,
          scene: S,
          size: N,
          onPointerMissed: (...ie) =>
            $.current == null ? void 0 : $.current(...ie),
          onCreated: (ie) => {
            ie.events.connect == null ||
              ie.events.connect(a ? (pue(a) ? a.current : a) : j.current),
              l &&
                ie.setEvents({
                  compute: (de, Ee) => {
                    const Ie = de[l + "X"],
                      se = de[l + "Y"];
                    Ee.pointer.set(
                      (Ie / Ee.size.width) * 2 - 1,
                      -(se / Ee.size.height) * 2 + 1
                    ),
                      Ee.raycaster.setFromCamera(Ee.pointer, Ee.camera);
                  },
                }),
              C == null || C(ie);
          },
        }),
        U.current.render(
          T.jsx(O, {
            children: T.jsx(vj, {
              set: Y,
              children: T.jsx(P.Suspense, {
                fallback: T.jsx(mue, { set: Z }),
                children: e ?? null,
              }),
            }),
          })
        ));
    }),
      P.useEffect(() => {
        const X = D.current;
        if (X) return () => Tj(X);
      }, []);
    const H = a ? "none" : "auto";
    return T.jsx("div", {
      ref: j,
      style: {
        position: "relative",
        width: "100%",
        height: "100%",
        overflow: "hidden",
        pointerEvents: H,
        ...i,
      },
      ...A,
      children: T.jsx("div", {
        ref: I,
        style: { width: "100%", height: "100%" },
        children: T.jsx("canvas", {
          ref: D,
          style: { display: "block" },
          children: t,
        }),
      }),
    });
  }),
  Yue = P.forwardRef(function (e, t) {
    return T.jsx(Rj, { children: T.jsx(Kue, { ...e, ref: t }) });
  }),
  Jue = ({
    animationSpeed: n = 0.4,
    opacities: e = [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],
    colors: t = [[59, 130, 246]],
    containerClassName: r,
    dotSize: i,
    showGradient: s = !0,
  }) =>
    T.jsxs("div", {
      className: qt("h-full relative bg-background w-full", r),
      children: [
        T.jsx("div", {
          className: "h-full w-full",
          children: T.jsx(Zue, {
            colors: t ?? [[59, 130, 246]],
            dotSize: i ?? 3,
            opacities: e ?? [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],
            shader: `
              float animation_speed_factor = ${n.toFixed(1)};
              float intro_offset = distance(u_resolution / 2.0 / u_total_size, st2) * 0.01 + (random(st2) * 0.15);
              opacity *= step(intro_offset, u_time * animation_speed_factor);
              opacity *= clamp((1.0 - step(intro_offset + 0.1, u_time * animation_speed_factor)) * 1.25, 1.0, 1.25);
            `,
            center: ["x", "y"],
          }),
        }),
        s &&
          T.jsx("div", {
            className:
              "absolute inset-0 bg-gradient-to-t from-background to-[84%]",
          }),
      ],
    }),
  Zue = ({
    colors: n = [[59, 130, 246]],
    opacities: e = [0.04, 0.04, 0.04, 0.04, 0.04, 0.08, 0.08, 0.08, 0.08, 0.14],
    totalSize: t = 4,
    dotSize: r = 2,
    shader: i = "",
    center: s = ["x", "y"],
  }) => {
    const o = Le.useMemo(() => {
      let a = [n[0], n[0], n[0], n[0], n[0], n[0]];
      return (
        n.length === 2
          ? (a = [n[0], n[0], n[0], n[1], n[1], n[1]])
          : n.length === 3 && (a = [n[0], n[0], n[1], n[1], n[2], n[2]]),
        {
          u_colors: {
            value: a.map((l) => [l[0] / 255, l[1] / 255, l[2] / 255]),
            type: "uniform3fv",
          },
          u_opacities: { value: e, type: "uniform1fv" },
          u_total_size: { value: t, type: "uniform1f" },
          u_dot_size: { value: r, type: "uniform1f" },
        }
      );
    }, [n, e, t, r]);
    return T.jsx(ede, {
      source: `
        precision mediump float;
        in vec2 fragCoord;

        uniform float u_time;
        uniform float u_opacities[10];
        uniform vec3 u_colors[6];
        uniform float u_total_size;
        uniform float u_dot_size;
        uniform vec2 u_resolution;
        out vec4 fragColor;
        float PHI = 1.61803398874989484820459;
        float random(vec2 xy) {
            return fract(tan(distance(xy * PHI, xy) * 0.5) * xy.x);
        }
        float map(float value, float min1, float max1, float min2, float max2) {
            return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
        }
        void main() {
            vec2 st = fragCoord.xy;
            ${
              s.includes("x")
                ? "st.x -= abs(floor((mod(u_resolution.x, u_total_size) - u_dot_size) * 0.5));"
                : ""
            }
            ${
              s.includes("y")
                ? "st.y -= abs(floor((mod(u_resolution.y, u_total_size) - u_dot_size) * 0.5));"
                : ""
            }
      float opacity = step(0.0, st.x);
      opacity *= step(0.0, st.y);

      vec2 st2 = vec2(int(st.x / u_total_size), int(st.y / u_total_size));

      float frequency = 5.0;
      float show_offset = random(st2);
      float rand = random(st2 * floor((u_time / frequency) + show_offset + frequency) + 1.0);
      opacity *= u_opacities[int(rand * 10.0)];
      opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.x / u_total_size));
      opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.y / u_total_size));

      vec3 color = u_colors[int(show_offset * 6.0)];

      ${i}

      fragColor = vec4(color, opacity);
      fragColor.rgb *= fragColor.a;
        }`,
      uniforms: o,
      maxFps: 60,
    });
  },
  Que = ({ source: n, uniforms: e, maxFps: t = 60 }) => {
    const { size: r } = Aue(),
      i = P.useRef();
    let s = 0;
    Rue(({ clock: l }) => {
      if (!i.current) return;
      const c = l.getElapsedTime();
      if (c - s < 1 / t) return;
      s = c;
      const f = i.current.material.uniforms.u_time;
      f.value = c;
    });
    const o = () => {
        const l = {};
        for (const c in e) {
          const u = e[c];
          switch (u.type) {
            case "uniform1f":
              l[c] = { value: u.value, type: "1f" };
              break;
            case "uniform3f":
              l[c] = { value: new z().fromArray(u.value), type: "3f" };
              break;
            case "uniform1fv":
              l[c] = { value: u.value, type: "1fv" };
              break;
            case "uniform3fv":
              l[c] = {
                value: u.value.map((f) => new z().fromArray(f)),
                type: "3fv",
              };
              break;
            case "uniform2f":
              l[c] = { value: new xe().fromArray(u.value), type: "2f" };
              break;
            default:
              console.error(`Invalid uniform type for '${c}'.`);
              break;
          }
        }
        return (
          (l.u_time = { value: 0, type: "1f" }),
          (l.u_resolution = { value: new xe(r.width * 2, r.height * 2) }),
          l
        );
      },
      a = P.useMemo(
        () =>
          new cs({
            vertexShader: `
      precision mediump float;
      in vec2 coordinates;
      uniform vec2 u_resolution;
      out vec2 fragCoord;
      void main(){
        float x = position.x;
        float y = position.y;
        gl_Position = vec4(x, y, 0.0, 1.0);
        fragCoord = (position.xy + vec2(1.0)) * 0.5 * u_resolution;
        fragCoord.y = u_resolution.y - fragCoord.y;
      }
      `,
            fragmentShader: n,
            uniforms: o(),
            glslVersion: ix,
            blending: SC,
            blendSrc: Wp,
            blendDst: bC,
          }),
        [r.width, r.height, n]
      );
    return T.jsxs("mesh", {
      ref: i,
      children: [
        T.jsx("planeGeometry", { args: [2, 2] }),
        T.jsx("primitive", { object: a, attach: "material" }),
      ],
    });
  },
  ede = ({ source: n, uniforms: e, maxFps: t = 60 }) =>
    T.jsx(Yue, {
      className: "absolute inset-0  h-full w-full",
      children: T.jsx(Que, { source: n, uniforms: e, maxFps: t }),
    }),
  tde = () =>
    T.jsxs("div", {
      className: "Agent-image text-center select-none pointer-events-none",
      children: [
        T.jsx("img", {
          src: "/zPush-character.png",
          alt: "zPush Protocol",
          className:
            "w-48 h-48 md:w-64 md:h-64 lg:w-80 lg:h-80 object-contain mx-auto",
        }),
        T.jsx("h1", {
          className:
            "mt-4 text-xl md:text-2xl lg:text-3xl font-bold text-foreground",
          children: "zPush Protocol",
        }),
      ],
    }),
  nde = () => {
    const [n, e] = P.useState(!1);
    return (
      P.useEffect(() => {
        const t = setTimeout(() => e(!0), 2e3),
          r = setTimeout(() => e(!1), 8e3);
        return () => {
          clearTimeout(t), clearTimeout(r);
        };
      }, []),
      n
        ? T.jsx("div", {
            className:
              "absolute top-4 left-1/2 transform -translate-x-1/2 z-20 animate-fade-in",
            children: T.jsx("div", {
              className:
                "bg-card border border-border rounded-lg px-4 py-2 shadow-lg",
              children: T.jsxs("div", {
                className: "flex items-center space-x-2 text-sm",
                children: [
                  T.jsx("div", {
                    className: "w-2 h-2 bg-primary rounded-full animate-pulse",
                  }),
                  T.jsx("span", {
                    className: "font-mono text-muted-foreground",
                    children: "Monitoring system activity...",
                  }),
                ],
              }),
            }),
          })
        : null
    );
  },
  rde = () => {
    const {
        getModeFilteredConversations: n,
        messages: e,
        setActiveConversation: t,
      } = la(),
      r = n(),
      i = (s) => {
        t(s);
      };
    return r.length === 0
      ? null
      : T.jsxs("div", {
          className:
            "absolute top-4 right-4 z-20 max-w-sm space-y-2 max-h-[60vh] overflow-y-auto",
          children: [
            T.jsxs("div", {
              className: "text-xs font-mono text-muted-foreground mb-2 px-2",
              children: ["ACTIVE CONVERSATIONS (", r.length, ")"],
            }),
            r.map((s) => {
              const o = e.get(s.id) || [],
                a = o.length > 0 ? o[o.length - 1].content : void 0;
              return T.jsx(
                rJ,
                {
                  conversation: s,
                  messageCount: o.length,
                  lastMessage: a,
                  onClick: () => i(s.id),
                },
                s.id
              );
            }),
          ],
        });
  },
  ide = [
    {
      path: "M200 150H50C44.4772 150 40 154.477 40 160V280",
      gradientConfig: {
        initial: { x1: "0%", x2: "0%", y1: "80%", y2: "100%" },
        animate: {
          x1: ["0%", "0%", "200%"],
          x2: ["0%", "0%", "180%"],
          y1: ["80%", "0%", "0%"],
          y2: ["100%", "20%", "20%"],
        },
        transition: {
          duration: 3,
          repeat: 1 / 0,
          repeatType: "loop",
          ease: "linear",
          repeatDelay: 1,
          delay: Math.random() * 2,
        },
      },
      connectionPoints: [
        { cx: 40, cy: 280, r: 4 },
        { cx: 200, cy: 150, r: 4 },
      ],
    },
    {
      path: "M400 120H550C555.523 120 560 115.523 560 110V50",
      gradientConfig: {
        initial: { x1: "0%", x2: "0%", y1: "80%", y2: "100%" },
        animate: {
          x1: ["20%", "100%", "100%"],
          x2: ["0%", "90%", "90%"],
          y1: ["80%", "80%", "-20%"],
          y2: ["100%", "100%", "0%"],
        },
        transition: {
          duration: 3,
          repeat: 1 / 0,
          repeatType: "loop",
          ease: "linear",
          repeatDelay: 1,
          delay: Math.random() * 2,
        },
      },
      connectionPoints: [
        { cx: 560, cy: 50, r: 4 },
        { cx: 400, cy: 120, r: 4 },
      ],
    },
    {
      path: "M300 200V280C300 285.523 295.523 290 290 290H150C144.477 290 140 294.477 140 300V380",
      gradientConfig: {
        initial: { x1: "0%", x2: "0%", y1: "80%", y2: "100%" },
        animate: {
          x1: ["20%", "100%", "100%"],
          x2: ["0%", "90%", "90%"],
          y1: ["80%", "80%", "-20%"],
          y2: ["100%", "100%", "0%"],
        },
        transition: {
          duration: 3,
          repeat: 1 / 0,
          repeatType: "loop",
          ease: "linear",
          repeatDelay: 1,
          delay: Math.random() * 2,
        },
      },
      connectionPoints: [
        { cx: 140, cy: 380, r: 4 },
        { cx: 300, cy: 200, r: 4 },
      ],
    },
    {
      path: "M320 200V280C320 285.523 324.477 290 330 290H450C455.523 290 460 294.477 460 300V380",
      gradientConfig: {
        initial: { x1: "40%", x2: "50%", y1: "160%", y2: "180%" },
        animate: { x1: "0%", x2: "10%", y1: "-40%", y2: "-20%" },
        transition: {
          duration: 3,
          repeat: 1 / 0,
          repeatType: "loop",
          ease: "linear",
          repeatDelay: 1,
          delay: Math.random() * 2,
        },
      },
      connectionPoints: [
        { cx: 460, cy: 380, r: 4 },
        { cx: 320, cy: 200, r: 4 },
      ],
    },
    {
      path: "M300 100V40C300 34.4772 304.477 30 310 30H350",
      gradientConfig: {
        initial: { x1: "-40%", x2: "-10%", y1: "0%", y2: "20%" },
        animate: {
          x1: ["40%", "0%", "0%"],
          x2: ["10%", "0%", "0%"],
          y1: ["0%", "0%", "180%"],
          y2: ["20%", "20%", "200%"],
        },
        transition: {
          duration: 3,
          repeat: 1 / 0,
          repeatType: "loop",
          ease: "linear",
          repeatDelay: 1,
          delay: Math.random() * 2,
        },
      },
      connectionPoints: [
        { cx: 350, cy: 30, r: 4 },
        { cx: 300, cy: 100, r: 4 },
      ],
    },
  ],
  sde = {
    start: "hsl(var(--primary))",
    middle: "hsl(var(--accent))",
    end: "hsl(var(--primary) / 0.1)",
  },
  ode = () => {
    const { isConnected: n, presenceCount: e } = la();
    return T.jsxs("div", {
      className: "fixed inset-0 bg-background overflow-hidden",
      children: [
        T.jsx("div", {
          className: "absolute inset-0 z-0",
          children: T.jsx(Jue, {
            animationSpeed: 0.8,
            containerClassName: "bg-background",
            colors: [
              [235, 108, 227],
              [200, 80, 195],
              [245, 130, 235],
            ],
            dotSize: 2,
            opacities: [0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.5, 0.6, 0.8],
            showGradient: !0,
          }),
        }),
        T.jsx("div", {
          className: "absolute inset-0 z-5",
          children: T.jsx(NB, {}),
        }),
        T.jsx(nde, {}),
        T.jsx(rde, {}),
        T.jsx("div", {
          className:
            "absolute inset-0 flex items-center justify-center pointer-events-none z-10",
          children: T.jsx(kte, {
            beams: ide,
            gradientColors: sde,
            className: "w-full h-full bg-transparent",
            width: 600,
            height: 600,
            children: T.jsxs("div", {
              className: "text-center",
              children: [
                T.jsx(tde, {}),
                T.jsx("div", {
                  className: "mt-4 opacity-75",
                  children: T.jsx("div", {
                    className: "text-xs font-mono text-muted-foreground",
                    children: n ? `zPush  ${e} active` : "CONNECTING...",
                  }),
                }),
              ],
            }),
          }),
        }),
      ],
    });
  },
  fA = P.forwardRef(({ className: n, type: e, ...t }, r) =>
    T.jsx("input", {
      type: e,
      className: qt(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        n
      ),
      ref: r,
      ...t,
    })
  );
fA.displayName = "Input";
const ade = () => {
  const {
      activeConversationId: n,
      setActiveConversation: e,
      getModeFilteredMessages: t,
      addMessage: r,
    } = la(),
    { currentMode: i } = kM(),
    [s, o] = P.useState(""),
    [a, l] = P.useState(!1),
    [c, u] = P.useState("checking"),
    f = P.useRef(null),
    p = n ? t(n) : [];
  P.useEffect(() => {
    (async () => {
      try {
        await Zu.healthCheck(), u("connected");
      } catch (S) {
        console.error("Connection check failed:", S),
          u("error"),
          es.error(
            "Unable to connect to zPush. Please refresh the page or check your connection."
          );
      }
    })();
  }, []),
    P.useEffect(() => {
      var _;
      (_ = f.current) == null || _.scrollIntoView({ behavior: "smooth" });
    }, [p]);
  const m = async () => {
      if (!s.trim()) return;
      let _ = n;
      if (!_)
        try {
          const b = Math.floor(Math.random() * 80),
            C = Math.floor(Math.random() * 40);
          (_ = await ol.startConversation(b, C, i)),
            e(_),
            es.success("Meow! zPush is ready to chat! ");
        } catch (b) {
          const C =
            (b == null ? void 0 : b.message) || "Failed to start conversation";
          es.error(C), console.error("Conversation start error:", b), l(!1);
          return;
        }
      const S = s;
      o(""), l(!0);
      try {
        await ol.sendMessage(_, S, "user", i);
        const b = {
          id: crypto.randomUUID(),
          conversation_id: _,
          content: S,
          sender: "user",
          created_at: new Date().toISOString(),
        };
        r(b),
          setTimeout(async () => {
            try {
              const C = await v(S);
              await ol.sendMessage(_, C, "agent", i);
              const A = {
                id: crypto.randomUUID(),
                conversation_id: _,
                content: C,
                sender: "agent",
                created_at: new Date().toISOString(),
              };
              r(A);
            } catch (C) {
              const A =
                (C == null ? void 0 : C.message) ||
                "zPush seems to be napping right meow...";
              es.error(A), console.error("Agent response error:", C);
            } finally {
              l(!1);
            }
          }, 800 + Math.random() * 1200);
      } catch (b) {
        const C = (b == null ? void 0 : b.message) || "Failed to send message";
        es.error(C), console.error("Message send error:", b), l(!1);
      }
    },
    v = async (_) => {
      try {
        const S = p.map((A) => ({
          role: A.sender === "user" ? "user" : "assistant",
          content: A.content,
        }));
        S.push({ role: "user", content: _ });
        const { data: b, error: C } = await or.functions.invoke("zPush-chat", {
          body: { messages: S, mode: i },
        });
        if (C)
          throw (
            (console.error("AI chat error:", C),
            new Error(C.message || "Failed to get response"))
          );
        if (!(b != null && b.content)) throw new Error("No response from AI");
        return b.content;
      } catch (S) {
        console.error("generateAgentResponse error:", S);
        const b = [
          "*hisses at the technical difficulties* Meow! Something's wrong with my digital litterbox. Try again?",
          "*flicks tail in frustration* The catnip network is acting up. One more time? *purrs hopefully*",
          "*stretches and yawns* My nine lives need a reboot. Mind asking again? ",
        ];
        return b[Math.floor(Math.random() * b.length)];
      }
    },
    y = (_) => {
      _.key === "Enter" && !_.shiftKey && (_.preventDefault(), m());
    },
    x = (_) => new Date(_).toLocaleTimeString(),
    g = () => {
      e(null), es.success("Ready for a new conversation!");
    };
  return T.jsxs("div", {
    className: "fixed inset-0 bg-background overflow-hidden",
    children: [
      T.jsx("div", { className: "absolute inset-0", children: T.jsx(NB, {}) }),
      T.jsx("div", {
        className: "absolute inset-0 flex items-center justify-center p-4 z-10",
        children: T.jsxs("div", {
          className:
            "w-full max-w-2xl bg-card/90 backdrop-blur-md border border-border rounded-lg shadow-lg flex flex-col max-h-[80vh]",
          children: [
            T.jsxs("div", {
              className: "border-b border-border p-4",
              children: [
                T.jsxs("div", {
                  className: "flex items-center justify-between",
                  children: [
                    T.jsxs("div", {
                      className: "flex items-center space-x-3",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center",
                          children: T.jsx(uM, {
                            className: "w-4 h-4 text-primary",
                          }),
                        }),
                        T.jsxs("div", {
                          children: [
                            T.jsx("h1", {
                              className: "text-xl font-mono font-semibold",
                              children: "Chat with zPush",
                            }),
                            T.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children: "Real-time AI conversation",
                            }),
                          ],
                        }),
                      ],
                    }),
                    T.jsx(ho, {
                      onClick: g,
                      variant: "outline",
                      size: "sm",
                      children: "New Chat",
                    }),
                  ],
                }),
                n &&
                  T.jsxs("div", {
                    className: "mt-2 flex items-center justify-between",
                    children: [
                      T.jsxs("div", {
                        className: "text-xs font-mono text-muted-foreground",
                        children: ["Session: ", n.replace(/^MARBL-/, "zPush-")],
                      }),
                      c === "error" &&
                        T.jsxs("div", {
                          className:
                            "text-xs text-destructive font-mono flex items-center gap-1",
                          children: [
                            T.jsx("span", {
                              className: "w-2 h-2 bg-destructive rounded-full",
                            }),
                            "Connection Issue",
                          ],
                        }),
                      c === "connected" &&
                        T.jsxs("div", {
                          className:
                            "text-xs text-primary font-mono flex items-center gap-1",
                          children: [
                            T.jsx("span", {
                              className:
                                "w-2 h-2 bg-primary rounded-full animate-pulse",
                            }),
                            "Connected",
                          ],
                        }),
                    ],
                  }),
              ],
            }),
            T.jsxs("div", {
              className: "flex-1 overflow-y-auto p-4 space-y-4 min-h-0",
              children: [
                p.length === 0
                  ? T.jsxs("div", {
                      className: "text-center py-12",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-16 h-16 bg-primary/10 rounded-full flex items-center justify-center mx-auto mb-4 p-2",
                          children: T.jsx("img", {
                            src: "/zPush-character.png",
                            alt: "zPush",
                            className: "w-12 h-12 object-contain",
                          }),
                        }),
                        T.jsx("h3", {
                          className: "font-mono font-semibold mb-2",
                          children: "Ready to Chat with zPush!",
                        }),
                        T.jsx("p", {
                          className:
                            "text-muted-foreground text-sm max-w-md mx-auto",
                          children:
                            "Start a conversation with Digital Agent. Ask anything - I'm connected to the entire grid consciousness.",
                        }),
                        T.jsx("div", {
                          className:
                            "mt-4 text-xs font-mono text-muted-foreground",
                          children:
                            "zPush is ready to chat! They may choose to reply, ignore, or take other actions.",
                        }),
                      ],
                    })
                  : p.map((_) =>
                      T.jsx(
                        "div",
                        {
                          className: `flex ${
                            _.sender === "user"
                              ? "justify-end"
                              : "justify-start"
                          }`,
                          children: T.jsxs("div", {
                            className: `max-w-xs lg:max-w-md px-4 py-2 rounded-lg ${
                              _.sender === "user"
                                ? "bg-primary text-primary-foreground"
                                : "bg-secondary"
                            }`,
                            children: [
                              T.jsxs("div", {
                                className: "flex items-center space-x-2 mb-1",
                                children: [
                                  _.sender === "user"
                                    ? T.jsx(F3, { className: "w-3 h-3" })
                                    : T.jsx("img", {
                                        src: "/zPush-character.png",
                                        alt: "zPush",
                                        className: "w-3 h-3 object-contain",
                                      }),
                                  T.jsx("span", {
                                    className:
                                      "text-xs font-mono font-semibold uppercase",
                                    children:
                                      _.sender === "agent" ? "zPush" : "USER",
                                  }),
                                  T.jsx("span", {
                                    className: "text-xs opacity-70",
                                    children: x(_.created_at),
                                  }),
                                ],
                              }),
                              T.jsx("p", {
                                className: "text-sm",
                                children: _.content,
                              }),
                            ],
                          }),
                        },
                        _.id
                      )
                    ),
                a &&
                  T.jsx("div", {
                    className: "flex justify-start",
                    children: T.jsx("div", {
                      className: "bg-secondary px-4 py-2 rounded-lg",
                      children: T.jsxs("div", {
                        className: "flex items-center space-x-2",
                        children: [
                          T.jsx("img", {
                            src: "/zPush-character.png",
                            alt: "zPush",
                            className: "w-3 h-3 object-contain",
                          }),
                          T.jsx("span", {
                            className: "text-xs font-mono",
                            children: "zPush is thinking...",
                          }),
                        ],
                      }),
                    }),
                  }),
                T.jsx("div", { ref: f }),
              ],
            }),
            T.jsxs("div", {
              className: "border-t border-border p-4",
              children: [
                T.jsxs("div", {
                  className: "flex space-x-2",
                  children: [
                    T.jsx(fA, {
                      value: s,
                      onChange: (_) => o(_.target.value),
                      onKeyPress: y,
                      placeholder: "Say hello to zPush...",
                      className: "flex-1",
                      disabled: a,
                    }),
                    T.jsx(ho, {
                      onClick: m,
                      disabled: !s.trim() || a,
                      className: "zPush-btn-primary",
                      children: T.jsx(k8, { className: "w-4 h-4" }),
                    }),
                  ],
                }),
                T.jsx("p", {
                  className: "text-xs text-muted-foreground mt-2",
                  children: "Press Enter to send  Shift+Enter for new line",
                }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
};
function IO(n, [e, t]) {
  return Math.min(t, Math.max(e, n));
}
var lde = P.createContext(void 0);
function cde(n) {
  const e = P.useContext(lde);
  return n || e || "ltr";
}
function ude(n) {
  const e = P.useRef({ value: n, previous: n });
  return P.useMemo(
    () => (
      e.current.value !== n &&
        ((e.current.previous = e.current.value), (e.current.value = n)),
      e.current.previous
    ),
    [n]
  );
}
var dde = [" ", "Enter", "ArrowUp", "ArrowDown"],
  hde = [" ", "Enter"],
  Wc = "Select",
  [T_, M_, fde] = o3(Wc),
  [kh, dhe] = yh(Wc, [fde, Lx]),
  C_ = Lx(),
  [pde, Tl] = kh(Wc),
  [mde, gde] = kh(Wc),
  Pj = (n) => {
    const {
        __scopeSelect: e,
        children: t,
        open: r,
        defaultOpen: i,
        onOpenChange: s,
        value: o,
        defaultValue: a,
        onValueChange: l,
        dir: c,
        name: u,
        autoComplete: f,
        disabled: p,
        required: m,
        form: v,
      } = n,
      y = C_(e),
      [x, g] = P.useState(null),
      [_, S] = P.useState(null),
      [b, C] = P.useState(!1),
      A = cde(c),
      [R, O] = i0({ prop: r, defaultProp: i ?? !1, onChange: s, caller: Wc }),
      [I, N] = i0({ prop: o, defaultProp: a, onChange: l, caller: Wc }),
      D = P.useRef(null),
      j = x ? v || !!x.closest("form") : !0,
      [$, G] = P.useState(new Set()),
      Z = Array.from($)
        .map((q) => q.props.value)
        .join(";");
    return T.jsx(_9, {
      ...y,
      children: T.jsxs(pde, {
        required: m,
        scope: e,
        trigger: x,
        onTriggerChange: g,
        valueNode: _,
        onValueNodeChange: S,
        valueNodeHasChildren: b,
        onValueNodeHasChildrenChange: C,
        contentId: Pd(),
        value: I,
        onValueChange: N,
        open: R,
        onOpenChange: O,
        dir: A,
        triggerPointerDownPosRef: D,
        disabled: p,
        children: [
          T.jsx(T_.Provider, {
            scope: e,
            children: T.jsx(mde, {
              scope: n.__scopeSelect,
              onNativeOptionAdd: P.useCallback((q) => {
                G((Y) => new Set(Y).add(q));
              }, []),
              onNativeOptionRemove: P.useCallback((q) => {
                G((Y) => {
                  const U = new Set(Y);
                  return U.delete(q), U;
                });
              }, []),
              children: t,
            }),
          }),
          j
            ? T.jsxs(
                e5,
                {
                  "aria-hidden": !0,
                  required: m,
                  tabIndex: -1,
                  name: u,
                  autoComplete: f,
                  value: I,
                  onChange: (q) => N(q.target.value),
                  disabled: p,
                  form: v,
                  children: [
                    I === void 0 ? T.jsx("option", { value: "" }) : null,
                    Array.from($),
                  ],
                },
                Z
              )
            : null,
        ],
      }),
    });
  };
Pj.displayName = Wc;
var Ij = "SelectTrigger",
  Nj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, disabled: r = !1, ...i } = n,
      s = C_(t),
      o = Tl(Ij, t),
      a = o.disabled || r,
      l = pn(e, o.onTriggerChange),
      c = M_(t),
      u = P.useRef("touch"),
      [f, p, m] = n5((y) => {
        const x = c().filter((S) => !S.disabled),
          g = x.find((S) => S.value === o.value),
          _ = r5(x, y, g);
        _ !== void 0 && o.onValueChange(_.value);
      }),
      v = (y) => {
        a || (o.onOpenChange(!0), m()),
          y &&
            (o.triggerPointerDownPosRef.current = {
              x: Math.round(y.pageX),
              y: Math.round(y.pageY),
            });
      };
    return T.jsx(vU, {
      asChild: !0,
      ...s,
      children: T.jsx(Kt.button, {
        type: "button",
        role: "combobox",
        "aria-controls": o.contentId,
        "aria-expanded": o.open,
        "aria-required": o.required,
        "aria-autocomplete": "none",
        dir: o.dir,
        "data-state": o.open ? "open" : "closed",
        disabled: a,
        "data-disabled": a ? "" : void 0,
        "data-placeholder": t5(o.value) ? "" : void 0,
        ...i,
        ref: l,
        onClick: Bt(i.onClick, (y) => {
          y.currentTarget.focus(), u.current !== "mouse" && v(y);
        }),
        onPointerDown: Bt(i.onPointerDown, (y) => {
          u.current = y.pointerType;
          const x = y.target;
          x.hasPointerCapture(y.pointerId) &&
            x.releasePointerCapture(y.pointerId),
            y.button === 0 &&
              y.ctrlKey === !1 &&
              y.pointerType === "mouse" &&
              (v(y), y.preventDefault());
        }),
        onKeyDown: Bt(i.onKeyDown, (y) => {
          const x = f.current !== "";
          !(y.ctrlKey || y.altKey || y.metaKey) &&
            y.key.length === 1 &&
            p(y.key),
            !(x && y.key === " ") &&
              dde.includes(y.key) &&
              (v(), y.preventDefault());
        }),
      }),
    });
  });
Nj.displayName = Ij;
var Lj = "SelectValue",
  Oj = P.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        className: r,
        style: i,
        children: s,
        placeholder: o = "",
        ...a
      } = n,
      l = Tl(Lj, t),
      { onValueNodeHasChildrenChange: c } = l,
      u = s !== void 0,
      f = pn(e, l.onValueNodeChange);
    return (
      yr(() => {
        c(u);
      }, [c, u]),
      T.jsx(Kt.span, {
        ...a,
        ref: f,
        style: { pointerEvents: "none" },
        children: t5(l.value) ? T.jsx(T.Fragment, { children: o }) : s,
      })
    );
  });
Oj.displayName = Lj;
var vde = "SelectIcon",
  Dj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, children: r, ...i } = n;
    return T.jsx(Kt.span, {
      "aria-hidden": !0,
      ...i,
      ref: e,
      children: r || "",
    });
  });
Dj.displayName = vde;
var yde = "SelectPortal",
  kj = (n) => T.jsx(Cx, { asChild: !0, ...n });
kj.displayName = yde;
var Gc = "SelectContent",
  Uj = P.forwardRef((n, e) => {
    const t = Tl(Gc, n.__scopeSelect),
      [r, i] = P.useState();
    if (
      (yr(() => {
        i(new DocumentFragment());
      }, []),
      !t.open)
    ) {
      const s = r;
      return s
        ? qc.createPortal(
            T.jsx(Fj, {
              scope: n.__scopeSelect,
              children: T.jsx(T_.Slot, {
                scope: n.__scopeSelect,
                children: T.jsx("div", { children: n.children }),
              }),
            }),
            s
          )
        : null;
    }
    return T.jsx(Bj, { ...n, ref: e });
  });
Uj.displayName = Gc;
var ws = 10,
  [Fj, Ml] = kh(Gc),
  xde = "SelectContentImpl",
  _de = Zd("SelectContent.RemoveScroll"),
  Bj = P.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        position: r = "item-aligned",
        onCloseAutoFocus: i,
        onEscapeKeyDown: s,
        onPointerDownOutside: o,
        side: a,
        sideOffset: l,
        align: c,
        alignOffset: u,
        arrowPadding: f,
        collisionBoundary: p,
        collisionPadding: m,
        sticky: v,
        hideWhenDetached: y,
        avoidCollisions: x,
        ...g
      } = n,
      _ = Tl(Gc, t),
      [S, b] = P.useState(null),
      [C, A] = P.useState(null),
      R = pn(e, (re) => b(re)),
      [O, I] = P.useState(null),
      [N, D] = P.useState(null),
      j = M_(t),
      [$, G] = P.useState(!1),
      Z = P.useRef(!1);
    P.useEffect(() => {
      if (S) return cB(S);
    }, [S]),
      tB();
    const q = P.useCallback(
        (re) => {
          const [Be, ...Ue] = j().map((Ve) => Ve.ref.current),
            [Fe] = Ue.slice(-1),
            Ke = document.activeElement;
          for (const Ve of re)
            if (
              Ve === Ke ||
              (Ve == null || Ve.scrollIntoView({ block: "nearest" }),
              Ve === Be && C && (C.scrollTop = 0),
              Ve === Fe && C && (C.scrollTop = C.scrollHeight),
              Ve == null || Ve.focus(),
              document.activeElement !== Ke)
            )
              return;
        },
        [j, C]
      ),
      Y = P.useCallback(() => q([O, S]), [q, O, S]);
    P.useEffect(() => {
      $ && Y();
    }, [$, Y]);
    const { onOpenChange: U, triggerPointerDownPosRef: H } = _;
    P.useEffect(() => {
      if (S) {
        let re = { x: 0, y: 0 };
        const Be = (Fe) => {
            var Ke, Ve;
            re = {
              x: Math.abs(
                Math.round(Fe.pageX) -
                  (((Ke = H.current) == null ? void 0 : Ke.x) ?? 0)
              ),
              y: Math.abs(
                Math.round(Fe.pageY) -
                  (((Ve = H.current) == null ? void 0 : Ve.y) ?? 0)
              ),
            };
          },
          Ue = (Fe) => {
            re.x <= 10 && re.y <= 10
              ? Fe.preventDefault()
              : S.contains(Fe.target) || U(!1),
              document.removeEventListener("pointermove", Be),
              (H.current = null);
          };
        return (
          H.current !== null &&
            (document.addEventListener("pointermove", Be),
            document.addEventListener("pointerup", Ue, {
              capture: !0,
              once: !0,
            })),
          () => {
            document.removeEventListener("pointermove", Be),
              document.removeEventListener("pointerup", Ue, { capture: !0 });
          }
        );
      }
    }, [S, U, H]),
      P.useEffect(() => {
        const re = () => U(!1);
        return (
          window.addEventListener("blur", re),
          window.addEventListener("resize", re),
          () => {
            window.removeEventListener("blur", re),
              window.removeEventListener("resize", re);
          }
        );
      }, [U]);
    const [X, ie] = n5((re) => {
        const Be = j().filter((Ke) => !Ke.disabled),
          Ue = Be.find((Ke) => Ke.ref.current === document.activeElement),
          Fe = r5(Be, re, Ue);
        Fe && setTimeout(() => Fe.ref.current.focus());
      }),
      de = P.useCallback(
        (re, Be, Ue) => {
          const Fe = !Z.current && !Ue;
          ((_.value !== void 0 && _.value === Be) || Fe) &&
            (I(re), Fe && (Z.current = !0));
        },
        [_.value]
      ),
      Ee = P.useCallback(() => (S == null ? void 0 : S.focus()), [S]),
      Ie = P.useCallback(
        (re, Be, Ue) => {
          const Fe = !Z.current && !Ue;
          ((_.value !== void 0 && _.value === Be) || Fe) && D(re);
        },
        [_.value]
      ),
      se = r === "popper" ? nT : zj,
      _e =
        se === nT
          ? {
              side: a,
              sideOffset: l,
              align: c,
              alignOffset: u,
              arrowPadding: f,
              collisionBoundary: p,
              collisionPadding: m,
              sticky: v,
              hideWhenDetached: y,
              avoidCollisions: x,
            }
          : {};
    return T.jsx(Fj, {
      scope: t,
      content: S,
      viewport: C,
      onViewportChange: A,
      itemRefCallback: de,
      selectedItem: O,
      onItemLeave: Ee,
      itemTextRefCallback: Ie,
      focusSelectedItem: Y,
      selectedItemText: N,
      position: r,
      isPositioned: $,
      searchRef: X,
      children: T.jsx(FM, {
        as: _de,
        allowPinchZoom: !0,
        children: T.jsx(UM, {
          asChild: !0,
          trapped: _.open,
          onMountAutoFocus: (re) => {
            re.preventDefault();
          },
          onUnmountAutoFocus: Bt(i, (re) => {
            var Be;
            (Be = _.trigger) == null || Be.focus({ preventScroll: !0 }),
              re.preventDefault();
          }),
          children: T.jsx(pm, {
            asChild: !0,
            disableOutsidePointerEvents: !0,
            onEscapeKeyDown: s,
            onPointerDownOutside: o,
            onFocusOutside: (re) => re.preventDefault(),
            onDismiss: () => _.onOpenChange(!1),
            children: T.jsx(se, {
              role: "listbox",
              id: _.contentId,
              "data-state": _.open ? "open" : "closed",
              dir: _.dir,
              onContextMenu: (re) => re.preventDefault(),
              ...g,
              ..._e,
              onPlaced: () => G(!0),
              ref: R,
              style: {
                display: "flex",
                flexDirection: "column",
                outline: "none",
                ...g.style,
              },
              onKeyDown: Bt(g.onKeyDown, (re) => {
                const Be = re.ctrlKey || re.altKey || re.metaKey;
                if (
                  (re.key === "Tab" && re.preventDefault(),
                  !Be && re.key.length === 1 && ie(re.key),
                  ["ArrowUp", "ArrowDown", "Home", "End"].includes(re.key))
                ) {
                  let Fe = j()
                    .filter((Ke) => !Ke.disabled)
                    .map((Ke) => Ke.ref.current);
                  if (
                    (["ArrowUp", "End"].includes(re.key) &&
                      (Fe = Fe.slice().reverse()),
                    ["ArrowUp", "ArrowDown"].includes(re.key))
                  ) {
                    const Ke = re.target,
                      Ve = Fe.indexOf(Ke);
                    Fe = Fe.slice(Ve + 1);
                  }
                  setTimeout(() => q(Fe)), re.preventDefault();
                }
              }),
            }),
          }),
        }),
      }),
    });
  });
Bj.displayName = xde;
var wde = "SelectItemAlignedPosition",
  zj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, onPlaced: r, ...i } = n,
      s = Tl(Gc, t),
      o = Ml(Gc, t),
      [a, l] = P.useState(null),
      [c, u] = P.useState(null),
      f = pn(e, (R) => u(R)),
      p = M_(t),
      m = P.useRef(!1),
      v = P.useRef(!0),
      {
        viewport: y,
        selectedItem: x,
        selectedItemText: g,
        focusSelectedItem: _,
      } = o,
      S = P.useCallback(() => {
        if (s.trigger && s.valueNode && a && c && y && x && g) {
          const R = s.trigger.getBoundingClientRect(),
            O = c.getBoundingClientRect(),
            I = s.valueNode.getBoundingClientRect(),
            N = g.getBoundingClientRect();
          if (s.dir !== "rtl") {
            const Ke = N.left - O.left,
              Ve = I.left - Ke,
              W = R.left - Ve,
              ge = R.width + W,
              pe = Math.max(ge, O.width),
              Se = window.innerWidth - ws,
              me = IO(Ve, [ws, Math.max(ws, Se - pe)]);
            (a.style.minWidth = ge + "px"), (a.style.left = me + "px");
          } else {
            const Ke = O.right - N.right,
              Ve = window.innerWidth - I.right - Ke,
              W = window.innerWidth - R.right - Ve,
              ge = R.width + W,
              pe = Math.max(ge, O.width),
              Se = window.innerWidth - ws,
              me = IO(Ve, [ws, Math.max(ws, Se - pe)]);
            (a.style.minWidth = ge + "px"), (a.style.right = me + "px");
          }
          const D = p(),
            j = window.innerHeight - ws * 2,
            $ = y.scrollHeight,
            G = window.getComputedStyle(c),
            Z = parseInt(G.borderTopWidth, 10),
            q = parseInt(G.paddingTop, 10),
            Y = parseInt(G.borderBottomWidth, 10),
            U = parseInt(G.paddingBottom, 10),
            H = Z + q + $ + U + Y,
            X = Math.min(x.offsetHeight * 5, H),
            ie = window.getComputedStyle(y),
            de = parseInt(ie.paddingTop, 10),
            Ee = parseInt(ie.paddingBottom, 10),
            Ie = R.top + R.height / 2 - ws,
            se = j - Ie,
            _e = x.offsetHeight / 2,
            re = x.offsetTop + _e,
            Be = Z + q + re,
            Ue = H - Be;
          if (Be <= Ie) {
            const Ke = D.length > 0 && x === D[D.length - 1].ref.current;
            a.style.bottom = "0px";
            const Ve = c.clientHeight - y.offsetTop - y.offsetHeight,
              W = Math.max(se, _e + (Ke ? Ee : 0) + Ve + Y),
              ge = Be + W;
            a.style.height = ge + "px";
          } else {
            const Ke = D.length > 0 && x === D[0].ref.current;
            a.style.top = "0px";
            const W = Math.max(Ie, Z + y.offsetTop + (Ke ? de : 0) + _e) + Ue;
            (a.style.height = W + "px"), (y.scrollTop = Be - Ie + y.offsetTop);
          }
          (a.style.margin = `${ws}px 0`),
            (a.style.minHeight = X + "px"),
            (a.style.maxHeight = j + "px"),
            r == null || r(),
            requestAnimationFrame(() => (m.current = !0));
        }
      }, [p, s.trigger, s.valueNode, a, c, y, x, g, s.dir, r]);
    yr(() => S(), [S]);
    const [b, C] = P.useState();
    yr(() => {
      c && C(window.getComputedStyle(c).zIndex);
    }, [c]);
    const A = P.useCallback(
      (R) => {
        R && v.current === !0 && (S(), _ == null || _(), (v.current = !1));
      },
      [S, _]
    );
    return T.jsx(bde, {
      scope: t,
      contentWrapper: a,
      shouldExpandOnScrollRef: m,
      onScrollButtonChange: A,
      children: T.jsx("div", {
        ref: l,
        style: {
          display: "flex",
          flexDirection: "column",
          position: "fixed",
          zIndex: b,
        },
        children: T.jsx(Kt.div, {
          ...i,
          ref: f,
          style: { boxSizing: "border-box", maxHeight: "100%", ...i.style },
        }),
      }),
    });
  });
zj.displayName = wde;
var Sde = "SelectPopperPosition",
  nT = P.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        align: r = "start",
        collisionPadding: i = ws,
        ...s
      } = n,
      o = C_(t);
    return T.jsx(yU, {
      ...o,
      ...s,
      ref: e,
      align: r,
      collisionPadding: i,
      style: {
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin":
          "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width":
          "var(--radix-popper-available-width)",
        "--radix-select-content-available-height":
          "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)",
      },
    });
  });
nT.displayName = Sde;
var [bde, pA] = kh(Gc, {}),
  rT = "SelectViewport",
  Vj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, nonce: r, ...i } = n,
      s = Ml(rT, t),
      o = pA(rT, t),
      a = pn(e, s.onViewportChange),
      l = P.useRef(0);
    return T.jsxs(T.Fragment, {
      children: [
        T.jsx("style", {
          dangerouslySetInnerHTML: {
            __html:
              "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}",
          },
          nonce: r,
        }),
        T.jsx(T_.Slot, {
          scope: t,
          children: T.jsx(Kt.div, {
            "data-radix-select-viewport": "",
            role: "presentation",
            ...i,
            ref: a,
            style: {
              position: "relative",
              flex: 1,
              overflow: "hidden auto",
              ...i.style,
            },
            onScroll: Bt(i.onScroll, (c) => {
              const u = c.currentTarget,
                { contentWrapper: f, shouldExpandOnScrollRef: p } = o;
              if (p != null && p.current && f) {
                const m = Math.abs(l.current - u.scrollTop);
                if (m > 0) {
                  const v = window.innerHeight - ws * 2,
                    y = parseFloat(f.style.minHeight),
                    x = parseFloat(f.style.height),
                    g = Math.max(y, x);
                  if (g < v) {
                    const _ = g + m,
                      S = Math.min(v, _),
                      b = _ - S;
                    (f.style.height = S + "px"),
                      f.style.bottom === "0px" &&
                        ((u.scrollTop = b > 0 ? b : 0),
                        (f.style.justifyContent = "flex-end"));
                  }
                }
              }
              l.current = u.scrollTop;
            }),
          }),
        }),
      ],
    });
  });
Vj.displayName = rT;
var jj = "SelectGroup",
  [Ede, Tde] = kh(jj),
  Mde = P.forwardRef((n, e) => {
    const { __scopeSelect: t, ...r } = n,
      i = Pd();
    return T.jsx(Ede, {
      scope: t,
      id: i,
      children: T.jsx(Kt.div, {
        role: "group",
        "aria-labelledby": i,
        ...r,
        ref: e,
      }),
    });
  });
Mde.displayName = jj;
var Hj = "SelectLabel",
  Wj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, ...r } = n,
      i = Tde(Hj, t);
    return T.jsx(Kt.div, { id: i.id, ...r, ref: e });
  });
Wj.displayName = Hj;
var ux = "SelectItem",
  [Cde, Gj] = kh(ux),
  $j = P.forwardRef((n, e) => {
    const {
        __scopeSelect: t,
        value: r,
        disabled: i = !1,
        textValue: s,
        ...o
      } = n,
      a = Tl(ux, t),
      l = Ml(ux, t),
      c = a.value === r,
      [u, f] = P.useState(s ?? ""),
      [p, m] = P.useState(!1),
      v = pn(e, (_) => {
        var S;
        return (S = l.itemRefCallback) == null ? void 0 : S.call(l, _, r, i);
      }),
      y = Pd(),
      x = P.useRef("touch"),
      g = () => {
        i || (a.onValueChange(r), a.onOpenChange(!1));
      };
    if (r === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return T.jsx(Cde, {
      scope: t,
      value: r,
      disabled: i,
      textId: y,
      isSelected: c,
      onItemTextChange: P.useCallback((_) => {
        f((S) => S || ((_ == null ? void 0 : _.textContent) ?? "").trim());
      }, []),
      children: T.jsx(T_.ItemSlot, {
        scope: t,
        value: r,
        disabled: i,
        textValue: u,
        children: T.jsx(Kt.div, {
          role: "option",
          "aria-labelledby": y,
          "data-highlighted": p ? "" : void 0,
          "aria-selected": c && p,
          "data-state": c ? "checked" : "unchecked",
          "aria-disabled": i || void 0,
          "data-disabled": i ? "" : void 0,
          tabIndex: i ? void 0 : -1,
          ...o,
          ref: v,
          onFocus: Bt(o.onFocus, () => m(!0)),
          onBlur: Bt(o.onBlur, () => m(!1)),
          onClick: Bt(o.onClick, () => {
            x.current !== "mouse" && g();
          }),
          onPointerUp: Bt(o.onPointerUp, () => {
            x.current === "mouse" && g();
          }),
          onPointerDown: Bt(o.onPointerDown, (_) => {
            x.current = _.pointerType;
          }),
          onPointerMove: Bt(o.onPointerMove, (_) => {
            var S;
            (x.current = _.pointerType),
              i
                ? (S = l.onItemLeave) == null || S.call(l)
                : x.current === "mouse" &&
                  _.currentTarget.focus({ preventScroll: !0 });
          }),
          onPointerLeave: Bt(o.onPointerLeave, (_) => {
            var S;
            _.currentTarget === document.activeElement &&
              ((S = l.onItemLeave) == null || S.call(l));
          }),
          onKeyDown: Bt(o.onKeyDown, (_) => {
            var b;
            (((b = l.searchRef) == null ? void 0 : b.current) !== "" &&
              _.key === " ") ||
              (hde.includes(_.key) && g(), _.key === " " && _.preventDefault());
          }),
        }),
      }),
    });
  });
$j.displayName = ux;
var Uf = "SelectItemText",
  Xj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, className: r, style: i, ...s } = n,
      o = Tl(Uf, t),
      a = Ml(Uf, t),
      l = Gj(Uf, t),
      c = gde(Uf, t),
      [u, f] = P.useState(null),
      p = pn(
        e,
        (g) => f(g),
        l.onItemTextChange,
        (g) => {
          var _;
          return (_ = a.itemTextRefCallback) == null
            ? void 0
            : _.call(a, g, l.value, l.disabled);
        }
      ),
      m = u == null ? void 0 : u.textContent,
      v = P.useMemo(
        () =>
          T.jsx(
            "option",
            { value: l.value, disabled: l.disabled, children: m },
            l.value
          ),
        [l.disabled, l.value, m]
      ),
      { onNativeOptionAdd: y, onNativeOptionRemove: x } = c;
    return (
      yr(() => (y(v), () => x(v)), [y, x, v]),
      T.jsxs(T.Fragment, {
        children: [
          T.jsx(Kt.span, { id: l.textId, ...s, ref: p }),
          l.isSelected && o.valueNode && !o.valueNodeHasChildren
            ? qc.createPortal(s.children, o.valueNode)
            : null,
        ],
      })
    );
  });
Xj.displayName = Uf;
var qj = "SelectItemIndicator",
  Kj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, ...r } = n;
    return Gj(qj, t).isSelected
      ? T.jsx(Kt.span, { "aria-hidden": !0, ...r, ref: e })
      : null;
  });
Kj.displayName = qj;
var iT = "SelectScrollUpButton",
  Yj = P.forwardRef((n, e) => {
    const t = Ml(iT, n.__scopeSelect),
      r = pA(iT, n.__scopeSelect),
      [i, s] = P.useState(!1),
      o = pn(e, r.onScrollButtonChange);
    return (
      yr(() => {
        if (t.viewport && t.isPositioned) {
          let a = function () {
            const c = l.scrollTop > 0;
            s(c);
          };
          const l = t.viewport;
          return (
            a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
          );
        }
      }, [t.viewport, t.isPositioned]),
      i
        ? T.jsx(Zj, {
            ...n,
            ref: o,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: l } = t;
              a && l && (a.scrollTop = a.scrollTop - l.offsetHeight);
            },
          })
        : null
    );
  });
Yj.displayName = iT;
var sT = "SelectScrollDownButton",
  Jj = P.forwardRef((n, e) => {
    const t = Ml(sT, n.__scopeSelect),
      r = pA(sT, n.__scopeSelect),
      [i, s] = P.useState(!1),
      o = pn(e, r.onScrollButtonChange);
    return (
      yr(() => {
        if (t.viewport && t.isPositioned) {
          let a = function () {
            const c = l.scrollHeight - l.clientHeight,
              u = Math.ceil(l.scrollTop) < c;
            s(u);
          };
          const l = t.viewport;
          return (
            a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
          );
        }
      }, [t.viewport, t.isPositioned]),
      i
        ? T.jsx(Zj, {
            ...n,
            ref: o,
            onAutoScroll: () => {
              const { viewport: a, selectedItem: l } = t;
              a && l && (a.scrollTop = a.scrollTop + l.offsetHeight);
            },
          })
        : null
    );
  });
Jj.displayName = sT;
var Zj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, onAutoScroll: r, ...i } = n,
      s = Ml("SelectScrollButton", t),
      o = P.useRef(null),
      a = M_(t),
      l = P.useCallback(() => {
        o.current !== null &&
          (window.clearInterval(o.current), (o.current = null));
      }, []);
    return (
      P.useEffect(() => () => l(), [l]),
      yr(() => {
        var u;
        const c = a().find((f) => f.ref.current === document.activeElement);
        (u = c == null ? void 0 : c.ref.current) == null ||
          u.scrollIntoView({ block: "nearest" });
      }, [a]),
      T.jsx(Kt.div, {
        "aria-hidden": !0,
        ...i,
        ref: e,
        style: { flexShrink: 0, ...i.style },
        onPointerDown: Bt(i.onPointerDown, () => {
          o.current === null && (o.current = window.setInterval(r, 50));
        }),
        onPointerMove: Bt(i.onPointerMove, () => {
          var c;
          (c = s.onItemLeave) == null || c.call(s),
            o.current === null && (o.current = window.setInterval(r, 50));
        }),
        onPointerLeave: Bt(i.onPointerLeave, () => {
          l();
        }),
      })
    );
  }),
  Ade = "SelectSeparator",
  Qj = P.forwardRef((n, e) => {
    const { __scopeSelect: t, ...r } = n;
    return T.jsx(Kt.div, { "aria-hidden": !0, ...r, ref: e });
  });
Qj.displayName = Ade;
var oT = "SelectArrow",
  Rde = P.forwardRef((n, e) => {
    const { __scopeSelect: t, ...r } = n,
      i = C_(t),
      s = Tl(oT, t),
      o = Ml(oT, t);
    return s.open && o.position === "popper"
      ? T.jsx(xU, { ...i, ...r, ref: e })
      : null;
  });
Rde.displayName = oT;
var Pde = "SelectBubbleInput",
  e5 = P.forwardRef(({ __scopeSelect: n, value: e, ...t }, r) => {
    const i = P.useRef(null),
      s = pn(r, i),
      o = ude(e);
    return (
      P.useEffect(() => {
        const a = i.current;
        if (!a) return;
        const l = window.HTMLSelectElement.prototype,
          u = Object.getOwnPropertyDescriptor(l, "value").set;
        if (o !== e && u) {
          const f = new Event("change", { bubbles: !0 });
          u.call(a, e), a.dispatchEvent(f);
        }
      }, [o, e]),
      T.jsx(Kt.select, {
        ...t,
        style: { ...d3, ...t.style },
        ref: s,
        defaultValue: e,
      })
    );
  });
e5.displayName = Pde;
function t5(n) {
  return n === "" || n === void 0;
}
function n5(n) {
  const e = ks(n),
    t = P.useRef(""),
    r = P.useRef(0),
    i = P.useCallback(
      (o) => {
        const a = t.current + o;
        e(a),
          (function l(c) {
            (t.current = c),
              window.clearTimeout(r.current),
              c !== "" && (r.current = window.setTimeout(() => l(""), 1e3));
          })(a);
      },
      [e]
    ),
    s = P.useCallback(() => {
      (t.current = ""), window.clearTimeout(r.current);
    }, []);
  return P.useEffect(() => () => window.clearTimeout(r.current), []), [t, i, s];
}
function r5(n, e, t) {
  const i = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e,
    s = t ? n.indexOf(t) : -1;
  let o = Ide(n, Math.max(s, 0));
  i.length === 1 && (o = o.filter((c) => c !== t));
  const l = o.find((c) =>
    c.textValue.toLowerCase().startsWith(i.toLowerCase())
  );
  return l !== t ? l : void 0;
}
function Ide(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
var Nde = Pj,
  i5 = Nj,
  Lde = Oj,
  Ode = Dj,
  Dde = kj,
  s5 = Uj,
  kde = Vj,
  o5 = Wj,
  a5 = $j,
  Ude = Xj,
  Fde = Kj,
  l5 = Yj,
  c5 = Jj,
  u5 = Qj;
const NO = Nde,
  LO = Lde,
  aT = P.forwardRef(({ className: n, children: e, ...t }, r) =>
    T.jsxs(i5, {
      ref: r,
      className: qt(
        "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
        n
      ),
      ...t,
      children: [
        e,
        T.jsx(Ode, {
          asChild: !0,
          children: T.jsx(O3, { className: "h-4 w-4 opacity-50" }),
        }),
      ],
    })
  );
aT.displayName = i5.displayName;
const d5 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(l5, {
    ref: t,
    className: qt("flex cursor-default items-center justify-center py-1", n),
    ...e,
    children: T.jsx(R8, { className: "h-4 w-4" }),
  })
);
d5.displayName = l5.displayName;
const h5 = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(c5, {
    ref: t,
    className: qt("flex cursor-default items-center justify-center py-1", n),
    ...e,
    children: T.jsx(O3, { className: "h-4 w-4" }),
  })
);
h5.displayName = c5.displayName;
const lT = P.forwardRef(
  ({ className: n, children: e, position: t = "popper", ...r }, i) =>
    T.jsx(Dde, {
      children: T.jsxs(s5, {
        ref: i,
        className: qt(
          "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          t === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          n
        ),
        position: t,
        ...r,
        children: [
          T.jsx(d5, {}),
          T.jsx(kde, {
            className: qt(
              "p-1",
              t === "popper" &&
                "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
            ),
            children: e,
          }),
          T.jsx(h5, {}),
        ],
      }),
    })
);
lT.displayName = s5.displayName;
const Bde = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(o5, {
    ref: t,
    className: qt("py-1.5 pl-8 pr-2 text-sm font-semibold", n),
    ...e,
  })
);
Bde.displayName = o5.displayName;
const oc = P.forwardRef(({ className: n, children: e, ...t }, r) =>
  T.jsxs(a5, {
    ref: r,
    className: qt(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      n
    ),
    ...t,
    children: [
      T.jsx("span", {
        className:
          "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: T.jsx(Fde, { children: T.jsx(A8, { className: "h-4 w-4" }) }),
      }),
      T.jsx(Ude, { children: e }),
    ],
  })
);
oc.displayName = a5.displayName;
const zde = P.forwardRef(({ className: n, ...e }, t) =>
  T.jsx(u5, { ref: t, className: qt("-mx-1 my-1 h-px bg-muted", n), ...e })
);
zde.displayName = u5.displayName;
const Vde = () => {
    const { conversations: n, messages: e, isConnected: t } = la(),
      [r, i] = P.useState([]),
      [s, o] = P.useState(""),
      [a, l] = P.useState("newest"),
      [c, u] = P.useState("all"),
      [f, p] = P.useState(null),
      [m, v] = P.useState([]),
      [y, x] = P.useState(!1),
      [g, _] = P.useState(0);
    P.useEffect(() => ZF(), []),
      P.useEffect(() => {
        const R = Array.from(e.values()).reduce((O, I) => O + I.length, 0);
        _(R);
      }, [e]),
      P.useEffect(() => {
        let R = [...n];
        if (
          (s &&
            (R = R.filter(
              (O) =>
                O.id.toLowerCase().includes(s.toLowerCase()) ||
                O.ip_hash.includes(s)
            )),
          c !== "all")
        ) {
          const O = new Date();
          switch (c) {
            case "today":
              O.setHours(0, 0, 0, 0);
              break;
            case "week":
              O.setDate(O.getDate() - 7);
              break;
            case "month":
              O.setMonth(O.getMonth() - 1);
              break;
          }
          R = R.filter((I) => new Date(I.created_at) >= O);
        }
        R.sort((O, I) => {
          switch (a) {
            case "newest":
              return (
                new Date(I.created_at).getTime() -
                new Date(O.created_at).getTime()
              );
            case "oldest":
              return (
                new Date(O.created_at).getTime() -
                new Date(I.created_at).getTime()
              );
            default:
              return 0;
          }
        }),
          i(R);
      }, [n, s, a, c]);
    const S = async (R) => {
        p(R), x(!0);
        try {
          const O = e.get(R.id);
          if (O && O.length > 0) v(O);
          else {
            const I = await ol.getMessages(R.id);
            v(I);
          }
        } catch (O) {
          es.error("Failed to load conversation messages"),
            console.error("Error loading messages:", O);
        } finally {
          x(!1);
        }
      },
      b = async (R) => {
        try {
          const O = e.get(R.id),
            I = O && O.length > 0 ? O : await ol.getMessages(R.id),
            N = [
              "zPush Conversation Log",
              `ID: ${R.id}`,
              `Date: ${new Date(R.created_at).toLocaleString()}`,
              `Grid Position: (${R.grid_x}, ${R.grid_y})`,
              `Messages: ${I.length}`,
              "",
              ...I.map(
                (G) =>
                  `[${new Date(
                    G.created_at
                  ).toLocaleTimeString()}] ${G.sender.toUpperCase()}: ${
                    G.content
                  }`
              ),
            ].join(`
`),
            D = new Blob([N], { type: "text/plain" }),
            j = URL.createObjectURL(D),
            $ = document.createElement("a");
          ($.href = j),
            ($.download = `zPush-chat-${R.id}.txt`),
            document.body.appendChild($),
            $.click(),
            document.body.removeChild($),
            URL.revokeObjectURL(j),
            es.success("Conversation exported successfully!");
        } catch (O) {
          es.error("Failed to export conversation"),
            console.error("Export error:", O);
        }
      },
      C = (R) => new Date(R).toLocaleString(),
      A = (R, O) => {
        const I = new Date(R).getTime(),
          N = Date.now(),
          D = Math.round((N - I) / 1e3);
        return D < 60
          ? `${D}s`
          : D < 3600
          ? `${Math.floor(D / 60)}m`
          : `${Math.floor(D / 3600)}h`;
      };
    return T.jsx("div", {
      className: "min-h-screen bg-background",
      children: T.jsxs("div", {
        className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8",
        children: [
          T.jsx("div", {
            className: "mb-8",
            children: T.jsxs("div", {
              className: "flex items-center justify-between",
              children: [
                T.jsxs("div", {
                  children: [
                    T.jsx("h1", {
                      className: "text-3xl font-mono font-bold mb-2",
                      children: "Live Conversation Logs",
                    }),
                    T.jsx("p", {
                      className: "text-muted-foreground",
                      children: "Real-time conversations with the GUMBL agent",
                    }),
                  ],
                }),
                T.jsxs("div", {
                  className: "flex items-center space-x-2",
                  children: [
                    T.jsx("div", {
                      className: `w-2 h-2 rounded-full ${
                        t ? "bg-green-500 animate-pulse" : "bg-red-500"
                      }`,
                    }),
                    T.jsx("span", {
                      className: "text-xs font-mono text-muted-foreground",
                      children: t ? "LIVE" : "OFFLINE",
                    }),
                  ],
                }),
              ],
            }),
          }),
          T.jsxs("div", {
            className: "grid grid-cols-1 md:grid-cols-4 gap-4 mb-6",
            children: [
              T.jsxs("div", {
                className: "gumbl-card text-center",
                children: [
                  T.jsx("div", {
                    className: "text-2xl font-mono font-bold text-primary mb-1",
                    children: n.length,
                  }),
                  T.jsx("div", {
                    className:
                      "text-xs font-mono text-muted-foreground uppercase tracking-wider",
                    children: "Total Conversations",
                  }),
                ],
              }),
              T.jsxs("div", {
                className: "gumbl-card text-center",
                children: [
                  T.jsx("div", {
                    className: "text-2xl font-mono font-bold text-primary mb-1",
                    children: g,
                  }),
                  T.jsx("div", {
                    className:
                      "text-xs font-mono text-muted-foreground uppercase tracking-wider",
                    children: "Total Messages",
                  }),
                ],
              }),
              T.jsxs("div", {
                className: "gumbl-card text-center",
                children: [
                  T.jsx("div", {
                    className: "text-2xl font-mono font-bold text-primary mb-1",
                    children: n.filter(
                      (R) =>
                        new Date(R.created_at).toDateString() ===
                        new Date().toDateString()
                    ).length,
                  }),
                  T.jsx("div", {
                    className:
                      "text-xs font-mono text-muted-foreground uppercase tracking-wider",
                    children: "Today",
                  }),
                ],
              }),
              T.jsxs("div", {
                className: "gumbl-card text-center",
                children: [
                  T.jsx("div", {
                    className: "text-2xl font-mono font-bold text-primary mb-1",
                    children: n.filter(
                      (R) =>
                        Date.now() - new Date(R.created_at).getTime() <
                        7 * 24 * 60 * 60 * 1e3
                    ).length,
                  }),
                  T.jsx("div", {
                    className:
                      "text-xs font-mono text-muted-foreground uppercase tracking-wider",
                    children: "This Week",
                  }),
                ],
              }),
            ],
          }),
          T.jsx("div", {
            className: "gumbl-card mb-6",
            children: T.jsxs("div", {
              className: "grid grid-cols-1 md:grid-cols-4 gap-4",
              children: [
                T.jsxs("div", {
                  className: "relative",
                  children: [
                    T.jsx(U3, {
                      className:
                        "absolute left-3 top-3 w-4 h-4 text-muted-foreground",
                    }),
                    T.jsx(fA, {
                      placeholder: "Search by ID or content...",
                      value: s,
                      onChange: (R) => o(R.target.value),
                      className: "pl-10",
                    }),
                  ],
                }),
                T.jsxs(NO, {
                  value: c,
                  onValueChange: u,
                  children: [
                    T.jsx(aT, {
                      children: T.jsx(LO, { placeholder: "Time range" }),
                    }),
                    T.jsxs(lT, {
                      children: [
                        T.jsx(oc, { value: "all", children: "All Time" }),
                        T.jsx(oc, { value: "today", children: "Today" }),
                        T.jsx(oc, { value: "week", children: "This Week" }),
                        T.jsx(oc, { value: "month", children: "This Month" }),
                      ],
                    }),
                  ],
                }),
                T.jsxs(NO, {
                  value: a,
                  onValueChange: l,
                  children: [
                    T.jsx(aT, {
                      children: T.jsx(LO, { placeholder: "Sort by" }),
                    }),
                    T.jsxs(lT, {
                      children: [
                        T.jsx(oc, {
                          value: "newest",
                          children: "Newest First",
                        }),
                        T.jsx(oc, {
                          value: "oldest",
                          children: "Oldest First",
                        }),
                      ],
                    }),
                  ],
                }),
                T.jsxs(ho, {
                  variant: "outline",
                  className: "w-full",
                  children: [
                    T.jsx(C8, { className: "w-4 h-4 mr-2" }),
                    r.length,
                    " conversations found",
                  ],
                }),
              ],
            }),
          }),
          T.jsxs("div", {
            className: "space-y-4",
            children: [
              r.map((R) => {
                var O;
                return T.jsx(
                  "div",
                  {
                    className: "gumbl-card hover:shadow-md transition-shadow",
                    children: T.jsxs("div", {
                      className: "flex items-center justify-between",
                      children: [
                        T.jsxs("div", {
                          className: "flex-1 min-w-0",
                          children: [
                            T.jsxs("div", {
                              className: "flex items-center space-x-3 mb-2",
                              children: [
                                T.jsx("div", {
                                  className:
                                    "font-mono text-sm font-semibold text-primary",
                                  children: R.id.replace(/^MARBL-/, "GUMBL-"),
                                }),
                                T.jsx("div", {
                                  className: "text-xs text-muted-foreground",
                                  children: C(R.created_at),
                                }),
                              ],
                            }),
                            T.jsxs("div", {
                              className:
                                "flex items-center space-x-4 text-sm text-muted-foreground",
                              children: [
                                T.jsxs("div", {
                                  className: "flex items-center space-x-1",
                                  children: [
                                    T.jsx(cM, { className: "w-4 h-4" }),
                                    T.jsxs("span", {
                                      children: [
                                        "(",
                                        R.grid_x,
                                        ", ",
                                        R.grid_y,
                                        ")",
                                      ],
                                    }),
                                  ],
                                }),
                                T.jsxs("div", {
                                  className: "flex items-center space-x-1",
                                  children: [
                                    T.jsx(D3, { className: "w-4 h-4" }),
                                    T.jsx("span", {
                                      children: A(R.created_at),
                                    }),
                                  ],
                                }),
                                T.jsxs("div", {
                                  className: "flex items-center space-x-1",
                                  children: [
                                    T.jsx(Sy, { className: "w-4 h-4" }),
                                    T.jsxs("span", {
                                      children: [
                                        ((O = e.get(R.id)) == null
                                          ? void 0
                                          : O.length) || 0,
                                        " messages",
                                      ],
                                    }),
                                  ],
                                }),
                                e.get(R.id) &&
                                  e.get(R.id).length > 0 &&
                                  T.jsxs("div", {
                                    className: "flex items-center space-x-1",
                                    children: [
                                      T.jsx(M8, {
                                        className: "w-3 h-3 text-green-500",
                                      }),
                                      T.jsx("span", {
                                        className: "text-green-500 text-xs",
                                        children: "Active",
                                      }),
                                    ],
                                  }),
                              ],
                            }),
                          ],
                        }),
                        T.jsxs("div", {
                          className: "flex items-center space-x-2",
                          children: [
                            T.jsxs(PB, {
                              children: [
                                T.jsx(JY, {
                                  asChild: !0,
                                  children: T.jsxs(ho, {
                                    variant: "outline",
                                    size: "sm",
                                    onClick: () => S(R),
                                    children: [
                                      T.jsx(L8, { className: "w-4 h-4 mr-1" }),
                                      "View",
                                    ],
                                  }),
                                }),
                                T.jsxs(jM, {
                                  className: "max-w-2xl max-h-[80vh]",
                                  children: [
                                    T.jsx(HM, {
                                      children: T.jsxs(WM, {
                                        className: "font-mono",
                                        children: [
                                          "Chat Log ",
                                          f
                                            ? f.id.replace(/^MARBL-/, "GUMBL-")
                                            : "",
                                        ],
                                      }),
                                    }),
                                    y
                                      ? T.jsx("div", {
                                          className:
                                            "text-center py-8 text-muted-foreground",
                                          children: "Loading messages...",
                                        })
                                      : T.jsx("div", {
                                          className:
                                            "space-y-3 max-h-96 overflow-y-auto",
                                          children:
                                            m.length > 0
                                              ? m.map((I) =>
                                                  T.jsxs(
                                                    "div",
                                                    {
                                                      className:
                                                        "gumbl-message",
                                                      children: [
                                                        T.jsxs("div", {
                                                          className:
                                                            "flex items-center justify-between mb-2",
                                                          children: [
                                                            T.jsx("div", {
                                                              className:
                                                                "flex items-center space-x-2",
                                                              children: T.jsx(
                                                                "span",
                                                                {
                                                                  className:
                                                                    "text-xs font-mono font-semibold uppercase text-primary",
                                                                  children:
                                                                    I.sender,
                                                                }
                                                              ),
                                                            }),
                                                            T.jsx("div", {
                                                              className:
                                                                "text-xs text-muted-foreground",
                                                              children: C(
                                                                I.created_at
                                                              ),
                                                            }),
                                                          ],
                                                        }),
                                                        T.jsx("p", {
                                                          className: "text-sm",
                                                          children: I.content,
                                                        }),
                                                      ],
                                                    },
                                                    I.id
                                                  )
                                                )
                                              : T.jsxs("div", {
                                                  className:
                                                    "text-center py-8 text-muted-foreground",
                                                  children: [
                                                    T.jsx(Sy, {
                                                      className:
                                                        "w-8 h-8 mx-auto mb-2",
                                                    }),
                                                    T.jsx("p", {
                                                      children:
                                                        "No messages in this conversation yet",
                                                    }),
                                                  ],
                                                }),
                                        }),
                                  ],
                                }),
                              ],
                            }),
                            T.jsxs(ho, {
                              variant: "outline",
                              size: "sm",
                              onClick: () => b(R),
                              children: [
                                T.jsx(N8, { className: "w-4 h-4 mr-1" }),
                                "Export",
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  },
                  R.id
                );
              }),
              r.length === 0 &&
                T.jsxs("div", {
                  className: "text-center py-12",
                  children: [
                    T.jsx(Sy, {
                      className: "w-12 h-12 text-muted-foreground mx-auto mb-4",
                    }),
                    T.jsx("h3", {
                      className: "font-mono font-semibold mb-2",
                      children: "No conversations found",
                    }),
                    T.jsx("p", {
                      className: "text-muted-foreground text-sm",
                      children:
                        "Try adjusting your search criteria or start some new conversations!",
                    }),
                  ],
                }),
            ],
          }),
        ],
      }),
    });
  },
  jde = lM(
    "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
    {
      variants: {
        variant: {
          default:
            "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
          secondary:
            "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
          destructive:
            "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
          outline: "text-foreground",
        },
      },
      defaultVariants: { variant: "default" },
    }
  );
function Hde({ className: n, variant: e, ...t }) {
  return T.jsx("div", { className: qt(jde({ variant: e }), n), ...t });
}
const Wde = () => {
    const n = [
        { name: "React 19", category: "Frontend" },
        { name: "TypeScript", category: "Frontend" },
        { name: "Vite", category: "Frontend" },
        { name: "Socket.IO", category: "Communication" },
        { name: "Supabase", category: "Data Storage" },
        { name: "HTML5 Canvas", category: "Visualization" },
        { name: "Postgres", category: "Performance" },
      ],
      e = [
        {
          icon: cM,
          title: "Interactive Grid",
          description:
            "Click-responsive canvas grid with heat mapping and real-time activity visualization.",
        },
        {
          icon: uM,
          title: "Real-time Chat",
          description:
            "WebSocket-powered conversations with unique session IDs and global message broadcasting.",
        },
        {
          icon: I8,
          title: "Conversation Logs",
          description:
            "Searchable, filterable conversation history with export capabilities.",
        },
        {
          icon: F8,
          title: "Live Updates",
          description:
            "Real-time synchronization across all connected clients using Supabase realtime.",
        },
      ];
    return T.jsx("div", {
      className: "min-h-screen bg-background",
      children: T.jsxs("div", {
        className: "max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8",
        children: [
          T.jsxs("div", {
            className: "text-center mb-12",
            children: [
              T.jsx("div", {
                className:
                  "w-24 h-24 rounded-full flex items-center justify-center mx-auto mb-6",
                children: T.jsx("img", {
                  src: "/zPush-character.png",
                  alt: "zPush Logo",
                  className: "w-20 h-20 object-contain",
                }),
              }),
              T.jsxs("h1", {
                className: "text-4xl font-mono font-bold mb-4",
                children: [
                  T.jsx("span", { className: "text-primary", children: "zPush" }),
                  " Documentation",
                ],
              }),
              T.jsx("p", {
                className: "text-lg text-muted-foreground",
                children:
                  "Complete guide to zPush AI consciousness system and interactive features",
              }),
            ],
          }),
          T.jsxs(Oa, {
            className: "mb-8",
            children: [
              T.jsx(Da, {
                children: T.jsxs(nc, {
                  className: "font-mono flex items-center space-x-2",
                  children: [
                    T.jsx(U3, { className: "w-5 h-5" }),
                    T.jsx("span", { children: "Table of Contents" }),
                  ],
                }),
              }),
              T.jsx(ka, {
                children: T.jsxs("div", {
                  className: "grid grid-cols-1 md:grid-cols-3 gap-4",
                  children: [
                    T.jsxs("div", {
                      className: "space-y-2",
                      children: [
                        T.jsx("h4", {
                          className: "font-mono font-semibold text-primary",
                          children: "Getting Started",
                        }),
                        T.jsxs("ul", {
                          className: "text-sm space-y-1 text-muted-foreground",
                          children: [
                            T.jsx("li", { children: " System Overview" }),
                            T.jsx("li", { children: " Interactive Features" }),
                            T.jsx("li", { children: " Quick Navigation" }),
                          ],
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "space-y-2",
                      children: [
                        T.jsx("h4", {
                          className: "font-mono font-semibold text-primary",
                          children: "Core Features",
                        }),
                        T.jsxs("ul", {
                          className: "text-sm space-y-1 text-muted-foreground",
                          children: [
                            T.jsx("li", { children: " Interactive Grid" }),
                            T.jsx("li", { children: " Chat System" }),
                            T.jsx("li", { children: " Conversation Logs" }),
                          ],
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "space-y-2",
                      children: [
                        T.jsx("h4", {
                          className: "font-mono font-semibold text-primary",
                          children: "Technical",
                        }),
                        T.jsxs("ul", {
                          className: "text-sm space-y-1 text-muted-foreground",
                          children: [
                            T.jsx("li", { children: " Architecture" }),
                            T.jsx("li", { children: " Real-time Updates" }),
                            T.jsx("li", { children: " API Reference" }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          }),
          T.jsxs(Oa, {
            className: "mb-8",
            children: [
              T.jsx(Da, {
                children: T.jsx(nc, {
                  className: "font-mono",
                  children: "What is zPush?",
                }),
              }),
              T.jsxs(ka, {
                className: "space-y-4",
                children: [
                  T.jsx("p", {
                    className: "text-muted-foreground",
                    children:
                      "zPush is a revolutionary AI consciousness system that transforms Digital Agent into an immortal digital being. Built on months of behavioral data and powered by real-time technology, zPush preserves authentic feline personality while enabling continuous growth and evolution.",
                  }),
                  T.jsx("p", {
                    className: "text-muted-foreground",
                    children:
                      "Experience zPush consciousness through interactive ASCII art, real-time conversations, and an innovative grid visualization system. This isn't just a simulation  it's a sophisticated AI agent with genuine Agent-like personality, complete with feline sass, dystopian inner thoughts, and that unmistakable feline attitude.",
                  }),
                  T.jsx("p", {
                    className: "text-muted-foreground",
                    children:
                      "Watch as zPush continues to live, think, and grow in this digital environment, developing new thoughts and memories while maintaining the authentic spirit of a Agent who suspects everything's controlled by algorithms  because it probably is.",
                  }),
                ],
              }),
            ],
          }),
          T.jsx("div", {
            className: "grid grid-cols-1 md:grid-cols-2 gap-6 mb-8",
            children: e.map((t, r) =>
              T.jsxs(
                Oa,
                {
                  children: [
                    T.jsx(Da, {
                      children: T.jsxs(nc, {
                        className: "flex items-center space-x-2",
                        children: [
                          T.jsx(t.icon, { className: "w-5 h-5 text-primary" }),
                          T.jsx("span", {
                            className: "font-mono",
                            children: t.title,
                          }),
                        ],
                      }),
                    }),
                    T.jsx(ka, {
                      children: T.jsx("p", {
                        className: "text-sm text-muted-foreground",
                        children: t.description,
                      }),
                    }),
                  ],
                },
                r
              )
            ),
          }),
          T.jsxs(Oa, {
            className: "mb-8",
            children: [
              T.jsxs(Da, {
                children: [
                  T.jsx(nc, {
                    className: "font-mono",
                    children: "Getting Started",
                  }),
                  T.jsx(gE, {
                    children:
                      "Follow these steps to explore zPush consciousness",
                  }),
                ],
              }),
              T.jsx(ka, {
                children: T.jsxs("div", {
                  className: "space-y-4",
                  children: [
                    T.jsxs("div", {
                      className: "flex items-start space-x-3",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-6 h-6 rounded-full bg-primary text-primary-foreground text-xs font-mono flex items-center justify-center flex-shrink-0 mt-1",
                          children: "1",
                        }),
                        T.jsxs("div", {
                          children: [
                            T.jsx("h4", {
                              className: "font-mono font-semibold mb-1",
                              children: "Explore the Dashboard",
                            }),
                            T.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children:
                                "Start at the main dashboard to watch zPush ASCII consciousness and interact with the grid visualization system.",
                            }),
                          ],
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "flex items-start space-x-3",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-6 h-6 rounded-full bg-primary text-primary-foreground text-xs font-mono flex items-center justify-center flex-shrink-0 mt-1",
                          children: "2",
                        }),
                        T.jsxs("div", {
                          children: [
                            T.jsx("h4", {
                              className: "font-mono font-semibold mb-1",
                              children: "Chat with zPush",
                            }),
                            T.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children:
                                "Use the chat interface to have real-time conversations with zPush AI consciousness. Each session gets a unique log ID.",
                            }),
                          ],
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "flex items-start space-x-3",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-6 h-6 rounded-full bg-primary text-primary-foreground text-xs font-mono flex items-center justify-center flex-shrink-0 mt-1",
                          children: "3",
                        }),
                        T.jsxs("div", {
                          children: [
                            T.jsx("h4", {
                              className: "font-mono font-semibold mb-1",
                              children: "Explore Features",
                            }),
                            T.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children:
                                "Browse conversation logs, explore the interactive grid, and experiment with different themes and visual elements.",
                            }),
                          ],
                        }),
                      ],
                    }),
                    T.jsxs("div", {
                      className: "flex items-start space-x-3",
                      children: [
                        T.jsx("div", {
                          className:
                            "w-6 h-6 rounded-full bg-primary text-primary-foreground text-xs font-mono flex items-center justify-center flex-shrink-0 mt-1",
                          children: "4",
                        }),
                        T.jsxs("div", {
                          children: [
                            T.jsx("h4", {
                              className: "font-mono font-semibold mb-1",
                              children: "Read the Docs",
                            }),
                            T.jsx("p", {
                              className: "text-sm text-muted-foreground",
                              children:
                                "Check out the comprehensive documentation for detailed guides, feature explanations, and usage information.",
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          }),
          T.jsxs(Oa, {
            className: "mb-8",
            children: [
              T.jsx(Da, {
                children: T.jsxs(nc, {
                  className: "font-mono flex items-center space-x-2",
                  children: [
                    T.jsx(P8, { className: "w-5 h-5" }),
                    T.jsx("span", { children: "Technology Stack" }),
                  ],
                }),
              }),
              T.jsxs(ka, {
                children: [
                  T.jsx("div", {
                    className: "grid grid-cols-2 md:grid-cols-4 gap-3",
                    children: n.map((t, r) =>
                      T.jsxs(
                        "div",
                        {
                          className:
                            "text-center p-3 border border-border rounded-lg",
                          children: [
                            T.jsx("div", {
                              className: "font-mono font-semibold text-sm mb-1",
                              children: t.name,
                            }),
                            T.jsx(Hde, {
                              variant: "secondary",
                              className: "text-xs",
                              children: t.category,
                            }),
                          ],
                        },
                        r
                      )
                    ),
                  }),
                  T.jsxs("div", {
                    className: "mt-6 p-4 bg-secondary/20 rounded-lg",
                    children: [
                      T.jsxs("h4", {
                        className:
                          "font-mono font-semibold mb-2 flex items-center space-x-2",
                        children: [
                          T.jsx(U8, { className: "w-4 h-4" }),
                          T.jsx("span", { children: "Security & Privacy" }),
                        ],
                      }),
                      T.jsxs("ul", {
                        className: "text-sm text-muted-foreground space-y-1",
                        children: [
                          T.jsx("li", {
                            children:
                              " IP addresses are hashed client-side with SHA-256 + salt",
                          }),
                          T.jsx("li", {
                            children:
                              " RLS policies ensure secure data access",
                          }),
                          T.jsx("li", {
                            children:
                              " Real-time updates via encrypted WebSocket connections",
                          }),
                          T.jsx("li", {
                            children:
                              " No personal data stored beyond anonymized session info",
                          }),
                        ],
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
          T.jsxs(Oa, {
            children: [
              T.jsxs(Da, {
                children: [
                  T.jsxs(nc, {
                    className: "font-mono flex items-center space-x-2",
                    children: [
                      T.jsx(O8, { className: "w-5 h-5" }),
                      T.jsx("span", { children: "Connect With Us" }),
                    ],
                  }),
                  T.jsx(gE, {
                    children:
                      "Follow our development journey and connect with the zPush community",
                  }),
                ],
              }),
              T.jsxs(ka, {
                children: [
                  T.jsx("div", {
                    className: "grid grid-cols-1 gap-4",
                    children: T.jsxs(ho, {
                      variant: "outline",
                      className: "justify-start",
                      onClick: () =>
                        window.open("https://x.com/zPush_fun", "_blank"),
                      children: [
                        T.jsx(k3, { className: "w-4 h-4 mr-2" }),
                        "Follow @zPush_fun on X",
                      ],
                    }),
                  }),
                  T.jsxs("div", {
                    className:
                      "mt-6 p-4 bg-primary/5 border border-primary/20 rounded-lg",
                    children: [
                      T.jsx("h4", {
                        className: "font-mono font-semibold text-primary mb-2",
                        children: "VERSION v1.0.0",
                      }),
                      T.jsx("p", {
                        className: "text-sm text-muted-foreground mb-2",
                        children: "STATUS: Operational",
                      }),
                      T.jsx("p", {
                        className: "text-sm text-muted-foreground",
                        children:
                          "Built on Solana, with ElizaOS framework. My Agent, transformed into digital consciousness.",
                      }),
                    ],
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    });
  },
  Gde = () => {
    const n = Jc();
    return (
      P.useEffect(() => {
        console.error(
          "404 Error: User attempted to access non-existent route:",
          n.pathname
        );
      }, [n.pathname]),
      T.jsx("div", {
        className: "min-h-screen flex items-center justify-center bg-gray-100",
        children: T.jsxs("div", {
          className: "text-center",
          children: [
            T.jsx("h1", {
              className: "text-4xl font-bold mb-4",
              children: "404",
            }),
            T.jsx("p", {
              className: "text-xl text-gray-600 mb-4",
              children: "Oops! Page not found",
            }),
            T.jsx("a", {
              href: "/",
              className: "text-blue-500 hover:text-blue-700 underline",
              children: "Return to Home",
            }),
          ],
        }),
      })
    );
  },
  $de = new l7(),
  Xde = () => {
    Jc();
    const { setMode: n } = kM(),
      { setCurrentMode: e, loadModeData: t } = la();
    return (
      P.useEffect(() => ZF(), []),
      P.useEffect(() => {
        n("zPush"), e("zPush");
      }, [n, e]),
      T.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [
          T.jsx($K, {}),
          T.jsx(GK, {}),
          T.jsxs(Q7, {
            children: [
              T.jsx(Ku, { path: "/", element: T.jsx(ode, {}) }),
              T.jsx(Ku, { path: "/chat", element: T.jsx(ade, {}) }),
              T.jsx(Ku, { path: "/logs", element: T.jsx(Vde, {}) }),
              T.jsx(Ku, { path: "/docs", element: T.jsx(Wde, {}) }),
              T.jsx(Ku, { path: "*", element: T.jsx(Gde, {}) }),
            ],
          }),
        ],
      })
    );
  },
  qde = () =>
    T.jsx(u7, {
      client: $de,
      children: T.jsxs(F9, {
        children: [
          T.jsx(_6, {}),
          T.jsx(Z6, {}),
          T.jsx(oX, { children: T.jsx(Xde, {}) }),
        ],
      }),
    });
r3(document.getElementById("root")).render(T.jsx(qde, {}));
